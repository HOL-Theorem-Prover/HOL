(* ========================================================================= *)
(*                                                                           *)
(*                Elementary Topology in Euclidean Space (R^1)               *)
(*                                                                           *)
(*        (c) Copyright, John Harrison 1998-2015                             *)
(*        (c) Copyright, Valentina Bruno 2010                                *)
(*        (c) Copyright, Marco Maggesi 2014-2015                             *)
(*        (c) Copyright 2015,                                                *)
(*                       Muhammad Qasim,                                     *)
(*                       Osman Hasan,                                        *)
(*                       Hardware Verification Group,                        *)
(*                       Concordia University                                *)
(*            Contact:  <m_qasi@ece.concordia.ca>                            *)
(*                                                                           *)
(*    Note: This theory was ported from HOL Light                            *)
(*                                                                           *)
(* ========================================================================= *)

open HolKernel Parse boolLib bossLib;

open numTheory numLib unwindLib tautLib Arith prim_recTheory RealArith
     combinTheory quotientTheory arithmeticTheory realaxTheory realTheory
     jrhUtils pairTheory boolTheory pred_setTheory optionTheory
     sumTheory InductiveDefinition ind_typeTheory listTheory mesonLib
     seqTheory limTheory transcTheory realLib topologyTheory;

open wellorderTheory cardinalTheory iterateTheory productTheory hurdUtils;

val _ = new_theory "real_topology";

fun MESON ths tm = prove(tm,MESON_TAC ths);
fun METIS ths tm = prove(tm,METIS_TAC ths);

val DISC_RW_KILL = DISCH_TAC THEN ONCE_ASM_REWRITE_TAC [] THEN
                   POP_ASSUM K_TAC;

fun ASSERT_TAC tm = SUBGOAL_THEN tm STRIP_ASSUME_TAC;

val ASM_ARITH_TAC = REPEAT (POP_ASSUM MP_TAC) THEN ARITH_TAC;
val ASM_REAL_ARITH_TAC = REAL_ASM_ARITH_TAC;

fun PRINT_TAC s gl =                            (* from cardinalTheory *)
  (print ("** " ^ s ^ "\n"); ALL_TAC gl);

(* Minimal hol-light compatibility layer *)
val IMP_CONJ      = CONJ_EQ_IMP;     (* cardinalTheory *)
val FINITE_SUBSET = SUBSET_FINITE_I; (* pred_setTheory *)
val LE_0          = ZERO_LESS_EQ;    (* arithmeticTheory *)

(* ------------------------------------------------------------------------- *)
(* misc.                                                                     *)
(* ------------------------------------------------------------------------- *)

val REAL_LE_SQUARE_ABS = store_thm ("REAL_LE_SQUARE_ABS",
 ``!x y:real. abs(x) <= abs(y) <=> x pow 2 <= y pow 2``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_POW2_ABS] THEN
  EQ_TAC THEN DISCH_TAC THENL
  [MATCH_MP_TAC POW_LE THEN ASM_REAL_ARITH_TAC,
   CCONTR_TAC THEN UNDISCH_TAC ``abs (x:real) pow 2 <= abs y pow 2`` THEN
   REWRITE_TAC [TWO, REAL_NOT_LE] THEN MATCH_MP_TAC POW_LT THEN
   ASM_REAL_ARITH_TAC]);

val REAL_EQ_SQUARE_ABS = store_thm ("REAL_EQ_SQUARE_ABS",
 ``!x y:real. (abs x = abs y) <=> (x pow 2 = y pow 2)``,
  REWRITE_TAC[GSYM REAL_LE_ANTISYM, REAL_LE_SQUARE_ABS]);

val REAL_HALF = store_thm ("REAL_HALF",
 ``(!e:real. &0 < e / &2 <=> &0 < e) /\
   (!e:real. e / &2 + e / &2 = e) /\
   (!e:real. &2 * (e / &2) = e)``,
  SIMP_TAC std_ss [REAL_LT_HALF1, REAL_HALF_DOUBLE, REAL_DIV_LMUL,
  REAL_ARITH ``2 <> 0:real``]);

val FINITE_SUBSET_IMAGE = store_thm ("FINITE_SUBSET_IMAGE",
 ``!f:'a->'b s t.
        FINITE(t) /\ t SUBSET (IMAGE f s) <=>
        ?s'. FINITE s' /\ s' SUBSET s /\ (t = IMAGE f s')``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [ALL_TAC, ASM_MESON_TAC[IMAGE_FINITE, IMAGE_SUBSET]] THEN
  STRIP_TAC THEN
  EXISTS_TAC ``IMAGE (\y. @x. x IN s /\ ((f:'a->'b)(x) = y)) t`` THEN
  ASM_SIMP_TAC std_ss [IMAGE_FINITE] THEN
  SIMP_TAC std_ss [EXTENSION, SUBSET_DEF, FORALL_IN_IMAGE] THEN CONJ_TAC THENL
   [METIS_TAC[SUBSET_DEF, IN_IMAGE], ALL_TAC] THEN
  REWRITE_TAC[IN_IMAGE] THEN X_GEN_TAC ``y:'b`` THEN
  SIMP_TAC std_ss [GSYM RIGHT_EXISTS_AND_THM] THEN
  ONCE_REWRITE_TAC[CONJ_SYM] THEN
  REWRITE_TAC[UNWIND_THM2, GSYM CONJ_ASSOC] THEN
  METIS_TAC [SUBSET_DEF, IN_IMAGE]);

val EXISTS_FINITE_SUBSET_IMAGE = store_thm ("EXISTS_FINITE_SUBSET_IMAGE",
 ``!P f s.
    (?t. FINITE t /\ t SUBSET IMAGE f s /\ P t) <=>
    (?t. FINITE t /\ t SUBSET s /\ P (IMAGE f t))``,
  REWRITE_TAC[FINITE_SUBSET_IMAGE, CONJ_ASSOC] THEN MESON_TAC[]);

val FORALL_FINITE_SUBSET_IMAGE = store_thm ("FORALL_FINITE_SUBSET_IMAGE",
 ``!P f s. (!t. FINITE t /\ t SUBSET IMAGE f s ==> P t) <=>
           (!t. FINITE t /\ t SUBSET s ==> P(IMAGE f t))``,
   REPEAT GEN_TAC THEN
   ONCE_REWRITE_TAC [METIS [] ``(FINITE t /\ t SUBSET IMAGE f s ==> P t) =
                            (\t. FINITE t /\ t SUBSET IMAGE f s ==> P t) t``] THEN
   ONCE_REWRITE_TAC [METIS [] ``(FINITE t /\ t SUBSET s ==> P (IMAGE f t)) =
                            (\t. FINITE t /\ t SUBSET s ==> P (IMAGE f t)) t``] THEN
   ONCE_REWRITE_TAC [MESON[] ``(!x. P x) <=> ~(?x. ~P x)``] THEN
   SIMP_TAC std_ss [NOT_IMP, GSYM CONJ_ASSOC, EXISTS_FINITE_SUBSET_IMAGE]);

val FORALL_IN_GSPEC = store_thm ("FORALL_IN_GSPEC",
 ``(!P f. (!z. z IN {f x | P x} ==> Q z) <=> (!x. P x ==> Q(f x))) /\
   (!P f. (!z. z IN {f x y | P x y} ==> Q z) <=>
          (!x y. P x y ==> Q(f x y))) /\
   (!P f. (!z. z IN {f w x y | P w x y} ==> Q z) <=>
          (!w x y. P w x y ==> Q(f w x y)))``,
   SRW_TAC [][] THEN SET_TAC []);

val EXISTS_IN_GSPEC = store_thm ("EXISTS_IN_GSPEC",
 ``(!P f. (?z. z IN {f x | P x} /\ Q z) <=> (?x. P x /\ Q(f x))) /\
   (!P f. (?z. z IN {f x y | P x y} /\ Q z) <=>
          (?x y. P x y /\ Q(f x y))) /\
   (!P f. (?z. z IN {f w x y | P w x y} /\ Q z) <=>
          (?w x y. P w x y /\ Q(f w x y)))``,
  SRW_TAC [][] THEN SET_TAC[]);

val EMPTY_BIGUNION = store_thm ("EMPTY_BIGUNION",
 ``!s. (BIGUNION s = {}) <=> !t. t IN s ==> (t = {})``,
  SET_TAC[]);

val UPPER_BOUND_FINITE_SET = store_thm ("UPPER_BOUND_FINITE_SET",
 ``!f:('a->num) s. FINITE(s) ==> ?a. !x. x IN s ==> f(x) <= a``,
  GEN_TAC THEN
  KNOW_TAC ``!s. (?a. !x. x IN s ==> (f:('a->num))(x) <= a) =
             (\s. ?a. !x. x IN s ==> f(x) <= a) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[IN_INSERT, NOT_IN_EMPTY] THEN
  MESON_TAC[LESS_EQ_CASES, LESS_EQ_REFL, LESS_EQ_TRANS]);

val REAL_BOUNDS_LT = store_thm ("REAL_BOUNDS_LT",
 ``!x k:real. -k < x /\ x < k <=> abs(x) < k``,
  REAL_ARITH_TAC);

val BIGUNION_IMAGE = store_thm ("BIGUNION_IMAGE",
 ``!f s. BIGUNION (IMAGE f s) = {y | ?x. x IN s /\ y IN f x}``,
  REPEAT GEN_TAC THEN  GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGUNION, IN_IMAGE, GSPECIFICATION] THEN MESON_TAC[]);

val BIGINTER_IMAGE = store_thm ("BIGINTER_IMAGE",
 ``!f s. BIGINTER (IMAGE f s) = {y | !x. x IN s ==> y IN f x}``,
  REPEAT GEN_TAC THEN  GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGINTER, IN_IMAGE, GSPECIFICATION] THEN MESON_TAC[]);

val REAL_LE_LMUL1 = store_thm ("REAL_LE_LMUL1",
 ``!x y z:real. &0 <= x /\ y <= z ==> x * y <= x * z``,
  METIS_TAC [REAL_LE_LMUL, REAL_MUL_LZERO, REAL_LE_LT]);

val LE_EXISTS = store_thm ("LE_EXISTS",
 ``!m n:num. (m <= n) <=> (?d. n = m + d)``,
  GEN_TAC THEN INDUCT_TAC THEN ASM_REWRITE_TAC[LE] THENL
   [REWRITE_TAC[CONV_RULE(LAND_CONV SYM_CONV) (SPEC_ALL ADD_EQ_0)] THEN
    SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, EXISTS_REFL],
    EQ_TAC THENL
     [DISCH_THEN(DISJ_CASES_THEN2 SUBST1_TAC MP_TAC) THENL
       [EXISTS_TAC ``0:num`` THEN REWRITE_TAC[ADD_CLAUSES],
        DISCH_THEN(X_CHOOSE_THEN ``d:num`` SUBST1_TAC) THEN
        EXISTS_TAC ``SUC d`` THEN REWRITE_TAC[ADD_CLAUSES]],
      SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
      INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES, INV_SUC_EQ] THEN
      DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[] THEN DISJ2_TAC THEN
      EXISTS_TAC ``d:num`` THEN SIMP_TAC std_ss []]]);

val LT_EXISTS = store_thm ("LT_EXISTS",
 ``!m n. (m < n) <=> (?d. n = m + SUC d)``,
  GEN_TAC THEN INDUCT_TAC THEN REWRITE_TAC[LT, ADD_CLAUSES, SUC_NOT] THEN
  ASM_REWRITE_TAC[INV_SUC_EQ] THEN EQ_TAC THENL
   [DISCH_THEN(DISJ_CASES_THEN2 SUBST1_TAC MP_TAC) THENL
     [EXISTS_TAC ``0:num`` THEN REWRITE_TAC[ADD_CLAUSES],
      DISCH_THEN(X_CHOOSE_THEN ``d:num`` SUBST1_TAC) THEN
      EXISTS_TAC ``SUC d`` THEN REWRITE_TAC[ADD_CLAUSES]],
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES, INV_SUC_EQ] THEN
    DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[] THEN DISJ2_TAC THEN
    EXISTS_TAC ``d:num`` THEN SIMP_TAC std_ss []]);

val BOUNDS_LINEAR = store_thm ("BOUNDS_LINEAR",
 ``!A B C. (!n:num. A * n <= B * n + C) <=> A <= B``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [CONV_TAC CONTRAPOS_CONV THEN REWRITE_TAC[NOT_LESS_EQUAL] THEN
    DISCH_THEN(CHOOSE_THEN SUBST1_TAC o REWRITE_RULE[LT_EXISTS]) THEN
    REWRITE_TAC[RIGHT_ADD_DISTRIB, LE_ADD_LCANCEL] THEN
    DISCH_THEN(MP_TAC o SPEC ``SUC C``) THEN
    REWRITE_TAC[NOT_LESS_EQUAL, MULT_CLAUSES, ADD_CLAUSES, LT_SUC_LE] THEN
    ARITH_TAC,
    DISCH_THEN(CHOOSE_THEN SUBST1_TAC o REWRITE_RULE[LE_EXISTS]) THEN
    ARITH_TAC]);

val BOUNDS_LINEAR_0 = store_thm ("BOUNDS_LINEAR_0",
 ``!A B. (!n:num. A * n <= B) <=> (A = 0)``,
  REPEAT GEN_TAC THEN
  MP_TAC (SPECL [``A:num``, ``0:num``, ``B:num``] BOUNDS_LINEAR) THEN
  REWRITE_TAC[MULT_CLAUSES, ADD_CLAUSES, LE]);

val REAL_LE_BETWEEN = store_thm ("REAL_LE_BETWEEN",
 ``!a b. a <= b <=> ?x:real. a <= x /\ x <= b``,
  MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL]);

val WLOG_LE = store_thm ("WLOG_LE",
 ``(!m n:num. P m n <=> P n m) /\ (!m n:num. m <= n ==> P m n) ==>
    !m n:num. P m n``,
  METIS_TAC[LE_CASES]);

val BIGUNION_GSPEC = store_thm ("BIGUNION_GSPEC",
 ``(!P f. BIGUNION {f x | P x} = {a | ?x. P x /\ a IN (f x)}) /\
   (!P f. BIGUNION {f x y | P x y} = {a | ?x y. P x y /\ a IN (f x y)}) /\
   (!P f. BIGUNION {f x y z | P x y z} =
            {a | ?x y z. P x y z /\ a IN (f x y z)})``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGUNION, GSPECIFICATION, EXISTS_PROD] THEN MESON_TAC[]);

val BIGINTER_GSPEC = store_thm ("BIGINTER_GSPEC",
 ``(!P f. BIGINTER {f x | P x} = {a | !x. P x ==> a IN (f x)}) /\
   (!P f. BIGINTER {f x y | P x y} = {a | !x y. P x y ==> a IN (f x y)}) /\
   (!P f. BIGINTER {f x y z | P x y z} =
                {a | !x y z. P x y z ==> a IN (f x y z)})``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGINTER, GSPECIFICATION, EXISTS_PROD] THEN MESON_TAC[]);

val FINITE_POWERSET = store_thm ("FINITE_POWERSET",
  ``!s. FINITE s ==> FINITE {t | t SUBSET s}``,
    METIS_TAC [FINITE_POW, POW_DEF]);

val LE_ADD = store_thm ("LE_ADD",
 ``!m n:num. m <= m + n``,
  GEN_TAC THEN INDUCT_TAC THEN
  ASM_SIMP_TAC arith_ss [LE, ADD_CLAUSES, LESS_EQ_REFL]);

val LE_ADDR = store_thm ("LE_ADDR",
 ``!m n:num. n <= m + n``,
  ONCE_REWRITE_TAC[ADD_SYM] THEN MATCH_ACCEPT_TAC LE_ADD);

val ADD_SUB2 = store_thm ("ADD_SUB2",
 ``!m n:num. (m + n) - m = n``,
  ONCE_REWRITE_TAC[ADD_SYM] THEN MATCH_ACCEPT_TAC ADD_SUB);

val ADD_SUBR2 = store_thm ("ADD_SUBR2",
 ``!m n:num. m - (m + n) = 0``,
  REWRITE_TAC[SUB_EQ_0, LESS_EQ_ADD]);

val ADD_SUBR = store_thm ("ADD_SUBR",
 ``!m n:num. n - (m + n) = 0``,
  ONCE_REWRITE_TAC[ADD_SYM] THEN MATCH_ACCEPT_TAC ADD_SUBR2);

val TRANSITIVE_STEPWISE_LE_EQ = store_thm ("TRANSITIVE_STEPWISE_LE_EQ",
 ``!R. (!x. R x x) /\ (!x y z. R x y /\ R y z ==> R x z)
       ==> ((!m n. m <= n ==> R m n) <=> (!n. R n (SUC n)))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC std_ss [LE, LESS_EQ_REFL] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [LE_EXISTS, LEFT_IMP_EXISTS_THM] THEN
  GEN_TAC THEN INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES] THEN ASM_MESON_TAC[]);

val TRANSITIVE_STEPWISE_LE = store_thm ("TRANSITIVE_STEPWISE_LE",
 ``!R. (!x. R x x) /\ (!x y z. R x y /\ R y z ==> R x z) /\
       (!n. R n (SUC n))
       ==> !m n. m <= n ==> R m n``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(a /\ a' ==> (c <=> b)) ==> a /\ a' /\ b ==> c`) THEN
  MATCH_ACCEPT_TAC TRANSITIVE_STEPWISE_LE_EQ);

val LAMBDA_PAIR = store_thm ("LAMBDA_PAIR",
 ``(\(x,y). P x y) = (\p. P (FST p) (SND p))``,
  SIMP_TAC std_ss [FUN_EQ_THM, FORALL_PROD] THEN
  SIMP_TAC std_ss []);

val NOT_EQ = store_thm ("NOT_EQ",
 ``!a b. (a <> b) = ~(a = b)``, METIS_TAC []);

val ABS_LE_0 = store_thm ("ABS_LE_0",
 ``!x:real. abs x <= &0 <=> (x = 0)``,
  MESON_TAC[REAL_LE_ANTISYM, ABS_ZERO, ABS_POS]);

val REAL_OF_NUM_GE = store_thm ("REAL_OF_NUM_GE",
 ``!m n. &m >= (&n:real) <=> m >= n``,
  REWRITE_TAC[GE, real_ge, REAL_OF_NUM_LE]);

val POWERSET_CLAUSES = store_thm ("POWERSET_CLAUSES",
 ``({s | s SUBSET {}} = {{}}) /\
   ((!a:'a t. {s | s SUBSET (a INSERT t)} =
            {s | s SUBSET t} UNION IMAGE (\s. a INSERT s) {s | s SUBSET t}))``,
  REWRITE_TAC[SUBSET_INSERT_DELETE, SUBSET_EMPTY, SET_RULE
   ``(!a. {x | x = a} = {a}) /\ (!a. {x | a = x} = {a})``] THEN
  MAP_EVERY X_GEN_TAC [``a:'a``, ``t:'a->bool``] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[UNION_SUBSET] THEN
  ONCE_REWRITE_TAC[SUBSET_DEF] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, FORALL_IN_GSPEC] THEN
  SIMP_TAC std_ss [GSPECIFICATION, IN_UNION, IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[]] THEN
  X_GEN_TAC ``s:'a->bool`` THEN
  ASM_CASES_TAC ``(a:'a) IN s`` THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  STRIP_TAC THEN DISJ2_TAC THEN EXISTS_TAC ``s DELETE (a:'a)`` THEN
  ASM_SET_TAC[]);

val REAL_LT_LCANCEL_IMP = store_thm ("REAL_LT_LCANCEL_IMP",
 ``!x y z:real. &0 < x /\ x * y < x * z ==> y < z``,
  METIS_TAC [REAL_LT_LMUL]);

val SIMPLE_IMAGE_GEN = store_thm ("SIMPLE_IMAGE_GEN",
 ``!f P. {f x | P x} = IMAGE f {x | P x}``,
  SET_TAC[]);

val FINITE_IMAGE = IMAGE_FINITE;

val SUBSET_BIGUNION = store_thm ("SUBSET_BIGUNION",
 ``!f g. f SUBSET g ==> BIGUNION f SUBSET BIGUNION g``,
  SET_TAC[]);

val REAL_LT_POW2 = store_thm ("REAL_LT_POW2",
 ``!n:num. (&0:real) < &2 pow n``,
  SIMP_TAC arith_ss [REAL_POW_LT, REAL_LT]);

val FUN_IN_IMAGE = store_thm ("FUN_IN_IMAGE",
 ``!f s x. x IN s ==> f(x) IN IMAGE f s``,
  SET_TAC[]);

val SUBSET_ANTISYM_EQ = store_thm ("SUBSET_ANTISYM_EQ",
 ``!(s:'a->bool) t. s SUBSET t /\ t SUBSET s <=> (s = t)``,
 SET_TAC[]);

val DIFF_BIGINTER = store_thm ("DIFF_BIGINTER",
 ``!u s. u DIFF BIGINTER s = BIGUNION {u DIFF t | t IN s}``,
  SIMP_TAC std_ss [BIGUNION_GSPEC] THEN SET_TAC[]);

val BIGINTER_BIGUNION = store_thm ("BIGINTER_BIGUNION",
 ``!s. BIGINTER s = UNIV DIFF (BIGUNION {UNIV DIFF t | t IN s})``,
  REWRITE_TAC[GSYM DIFF_BIGINTER] THEN SET_TAC[]);

val BIGUNION_BIGINTER = store_thm ("BIGUNION_BIGINTER",
 ``!s. BIGUNION s = UNIV DIFF (BIGINTER {UNIV DIFF t | t IN s})``,
  GEN_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGUNION, IN_UNIV, IN_DIFF, BIGINTER_GSPEC,
   GSPECIFICATION] THEN
  MESON_TAC[]);

val REAL_POW_1_LE = store_thm ("REAL_POW_1_LE",
 ``!n x:real. &0 <= x /\ x <= &1 ==> x pow n <= &1``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``n:num``, ``x:real``, ``&1:real``] POW_LE) THEN
  ASM_REWRITE_TAC[POW_ONE]);

val REAL_POW_LE_1 = store_thm ("REAL_POW_LE_1",
 ``!n x:real. &1 <= x ==> &1 <= x pow n``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``n:num``, ``&1:real``, ``x:real``] POW_LE) THEN
  ASM_SIMP_TAC real_ss [POW_ONE, REAL_POS]);

val REAL_LT_INV2 = store_thm ("REAL_LT_INV2",
 ``!x y. &0:real < x /\ x < y ==> inv(y) < inv(x)``,
  REPEAT STRIP_TAC THEN KNOW_TAC ``&0:real < x * y`` THENL
  [MATCH_MP_TAC REAL_LT_MUL THEN
   POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN KNOW_TAC ``inv y * (x * y) < inv x * (x * y:real)`` THENL
  [ALL_TAC, FULL_SIMP_TAC std_ss [REAL_LT_RMUL]] THEN
  SUBGOAL_THEN ``(inv x * x = &1:real) /\ (inv y * y = &1:real)`` ASSUME_TAC THENL
  [CONJ_TAC THEN MATCH_MP_TAC REAL_MUL_LINV THEN
   POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN REAL_ARITH_TAC,
   ASM_REWRITE_TAC[REAL_MUL_ASSOC, REAL_MUL_LID] THEN
   GEN_REWR_TAC (LAND_CONV o LAND_CONV) [REAL_MUL_SYM] THEN
   ASM_REWRITE_TAC[GSYM REAL_MUL_ASSOC, REAL_MUL_RID]]);

val REAL_LE_INV2 = store_thm ("REAL_LE_INV2",
 ``!x y. &0:real < x /\ x <= y ==> inv(y) <= inv(x)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_LT] THEN
  ASM_CASES_TAC ``x:real = y`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN DISJ1_TAC THEN MATCH_MP_TAC REAL_LT_INV2 THEN
  ASM_REWRITE_TAC[]);

val REAL_INV_1_LE = store_thm ("REAL_INV_1_LE",
 ``!x:real. &0 < x /\ x <= &1 ==> &1 <= inv(x)``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_INV1] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_REWRITE_TAC[REAL_LT_01]);

val SUM_GP_BASIC = store_thm ("SUM_GP_BASIC",
 ``!x:real n:num. (&1 - x) * sum((0:num)..n) (\i. x pow i) = &1 - x pow (SUC n)``,
  GEN_TAC THEN INDUCT_TAC THEN SIMP_TAC std_ss [SUM_CLAUSES_NUMSEG] THEN
  SIMP_TAC std_ss [pow, REAL_MUL_RID, ZERO_LESS_EQ, POW_1] THEN
  ASM_REWRITE_TAC[REAL_ADD_LDISTRIB, pow] THEN REAL_ARITH_TAC);

val SUM_GP_MULTIPLIED = store_thm ("SUM_GP_MULTIPLIED",
 ``!x m n. m <= n
           ==> ((&1 - x) * sum(m..n) (\i. x pow i) = x pow m - x pow (SUC n))``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``((1 :real) - (x :real)) *
    sum ((0 :num) .. (n :num - m)) (\i. (\(i :num). x pow i) (i + m)) =
    x pow m - x pow SUC n`` THENL [ALL_TAC, METIS_TAC [SUM_OFFSET_0]] THEN
  ASM_SIMP_TAC std_ss
   [REAL_POW_ADD, REAL_MUL_ASSOC, SUM_GP_BASIC, SUM_RMUL] THEN
  SIMP_TAC std_ss [REAL_SUB_RDISTRIB, GSYM REAL_POW_ADD, REAL_MUL_LID] THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``m <= n ==> (SUC(n - m) + m = SUC n)``]);

val SUM_GP = store_thm ("SUM_GP",
 ``!x m n.
        sum(m..n) (\i. x pow i) =
                if n < m then &0
                else if x = &1 then &((n + 1) - m)
                else (x pow m - x pow (SUC n)) / (&1 - x)``,
  REPEAT GEN_TAC THEN
  DISJ_CASES_TAC(ARITH_PROVE ``n < m \/ ~(n < m) /\ m <= n:num``) THEN
  ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG] THEN COND_CASES_TAC THENL
   [ASM_REWRITE_TAC[POW_ONE, SUM_CONST_NUMSEG, REAL_MUL_RID], ALL_TAC] THEN
  MATCH_MP_TAC REAL_EQ_LMUL_IMP THEN EXISTS_TAC ``&1 - x:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_LMUL, REAL_SUB_0, SUM_GP_MULTIPLIED]);

val SUMS_SYM = store_thm ("SUMS_SYM",
 ``!s t:real->bool. {x + y | x IN s /\ y IN t} = {y + x | y IN t /\ x IN s}``,
 SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
 MESON_TAC[REAL_ADD_SYM]);

val SUM_ABS_TRIANGLE = store_thm ("SUM_ABS_TRIANGLE",
 ``!s f b. FINITE s /\ sum s (\a. abs(f a)) <= b ==> abs(sum s f) <= b``,
  METIS_TAC[SUM_ABS, REAL_LE_TRANS]);

val IMAGE_SING = store_thm ("IMAGE_SING",
 ``!f a. IMAGE f {a} = {f a}``,
  SET_TAC []);

val REAL_WLOG_LE = store_thm ("REAL_WLOG_LE",
 ``(!x y:real. P x y <=> P y x) /\ (!x y. x <= y ==> P x y) ==> !x y. P x y``,
  METIS_TAC[REAL_LE_TOTAL]);

(* ------------------------------------------------------------------------- *)
(* Pairwise property over sets and lists.                                    *)
(* ------------------------------------------------------------------------- *)

val pairwise = new_definition ("pairwise",
  ``pairwise r s <=> !x y. x IN s /\ y IN s /\ ~(x = y) ==> r x y``);

val PAIRWISE_EMPTY = store_thm ("PAIRWISE_EMPTY",
 ``!r. pairwise r {} <=> T``,
  REWRITE_TAC[pairwise, NOT_IN_EMPTY] THEN MESON_TAC[]);

val PAIRWISE_SING = store_thm ("PAIRWISE_SING",
 ``!r x. pairwise r {x} <=> T``,
  REWRITE_TAC[pairwise, IN_SING] THEN MESON_TAC[]);

val PAIRWISE_MONO = store_thm ("PAIRWISE_MONO",
 ``!r s t. pairwise r s /\ t SUBSET s ==> pairwise r t``,
  REWRITE_TAC[pairwise] THEN SET_TAC[]);

val PAIRWISE_INSERT = store_thm ("PAIRWISE_INSERT",
 ``!r x s.
        pairwise r (x INSERT s) <=>
        (!y. y IN s /\ ~(y = x) ==> r x y /\ r y x) /\
        pairwise r s``,
  REWRITE_TAC[pairwise, IN_INSERT] THEN MESON_TAC[]);

val PAIRWISE_IMAGE = store_thm ("PAIRWISE_IMAGE",
 ``!r f. pairwise r (IMAGE f s) <=>
         pairwise (\x y. ~(f x = f y) ==> r (f x) (f y)) s``,
  REWRITE_TAC[pairwise, IN_IMAGE] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Permutes                                                                  *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "permutes" (Infix(NONASSOC, 450));

val permutes = new_definition ("permutes",
 ``p permutes s <=> (!x. ~(x IN s) ==> (p(x) = x)) /\ (!y. ?!x. (p x = y))``);

val PERMUTES_IMAGE = store_thm ("PERMUTES_IMAGE",
 ``!p s. p permutes s ==> (IMAGE p s = s)``,
  REWRITE_TAC[permutes, EXTENSION, IN_IMAGE] THEN MESON_TAC[]);

val PERMUTES_INJECTIVE = store_thm ("PERMUTES_INJECTIVE",
 ``!p s. p permutes s ==> !x y. (p(x) = p(y)) <=> (x = y)``,
  REWRITE_TAC[permutes] THEN MESON_TAC[]);

val EXISTS_IN_INSERT = store_thm ("EXISTS_IN_INSERT",
 ``!P a s. (?x. x IN (a INSERT s) /\ P x) <=> P a \/ ?x. x IN s /\ P x``,
  REWRITE_TAC[IN_INSERT] THEN MESON_TAC[]);

val DEPENDENT_CHOICE_FIXED = store_thm ("DEPENDENT_CHOICE_FIXED",
 ``!P R a:'a. P 0 a /\ (!n x. P n x ==> ?y. P (SUC n) y /\ R n x y) ==>
          ?f. (f 0 = a) /\ (!n. P n (f n)) /\ (!n. R n (f n) (f(SUC n)))``,
  REPEAT STRIP_TAC THEN KNOW_TAC ``(?f. (f 0 = (a:'a)) /\
    (!n. f(SUC n) = (@y. P (SUC n) y /\ R n (f n) y)))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``f:num->'a`` THEN ASM_REWRITE_TAC [] THEN
  ONCE_REWRITE_TAC[METIS [] ``(!n. P n (f n)) = (!n. (\n. P n (f n)) n)``] THEN
  GEN_REWR_TAC LAND_CONV
   [MESON[num_CASES] ``(!n. P n) <=> P 0 /\ !n. P(SUC n)``] THEN
  ASM_SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN INDUCT_TAC THEN METIS_TAC[]);

val DEPENDENT_CHOICE = store_thm ("DEPENDENT_CHOICE",
 ``!P R:num->'a->'a->bool. (?a. P 0 a) /\
   (!n x. P n x ==> ?y. P (SUC n) y /\ R n x y) ==>
   ?f. (!n. P n (f n)) /\ (!n. R n (f n) (f(SUC n)))``,
  MESON_TAC[DEPENDENT_CHOICE_FIXED]);

val BIGUNION_MONO_IMAGE = store_thm ("BIGUNION_MONO_IMAGE",
 ``(!x. x IN s ==> f x SUBSET g x) ==>
    BIGUNION(IMAGE f s) SUBSET BIGUNION(IMAGE g s)``,
  SET_TAC[]);

val BIGUNION_MONO = store_thm ("BIGUNION_MONO",
 ``(!x. x IN s ==> ?y. y IN t /\ x SUBSET y) ==> BIGUNION s SUBSET BIGUNION t``,
  SET_TAC[]);

Triviality th =
  REWRITE_RULE[IN_UNIV]
    (ISPECL [``f:'a->'b``, ``UNIV:'a->bool``] INJECTIVE_ON_LEFT_INVERSE);

val REAL_WLOG_LT = store_thm ("REAL_WLOG_LT",
 ``(!x. P x x) /\ (!x y. P x y <=> P y x) /\ (!x y. x < y ==> P x y)
   ==> !x y:real. P x y``,
  METIS_TAC[REAL_LT_TOTAL]);

(* ------------------------------------------------------------------------- *)
(* Metric function. (TODO: merge with metricTheory)                          *)
(* ------------------------------------------------------------------------- *)

val dist = new_definition ("dist",
  ``Dist(x:real,y:real) = abs(x - y)``);

val _ = overload_on ("dist",``Dist``);

val DIST_REFL = store_thm ("DIST_REFL",
 ``!x. dist(x,x) = &0``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_SYM = store_thm ("DIST_SYM",
 ``!x y. dist(x,y) = dist(y,x)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE = store_thm ("DIST_TRIANGLE",
 ``!x:real y z. dist(x,z) <= dist(x,y) + dist(y,z)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE_ALT = store_thm ("DIST_TRIANGLE_ALT",
 ``!x y z. dist(y,z) <= dist(x,y) + dist(x,z)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_EQ_0 = store_thm ("DIST_EQ_0",
 ``!x y. (dist(x,y) = 0:real) <=> (x = y)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_POS_LT = store_thm ("DIST_POS_LT",
 ``!x y. ~(x = y) ==> &0 < dist(x,y)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_NZ = store_thm ("DIST_NZ",
 ``!x y. ~(x = y) <=> &0 < dist(x,y)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE_LE = store_thm ("DIST_TRIANGLE_LE",
 ``!x y z e. dist(x,z) + dist(y,z) <= e ==> dist(x,y) <= e``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE_LT = store_thm ("DIST_TRIANGLE_LT",
 ``!x y z e. dist(x,z) + dist(y,z) < e ==> dist(x,y) < e``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE_HALF_L = store_thm ("DIST_TRIANGLE_HALF_L",
 ``!x1 x2 y. dist(x1,y) < e / &2 /\ dist(x2,y) < e / &2 ==> dist(x1,x2) < e``,
  REPEAT STRIP_TAC THEN KNOW_TAC `` dist (x1,y) + dist (x2,y) < e`` THENL
  [METIS_TAC [REAL_LT_ADD2, REAL_HALF_DOUBLE],
   DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist (x1,y) + dist (x2,y)`` THEN
   METIS_TAC [DIST_TRIANGLE, DIST_SYM]]);

val DIST_TRIANGLE_HALF_R = store_thm ("DIST_TRIANGLE_HALF_R",
 ``!x1 x2 y. dist(y,x1) < e / &2 /\ dist(y,x2) < e / &2 ==> dist(x1,x2) < e``,
  REPEAT STRIP_TAC THEN KNOW_TAC `` dist (y, x1) + dist (y, x2) < e`` THENL
  [METIS_TAC [REAL_LT_ADD2, REAL_HALF_DOUBLE],
   DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist (y, x1) + dist (y, x2)`` THEN
   METIS_TAC [DIST_TRIANGLE, DIST_SYM]]);

val DIST_TRIANGLE_ADD = store_thm ("DIST_TRIANGLE_ADD",
 ``!x x' y y'. dist(x + y,x' + y') <= dist(x,x') + dist(y,y')``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_MUL = store_thm ("DIST_MUL",
 ``!x y c. dist(c * x,c * y) = abs(c) * dist(x,y)``,
  REWRITE_TAC[dist, GSYM ABS_MUL] THEN REAL_ARITH_TAC);

val DIST_TRIANGLE_ADD_HALF = store_thm ("DIST_TRIANGLE_ADD_HALF",
 ``!x x' y y':real.
    dist(x,x') < e / &2 /\ dist(y,y') < e / &2 ==> dist(x + y,x' + y') < e``,
  REPEAT STRIP_TAC THEN KNOW_TAC `` dist (x, x') + dist (y, y') < e`` THENL
  [METIS_TAC [REAL_LT_ADD2, REAL_HALF_DOUBLE],
   DISCH_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist (x, x') + dist (y, y')`` THEN
   METIS_TAC [DIST_TRIANGLE_ADD, DIST_SYM]]);

val DIST_LE_0 = store_thm ("DIST_LE_0",
 ``!x y. dist(x,y) <= &0 <=> (x = y)``,
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val DIST_POS_LE = store_thm ("DIST_POS_LE",
 ``!x y. &0 <= dist(x,y)``,
  METIS_TAC [DIST_EQ_0, DIST_NZ, REAL_LE_LT]);

val DIST_EQ = store_thm ("DIST_EQ",
 ``!w x y z. (dist(w,x) = dist(y,z)) <=> (dist(w,x) pow 2 = dist(y,z) pow 2)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL [RW_TAC std_ss [],
  DISCH_TAC THEN MATCH_MP_TAC POW_EQ THEN EXISTS_TAC ``1:num`` THEN
  RW_TAC arith_ss [DIST_POS_LE]]);

val DIST_0 = store_thm ("DIST_0",
 ``!x. (dist(x,0) = abs(x)) /\ (dist(0,x) = abs(x))``,
  RW_TAC arith_ss [dist, REAL_SUB_RZERO, REAL_SUB_LZERO, ABS_NEG]);

val REAL_CHOOSE_DIST = store_thm ("REAL_CHOOSE_DIST",
 ``!x e. &0 <= e ==> (?y. dist (x,y) = e)``,
  REPEAT STRIP_TAC THEN EXISTS_TAC ``x - e:real`` THEN
  ASM_REWRITE_TAC [dist, REAL_SUB_SUB2, ABS_REFL]);

(* ------------------------------------------------------------------------- *)
(* Linear functions.                                                         *)
(* ------------------------------------------------------------------------- *)

val linear = new_definition ("linear",
  ``linear (f:real->real) <=>
        (!x y. f(x + y) = f(x) + f(y)) /\
        (!c x. f(c * x) = c * f(x))``);

val LINEAR_SCALING = store_thm ("LINEAR_SCALING",
 ``!c. linear(\x:real. c * x)``,
 SIMP_TAC std_ss [linear] THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_CMUL = store_thm ("LINEAR_COMPOSE_CMUL",
 ``!f c. linear f ==> linear (\x. c * f(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_NEG = store_thm ("LINEAR_COMPOSE_NEG",
 ``!f. linear f ==> linear (\x. -(f(x)))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_ADD = store_thm ("LINEAR_COMPOSE_ADD",
 ``!f g. linear f /\ linear g ==> linear (\x. f(x) + g(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_SUB = store_thm ("LINEAR_COMPOSE_SUB",
 ``!f g. linear f /\ linear g ==> linear (\x. f(x) - g(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE = store_thm ("LINEAR_COMPOSE",
 ``!f g. linear f /\ linear g ==> linear (g o f)``,
  SIMP_TAC std_ss [linear, o_THM]);

val LINEAR_ID = store_thm ("LINEAR_ID",
 ``linear (\x. x)``,
  SIMP_TAC std_ss [linear]);

val LINEAR_ZERO = store_thm ("LINEAR_ZERO",
 ``linear (\x. 0)``,
  SIMP_TAC std_ss [linear] THEN CONJ_TAC THEN REAL_ARITH_TAC);

val LINEAR_NEGATION = store_thm ("LINEAR_NEGATION",
 ``linear (\x. -x)``,
  SIMP_TAC std_ss [linear] THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_SUM = store_thm ("LINEAR_COMPOSE_SUM",
 ``!f s. FINITE s /\ (!a. a IN s ==> linear(f a))
         ==> linear(\x. sum s (\a. f a x))``,
  GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN GEN_TAC THEN
  KNOW_TAC
    ``((!a. a IN s ==> linear (f a)) ==> linear (\x. sum s (\a. f a x))) =
     (\s. (!a. a IN s ==> linear (f a)) ==> linear (\x. sum s (\a. f a x))) s``
  THENL [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES, LINEAR_ZERO] THEN REPEAT STRIP_TAC THEN
  KNOW_TAC ``(linear (\x. f e x + sum s (\a. f a x))) =
              linear (\x. (\x. f e x) x + (\x. sum s (\a. f a x)) x)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LINEAR_COMPOSE_ADD THEN METIS_TAC [IN_INSERT]);

val LINEAR_MUL_COMPONENT = store_thm ("LINEAR_MUL_COMPONENT",
 ``!f:real->real v.
     linear f ==> linear (\x. f(x) * v)``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_0 = store_thm ("LINEAR_0",
 ``!f. linear f ==> (f(0) = 0)``,
  METIS_TAC [REAL_MUL_LZERO, linear]);

val LINEAR_CMUL = store_thm ("LINEAR_CMUL",
 ``!f c x. linear f ==> (f(c * x) = c * f(x))``,
  SIMP_TAC std_ss [linear]);

val LINEAR_NEG = store_thm ("LINEAR_NEG",
 ``!f x. linear f ==> (f(-x) = -(f x))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [LINEAR_CMUL]);

val LINEAR_ADD = store_thm ("LINEAR_ADD",
 ``!f x y. linear f ==> (f(x + y) = f(x) + f(y))``,
  SIMP_TAC std_ss [linear]);

val LINEAR_SUB = store_thm ("LINEAR_SUB",
 ``!f x y. linear f ==> (f(x - y) = f(x) - f(y))``,
  SIMP_TAC std_ss [real_sub, LINEAR_ADD, LINEAR_NEG]);

val LINEAR_SUM = store_thm ("LINEAR_SUM",
 ``!f g s. linear f /\ FINITE s ==> (f(sum s g) = sum s (f o g))``,
  GEN_TAC THEN GEN_TAC THEN SIMP_TAC std_ss [GSYM AND_IMP_INTRO, RIGHT_FORALL_IMP_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN
  KNOW_TAC ``(f (sum s g) = sum s (f o g)) =
          (\s. (f (sum s g) = sum s (f o g))) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES] THEN FIRST_ASSUM(fn th =>
    SIMP_TAC std_ss [MATCH_MP LINEAR_0 th, MATCH_MP LINEAR_ADD th, o_THM]));

val LINEAR_SUM_MUL = store_thm ("LINEAR_SUM_MUL",
 ``!f s c v.
        linear f /\ FINITE s
        ==> (f(sum s (\i. c i * v i)) = sum s (\i. c(i) * f(v i)))``,
  SIMP_TAC std_ss [LINEAR_SUM, o_DEF, LINEAR_CMUL]);

val lemma = prove (
 ``x = sum (1:num..1:num) (\i. x * &i)``,
  REWRITE_TAC [SUM_SING_NUMSEG] THEN BETA_TAC THEN REAL_ARITH_TAC);

val LINEAR_BOUNDED = store_thm ("LINEAR_BOUNDED",
 ``!f:real->real. linear f ==> ?B. !x. abs(f x) <= B * abs(x)``,
  REPEAT STRIP_TAC THEN EXISTS_TAC
   ``sum(1:num..1:num) (\i. abs((f:real->real)(&i)))`` THEN
  GEN_TAC THEN
  GEN_REWR_TAC (LAND_CONV o funpow 2 RAND_CONV) [lemma] THEN
  ASM_SIMP_TAC std_ss [LINEAR_SUM, FINITE_NUMSEG] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN REWRITE_TAC[GSYM SUM_LMUL] THEN
  MATCH_MP_TAC SUM_ABS_LE THEN REWRITE_TAC [FINITE_NUMSEG, IN_NUMSEG] THEN
  BETA_TAC THEN ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN
  ASM_SIMP_TAC std_ss [o_DEF, ABS_MUL, LINEAR_CMUL] THEN
  METIS_TAC [REAL_LE_RMUL, ABS_POS, REAL_LE_LT, REAL_MUL_COMM]);

val LINEAR_BOUNDED_POS = store_thm ("LINEAR_BOUNDED_POS",
 ``!f:real->real. linear f ==> ?B. &0 < B /\ !x. abs(f x) <= B * abs(x)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(X_CHOOSE_TAC ``B:real`` o MATCH_MP LINEAR_BOUNDED) THEN
  EXISTS_TAC ``abs(B) + &1:real`` THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x <= a ==> x <= b:real``) THEN
  MATCH_MP_TAC REAL_LE_RMUL_IMP THEN REWRITE_TAC[ABS_POS] THEN
  REAL_ARITH_TAC);

val SYMMETRIC_LINEAR_IMAGE = store_thm ("SYMMETRIC_LINEAR_IMAGE",
 ``!f s. (!x. x IN s ==> -x IN s) /\ linear f
          ==> !x. x IN (IMAGE f s) ==> -x IN (IMAGE f s)``,
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  SIMP_TAC std_ss [GSYM LINEAR_NEG] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Bilinear functions.                                                       *)
(* ------------------------------------------------------------------------- *)

val bilinear = new_definition ("bilinear",
  ``bilinear f <=> (!x. linear(\y. f x y)) /\ (!y. linear(\x. f x y))``);

val BILINEAR_SWAP = store_thm ("BILINEAR_SWAP",
 ``!op:real->real->real.
        bilinear(\x y. op y x) <=> bilinear op``,
  SIMP_TAC std_ss [bilinear, ETA_AX] THEN METIS_TAC[]);

val BILINEAR_LADD = store_thm ("BILINEAR_LADD",
 ``!h x y z. bilinear h ==> (h (x + y) z = (h x z) + (h y z))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_RADD = store_thm ("BILINEAR_RADD",
 ``!h x y z. bilinear h ==> (h x (y + z) = (h x y) + (h x z))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_LMUL = store_thm ("BILINEAR_LMUL",
 ``!h c x y. bilinear h ==> (h (c * x) y = c * (h x y))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_RMUL = store_thm ("BILINEAR_RMUL",
 ``!h c x y. bilinear h ==> (h x (c * y) = c * (h x y))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_LNEG = store_thm ("BILINEAR_LNEG",
 ``!h x y. bilinear h ==> (h (-x) y = -(h x y))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [BILINEAR_LMUL]);

val BILINEAR_RNEG = store_thm ("BILINEAR_RNEG",
 ``!h x y. bilinear h ==> (h x (-y) = -(h x y))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [BILINEAR_RMUL]);

val BILINEAR_LZERO = store_thm ("BILINEAR_LZERO",
 ``!h x. bilinear h ==> (h (0) x = 0)``,
  ONCE_REWRITE_TAC[REAL_ARITH ``(x = 0:real) <=> (x + x = x)``] THEN
  SIMP_TAC std_ss [GSYM BILINEAR_LADD, REAL_ADD_LID]);

val BILINEAR_RZERO = store_thm ("BILINEAR_RZERO",
 ``!h x. bilinear h ==> (h x (0) = 0)``,
  ONCE_REWRITE_TAC[REAL_ARITH ``(x = 0:real) <=> (x + x = x)``] THEN
  SIMP_TAC std_ss [GSYM BILINEAR_RADD, REAL_ADD_LID]);

val BILINEAR_LSUB = store_thm ("BILINEAR_LSUB",
 ``!h x y z. bilinear h ==> (h (x - y) z = (h x z) - (h y z))``,
  SIMP_TAC std_ss [real_sub, BILINEAR_LNEG, BILINEAR_LADD]);

val BILINEAR_RSUB = store_thm ("BILINEAR_RSUB",
 ``!h x y z. bilinear h ==> (h x (y - z) = (h x y) - (h x z))``,
  SIMP_TAC std_ss [real_sub, BILINEAR_RNEG, BILINEAR_RADD]);

val lemma = prove (
 ``!s t. s CROSS t = {(x,y) | x IN s /\ y IN t}``,
  REWRITE_TAC [CROSS_DEF] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD]);

val BILINEAR_SUM = store_thm ("BILINEAR_SUM",
 ``!h:real->real->real.
       bilinear h /\ FINITE s /\ FINITE t
       ==> (h (sum s f) (sum t g) = sum (s CROSS t) (\(i,j). h (f i) (g j)))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [bilinear] THEN
  KNOW_TAC ``(!x. linear (\y. h:real->real->real x y)) = (!x. linear (h x))`` THENL
  [METIS_TAC [ETA_AX], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `(a /\ b) /\ c /\ d <=> (a /\ d) /\ (b /\ c)`] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  KNOW_TAC ``((!y. linear (\x. h:real->real->real x y)) /\ FINITE s) =
             ((!y. linear (\x. h x y) /\ FINITE s))`` THENL
  [SIMP_TAC std_ss [LEFT_AND_FORALL_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o GEN_ALL o MATCH_MP LINEAR_SUM o SPEC_ALL) THEN
  SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [LINEAR_SUM, o_DEF, SUM_SUM_PRODUCT] THEN
  SIMP_TAC std_ss [lemma]);

val lemma = prove (
 ``!x. x = sum (1:num..1:num) (\i. x * &i)``,
  REWRITE_TAC [SUM_SING_NUMSEG] THEN BETA_TAC THEN REAL_ARITH_TAC);

val BILINEAR_BOUNDED = store_thm ("BILINEAR_BOUNDED",
 ``!h:real->real->real.
        bilinear h ==> ?B. !x y. abs(h x y) <= B * abs(x) * abs(y)``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``sum ((1:num..1:num) CROSS (1:num..1:num))
                  (\ (i,j). abs((h:real->real->real)
                                (&i) (&j)))`` THEN
  REPEAT GEN_TAC THEN GEN_REWR_TAC
   (LAND_CONV o RAND_CONV o BINOP_CONV) [lemma] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_SUM, FINITE_NUMSEG] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = b * c * a:real``] THEN
  REWRITE_TAC[GSYM SUM_LMUL] THEN MATCH_MP_TAC SUM_ABS_LE THEN
  SIMP_TAC std_ss [FINITE_CROSS, FINITE_NUMSEG, FORALL_PROD, IN_CROSS] THEN
  REWRITE_TAC[IN_NUMSEG] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [BILINEAR_LMUL, ABS_MUL] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RMUL, ABS_MUL, REAL_MUL_ASSOC] THEN
  METIS_TAC [REAL_LE_LT]);

val BILINEAR_BOUNDED_POS = store_thm ("BILINEAR_BOUNDED_POS",
 ``!h. bilinear h
       ==> ?B. &0 < B /\ !x y. abs(h x y) <= B * abs(x) * abs(y)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(X_CHOOSE_TAC ``B:real`` o MATCH_MP BILINEAR_BOUNDED) THEN
  EXISTS_TAC ``abs(B) + &1:real`` THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  REPEAT GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPECL [`x:real`, `y:real`]) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x <= a ==> x <= b:real``) THEN
  REPEAT(MATCH_MP_TAC REAL_LE_RMUL_IMP THEN
         SIMP_TAC std_ss [ABS_POS, REAL_LE_MUL]) THEN
  REAL_ARITH_TAC);

val BILINEAR_SUM_PARTIAL_SUC = store_thm ("BILINEAR_SUM_PARTIAL_SUC",
 ``!f g h:real->real->real m n.
        bilinear h
        ==> (sum (m..n) (\k. h (f k) (g(k + 1) - g(k))) =
                if m <= n then h (f(n + 1)) (g(n + 1)) - h (f m) (g m) -
                               sum (m..n) (\k. h (f(k + 1) - f(k)) (g(k + 1)))
                else 0)``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  GEN_TAC THEN INDUCT_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, NOT_LESS_EQ] THEN
  ASM_REWRITE_TAC[SUM_CLAUSES_NUMSEG] THENL
   [COND_CASES_TAC THEN ASM_SIMP_TAC arith_ss [] THENL
     [ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC,
      FULL_SIMP_TAC std_ss [bilinear, linear]], FULL_SIMP_TAC std_ss [bilinear, linear],
  POP_ASSUM MP_TAC THEN REWRITE_TAC [LE] THEN
  DISCH_THEN(DISJ_CASES_THEN2 SUBST_ALL_TAC ASSUME_TAC) THENL [ALL_TAC, ASM_REWRITE_TAC []] THEN
  ASM_SIMP_TAC std_ss [GSYM NOT_LESS, SUM_TRIV_NUMSEG, ARITH_PROVE ``n < SUC n``] THEN
  ASM_SIMP_TAC std_ss [GSYM ADD1, ADD_CLAUSES] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC,
  ALL_TAC] THEN POP_ASSUM MP_TAC THEN REWRITE_TAC [LE] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  ASM_SIMP_TAC std_ss [GSYM NOT_LESS, SUM_TRIV_NUMSEG, ARITH_PROVE ``n < SUC n``] THEN
  ASM_SIMP_TAC std_ss [GSYM ADD1, ADD_CLAUSES] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC);

val BILINEAR_SUM_PARTIAL_PRE = store_thm ("BILINEAR_SUM_PARTIAL_PRE",
 ``!f g h:real->real->real m n.
        bilinear h
        ==> (sum (m..n) (\k. h (f k) (g(k) - g(k - 1))) =
                if m <= n then h (f(n + 1)) (g(n)) - h (f m) (g(m - 1)) -
                               sum (m..n) (\k. h (f(k + 1) - f(k)) (g(k)))
                else 0)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o ISPECL [``f:num->real``, ``\k. (g:num->real)(k - 1)``,
                 ``m:num``, ``n:num``] o MATCH_MP BILINEAR_SUM_PARTIAL_SUC) THEN
  BETA_TAC THEN REWRITE_TAC[ADD_SUB] THEN DISCH_THEN SUBST1_TAC THEN
  COND_CASES_TAC THEN REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* A bit of linear algebra.                                                  *)
(* ------------------------------------------------------------------------- *)

val subspace = new_definition ("subspace",
 ``subspace s <=>
        (0:real) IN s /\
        (!x y. x IN s /\ y IN s ==> (x + y) IN s) /\
        (!c x. x IN s ==> (c * x) IN s)``);

val span = new_definition ("span",
  ``span s = subspace hull s``);

val dependent = new_definition ("dependent",
 ``dependent s <=> ?a. a IN s /\ a IN span(s DELETE a)``);

val independent = new_definition ("independent",
 ``independent s <=> ~(dependent s)``);

(* ------------------------------------------------------------------------- *)
(* Closure properties of subspaces.                                          *)
(* ------------------------------------------------------------------------- *)

val SUBSPACE_UNIV = store_thm ("SUBSPACE_UNIV",
 ``subspace(UNIV:real->bool)``,
  REWRITE_TAC[subspace, IN_UNIV]);

val SUBSPACE_IMP_NONEMPTY = store_thm ("SUBSPACE_IMP_NONEMPTY",
 ``!s. subspace s ==> ~(s = {})``,
  REWRITE_TAC[subspace] THEN SET_TAC[]);

val SUBSPACE_0 = store_thm ("SUBSPACE_0",
 ``subspace s ==> (0:real) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_ADD = store_thm ("SUBSPACE_ADD",
 ``!x y s. subspace s /\ x IN s /\ y IN s ==> (x + y) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_MUL = store_thm ("SUBSPACE_MUL",
 ``!x c s. subspace s /\ x IN s ==> (c * x) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_NEG = store_thm ("SUBSPACE_NEG",
 ``!x s. subspace s /\ x IN s ==> (-x) IN s``,
  METIS_TAC [REAL_ARITH ``-x = -(&1) * x:real``, SUBSPACE_MUL]);

val SUBSPACE_SUB = store_thm ("SUBSPACE_SUB",
 ``!x y s. subspace s /\ x IN s /\ y IN s ==> (x - y) IN s``,
  SIMP_TAC std_ss [real_sub, SUBSPACE_ADD, SUBSPACE_NEG]);

val SUBSPACE_SUM = store_thm ("SUBSPACE_SUM",
 ``!s f t. subspace s /\ FINITE t /\ (!x. x IN t ==> f(x) IN s)
           ==> (sum t f) IN s``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!t. ((!x. x IN t ==> f x IN s) ==> sum t f IN s) =
                               (\t. (!x. x IN t ==> f x IN s) ==> sum t f IN s) t``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  ASM_SIMP_TAC std_ss [SUM_CLAUSES, SUBSPACE_0, IN_INSERT, SUBSPACE_ADD]);

val SUBSPACE_LINEAR_IMAGE = store_thm ("SUBSPACE_LINEAR_IMAGE",
 ``!f s. linear f /\ subspace s ==> subspace(IMAGE f s)``,
  SIMP_TAC std_ss [subspace, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN REWRITE_TAC[IN_IMAGE] THEN
  METIS_TAC [linear, LINEAR_0]);

val SUBSPACE_LINEAR_PREIMAGE = store_thm ("SUBSPACE_LINEAR_PREIMAGE",
 ``!f s. linear f /\ subspace s ==> subspace {x | f(x) IN s}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  METIS_TAC [linear, LINEAR_0]);

val SUBSPACE_TRIVIAL = store_thm ("SUBSPACE_TRIVIAL",
 ``subspace {0}``,
  SIMP_TAC std_ss [subspace, IN_SING] THEN CONJ_TAC THEN REAL_ARITH_TAC);

val SUBSPACE_INTER = store_thm ("SUBSPACE_INTER",
 ``!s t. subspace s /\ subspace t ==> subspace (s INTER t)``,
  REWRITE_TAC[subspace, IN_INTER] THEN METIS_TAC []);

val SUBSPACE_BIGINTER = store_thm ("SUBSPACE_BIGINTER",
 ``!f. (!s. s IN f ==> subspace s) ==> subspace(BIGINTER f)``,
  SIMP_TAC std_ss [subspace, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, IN_BIGINTER]);

val LINEAR_INJECTIVE_0_SUBSPACE = store_thm ("LINEAR_INJECTIVE_0_SUBSPACE",
 ``!f:real->real s.
        linear f /\ subspace s
         ==> ((!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) <=>
              (!x. x IN s /\ (f x = 0) ==> (x = 0)))``,
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_SUB_0] THEN
  ASM_SIMP_TAC std_ss [GSYM LINEAR_SUB] THEN
  METIS_TAC [REAL_SUB_RZERO, SUBSPACE_SUB, SUBSPACE_0]);

val SUBSPACE_UNION_CHAIN = store_thm ("SUBSPACE_UNION_CHAIN",
 ``!s t:real->bool.
        subspace s /\ subspace t /\ subspace(s UNION t)
         ==> s SUBSET t \/ t SUBSET s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC [SET_RULE
   ``s SUBSET t \/ t SUBSET s <=>
    ~(?x y. x IN s /\ ~(x IN t) /\ y IN t /\ ~(y IN s))``] THEN
  STRIP_TAC THEN SUBGOAL_THEN ``(x + y:real) IN (s UNION t)`` MP_TAC THENL
   [MATCH_MP_TAC SUBSPACE_ADD THEN ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
    REWRITE_TAC[IN_UNION, DE_MORGAN_THM] THEN
    METIS_TAC [SUBSPACE_SUB, REAL_ARITH
     ``((x + y) - x:real = y) /\ ((x + y) - y:real = x)``]]);

(* ------------------------------------------------------------------------- *)
(* Lemmas.                                                                   *)
(* ------------------------------------------------------------------------- *)

val SPAN_SPAN = store_thm ("SPAN_SPAN",
 ``!s. span(span s) = span s``,
  REWRITE_TAC[span, HULL_HULL]);

val SPAN_MONO = store_thm ("SPAN_MONO",
 ``!s t. s SUBSET t ==> span s SUBSET span t``,
  REWRITE_TAC[span, HULL_MONO]);

val SUBSPACE_SPAN = store_thm ("SUBSPACE_SPAN",
 ``!s. subspace(span s)``,
  GEN_TAC THEN REWRITE_TAC[span] THEN MATCH_MP_TAC P_HULL THEN
  SIMP_TAC std_ss [subspace, IN_BIGINTER]);

val SPAN_CLAUSES = store_thm ("SPAN_CLAUSES",
 ``(!a s. a IN s ==> a IN span s) /\
   ((0) IN span s) /\
   (!x y s. x IN span s /\ y IN span s ==> (x + y) IN span s) /\
   (!x c s. x IN span s ==> (c * x) IN span s)``,
  MESON_TAC[span, HULL_SUBSET, SUBSET_DEF, SUBSPACE_SPAN, subspace]);

val SPAN_INDUCT = store_thm ("SPAN_INDUCT",
 ``!s h. (!x. x IN s ==> x IN h) /\ subspace h ==> !x. x IN span(s) ==> h(x)``,
  REWRITE_TAC[span] THEN MESON_TAC[SUBSET_DEF, HULL_MINIMAL, IN_DEF]);

val SPAN_EMPTY = store_thm ("SPAN_EMPTY",
 ``span {} = {0}``,
  REWRITE_TAC[span] THEN MATCH_MP_TAC HULL_UNIQUE THEN
  SIMP_TAC std_ss [subspace, SUBSET_DEF, IN_SING, NOT_IN_EMPTY] THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val INDEPENDENT_EMPTY = store_thm ("INDEPENDENT_EMPTY",
 ``independent {}``,
  REWRITE_TAC[independent, dependent, NOT_IN_EMPTY]);

val INDEPENDENT_NONZERO = store_thm ("INDEPENDENT_NONZERO",
 ``!s. independent s ==> ~(0 IN s)``,
  REWRITE_TAC[independent, dependent] THEN MESON_TAC[SPAN_CLAUSES]);

val INDEPENDENT_MONO = store_thm ("INDEPENDENT_MONO",
 ``!s t. independent t /\ s SUBSET t ==> independent s``,
  REWRITE_TAC[independent, dependent] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_DELETE]);

val DEPENDENT_MONO = store_thm ("DEPENDENT_MONO",
 ``!s t:real->bool. dependent s /\ s SUBSET t ==> dependent t``,
  ONCE_REWRITE_TAC[TAUT `p /\ q ==> r <=> ~r /\ q ==> ~p`] THEN
  REWRITE_TAC[GSYM independent, INDEPENDENT_MONO]);

val SPAN_SUBSPACE = store_thm ("SPAN_SUBSPACE",
 ``!b s. b SUBSET s /\ s SUBSET (span b) /\ subspace s ==> (span b = s)``,
  MESON_TAC[SUBSET_ANTISYM, span, HULL_MINIMAL]);

val SPAN_INDUCT_ALT = store_thm ("SPAN_INDUCT_ALT",
 ``!s h. h(0) /\
         (!c x y. x IN s /\ h(y) ==> h(c * x + y))
          ==> !x:real. x IN span(s) ==> h(x)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o prove_nonschematic_inductive_relations_exist bool_monoset o concl) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``!x:real. x IN span(s) ==> g(x)``
   (fn th => METIS_TAC [th]) THEN
  MATCH_MP_TAC SPAN_INDUCT THEN SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  SIMP_TAC std_ss [IN_DEF, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(g x ==> g (c * x)) = (\c x:real. g x ==> g (c * x)) c x``] THEN
  ONCE_REWRITE_TAC[SWAP_FORALL_THM] THEN SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN
  REPEAT CONJ_TAC THENL
  [METIS_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   METIS_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   ONCE_REWRITE_TAC [METIS [] ``!x. (!y. g y ==> g (x + y)) =
                              (\x. !y. g y ==> g (x + y)) (x:real)``] THEN
   FIRST_X_ASSUM MATCH_MP_TAC THEN
   SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_ASSOC] THEN
   ASM_MESON_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   ONCE_REWRITE_TAC [METIS [] ``(!x. g (x * y)) =
                            (\y.!x. g (x * y)) (y:real)``] THEN
   FIRST_X_ASSUM MATCH_MP_TAC THEN
   SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_ASSOC] THEN
   ASM_MESON_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO]]);

(* ------------------------------------------------------------------------- *)
(* Individual closure properties.                                            *)
(* ------------------------------------------------------------------------- *)

val SPAN_SUPERSET = store_thm ("SPAN_SUPERSET",
 ``!x. x IN s ==> x IN span s``,
  MESON_TAC[SPAN_CLAUSES]);

val SPAN_INC = store_thm ("SPAN_INC",
 ``!s. s SUBSET span s``,
  REWRITE_TAC[SUBSET_DEF, SPAN_SUPERSET]);

val SPAN_UNION_SUBSET = store_thm ("SPAN_UNION_SUBSET",
 ``!s t. span s UNION span t SUBSET span(s UNION t)``,
  REWRITE_TAC[span, HULL_UNION_SUBSET]);

val SPAN_UNIV = store_thm ("SPAN_UNIV",
 ``span univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [SPAN_INC, SET_RULE ``UNIV SUBSET s ==> (s = UNIV)``]);

val SPAN_0 = store_thm ("SPAN_0",
 ``(0) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_0]);

val SPAN_ADD = store_thm ("SPAN_ADD",
 ``!x y s. x IN span s /\ y IN span s ==> (x + y) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_ADD]);

val SPAN_MUL = store_thm ("SPAN_MUL",
 ``!x c s. x IN span s ==> (c * x) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_MUL]);

val SPAN_MUL_EQ = store_thm ("SPAN_MUL_EQ",
 ``!x:real c s. ~(c = &0) ==> ((c * x) IN span s <=> x IN span s)``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN ASM_SIMP_TAC std_ss [SPAN_MUL] THEN
  SUBGOAL_THEN ``(inv(c) * c * x:real) IN span s`` MP_TAC THENL
   [REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN ASM_SIMP_TAC std_ss [SPAN_MUL],
    ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID]]);

val SPAN_NEG = store_thm ("SPAN_NEG",
 ``!x s. x IN span s ==> (-x) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_NEG]);

val SPAN_NEG_EQ = store_thm ("SPAN_NEG_EQ",
 ``!x s. -x IN span s <=> x IN span s``,
  MESON_TAC[SPAN_NEG, REAL_NEG_NEG]);

val SPAN_SUB = store_thm ("SPAN_SUB",
 ``!x y s. x IN span s /\ y IN span s ==> (x - y) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_SUB]);

val SPAN_SUM = store_thm ("SPAN_SUM",
 ``!s f t. FINITE t /\ (!x. x IN t ==> f(x) IN span(s))
           ==> (sum t f) IN span(s)``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_SUM]);

val SPAN_ADD_EQ = store_thm ("SPAN_ADD_EQ",
 ``!s x y. x IN span s ==> ((x + y) IN span s <=> y IN span s)``,
  MESON_TAC[SPAN_ADD, SPAN_SUB, REAL_ARITH ``(x + y) - x:real = y``]);

val SPAN_EQ_SELF = store_thm ("SPAN_EQ_SELF",
 ``!s. (span s = s) <=> subspace s``,
  GEN_TAC THEN EQ_TAC THENL [MESON_TAC[SUBSPACE_SPAN], ALL_TAC] THEN
  DISCH_TAC THEN MATCH_MP_TAC SPAN_SUBSPACE THEN
  ASM_REWRITE_TAC[SUBSET_REFL, SPAN_INC]);

val SPAN_SUBSET_SUBSPACE = store_thm ("SPAN_SUBSET_SUBSPACE",
 ``!s t:real->bool. s SUBSET t /\ subspace t ==> span s SUBSET t``,
  MESON_TAC[SPAN_MONO, SPAN_EQ_SELF]);

val SURJECTIVE_IMAGE_EQ = store_thm ("SURJECTIVE_IMAGE_EQ",
 ``!s t. (!y. y IN t ==> ?x. f x = y) /\ (!x. (f x) IN t <=> x IN s)
         ==> (IMAGE f s = t)``,
  SET_TAC[]);

val SUBSPACE_TRANSLATION_SELF = store_thm ("SUBSPACE_TRANSLATION_SELF",
 ``!s a. subspace s /\ a IN s ==> (IMAGE (\x. a + x) s = s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SURJECTIVE_IMAGE_EQ THEN
  FIRST_ASSUM(SUBST1_TAC o SYM o REWRITE_RULE [GSYM SPAN_EQ_SELF]) THEN
  ASM_SIMP_TAC std_ss [SPAN_ADD_EQ, SPAN_CLAUSES] THEN
  REWRITE_TAC[REAL_ARITH ``(a + x:real = y) <=> (x = y - a)``, EXISTS_REFL]);

val SUBSPACE_TRANSLATION_SELF_EQ = store_thm ("SUBSPACE_TRANSLATION_SELF_EQ",
 ``!s a:real. subspace s ==> ((IMAGE (\x. a + x) s = s) <=> a IN s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_TRANSLATION_SELF] THEN
  DISCH_THEN(MP_TAC o AP_TERM ``\s. (a:real) IN s``) THEN
  SIMP_TAC std_ss [] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  REWRITE_TAC[IN_IMAGE] THEN EXISTS_TAC ``0:real`` THEN
  ASM_MESON_TAC[subspace, REAL_ADD_RID]);

val SUBSPACE_SUMS = store_thm ("SUBSPACE_SUMS",
 ``!s t. subspace s /\ subspace t
         ==> subspace {x + y | x IN s /\ y IN t}``,
  SIMP_TAC std_ss [subspace, FORALL_IN_GSPEC, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN REPEAT STRIP_TAC THENL
   [ASM_MESON_TAC[REAL_ADD_LID],
    ONCE_REWRITE_TAC[REAL_ARITH
     ``(x + y) + (x' + y'):real = (x + x') + (y + y')``] THEN
    ASM_MESON_TAC[],
    REWRITE_TAC[REAL_ADD_LDISTRIB] THEN ASM_MESON_TAC[]]);

val SPAN_UNION = store_thm ("SPAN_UNION",
 ``!s t. span(s UNION t) = {x + y:real | x IN span s /\ y IN span t}``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [MATCH_MP_TAC SPAN_SUBSET_SUBSPACE THEN
    SIMP_TAC std_ss [SUBSPACE_SUMS, SUBSPACE_SPAN] THEN
    SIMP_TAC std_ss [SUBSET_DEF, IN_UNION, GSPECIFICATION, EXISTS_PROD] THEN
    X_GEN_TAC ``x:real`` THEN STRIP_TAC THENL
     [MAP_EVERY EXISTS_TAC [``x:real``, ``0:real``] THEN
      ASM_SIMP_TAC std_ss [SPAN_SUPERSET, SPAN_0, REAL_ADD_RID],
      MAP_EVERY EXISTS_TAC [``0:real``, ``x:real``] THEN
      ASM_SIMP_TAC std_ss [SPAN_SUPERSET, SPAN_0, REAL_ADD_LID]],
    SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_GSPEC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SPAN_ADD THEN
    ASM_MESON_TAC[SPAN_MONO, SUBSET_UNION, SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* Equality in Cauchy-Schwarz and triangle inequalities.                     *)
(* ------------------------------------------------------------------------- *)

val ABS_CAUCHY_SCHWARZ_EQ = store_thm
  ("ABS_CAUCHY_SCHWARZ_EQ",
 ``!x:real y. (x * y = abs(x) * abs(y)) <=> (abs(x) * y = abs(y) * x)``,
   REPEAT GEN_TAC THEN ASM_CASES_TAC ``0 <= x:real`` THEN
  (ASM_CASES_TAC ``0 <= y:real``) THEN ASM_REWRITE_TAC [abs] THENL
  [ASM_REAL_ARITH_TAC, ALL_TAC, ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  ((MP_TAC o SPECL [``x:real``,``y:real``]) REAL_LT_TOTAL THEN STRIP_TAC THEN
  TRY (ASM_REAL_ARITH_TAC)) THEN COND_CASES_TAC THEN EQ_TAC THEN
  TRY (ASM_REAL_ARITH_TAC));

val ABS_CAUCHY_SCHWARZ_ABS_EQ = store_thm
  ("ABS_CAUCHY_SCHWARZ_ABS_EQ",
 ``!x:real y. (abs(x * y) = abs(x) * abs(y)) <=>
                (abs(x) * y = abs(y) * x) \/ (abs(x) * y = -abs(y) * x)``,
  SIMP_TAC std_ss [REAL_ARITH ``&0 <= a ==> ((abs x = a) <=> (x = a) \/ (-x = a:real))``,
           REAL_LE_MUL, ABS_POS, REAL_MUL_RNEG] THEN
  REAL_ARITH_TAC);

val REAL_EQ_LINV = store_thm
  ("REAL_EQ_LINV", ``!x. (-x = (x :real)) <=> (x = 0)``,
    GEN_TAC
 >> REWRITE_TAC [SYM (Q.SPECL [`x`, `-x`, `x`] REAL_EQ_LADD)]
 >> REWRITE_TAC [REAL_ADD_RINV, REAL_DOUBLE]
 >> RW_TAC real_ss [REAL_ENTIRE]);

val REAL_EQ_RINV = store_thm
  ("REAL_EQ_RINV", ``!x. ((x :real) = -x) <=> (x = 0)``,
    GEN_TAC
 >> REWRITE_TAC [SYM (Q.SPECL [`x`, `x`, `-x`] REAL_EQ_LADD)]
 >> REWRITE_TAC [REAL_ADD_RINV, REAL_DOUBLE]
 >> RW_TAC real_ss [REAL_ENTIRE]);

(* this proof is too advanced in realScript *)
val ABS_TRIANGLE_EQ = store_thm ("ABS_TRIANGLE_EQ",
  ``!x y:real. (abs(x + y) = abs(x) + abs(y)) <=> (abs(x) * y = abs(y) * x)``,
    rpt GEN_TAC
 >> ASM_CASES_TAC ``0 <= x:real``
 >> ASM_CASES_TAC ``0 <= y:real``
 >> ASM_REWRITE_TAC [abs]
 >- ( `0 <= x + y` by PROVE_TAC [REAL_LE_ADD] \\
      ASM_SIMP_TAC bool_ss [] >> REAL_ARITH_TAC )
 >| [ (* goal 1 (of 3) *)
      Cases_on `0 <= x + y`
      >- ( ASM_SIMP_TAC bool_ss [REAL_EQ_LADD, Once REAL_MUL_SYM] \\
           EQ_TAC >- PROVE_TAC [] \\
           REWRITE_TAC [REAL_EQ_RMUL] \\
           STRIP_TAC >> FULL_SIMP_TAC bool_ss [REAL_ADD_LID] ) \\
      ASM_SIMP_TAC bool_ss [REAL_NEG_ADD, REAL_EQ_RADD, Once REAL_MUL_SYM] \\
      `(-x = x) = (x = 0)` by PROVE_TAC [REAL_EQ_LINV] \\
      POP_ASSUM (REWRITE_TAC o wrap) \\
      REWRITE_TAC [REAL_EQ_RMUL] \\
      EQ_TAC >- PROVE_TAC [] \\
      STRIP_TAC \\
      `y = 0` by PROVE_TAC [REAL_EQ_RINV] \\
      FULL_SIMP_TAC bool_ss [REAL_ADD_RID],
      (* goal 2 (of 3) *)
      Cases_on `0 <= x + y`
      >- ( ASM_SIMP_TAC bool_ss [REAL_EQ_RADD, Once REAL_MUL_SYM] \\
           EQ_TAC >- PROVE_TAC [] \\
           REWRITE_TAC [REAL_EQ_LMUL] \\
           Reverse STRIP_TAC >- ( MATCH_MP_TAC EQ_SYM >> ASM_REWRITE_TAC [] ) \\
           REWRITE_TAC [REAL_EQ_RINV] \\
           FULL_SIMP_TAC bool_ss [REAL_ADD_RID] ) \\
      FULL_SIMP_TAC bool_ss [REAL_NEG_ADD] \\
      REWRITE_TAC [REAL_EQ_LADD, REAL_EQ_LINV, Once REAL_MUL_SYM] \\
      EQ_TAC >- RW_TAC real_ss [] \\
      REWRITE_TAC [REAL_EQ_LMUL, REAL_EQ_LINV] >> STRIP_TAC \\
      FULL_SIMP_TAC bool_ss [REAL_ADD_LID],
      (* goal 3 (of 3) *)
      Know `~(0 <= x + y)`
      >- (FULL_SIMP_TAC bool_ss [REAL_NOT_LE] \\
          PROVE_TAC [REAL_LT_ADD2, REAL_ADD_RID]) \\
      DISCH_TAC >> ASM_SIMP_TAC bool_ss [] \\
      REWRITE_TAC [REAL_NEG_ADD] \\
      PROVE_TAC [REAL_NEG_RMUL, REAL_MUL_SYM] ]);

val DIST_TRIANGLE_EQ = store_thm ("DIST_TRIANGLE_EQ",
 ``!x y z:real. (dist(x,z) = dist(x,y) + dist(y,z)) <=>
                (abs (x - y) * (y - z) = abs (y - z) * (x - y))``,
  REWRITE_TAC[GSYM ABS_TRIANGLE_EQ, dist] THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Collinearity.                                                             *)
(* ------------------------------------------------------------------------- *)

val _ = hide "collinear";

val collinear = new_definition ("collinear",
 ``collinear s <=> ?u. !x y:real. x IN s /\ y IN s ==> ?c. x - y = c * u``);

val COLLINEAR_SUBSET = store_thm ("COLLINEAR_SUBSET",
 ``!s t. collinear t /\ s SUBSET t ==> collinear s``,
  REWRITE_TAC[collinear] THEN SET_TAC[]);

val COLLINEAR_EMPTY = store_thm ("COLLINEAR_EMPTY",
 ``collinear {}``,
  REWRITE_TAC[collinear, NOT_IN_EMPTY]);

val COLLINEAR_SING = store_thm ("COLLINEAR_SING",
 ``!x:real. collinear {x}``,
  SIMP_TAC std_ss [collinear, IN_SING, REAL_SUB_REFL] THEN
  METIS_TAC [REAL_MUL_LZERO]);

val COLLINEAR_2 = store_thm ("COLLINEAR_2",
 ``!x y:real. collinear {x;y}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[collinear, IN_INSERT, NOT_IN_EMPTY] THEN
  EXISTS_TAC ``x - y:real`` THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THENL
   [EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1:real``,
    EXISTS_TAC ``- &1:real``, EXISTS_TAC ``&0:real``] THEN
  REAL_ARITH_TAC);

val COLLINEAR_SMALL = store_thm ("COLLINEAR_SMALL",
 ``!s. FINITE s /\ CARD s <= 2 ==> collinear s``,
  REWRITE_TAC[ARITH_PROVE ``s <= 2 <=> (s = 0) \/ (s = 1) \/ (s = 2:num)``] THEN
  REWRITE_TAC[LEFT_AND_OVER_OR, GSYM HAS_SIZE] THEN
  REWRITE_TAC [ONE, TWO, HAS_SIZE_CLAUSES] THEN
  REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[COLLINEAR_EMPTY, COLLINEAR_SING, COLLINEAR_2]);

val COLLINEAR_3 = store_thm ("COLLINEAR_3",
 ``!x y z. collinear {x;y;z} <=> collinear {0;x - y;z - y}``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [collinear, FORALL_IN_INSERT, CONJ_EQ_IMP,
                   RIGHT_FORALL_IMP_THM, NOT_IN_EMPTY] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  METIS_TAC [REAL_ARITH ``x - y = (x - y) - 0:real``,
             REAL_ARITH ``y - x = 0 - (x - y:real)``,
             REAL_ARITH ``x - z:real = (x - y) - (z - y)``]);

val COLLINEAR_LEMMA = store_thm ("COLLINEAR_LEMMA",
 ``!x y:real. collinear {0;x;y} <=>
                   (x = 0) \/ (y = 0) \/ ?c. y = c * x``,
  REPEAT GEN_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``x:real = 0``, ``y:real = 0``] THEN
  TRY(ONCE_REWRITE_TAC [INSERT_COMM] THEN
      ASM_REWRITE_TAC[INSERT_INSERT, COLLINEAR_SING, COLLINEAR_2] THEN NO_TAC) THEN
  ASM_REWRITE_TAC[collinear] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``u:real``
     (fn th => MP_TAC(SPECL [``x:real``, ``0:real``] th) THEN
                MP_TAC(SPECL [``y:real``, ``0:real``] th))) THEN
    REWRITE_TAC[IN_INSERT, REAL_SUB_RZERO] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` SUBST_ALL_TAC) THEN
    DISCH_THEN(X_CHOOSE_THEN ``d:real`` SUBST_ALL_TAC) THEN
    EXISTS_TAC ``e / d:real`` THEN REWRITE_TAC[REAL_MUL_ASSOC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[REAL_ENTIRE, DE_MORGAN_THM]) THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL],
    STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[IN_INSERT, NOT_IN_EMPTY] THEN REPEAT STRIP_TAC THEN
    ASM_REWRITE_TAC[] THENL
     [EXISTS_TAC ``&0:real``, EXISTS_TAC ``- &1:real``, EXISTS_TAC ``-c:real``,
      EXISTS_TAC ``&1:real``, EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1 - c:real``,
      EXISTS_TAC ``c:real``, EXISTS_TAC ``c - &1:real``, EXISTS_TAC ``&0:real``] THEN
    REAL_ARITH_TAC]);

val COLLINEAR_LEMMA_ALT = store_thm ("COLLINEAR_LEMMA_ALT",
 ``!x y. collinear {0;x;y} <=> (x = 0) \/ ?c. y = c * x``,
  REWRITE_TAC[COLLINEAR_LEMMA] THEN METIS_TAC [REAL_MUL_LZERO]);

val ABS_CAUCHY_SCHWARZ_EQUAL = store_thm ("ABS_CAUCHY_SCHWARZ_EQUAL",
 ``!x y:real. (abs(x * y) = abs(x) * abs(y)) <=> collinear {0;x;y}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[ABS_CAUCHY_SCHWARZ_ABS_EQ] THEN
  MAP_EVERY ASM_CASES_TAC [``x:real = 0``, ``y:real = 0``] THEN
  TRY(ONCE_ASM_REWRITE_TAC [INSERT_COMM] THEN
      ASM_REWRITE_TAC[INSERT_INSERT, COLLINEAR_SING, COLLINEAR_2, ABS_0,
                      REAL_MUL_LZERO, REAL_MUL_RZERO] THEN NO_TAC) THEN
  ASM_REWRITE_TAC[COLLINEAR_LEMMA] THEN EQ_TAC THENL
   [STRIP_TAC THENL
     [EXISTS_TAC ``y / x:real``, EXISTS_TAC ``y / x:real``] THEN
    ASM_SIMP_TAC std_ss [REAL_DIV_RMUL],
    ASM_REAL_ARITH_TAC]);

val MUL_CAUCHY_SCHWARZ_EQUAL = store_thm ("MUL_CAUCHY_SCHWARZ_EQUAL",
 ``!x y:real.
        ((x * y) pow 2 = (x * x) * (y * y)) <=>
        collinear {0;x;y}``,
  REWRITE_TAC[GSYM ABS_CAUCHY_SCHWARZ_EQUAL] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(REAL_ARITH
   ``&0 <= y /\ ((u:real = v) <=> (x = abs y)) ==> ((u = v) <=> (x = y:real))``) THEN
  SIMP_TAC std_ss [ABS_POS, REAL_LE_MUL] THEN
  REWRITE_TAC[REAL_EQ_SQUARE_ABS] THEN REWRITE_TAC[POW_MUL, GSYM POW_2] THEN
  REWRITE_TAC [POW_2] THEN REAL_ARITH_TAC);

val COLLINEAR_3_EXPAND = store_thm ("COLLINEAR_3_EXPAND",
 ``!a b c:real. collinear{a;b;c} <=> ((a = c) \/ ?u. b = u * a + (&1 - u) * c)``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``{a;b;c} = {a;c;b}``] THEN
  ONCE_REWRITE_TAC[COLLINEAR_3] THEN
  REWRITE_TAC[COLLINEAR_LEMMA, REAL_SUB_0] THEN
  ASM_CASES_TAC ``a:real = c`` THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC ``b:real = c`` THEN
  ASM_REWRITE_TAC[REAL_ARITH ``u * c + (&1 - u) * c = c:real``] THENL
   [EXISTS_TAC ``&0:real`` THEN REAL_ARITH_TAC,
     AP_TERM_TAC THEN ABS_TAC THEN REAL_ARITH_TAC]);

val COLLINEAR_TRIPLES = store_thm ("COLLINEAR_TRIPLES",
 ``!s a b:real.
        ~(a = b)
        ==> (collinear(a INSERT b INSERT s) <=>
             !x. x IN s ==> collinear{a;b;x})``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP
     (REWRITE_RULE[CONJ_EQ_IMP] COLLINEAR_SUBSET)) THEN
    ASM_SET_TAC[],
    ONCE_REWRITE_TAC[SET_RULE ``{a;b;x} = {a;x;b}``] THEN
    ASM_REWRITE_TAC[COLLINEAR_3_EXPAND] THEN DISCH_TAC THEN
    SUBGOAL_THEN
     ``!x:real. x IN (a INSERT b INSERT s) ==> ?u. x = u * a + (&1 - u) * b``
    MP_TAC THENL
     [ASM_SIMP_TAC real_ss [FORALL_IN_INSERT] THEN CONJ_TAC THENL
       [EXISTS_TAC ``&1:real`` THEN REAL_ARITH_TAC,
        EXISTS_TAC ``&0:real`` THEN REAL_ARITH_TAC],
      POP_ASSUM_LIST(K ALL_TAC) THEN DISCH_TAC THEN
      REWRITE_TAC[collinear] THEN EXISTS_TAC ``b - a:real`` THEN
      MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``x:real`` th) THEN MP_TAC(SPEC
        ``y:real`` th)) THEN
      ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
      ASM_REWRITE_TAC[REAL_ARITH
       ``(u * a + (&1 - u) * b) - (v * a + (&1 - v) * b):real =
         (v - u) * (b - a)``] THEN
      METIS_TAC []]]);

val COLLINEAR_4_3 = store_thm ("COLLINEAR_4_3",
 ``!a b c d:real.
        ~(a = b)
        ==> (collinear {a;b;c;d} <=> collinear{a;b;c} /\ collinear{a;b;d})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{c:real;d}``, ``a:real``, ``b:real``]
    COLLINEAR_TRIPLES) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN SUBST1_TAC THEN
  SIMP_TAC real_ss [FORALL_IN_INSERT, NOT_IN_EMPTY]);

val COLLINEAR_3_TRANS = store_thm ("COLLINEAR_3_TRANS",
 ``!a b c d:real.
        collinear{a;b;c} /\ collinear{b;c;d} /\ ~(b = c) ==> collinear{a;b;d}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC COLLINEAR_SUBSET THEN
  EXISTS_TAC ``{b:real;c;a;d}`` THEN ASM_SIMP_TAC std_ss [COLLINEAR_4_3] THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[]] THEN
  ONCE_ASM_REWRITE_TAC [SET_RULE ``{b;c;a} = {a;b;c}``] THEN METIS_TAC []);

(* ------------------------------------------------------------------------- *)
(* Between-ness.                                                             *)
(* ------------------------------------------------------------------------- *)

val between = new_definition ("between",
 ``between x (a,b) <=> (dist(a,b) = dist(a,x) + dist(x,b))``);

val BETWEEN_REFL = store_thm ("BETWEEN_REFL",
 ``!a b. between a (a,b) /\ between b (a,b) /\ between a (a,a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_REFL_EQ = store_thm ("BETWEEN_REFL_EQ",
 ``!a x. between x (a,a) <=> (x = a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_SYM = store_thm ("BETWEEN_SYM",
 ``!a b x. between x (a,b) <=> between x (b,a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_ANTISYM = store_thm ("BETWEEN_ANTISYM",
 ``!a b c. between a (b,c) /\ between b (a,c) ==> (a = b)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_TRANS = store_thm ("BETWEEN_TRANS",
 ``!a b c d. between a (b,c) /\ between d (a,c) ==> between d (b,c)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_TRANS_2 = store_thm ("BETWEEN_TRANS_2",
 ``!a b c d. between a (b,c) /\ between d (a,b) ==> between a (c,d)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_ABS = store_thm ("BETWEEN_ABS",
 ``!a b x:real.
     between x (a,b) <=> (abs(x - a) * (b - x) = abs(b - x) * (x - a))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[between, DIST_TRIANGLE_EQ] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [ABS_SUB] THEN REAL_ARITH_TAC);

val BETWEEN_IMP_COLLINEAR = store_thm ("BETWEEN_IMP_COLLINEAR",
 ``!a b x:real. between x (a,b) ==> collinear {a;x;b}``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``x:real = a`` THENL
  [ONCE_REWRITE_TAC[COLLINEAR_3, BETWEEN_ABS] THEN
   DISCH_TAC THEN ASM_REWRITE_TAC[COLLINEAR_LEMMA, REAL_SUB_REFL] THEN
   ASM_REAL_ARITH_TAC,
   ONCE_REWRITE_TAC[COLLINEAR_3, BETWEEN_ABS] THEN
   DISCH_TAC THEN ASM_REWRITE_TAC[COLLINEAR_LEMMA] THEN
   DISJ2_TAC THEN DISJ2_TAC THEN EXISTS_TAC ``(b - x) / (a - x:real)`` THEN
   RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH
                   ``(x <> a) = ((a - x) <> 0:real)``]) THEN
   ASM_SIMP_TAC real_ss [REAL_DIV_RMUL]]);

val COLLINEAR_BETWEEN_CASES = store_thm ("COLLINEAR_BETWEEN_CASES",
 ``!a b c:real.
        collinear {a;b;c} <=>
        between a (b,c) \/ between b (c,a) \/ between c (a,b)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[COLLINEAR_3_EXPAND] THEN
    ASM_CASES_TAC ``c:real = a`` THEN ASM_REWRITE_TAC[BETWEEN_REFL] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[between, dist] THEN
    ASM_REAL_ARITH_TAC,
    DISCH_THEN(REPEAT_TCL DISJ_CASES_THEN (MP_TAC o MATCH_MP
      BETWEEN_IMP_COLLINEAR)) THEN
    METIS_TAC[INSERT_COMM]]);

val COLLINEAR_DIST_BETWEEN = store_thm ("COLLINEAR_DIST_BETWEEN",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)
           ==> between x (a,b)``,
  SIMP_TAC std_ss [COLLINEAR_BETWEEN_CASES, between, dist] THEN REAL_ARITH_TAC);

val COLLINEAR_1 = store_thm ("COLLINEAR_1",
 ``!s:real->bool. collinear s``,
  GEN_TAC THEN MATCH_MP_TAC COLLINEAR_SUBSET THEN
  EXISTS_TAC ``(0:real) INSERT (1:real) INSERT s`` THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[]] THEN
  W(MP_TAC o PART_MATCH (lhs o rand) COLLINEAR_TRIPLES o snd) THEN
  REWRITE_TAC[REAL_ARITH ``0 <> 1:real``] THEN DISCH_THEN SUBST1_TAC THEN
  REWRITE_TAC[COLLINEAR_BETWEEN_CASES] THEN
  REWRITE_TAC[between, dist, ABS_N] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Midpoint between two points.                                              *)
(* ------------------------------------------------------------------------- *)

val midpoint = new_definition ("midpoint",
 ``midpoint(a,b) = inv(&2:real) * (a + b)``);

Theorem MIDPOINT_REFL: !x. midpoint(x,x) = x
Proof
  REWRITE_TAC[midpoint, REAL_DOUBLE, REAL_MUL_ASSOC] THEN
  SIMP_TAC std_ss [REAL_MUL_LINV, REAL_ARITH ``2 <> 0:real``] THEN
  REAL_ARITH_TAC
QED

val MIDPOINT_SYM = store_thm ("MIDPOINT_SYM",
 ``!a b. midpoint(a,b) = midpoint(b,a)``,
  METIS_TAC[midpoint, REAL_ADD_SYM]);

val DIST_MIDPOINT = store_thm ("DIST_MIDPOINT",
 ``!a b. (dist(a,midpoint(a,b)) = dist(a,b) / &2) /\
         (dist(b,midpoint(a,b)) = dist(a,b) / &2) /\
         (dist(midpoint(a,b),a) = dist(a,b) / &2) /\
         (dist(midpoint(a,b),b) = dist(a,b) / &2)``,
  REWRITE_TAC[midpoint, dist] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ONCE_REWRITE_TAC [GSYM ABS_N] THEN
  REWRITE_TAC [GSYM ABS_MUL, REAL_SUB_RDISTRIB] THEN REWRITE_TAC [ABS_N] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = a * c * b:real``] THEN
  SIMP_TAC std_ss [REAL_MUL_LINV, REAL_ARITH ``2 <> 0:real``] THEN
  REAL_ARITH_TAC);

val MIDPOINT_EQ_ENDPOINT = store_thm ("MIDPOINT_EQ_ENDPOINT",
 ``!a b. ((midpoint(a,b) = a) <=> (a = b)) /\
         ((midpoint(a,b) = b) <=> (a = b)) /\
         ((a = midpoint(a,b)) <=> (a = b)) /\
         ((b = midpoint(a,b)) <=> (a = b))``,
  REWRITE_TAC[midpoint] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss
    [REAL_EQ_RDIV_EQ, REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val BETWEEN_MIDPOINT = store_thm ("BETWEEN_MIDPOINT",
 ``!a b. between (midpoint(a,b)) (a,b) /\ between (midpoint(a,b)) (b,a)``,
  REWRITE_TAC[between, midpoint] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [dist, GSYM real_div] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a / 2 - b = a / 2 - b * 1:real``] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``b - a / 2 = b * 1 - a / 2:real``] THEN
  REWRITE_TAC [
    METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``] ``1 = 2/2:real``] THEN
  REWRITE_TAC [real_div, REAL_MUL_ASSOC, real_sub] THEN
  REWRITE_TAC [REAL_ARITH ``-(a * b) = -a * b:real``] THEN
  REWRITE_TAC [GSYM real_div] THEN SIMP_TAC std_ss [REAL_DIV_ADD] THEN
  REWRITE_TAC [real_div, ABS_MUL] THEN
  SIMP_TAC std_ss [ABS_N, ABS_INV, REAL_ARITH ``2 <> 0:real``] THEN
  REWRITE_TAC [GSYM REAL_ADD_RDISTRIB] THEN REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val MIDPOINT_LINEAR_IMAGE = store_thm ("MIDPOINT_LINEAR_IMAGE",
 ``!f a b. linear f ==> (midpoint(f a,f b) = f(midpoint(a,b)))``,
  SIMP_TAC std_ss [midpoint, LINEAR_ADD, LINEAR_CMUL]);

val COLLINEAR_MIDPOINT = store_thm ("COLLINEAR_MIDPOINT",
 ``!a b. collinear{a;midpoint(a,b);b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[COLLINEAR_3_EXPAND, midpoint] THEN
  DISJ2_TAC THEN REWRITE_TAC [REAL_ARITH ``u * a + (1 - u) * b =
                                           a * u - b * u + b:real``] THEN
  EXISTS_TAC ``inv &2:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_MUL_SYM] THEN
  REWRITE_TAC [REAL_ADD_RDISTRIB] THEN
  GEN_REWR_TAC (RAND_CONV o RAND_CONV) [GSYM REAL_HALF] THEN
  REWRITE_TAC [GSYM real_div] THEN REAL_ARITH_TAC);

Theorem MIDPOINT_COLLINEAR:
   !a b c:real.
     a <> c ==>
     ((b = midpoint(a,c)) <=> collinear{a;b;c} /\ (dist(a,b) = dist(b,c)))
Proof
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `(a ==> b) /\ (b ==> (a <=> c)) ==> (a <=> b /\ c)`) THEN
  SIMP_TAC std_ss [COLLINEAR_MIDPOINT] THEN
  ASM_REWRITE_TAC[COLLINEAR_3_EXPAND] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[midpoint, dist] THEN
  REWRITE_TAC
   [REAL_ARITH ``a - (u * a + (&1 - u) * c) = (&1 - u) * (a - c:real)``,
    REAL_ARITH ``(u * a + (&1 - u) * c) - c = u * (a - c:real)``] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC
QED

(* ------------------------------------------------------------------------ *)
(*  MISC                                                                    *)
(* ------------------------------------------------------------------------ *)

val INDEPENDENT_MONO = store_thm ("INDEPENDENT_MONO",
 ``!s t. independent t /\ s SUBSET t ==> independent s``,
 SIMP_TAC std_ss [independent, dependent] THEN
 ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_DELETE]);

val SPAN_BREAKDOWN = store_thm ("SPAN_BREAKDOWN",
 ``!b s a:real. b IN s /\ a IN span s ==> ?k. (a - k * b) IN span(s DELETE b)``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC [METIS []
   ``(?k:real. a - k * b IN span (s DELETE b)) =
     (\a. ?k. a - k * b IN span (s DELETE b)) a``] THEN
  MATCH_MP_TAC SPAN_INDUCT THEN
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN CONJ_TAC THENL
   [GEN_TAC THEN DISCH_TAC THEN ASM_CASES_TAC ``x:real = b``, ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IN_DEF] THENL
  [EXISTS_TAC ``1:real`` THEN SIMP_TAC real_ss [] THEN
   ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN REWRITE_TAC [SPAN_CLAUSES],
   EXISTS_TAC ``0:real`` THEN SIMP_TAC real_ss [] THEN
   ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN MATCH_MP_TAC SPAN_SUPERSET THEN
   ASM_SET_TAC [],
   ALL_TAC] THEN REPEAT CONJ_TAC THENL
   [EXISTS_TAC ``0:real`` THEN SIMP_TAC real_ss [] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN REWRITE_TAC [SPAN_CLAUSES],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``k + k':real`` THEN
    ONCE_REWRITE_TAC [REAL_ARITH
     ``(x + y - (k + k') * b) = ((x - k * b) + (y - k' * b:real))``] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM SPECIFICATION]) THEN
    METIS_TAC [SPAN_ADD],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``c * k:real`` THEN
    ONCE_REWRITE_TAC [
      REAL_ARITH ``(c * x - (c * k) * y = c * (x - k * y:real))``] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM SPECIFICATION]) THEN
    METIS_TAC [SPAN_CLAUSES]]);

val IN_SPAN_INSERT = store_thm ("IN_SPAN_INSERT",
 ``!a b:real s. a IN span(b INSERT s) /\ ~(a IN span s)
   ==> b IN span(a INSERT s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``b:real``, ``(b:real) INSERT s``, ``a:real``]
    SPAN_BREAKDOWN) THEN ASM_REWRITE_TAC[IN_INSERT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` MP_TAC) THEN
  ASM_CASES_TAC ``k = &0:real`` THEN
  ASM_REWRITE_TAC[REAL_ARITH ``a - &0 * b = a:real``, DELETE_INSERT] THENL
   [ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, DELETE_SUBSET], ALL_TAC] THEN
  DISCH_THEN(MP_TAC o SPEC ``inv(k:real)`` o MATCH_MP SPAN_MUL) THEN
  ASM_SIMP_TAC real_ss [REAL_SUB_LDISTRIB, REAL_MUL_ASSOC, REAL_MUL_LINV] THEN
  DISCH_TAC THEN SUBST1_TAC(REAL_ARITH
   ``b:real = inv(k) * a - (inv(k) * a - b)``) THEN
  MATCH_MP_TAC SPAN_SUB THEN
  FULL_SIMP_TAC std_ss [SPAN_CLAUSES, IN_INSERT, SUBSET_DEF, IN_DELETE,
                        SPAN_MONO] THEN
  POP_ASSUM MP_TAC THEN ABBREV_TAC ``y = inv k * a - b:real`` THEN
  SPEC_TAC (``y:real``, ``y:real``) THEN REWRITE_TAC [GSYM SUBSET_DEF] THEN
  MATCH_MP_TAC SPAN_MONO THEN ASM_SET_TAC []);

val INDEPENDENT_INSERT = store_thm ("INDEPENDENT_INSERT",
 ``!a:real s. independent(a INSERT s) <=>
    if a IN s then independent s else independent s /\ ~(a IN span s)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(a:real) IN s`` THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``x IN s ==> (x INSERT s = s)``] THEN
  EQ_TAC THENL
   [DISCH_TAC THEN CONJ_TAC THENL
     [ASM_MESON_TAC[INDEPENDENT_MONO, SUBSET_DEF, IN_INSERT],
      POP_ASSUM MP_TAC THEN REWRITE_TAC[independent, dependent] THEN
      ASM_MESON_TAC[IN_INSERT, SET_RULE
        ``~(a IN s) ==> ((a INSERT s) DELETE a = s)``]],
    ALL_TAC] THEN
  SIMP_TAC std_ss [independent, dependent, NOT_EXISTS_THM] THEN
  STRIP_TAC THEN X_GEN_TAC ``b:real`` THEN
  REWRITE_TAC[IN_INSERT] THEN ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [
    SET_RULE ``~(a IN s) ==> ((a INSERT s) DELETE a = s)``] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``~(a IN s) /\ ~(b = a)
     ==> ((a INSERT s) DELETE b = a INSERT (s DELETE b))``] THEN
  ASM_MESON_TAC[IN_SPAN_INSERT, SET_RULE
    ``b IN s ==> (b INSERT (s DELETE b) = s)``]);

val INDEPENDENT_EMPTY = store_thm ("INDEPENDENT_EMPTY",
 ``independent {}``,
  REWRITE_TAC[independent, dependent, NOT_IN_EMPTY]);

val INDEPENDENT_SING = store_thm ("INDEPENDENT_SING",
 ``!x. independent {x} <=> ~(x = 0)``,
  REWRITE_TAC[INDEPENDENT_INSERT, NOT_IN_EMPTY, SPAN_EMPTY] THEN
  REWRITE_TAC[INDEPENDENT_EMPTY] THEN SET_TAC[]);

val INDEPENDENT_STDBASIS = store_thm ("INDEPENDENT_STDBASIS",
 ``independent {i:real | 1 <= i /\ i <= 1}``,
 REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
 REWRITE_TAC [INDEPENDENT_SING] THEN REAL_ARITH_TAC);

val SPANNING_SUBSET_INDEPENDENT = store_thm ("SPANNING_SUBSET_INDEPENDENT",
 ``!s t:real->bool.
        t SUBSET s /\ independent s /\ s SUBSET span(t) ==> (s = t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[SUBSET_DEF] THEN
  X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``independent s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [independent]) THEN
  SIMP_TAC std_ss [dependent, NOT_EXISTS_THM] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_DELETE]);

val IN_SPAN_DELETE = store_thm ("IN_SPAN_DELETE",
 ``!a b s.
         a IN span s /\ ~(a IN span (s DELETE b))
         ==> b IN span (a INSERT (s DELETE b))``,
  ASM_MESON_TAC[IN_SPAN_INSERT, SPAN_MONO, SUBSET_DEF, IN_INSERT, IN_DELETE]);

val SPAN_TRANS = store_thm ("SPAN_TRANS",
 ``!x y:real s. x IN span(s) /\ y IN span(x INSERT s) ==> y IN span(s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``x:real``, ``(x:real) INSERT s``, ``y:real``]
         SPAN_BREAKDOWN) THEN
  ASM_SIMP_TAC std_ss [IN_INSERT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  SUBST1_TAC(REAL_ARITH ``y:real = (y - k * x) + k * x``) THEN
  MATCH_MP_TAC SPAN_ADD THEN ASM_SIMP_TAC std_ss [SPAN_MUL] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_INSERT, IN_DELETE]);

val EXCHANGE_LEMMA = store_thm ("EXCHANGE_LEMMA",
 ``!s t:real->bool.
        FINITE t /\ independent s /\ s SUBSET span t
        ==> ?t'. t' HAS_SIZE (CARD t) /\
                 s SUBSET t' /\ t' SUBSET (s UNION t) /\ s SUBSET (span t')``,
  REPEAT GEN_TAC THEN
  completeInduct_on `CARD(t DIFF s :real->bool)` THEN
  GEN_TAC THEN GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM K_TAC THEN
  KNOW_TAC ``(!m. m < CARD (t:real->bool DIFF s) ==>
    !t:real->bool s:real->bool. (m = CARD (t DIFF s)) ==>
      FINITE t /\ independent s /\ s SUBSET span t ==>
      ?t'. t' HAS_SIZE CARD t /\ s SUBSET t' /\ t' SUBSET s UNION t /\
        s SUBSET span t') ==>
    (!t'':real->bool s':real->bool'. (CARD (t'' DIFF s') < CARD (t DIFF s)) ==>
      FINITE t'' /\ independent s' /\ s' SUBSET span t'' ==>
      ?t'. t' HAS_SIZE CARD t'' /\ s' SUBSET t' /\ t' SUBSET s' UNION t'' /\
        s' SUBSET span t')`` THENL
  [METIS_TAC [], ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC] THEN
  ASM_CASES_TAC ``(s:real->bool) SUBSET t`` THENL
   [ASM_MESON_TAC[HAS_SIZE, SUBSET_UNION], ALL_TAC] THEN
  ASM_CASES_TAC ``t SUBSET (s:real->bool)`` THENL
   [ASM_MESON_TAC[SPANNING_SUBSET_INDEPENDENT, HAS_SIZE], ALL_TAC] THEN
  STRIP_TAC THEN UNDISCH_TAC ``~(t SUBSET s:real->bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``s SUBSET span(t DELETE (b:real))`` THENL
   [FIRST_X_ASSUM(MP_TAC o
     SPECL [``t DELETE (b:real)``, ``s:real->bool``]) THEN
    ASM_REWRITE_TAC[SET_RULE ``s DELETE a DIFF t = (s DIFF t) DELETE a``] THEN
    ASM_SIMP_TAC arith_ss [CARD_DELETE, FINITE_DIFF, IN_DIFF, FINITE_DELETE,
                 CARD_EQ_0, ARITH_PROVE ``n - 1 < n <=> ~(n = 0:num)``] THEN
    KNOW_TAC ``t DIFF s <> {}:real->bool`` THENL
     [UNDISCH_TAC ``~((s:real->bool) SUBSET t)`` THEN ASM_SET_TAC[],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(b:real) INSERT u`` THEN
    ASM_SIMP_TAC std_ss [SUBSET_INSERT, INSERT_SUBSET, IN_UNION] THEN
    CONJ_TAC THENL
     [UNDISCH_TAC ``(u:real->bool) HAS_SIZE CARD(t:real->bool) - 1`` THEN
      SIMP_TAC std_ss [HAS_SIZE, FINITE_EMPTY, FINITE_INSERT, CARD_EMPTY,
                       CARD_INSERT] THEN
      STRIP_TAC THEN COND_CASES_TAC THENL
       [ASM_MESON_TAC[SUBSET_DEF, IN_UNION, IN_DELETE], ALL_TAC] THEN
      ASM_MESON_TAC[ARITH_PROVE ``~(n = 0) ==> (SUC(n - 1) = n)``,
                    CARD_EQ_0, MEMBER_NOT_EMPTY], ALL_TAC] THEN
    CONJ_TAC THENL
     [UNDISCH_TAC ``u SUBSET s UNION (t DELETE (b:real))`` THEN SET_TAC[],
      ASM_MESON_TAC[SUBSET_DEF, SPAN_MONO, IN_INSERT]],
    ALL_TAC] THEN
  UNDISCH_TAC ``~(s SUBSET span (t DELETE (b:real)))`` THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [SUBSET_DEF] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``~(a:real = b)`` ASSUME_TAC THENL
    [ASM_MESON_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``~((a:real) IN t)`` ASSUME_TAC THENL
   [ASM_MESON_TAC[IN_DELETE, SPAN_CLAUSES], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``(a:real) INSERT (t DELETE b)``, ``s:real->bool``]) THEN
  KNOW_TAC ``CARD ((a INSERT t DELETE b) DIFF s) < CARD (t DIFF s:real->bool)``
  THENL
   [ASM_SIMP_TAC std_ss [SET_RULE
     ``a IN s ==> ((a INSERT (t DELETE b)) DIFF s = (t DIFF s) DELETE b)``] THEN
    KNOW_TAC ``(b:real) IN (t DIFF s)``
      THENL [METIS_TAC [IN_DIFF], DISCH_TAC] THEN
    KNOW_TAC ``FINITE (t DIFF s:real->bool)``
      THENL [METIS_TAC [FINITE_DIFF], ALL_TAC] THEN
    SIMP_TAC std_ss [CARD_DELETE] THEN ASM_REWRITE_TAC [] THEN DISCH_TAC THEN
    ASM_SIMP_TAC std_ss [ARITH_PROVE ``n - 1 < n <=> ~(n = 0:num)``, CARD_EQ_0,
                 FINITE_DIFF] THEN
    UNDISCH_TAC ``~((s:real->bool) SUBSET t)`` THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  KNOW_TAC ``FINITE ((a:real) INSERT t DELETE b) /\
             s SUBSET span (a INSERT t DELETE b)`` THENL
   [ASM_SIMP_TAC std_ss [FINITE_EMPTY, FINITE_INSERT, FINITE_DELETE] THEN
    REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN
    DISCH_TAC THEN MATCH_MP_TAC SPAN_TRANS THEN EXISTS_TAC ``b:real`` THEN
    ASM_MESON_TAC[IN_SPAN_DELETE, SUBSET_DEF, SPAN_MONO,
                  SET_RULE ``t SUBSET (b INSERT (a INSERT (t DELETE b)))``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN
  EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  ASM_SIMP_TAC std_ss [HAS_SIZE, CARD_EMPTY, CARD_INSERT, CARD_DELETE,
                       FINITE_DELETE,
                       IN_DELETE, ARITH_PROVE ``(SUC(n - 1) = n) <=> ~(n = 0)``,
                       CARD_EQ_0] THEN
  UNDISCH_TAC ``(b:real) IN t`` THEN ASM_SET_TAC[]);

val CARD_STDBASIS = store_thm ("CARD_STDBASIS",
 ``CARD {1:real} = 1``,
   MESON_TAC[CARD_SING]);

val INDEPENDENT_SPAN_BOUND = store_thm ("INDEPENDENT_SPAN_BOUND",
 ``!s t. FINITE t /\ independent s /\ s SUBSET span(t)
         ==> FINITE s /\ CARD(s) <= CARD(t)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP EXCHANGE_LEMMA) THEN
  ASM_MESON_TAC[HAS_SIZE, CARD_SUBSET, SUBSET_FINITE_I]);

val INDEPENDENT_BOUND = store_thm ("INDEPENDENT_BOUND",
 ``!s:real->bool.
        independent s ==> FINITE s /\ CARD(s) <= 1:num``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[GSYM CARD_STDBASIS] THEN
  MATCH_MP_TAC INDEPENDENT_SPAN_BOUND THEN
  KNOW_TAC ``span {1} = univ(:real)`` THENL
  [SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
   SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
   REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
   FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_REWRITE_TAC[FINITE_SING, SUBSET_UNIV]);

val MAXIMAL_INDEPENDENT_SUBSET_EXTEND = store_thm ("MAXIMAL_INDEPENDENT_SUBSET_EXTEND",
 ``!s v:real->bool. s SUBSET v /\ independent s ==> ?b. s SUBSET b /\ b SUBSET v /\
   independent b /\ v SUBSET (span b)``,
  REPEAT GEN_TAC THEN
  completeInduct_on `(1:num) - CARD(s:real->bool)` THEN
  GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN POP_ASSUM K_TAC THEN
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``v SUBSET (span(s:real->bool))`` THENL
   [ASM_MESON_TAC[SUBSET_REFL], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  KNOW_TAC ``(!(m :num). m < (1 :num) - CARD (s :real -> bool) ==>
        !(s :real -> bool). (m = (1 :num) - CARD s) ==>
          s SUBSET (v :real -> bool) /\ independent s ==>
          ?(b :real -> bool).
            s SUBSET b /\ b SUBSET v /\ independent b /\ v SUBSET span b) ==>
        !s'. (1 - CARD s' < 1 - CARD s) ==> s' SUBSET v /\ independent s' ==>
          ?b. s' SUBSET b /\ b SUBSET v /\ independent b /\ v SUBSET span b`` THENL
  [METIS_TAC [], ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) INSERT s``) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  KNOW_TAC ``1 - CARD (a INSERT s) < 1 - CARD s /\ a INSERT s SUBSET v /\
              independent (a INSERT s:real->bool)`` THENL
   [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
             MESON_TAC[INSERT_SUBSET]] THEN
  SUBGOAL_THEN ``independent ((a:real) INSERT s)`` ASSUME_TAC THENL
   [ASM_REWRITE_TAC[INDEPENDENT_INSERT, COND_ID], ALL_TAC] THEN
  ASM_REWRITE_TAC[INSERT_SUBSET] THEN
  MATCH_MP_TAC(ARITH_PROVE ``(b = a + 1) /\ b <= n ==> n - b < n - a:num``) THEN
  ASM_SIMP_TAC std_ss [CARD_EMPTY, CARD_INSERT, INDEPENDENT_BOUND] THEN
  METIS_TAC[SPAN_SUPERSET, ADD1]);

val MAXIMAL_INDEPENDENT_SUBSET = store_thm ("MAXIMAL_INDEPENDENT_SUBSET",
 ``!v:real->bool. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b)``,
  MP_TAC(SPEC ``EMPTY:real->bool`` MAXIMAL_INDEPENDENT_SUBSET_EXTEND) THEN
  REWRITE_TAC[EMPTY_SUBSET, INDEPENDENT_EMPTY]);

val SPAN_BREAKDOWN_EQ = store_thm ("SPAN_BREAKDOWN_EQ",
 ``!a:real s. (x IN span(a INSERT s) <=> (?k. (x - k * a) IN span s))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_THEN(MP_TAC o CONJ(SET_RULE ``(a:real) IN (a INSERT s)``)) THEN
    DISCH_THEN(MP_TAC o MATCH_MP SPAN_BREAKDOWN) THEN
    DISCH_THEN (X_CHOOSE_TAC ``k:real``) THEN EXISTS_TAC ``k:real`` THEN
    POP_ASSUM MP_TAC THEN SPEC_TAC(``x - k * a:real``,``y:real``) THEN
    REWRITE_TAC[GSYM SUBSET_DEF] THEN MATCH_MP_TAC SPAN_MONO THEN SET_TAC[],
    DISCH_THEN(X_CHOOSE_TAC ``k:real``) THEN
    SUBST1_TAC(REAL_ARITH ``x = (x - k * a) + k * a:real``) THEN
    MATCH_MP_TAC SPAN_ADD THEN
    ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_INSERT, SPAN_CLAUSES]]);

val LINEAR_INDEPENDENT_EXTEND_LEMMA = store_thm ("LINEAR_INDEPENDENT_EXTEND_LEMMA",
 ``!f b. FINITE b ==> independent b ==>
    ?g:real->real. (!x y. x IN span b /\ y IN span b ==>
     (g(x + y) = g(x) + g(y))) /\ (!x c. x IN span b ==>
     (g(c * x) = c * g(x))) /\ (!x. x IN b ==> (g x = f x))``,
  GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS []
   ``!b. (independent b ==>
  ?g. (!x y. x IN span b /\ y IN span b ==> (g (x + y) = g x + g y)) /\
    (!x c. x IN span b ==> (g (c * x) = c * g x)) /\
    !x. x IN b ==> (g x = f x)) =
    (\b. independent b ==>
  ?g. (!x y. x IN span b /\ y IN span b ==> (g (x + y) = g x + g y)) /\
    (!x c. x IN span b ==> (g (c * x) = c * g x)) /\
    !x. x IN b ==> (g x = f x)) b``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[NOT_IN_EMPTY, INDEPENDENT_INSERT] THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN EXISTS_TAC ``(\x. 0):real->real`` THEN
    SIMP_TAC std_ss [SPAN_EMPTY] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``b:real->bool``, ``a:real``] THEN
  REWRITE_TAC [AND_IMP_INTRO] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
  REWRITE_TAC [CONJ_EQ_IMP] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  DISCH_TAC THEN DISCH_TAC THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  DISCH_THEN (CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  ABBREV_TAC ``h = \z:real. @k. (z - k * a) IN span b`` THEN
  SUBGOAL_THEN ``!z:real. z IN span(a INSERT b)
                    ==> (z - h(z) * a) IN span(b) /\
                        !k. (z - k * a) IN span(b) ==> (k = h(z))``
  MP_TAC THENL
   [GEN_TAC THEN DISCH_TAC THEN
    MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN CONJ_TAC THENL
     [EXPAND_TAC "h" THEN CONV_TAC SELECT_CONV THEN
      ASM_MESON_TAC[SPAN_BREAKDOWN_EQ],
      ALL_TAC] THEN
    SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, AND_IMP_INTRO] THEN GEN_TAC THEN
    DISCH_THEN(MP_TAC o MATCH_MP SPAN_SUB) THEN
    REWRITE_TAC[REAL_ARITH ``(z - a * v) - (z - b * v) = (b - a) * v:real``] THEN
    ASM_CASES_TAC ``k = (h:real->real) z`` THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC o SPEC ``inv(k - (h:real->real) z)`` o
               MATCH_MP SPAN_MUL) THEN
    ASM_SIMP_TAC real_ss [REAL_MUL_LINV, REAL_MUL_ASSOC, REAL_SUB_0],
    ALL_TAC] THEN
  SIMP_TAC std_ss [TAUT `(a ==> b /\ c) <=> (a ==> b) /\ (a ==> c)`] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, AND_IMP_INTRO] THEN
  DISCH_THEN (MP_TAC o SIMP_RULE std_ss [FORALL_AND_THM]) THEN STRIP_TAC THEN
  EXISTS_TAC ``\z:real. h(z) * (f:real->real)(a) + g(z - h(z) * a)`` THEN
  ONCE_REWRITE_TAC [CONJ_SYM] THEN REPEAT CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``(h:real->real)(x + y) = h(x) + h(y)`` ASSUME_TAC THENL
     [CONV_TAC SYM_CONV THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      REWRITE_TAC[REAL_ARITH
       ``(x + y) - (k + l) * a = (x - k * a) + (y - l * a:real)``] THEN
      CONJ_TAC THEN MATCH_MP_TAC SPAN_ADD THEN ASM_REWRITE_TAC[] THEN
      ASM_SIMP_TAC std_ss [],
      ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
       ``(x + y) - (k + l) * a = (x - k * a) + (y - l * a:real)``] THEN
    ASM_SIMP_TAC std_ss [] THEN REAL_ARITH_TAC,
    MAP_EVERY X_GEN_TAC [``x:real``, ``c:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``(h:real->real)(c * x) = c * h(x)`` ASSUME_TAC THENL
     [CONV_TAC SYM_CONV THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      REWRITE_TAC[REAL_ARITH
       ``c * x - (c * k) * a = c * (x - k * a:real)``] THEN
      CONJ_TAC THEN MATCH_MP_TAC SPAN_MUL THEN ASM_REWRITE_TAC[] THEN
      ASM_SIMP_TAC std_ss [],
      ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
       ``c * x - (c * k) * a = c * (x - k * a:real)``] THEN
    ASM_SIMP_TAC std_ss [] THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  X_GEN_TAC ``x:real`` THEN SIMP_TAC std_ss [IN_INSERT] THEN
  DISCH_THEN(DISJ_CASES_THEN2 SUBST_ALL_TAC ASSUME_TAC) THENL
   [SUBGOAL_THEN ``&1:real = h(a:real)`` (SUBST1_TAC o SYM) THENL
     [FIRST_X_ASSUM MATCH_MP_TAC, ALL_TAC] THEN
    REWRITE_TAC[REAL_ARITH ``a - &1 * a = 0:real``, SPAN_0] THENL
     [ASM_MESON_TAC[SPAN_SUPERSET, SUBSET_DEF, IN_INSERT], ALL_TAC] THEN
    UNDISCH_TAC ``!x y:real. x IN span b /\ y IN span b ==>
                        ((g:real->real) (x + y) = g x + g y)`` THEN
    DISCH_TAC THEN SIMP_TAC std_ss [] THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``0:real``, ``0:real``]) THEN
    SIMP_TAC real_ss [SPAN_0, REAL_ADD_LID] THEN
    REWRITE_TAC[REAL_ARITH ``(a = a + a) <=> (a = 0:real)``] THEN
    DISCH_THEN SUBST1_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  SUBGOAL_THEN ``&0:real = h(x:real)`` (SUBST1_TAC o SYM) THENL
   [FIRST_X_ASSUM MATCH_MP_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [REAL_ADD_LID, REAL_MUL_LZERO, REAL_SUB_RZERO] THEN
  ASM_MESON_TAC[SUBSET_DEF, IN_INSERT, SPAN_SUPERSET]);

val LINEAR_INDEPENDENT_EXTEND = store_thm ("LINEAR_INDEPENDENT_EXTEND",
 ``!f b. independent b ==> ?g:real->real. linear g /\ (!x. x IN b ==> (g x = f x))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``b:real->bool``, ``univ(:real)``]
           MAXIMAL_INDEPENDENT_SUBSET_EXTEND) THEN
  ASM_SIMP_TAC std_ss [SUBSET_UNIV, UNIV_SUBSET] THEN
  REWRITE_TAC[EXTENSION, IN_UNIV] THEN
  DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``f:real->real``, ``c:real->bool``]
    LINEAR_INDEPENDENT_EXTEND_LEMMA) THEN
  ASM_SIMP_TAC std_ss [INDEPENDENT_BOUND, linear] THEN
  ASM_MESON_TAC[SUBSET_DEF]);

val SUBSPACE_KERNEL = store_thm ("SUBSPACE_KERNEL",
 ``!f. linear f ==> subspace {x | f(x) = 0}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  SIMP_TAC std_ss [LINEAR_ADD, LINEAR_CMUL, REAL_ADD_LID, REAL_MUL_RZERO] THEN
  MESON_TAC[LINEAR_0]);

val LINEAR_EQ_0_SPAN = store_thm ("LINEAR_EQ_0_SPAN",
 ``!f:real->real b. linear f /\ (!x. x IN b ==> (f(x) = 0))
   ==> !x. x IN span(b) ==> (f(x) = 0)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN RULE_ASSUM_TAC(SIMP_RULE std_ss [IN_DEF]) THEN
  ONCE_REWRITE_TAC [METIS [] ``(f x = 0) = (\x. (f:real->real) x = 0) x``] THEN
  MATCH_MP_TAC SPAN_INDUCT THEN ASM_SIMP_TAC std_ss [IN_DEF] THEN
  MP_TAC(ISPEC ``f:real->real`` SUBSPACE_KERNEL) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_DEF]);

val LINEAR_EQ_0 = store_thm ("LINEAR_EQ_0",
 ``!f b s. linear f /\ s SUBSET (span b) /\
   (!x. x IN b ==> (f(x) = 0)) ==> !x. x IN s ==> (f(x) = 0)``,
  MESON_TAC[LINEAR_EQ_0_SPAN, SUBSET_DEF]);

val LINEAR_EQ = store_thm ("LINEAR_EQ",
 ``!f g b s. linear f /\ linear g /\ s SUBSET (span b) /\
    (!x. x IN b ==> (f(x) = g(x))) ==> !x. x IN s ==> (f(x) = g(x))``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(f x - g x = 0) = ((\x. (f:real->real) x - g x) x = 0)``] THEN
  MATCH_MP_TAC LINEAR_EQ_0 THEN SIMP_TAC std_ss [] THEN METIS_TAC[LINEAR_COMPOSE_SUB]);

val LINEAR_EQ_STDBASIS = store_thm ("LINEAR_EQ_STDBASIS",
 ``!f:real->real g. linear f /\ linear g /\
   (!i. 1 <= i /\ i <= 1 ==> (f i = g i)) ==> (f = g)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!x. x IN UNIV ==> ((f:real->real) x = g x)``
   (fn th => MP_TAC th THEN SIMP_TAC std_ss [FUN_EQ_THM, IN_UNIV]) THEN
  MATCH_MP_TAC LINEAR_EQ THEN
  EXISTS_TAC ``{i :real | 1 <= i /\ i <= 1}`` THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL, GSPECIFICATION] THEN
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
  KNOW_TAC ``span {1} = univ(:real)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [SUBSET_REFL]] THEN
  SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
  SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC []);

val LINEAR_INJECTIVE_LEFT_INVERSE = store_thm ("LINEAR_INJECTIVE_LEFT_INVERSE",
 ``!f:real->real. linear f /\ (!x y. (f x = f y) ==> (x = y))
                  ==> ?g. linear g /\ (g o f = (\x. x))``,
  REWRITE_TAC[INJECTIVE_LEFT_INVERSE] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``?h. linear(h:real->real) /\
                    !x. x IN IMAGE (f:real->real) {i | 1 <= i /\ i <= 1}
                  ==> (h x = g x)`` MP_TAC THENL
  [MATCH_MP_TAC LINEAR_INDEPENDENT_EXTEND THEN
   SIMP_TAC std_ss [REAL_LE_ANTISYM, GSPEC_EQ2, IMAGE_SING] THEN
   SIMP_TAC std_ss [INDEPENDENT_SING] THEN
   KNOW_TAC ``?g. !x. g ((f:real->real) x) = x`` THENL
   [METIS_TAC [], REWRITE_TAC [GSYM INJECTIVE_LEFT_INVERSE] THEN DISCH_TAC] THEN
   FULL_SIMP_TAC std_ss [linear] THEN KNOW_TAC ``0 = (f:real->real) 0`` THENL
   [UNDISCH_TAC ``!c x. (f:real->real) (c * x) = c * f x`` THEN
    DISCH_THEN (MP_TAC o SPECL [``0:real``, ``0:real``]) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN ONCE_ASM_REWRITE_TAC []] THEN DISCH_TAC THEN
   UNDISCH_TAC ``!x y. ((f:real->real) x = f y) ==> (x = y)`` THEN
   DISCH_THEN (MP_TAC o SPECL [``1:real``,``0:real``]) THEN
   POP_ASSUM MP_TAC THEN REAL_ARITH_TAC,
   DISCH_THEN (X_CHOOSE_TAC ``h:real->real``) THEN EXISTS_TAC ``h:real->real`` THEN
   POP_ASSUM MP_TAC THEN
   ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, GSPECIFICATION] THEN STRIP_TAC THEN
   ASM_REWRITE_TAC[] THEN MATCH_MP_TAC LINEAR_EQ_STDBASIS THEN
   ASM_SIMP_TAC std_ss [LINEAR_ID, LINEAR_COMPOSE, LINEAR_ID, o_THM] THEN
   ASM_MESON_TAC[]]);

val dim = new_definition ("dim",
  ``dim v = @n. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b) /\
                   b HAS_SIZE n``);

val BASIS_EXISTS = store_thm ("BASIS_EXISTS",
 ``!v. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b) /\ b HAS_SIZE (dim v)``,
  GEN_TAC THEN REWRITE_TAC[dim] THEN CONV_TAC SELECT_CONV THEN
  MESON_TAC[MAXIMAL_INDEPENDENT_SUBSET, HAS_SIZE, INDEPENDENT_BOUND]);

val INDEPENDENT_CARD_LE_DIM = store_thm ("INDEPENDENT_CARD_LE_DIM",
 ``!v b:real->bool. b SUBSET v /\ independent b ==> FINITE b /\ CARD(b) <= dim v``,
  METIS_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, HAS_SIZE, SUBSET_TRANS]);

val CARD_GE_DIM_INDEPENDENT = store_thm ("CARD_GE_DIM_INDEPENDENT",
 ``!v b:real->bool. b SUBSET v /\ independent b /\ dim v <= CARD(b)
        ==> v SUBSET (span b)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!a:real. ~(a IN v /\ ~(a IN span b))`` MP_TAC THENL
   [ALL_TAC, SET_TAC[]] THEN
  X_GEN_TAC ``a:real`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``independent((a:real) INSERT b)`` ASSUME_TAC THENL
   [METIS_TAC[INDEPENDENT_INSERT], ALL_TAC] THEN
  MP_TAC(ISPECL [``v:real->bool``, ``(a:real) INSERT b``]
                INDEPENDENT_CARD_LE_DIM) THEN
  ASM_SIMP_TAC std_ss [INSERT_SUBSET, CARD_EMPTY, CARD_INSERT, INDEPENDENT_BOUND] THEN
  METIS_TAC[SPAN_SUPERSET, SUBSET_DEF, ARITH_PROVE
    ``x <= y ==> ~(SUC y <= x)``]);

val SPAN_EXPLICIT = store_thm ("SPAN_EXPLICIT",
 ``!(p:real -> bool). span p =
    {y | ?s u. FINITE s /\ s SUBSET p /\ (sum s (\v. u v * v) = y)}``,
  GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [ALL_TAC,
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN
    REPEAT STRIP_TAC THEN FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    MATCH_MP_TAC SPAN_SUM THEN ASM_REWRITE_TAC[] THEN
    ASM_MESON_TAC[SPAN_SUPERSET, SPAN_MUL]] THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(?s u. FINITE s /\ (!x. x IN s ==> x IN p) /\ (sum s (\v. u v * v) = x)) =
     (\x. ?s u. FINITE s /\ (!x. x IN s ==> x IN p) /\ (sum s (\v. u v * v) = x)) x``] THEN
  MATCH_MP_TAC SPAN_INDUCT_ALT THEN SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [EXISTS_TAC ``{}:real->bool`` THEN
    SIMP_TAC std_ss [FINITE_EMPTY, FINITE_INSERT, SUM_CLAUSES,
     EMPTY_SUBSET, NOT_IN_EMPTY], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``c:real``, ``x:real``, ``y:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``] THEN
  STRIP_TAC THEN EXISTS_TAC ``(x:real) INSERT s`` THEN
  EXISTS_TAC ``\y. if y = x then (if x IN s then (u:real->real) y + c else c)
                  else u y`` THEN
  ASM_SIMP_TAC std_ss [FINITE_INSERT, IN_INSERT, SUM_CLAUSES] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL
   [FIRST_X_ASSUM(SUBST1_TAC o MATCH_MP (SET_RULE
     ``x IN s ==> (s = x INSERT (s DELETE x))``)) THEN
    ASM_SIMP_TAC std_ss [SUM_CLAUSES, FINITE_INSERT, FINITE_DELETE, IN_DELETE] THEN
    MATCH_MP_TAC(REAL_ARITH
      ``(y = z) ==> ((c + d) * x + y = d * x + (c * x + z:real))``),
    AP_TERM_TAC] THEN
  MATCH_MP_TAC SUM_EQ THEN METIS_TAC[IN_DELETE]);

val DEPENDENT_EXPLICIT = store_thm ("DEPENDENT_EXPLICIT",
 ``!p. dependent (p:real -> bool) <=>
       ?s u. FINITE s /\ s SUBSET p /\ (?v. v IN s /\ ~(u v = &0)) /\
             (sum s (\v. u v * v) = 0)``,
  GEN_TAC THEN SIMP_TAC std_ss [dependent, SPAN_EXPLICIT, GSPECIFICATION] THEN
  SIMP_TAC std_ss [GSYM RIGHT_EXISTS_AND_THM, GSYM LEFT_EXISTS_AND_THM] THEN
  EQ_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THENL
   [MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``] THEN
    STRIP_TAC THEN ABBREV_TAC ``a = sum s (\v. (u:real->real) v * v)`` THEN
    MAP_EVERY EXISTS_TAC
     [``(a:real) INSERT s``,
      ``\y. if y = a then - &1 else (u:real->real) y``,
      ``a:real``] THEN
    ASM_REWRITE_TAC[IN_INSERT, INSERT_SUBSET, FINITE_INSERT] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC real_ss []] THEN
    ASM_SIMP_TAC std_ss [SUM_CLAUSES] THEN
    COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[REAL_ARITH ``(-&1 * a + s = 0) <=> (a = s:real)``] THEN
    FIRST_X_ASSUM(fn th => GEN_REWR_TAC LAND_CONV [SYM th]) THEN
    MATCH_MP_TAC SUM_EQ THEN ASM_SET_TAC[],
    MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``, ``a:real``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s DELETE (a:real)``,
      ``\i. -((u:real->real) i) / (u (a:real))``] THEN
    ASM_SIMP_TAC std_ss [SUM_DELETE, FINITE_DELETE] THEN
    KNOW_TAC ``sum s (\v. -u v / (u:real->real) a * v) - -u a / u a * a = a`` THENL
    [REWRITE_TAC[real_div] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
     REWRITE_TAC [REAL_MUL_ASSOC] THEN SIMP_TAC real_ss [SUM_RMUL, SUM_NEG] THEN
     RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN ASM_REWRITE_TAC [] THEN
     ASM_SIMP_TAC real_ss [REAL_MUL_LNEG, GSYM REAL_MUL_ASSOC,
                           REAL_MUL_RNEG, REAL_MUL_RZERO] THEN
     ASM_SIMP_TAC real_ss [REAL_MUL_RINV], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    ASM_SET_TAC []]);

val INDEPENDENT_INJECTIVE_IMAGE_GEN = store_thm ("INDEPENDENT_INJECTIVE_IMAGE_GEN",
 ``!f:real->real s. independent s /\ linear f /\
     (!x y. x IN span s /\ y IN span s /\ (f(x) = f(y)) ==> (x = y))
    ==> independent (IMAGE f s)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [independent, DEPENDENT_EXPLICIT] THEN
  REWRITE_TAC[CONJ_ASSOC, FINITE_SUBSET_IMAGE] THEN DISCH_TAC THEN
  KNOW_TAC ``(?s':real->bool u:real->real. (FINITE s' /\ s' SUBSET s) /\
      (?v. v IN IMAGE f s' /\ ~(u v = &0)) /\
      (sum (IMAGE f s') (\v. u v * v) = 0))`` THENL
  [METIS_TAC [], POP_ASSUM K_TAC] THEN
  SIMP_TAC std_ss [EXISTS_IN_IMAGE, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``t:real->bool``, ``u:real->real``] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MAP_EVERY EXISTS_TAC
   [``t:real->bool``, ``(u:real->real) o (f:real->real)``] THEN
  ASM_REWRITE_TAC[o_THM] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC SPAN_SUM THEN ASM_SIMP_TAC std_ss [] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SPAN_MUL THEN
    MATCH_MP_TAC SPAN_SUPERSET THEN ASM_SET_TAC[],
    REWRITE_TAC[SPAN_0],
    ASM_SIMP_TAC std_ss [LINEAR_SUM] THEN
    FIRST_ASSUM(SUBST1_TAC o MATCH_MP LINEAR_0) THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN CONV_TAC SYM_CONV THEN
    W(MP_TAC o PART_MATCH (lhs o rand) SUM_IMAGE o lhand o snd) THEN
    ASM_SIMP_TAC std_ss [o_DEF] THEN ASM_SIMP_TAC std_ss [LINEAR_CMUL] THEN
    DISCH_THEN MATCH_MP_TAC THEN ASM_MESON_TAC[SPAN_SUPERSET, SUBSET_DEF]]);

val INDEPENDENT_INJECTIVE_IMAGE = store_thm ("INDEPENDENT_INJECTIVE_IMAGE",
 ``!f:real->real s. independent s /\ linear f /\
     (!x y. (f(x) = f(y)) ==> (x = y)) ==> independent (IMAGE f s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INDEPENDENT_INJECTIVE_IMAGE_GEN THEN
  ASM_MESON_TAC[]);

Theorem SPAN_LINEAR_IMAGE :
    !f:real->real s. linear f ==> (span(IMAGE f s) = IMAGE f (span s))
Proof
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  X_GEN_TAC ``x:real`` THEN EQ_TAC THENL
   [ONCE_REWRITE_TAC [METIS [] ``x IN IMAGE f (span s) <=>
                            (\x. x IN IMAGE f (span s)) x``] THEN
    SPEC_TAC(``x:real``, ``x:real``) THEN MATCH_MP_TAC SPAN_INDUCT THEN
    SIMP_TAC std_ss [SET_RULE ``(\x. x IN s) = s``] THEN
    ASM_SIMP_TAC std_ss [SUBSPACE_SPAN, SUBSPACE_LINEAR_IMAGE] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN REWRITE_TAC[IN_IMAGE] THEN
    MESON_TAC[SPAN_SUPERSET, SUBSET_DEF],
    SPEC_TAC(``x:real``, ``x:real``) THEN SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
    ONCE_REWRITE_TAC [METIS [] ``f x IN span (IMAGE f s) <=>
                            (\x. f x IN span (IMAGE f s)) x``] THEN
    MATCH_MP_TAC SPAN_INDUCT THEN
    SIMP_TAC std_ss [SET_RULE ``(\x. f x IN span(s)) = {x | f(x) IN span s}``] THEN
    ASM_SIMP_TAC std_ss [SUBSPACE_LINEAR_PREIMAGE, SUBSPACE_SPAN] THEN
    SIMP_TAC std_ss [GSPECIFICATION] THEN
    MESON_TAC[SPAN_SUPERSET, SUBSET_DEF, IN_IMAGE]]
QED

(* ------------------------------------------------------------------------- *)
(* An injective map real->real is also surjective.                       *)
(* ------------------------------------------------------------------------- *)

val LINEAR_INJECTIVE_IMP_SURJECTIVE = store_thm ("LINEAR_INJECTIVE_IMP_SURJECTIVE",
 ``!f:real->real. linear f /\ (!x y. (f(x) = f(y)) ==> (x = y))
                 ==> !y. ?x. f(x) = y``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``univ(:real)`` BASIS_EXISTS) THEN
  REWRITE_TAC[SUBSET_UNIV, HAS_SIZE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``UNIV SUBSET span(IMAGE (f:real->real) b)`` MP_TAC THENL
   [MATCH_MP_TAC CARD_GE_DIM_INDEPENDENT THEN
    ASM_MESON_TAC[INDEPENDENT_INJECTIVE_IMAGE, LESS_EQ_REFL,
                  SUBSET_UNIV, CARD_IMAGE_INJ],
    ASM_SIMP_TAC std_ss [SPAN_LINEAR_IMAGE] THEN
    ASM_MESON_TAC[SUBSET_DEF, IN_IMAGE, IN_UNIV]]);

(* ------------------------------------------------------------------------- *)
(* Left-invertible linear transformation has a lower bound.                  *)
(* ------------------------------------------------------------------------- *)

val LINEAR_INVERTIBLE_BOUNDED_BELOW_POS = store_thm ("LINEAR_INVERTIBLE_BOUNDED_BELOW_POS",
 ``!f:real->real g. linear f /\ linear g /\ (g o f = I)
   ==> ?B. &0 < B /\ !x. B * abs(x) <= abs(f x)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``g:real->real`` LINEAR_BOUNDED_POS) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``inv B:real`` THEN ASM_SIMP_TAC real_ss [REAL_LT_INV_EQ] THEN
  X_GEN_TAC ``x:real`` THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``inv(B) * abs(((g:real->real) o (f:real->real)) x)`` THEN
  CONJ_TAC THENL [ASM_SIMP_TAC real_ss [I_THM, REAL_LE_REFL], ALL_TAC] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC real_ss [o_THM, REAL_LE_LDIV_EQ] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_REWRITE_TAC[]);

val LINEAR_INVERTIBLE_BOUNDED_BELOW = store_thm ("LINEAR_INVERTIBLE_BOUNDED_BELOW",
 ``!f:real->real g. linear f /\ linear g /\ (g o f = I) ==>
   ?B. !x. B * abs(x) <= abs(f x)``,
  MESON_TAC[LINEAR_INVERTIBLE_BOUNDED_BELOW_POS]);

val LINEAR_INJECTIVE_BOUNDED_BELOW_POS = store_thm ("LINEAR_INJECTIVE_BOUNDED_BELOW_POS",
 ``!f:real->real. linear f /\ (!x y. (f x = f y) ==> (x = y))
    ==> ?B. &0 < B /\ !x. abs(x) * B <= abs(f x)``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  MATCH_MP_TAC LINEAR_INVERTIBLE_BOUNDED_BELOW_POS THEN
  METIS_TAC[LINEAR_INJECTIVE_LEFT_INVERSE, I_THM]);

(* ------------------------------------------------------------------------- *)
(* Consequences of independence or spanning for cardinality.                 *)
(* ------------------------------------------------------------------------- *)

val INDEPENDENT_CARD_LE_DIM = store_thm ("INDEPENDENT_CARD_LE_DIM",
 ``!v b:real->bool. b SUBSET v /\ independent b ==> FINITE b /\ CARD(b) <= dim v``,
  METIS_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, HAS_SIZE, SUBSET_TRANS]);

val SPAN_CARD_GE_DIM = store_thm ("SPAN_CARD_GE_DIM",
 ``!v b:real->bool. v SUBSET (span b) /\ FINITE b ==> dim(v) <= CARD(b)``,
  METIS_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, HAS_SIZE, SUBSET_TRANS]);

val BASIS_CARD_EQ_DIM = store_thm ("BASIS_CARD_EQ_DIM",
 ``!v b. b SUBSET v /\ v SUBSET (span b) /\ independent b
   ==> FINITE b /\ (CARD b = dim v)``,
  METIS_TAC[LESS_EQUAL_ANTISYM, INDEPENDENT_CARD_LE_DIM, SPAN_CARD_GE_DIM]);

val BASIS_HAS_SIZE_DIM = store_thm ("BASIS_HAS_SIZE_DIM",
 ``!v b. independent b /\ (span b = v) ==> b HAS_SIZE (dim v)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HAS_SIZE] THEN
  MATCH_MP_TAC BASIS_CARD_EQ_DIM THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN REWRITE_TAC[SPAN_INC]);

val DIM_UNIQUE = store_thm ("DIM_UNIQUE",
 ``!v b. b SUBSET v /\ v SUBSET (span b) /\ independent b /\ b HAS_SIZE n
        ==> (dim v = n)``,
  MESON_TAC[BASIS_CARD_EQ_DIM, HAS_SIZE]);

val DIM_LE_CARD = store_thm ("DIM_LE_CARD",
 ``!s. FINITE s ==> dim s <= CARD s``,
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC SPAN_CARD_GE_DIM THEN
  ASM_REWRITE_TAC[SPAN_INC, SUBSET_REFL]);

(* ------------------------------------------------------------------------- *)
(* Standard bases are a spanning set, and obviously finite.                  *)
(* ------------------------------------------------------------------------- *)

val SPAN_STDBASIS = store_thm ("SPAN_STDBASIS",
 ``span {i :real | 1 <= i /\ i <= 1} = UNIV``,
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
  SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
  SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC []);

val HAS_SIZE_STDBASIS = store_thm ("HAS_SIZE_STDBASIS",
 ``{i :real | 1 <= i /\ i <= 1} HAS_SIZE 1``,
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2, HAS_SIZE] THEN
  REWRITE_TAC [FINITE_SING, CARD_SING]);

(* ------------------------------------------------------------------------- *)
(* More lemmas about dimension.                                              *)
(* ------------------------------------------------------------------------- *)

val DIM_UNIV = store_thm ("DIM_UNIV",
 ``dim univ(:real) = 1:num``,
  MATCH_MP_TAC DIM_UNIQUE THEN EXISTS_TAC ``{i :real | &1 <= i /\ i <= &1}`` THEN
  REWRITE_TAC[SUBSET_UNIV, SPAN_STDBASIS, HAS_SIZE_STDBASIS, INDEPENDENT_STDBASIS]);

val DIM_SUBSET = store_thm ("DIM_SUBSET",
 ``!s t:real->bool. s SUBSET t ==> dim(s) <= dim(t)``,
  MESON_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, SUBSET_DEF, HAS_SIZE]);

val DIM_SUBSET_UNIV = store_thm ("DIM_SUBSET_UNIV",
 ``!s:real->bool. dim(s) <= (1:num)``,
  GEN_TAC THEN REWRITE_TAC[GSYM DIM_UNIV] THEN
  MATCH_MP_TAC DIM_SUBSET THEN REWRITE_TAC[SUBSET_UNIV]);

(* ------------------------------------------------------------------------- *)
(* General notion of a topology. (moved to real/topologyTheory)              *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Open sets. (moved to real/topologyTheory)                                 *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Closed sets. (moved to real/topologyTheory)                               *)
(* ------------------------------------------------------------------------- *)

(* ------------------------------------------------------------------------- *)
(* Subspace topology.                                                        *)
(* ------------------------------------------------------------------------- *)

val subtopology = new_definition ("subtopology",
 ``subtopology top u = topology {s INTER u | open_in top s}``);

val SUBSET_IMAGE = store_thm ("SUBSET_IMAGE",
 ``!f:'a->'b s t. s SUBSET (IMAGE f t) <=> ?u. u SUBSET t /\ (s = IMAGE f u)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL [ALL_TAC, MESON_TAC[IMAGE_SUBSET]] THEN
  DISCH_TAC THEN EXISTS_TAC ``{x | x IN t /\ (f:'a->'b) x IN s}`` THEN
  POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [EXTENSION, SUBSET_DEF, IN_IMAGE, GSPECIFICATION] THEN
  MESON_TAC[]);

val INTER_BIGUNION = store_thm ("INTER_BIGUNION",
 ``(!s t. BIGUNION s INTER t = BIGUNION {x INTER t | x IN s}) /\
   (!s t. t INTER BIGUNION s = BIGUNION {t INTER x | x IN s})``,
  ONCE_REWRITE_TAC[EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGUNION, GSPECIFICATION, IN_INTER] THEN
  MESON_TAC[IN_INTER]);

val ISTOPLOGY_SUBTOPOLOGY = store_thm ("ISTOPLOGY_SUBTOPOLOGY",
 ``!top u:'a->bool. istopology {s INTER u | open_in top s}``,
  REWRITE_TAC[istopology, SET_RULE
   ``{s INTER u | open_in top s} =
    IMAGE (\s. s INTER u) {s | open_in top s}``] THEN
  SIMP_TAC std_ss [GSYM AND_IMP_INTRO, FORALL_IN_IMAGE, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [SUBSET_IMAGE, IN_IMAGE, GSPECIFICATION, SUBSET_DEF] THEN
  REPEAT GEN_TAC THEN REPEAT CONJ_TAC THENL
   [EXISTS_TAC ``{}:'a->bool`` THEN REWRITE_TAC[OPEN_IN_EMPTY, INTER_EMPTY],
    SIMP_TAC std_ss [SET_RULE ``(s INTER u) INTER (t INTER u) = (s INTER t) INTER u``] THEN
    ASM_MESON_TAC[OPEN_IN_INTER],
    X_GEN_TAC ``f:('a->bool)->bool`` THEN DISCH_THEN (X_CHOOSE_TAC ``g:('a->bool)->bool``) THEN
    EXISTS_TAC ``BIGUNION g :'a->bool`` THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_BIGUNION, INTER_BIGUNION] THEN SET_TAC[]]);

val OPEN_IN_SUBTOPOLOGY = store_thm ("OPEN_IN_SUBTOPOLOGY",
 ``!top u s. open_in (subtopology top u) s <=>
                ?t. open_in top t /\ (s = t INTER u)``,
  REWRITE_TAC[subtopology] THEN
  SIMP_TAC std_ss [REWRITE_RULE[CONJUNCT2 topology_tybij] ISTOPLOGY_SUBTOPOLOGY] THEN
  GEN_REWR_TAC (QUANT_CONV o QUANT_CONV o QUANT_CONV o LAND_CONV) [GSYM SPECIFICATION] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION] THEN METIS_TAC []);

val TOPSPACE_SUBTOPOLOGY = store_thm ("TOPSPACE_SUBTOPOLOGY",
 ``!top u. topspace(subtopology top u) = topspace top INTER u``,
  REWRITE_TAC[topspace, OPEN_IN_SUBTOPOLOGY, INTER_BIGUNION] THEN
  REPEAT STRIP_TAC THEN AP_TERM_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN METIS_TAC []);

val CLOSED_IN_SUBTOPOLOGY = store_thm ("CLOSED_IN_SUBTOPOLOGY",
 ``!top u s. closed_in (subtopology top u) s <=>
                ?t:'a->bool. closed_in top t /\ (s = t INTER u)``,
  REWRITE_TAC[closed_in, TOPSPACE_SUBTOPOLOGY] THEN
  SIMP_TAC std_ss [SUBSET_INTER, OPEN_IN_SUBTOPOLOGY, GSYM RIGHT_EXISTS_AND_THM] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:'a->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``topspace top DIFF t :'a->bool`` THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_TOPSPACE, OPEN_IN_DIFF, CLOSED_IN_DIFF,
               OPEN_IN_TOPSPACE] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val OPEN_IN_SUBTOPOLOGY_EMPTY = store_thm ("OPEN_IN_SUBTOPOLOGY_EMPTY",
 ``!top s. open_in (subtopology top {}) s <=> (s = {})``,
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY, INTER_EMPTY] THEN
  MESON_TAC[OPEN_IN_EMPTY]);

val CLOSED_IN_SUBTOPOLOGY_EMPTY = store_thm ("CLOSED_IN_SUBTOPOLOGY_EMPTY",
 ``!top s. closed_in (subtopology top {}) s <=> (s = {})``,
  REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY, INTER_EMPTY] THEN
  MESON_TAC[CLOSED_IN_EMPTY]);

val OPEN_IN_SUBTOPOLOGY_REFL = store_thm ("OPEN_IN_SUBTOPOLOGY_REFL",
 ``!top u:'a->bool. open_in (subtopology top u) u <=> u SUBSET topspace top``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN ONCE_ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC(SET_RULE ``s SUBSET u ==> s INTER t SUBSET u``) THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_SUBSET],
    DISCH_TAC THEN EXISTS_TAC ``topspace top:'a->bool`` THEN
    REWRITE_TAC[OPEN_IN_TOPSPACE] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CLOSED_IN_SUBTOPOLOGY_REFL = store_thm ("CLOSED_IN_SUBTOPOLOGY_REFL",
 ``!top u:'a->bool. closed_in (subtopology top u) u <=> u SUBSET topspace top``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY] THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN ONCE_ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC(SET_RULE ``s SUBSET u ==> s INTER t SUBSET u``) THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_SUBSET],
    DISCH_TAC THEN EXISTS_TAC ``topspace top:'a->bool`` THEN
    REWRITE_TAC[CLOSED_IN_TOPSPACE] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val SUBTOPOLOGY_SUPERSET = store_thm ("SUBTOPOLOGY_SUPERSET",
 ``!top s:'a->bool. topspace top SUBSET s ==> (subtopology top s = top)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [TOPOLOGY_EQ, OPEN_IN_SUBTOPOLOGY] THEN
  DISCH_TAC THEN X_GEN_TAC ``u:'a->bool`` THEN EQ_TAC THENL
   [DISCH_THEN(CHOOSE_THEN(CONJUNCTS_THEN2 MP_TAC SUBST1_TAC)) THEN
    DISCH_THEN(fn th => MP_TAC th THEN
      ASSUME_TAC(MATCH_MP OPEN_IN_SUBSET th)) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN REPEAT (POP_ASSUM MP_TAC) THEN
    SET_TAC[],
    DISCH_TAC THEN EXISTS_TAC ``u:'a->bool`` THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_SUBSET) THEN
    REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val SUBTOPOLOGY_TOPSPACE = store_thm ("SUBTOPOLOGY_TOPSPACE",
 ``!top. subtopology top (topspace top) = top``,
  SIMP_TAC std_ss [SUBTOPOLOGY_SUPERSET, SUBSET_REFL]);

val SUBTOPOLOGY_UNIV = store_thm ("SUBTOPOLOGY_UNIV",
 ``!top. subtopology top UNIV = top``,
  SIMP_TAC std_ss [SUBTOPOLOGY_SUPERSET, SUBSET_UNIV]);

val OPEN_IN_IMP_SUBSET = store_thm ("OPEN_IN_IMP_SUBSET",
 ``!top s t. open_in (subtopology top s) t ==> t SUBSET s``,
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN SET_TAC[]);

val CLOSED_IN_IMP_SUBSET = store_thm ("CLOSED_IN_IMP_SUBSET",
 ``!top s t. closed_in (subtopology top s) t ==> t SUBSET s``,
  REWRITE_TAC[closed_in, TOPSPACE_SUBTOPOLOGY] THEN SET_TAC[]);

val OPEN_IN_SUBTOPOLOGY_UNION = store_thm ("OPEN_IN_SUBTOPOLOGY_UNION",
 ``!top s t u:'a->bool.
        open_in (subtopology top t) s /\ open_in (subtopology top u) s
        ==> open_in (subtopology top (t UNION u)) s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_SUBTOPOLOGY] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``s':'a->bool`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``t':'a->bool`` STRIP_ASSUME_TAC)) THEN
  EXISTS_TAC ``s' INTER t':'a->bool`` THEN ASM_SIMP_TAC std_ss [OPEN_IN_INTER] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CLOSED_IN_SUBTOPOLOGY_UNION = store_thm ("CLOSED_IN_SUBTOPOLOGY_UNION",
 ``!top s t u:'a->bool.
        closed_in (subtopology top t) s /\ closed_in (subtopology top u) s
        ==> closed_in (subtopology top (t UNION u)) s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``s':'a->bool`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``t':'a->bool`` STRIP_ASSUME_TAC)) THEN
  EXISTS_TAC ``s' INTER t':'a->bool`` THEN ASM_SIMP_TAC std_ss [CLOSED_IN_INTER] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* OPEN                                                                      *)
(* ------------------------------------------------------------------------- *)

val open_def = new_definition ("open_def",
  ``Open s <=> !x. x IN s ==> ?e. &0 < e /\ !x'. dist(x',x) < e ==> x' IN s``);

val _ = overload_on ("open",``Open``);

val closed_def = new_definition ("closed_def",
  ``Closed(s:real->bool) <=> open(UNIV DIFF s)``);

val _ = overload_on ("closed",``Closed``);

val euclidean = new_definition ("euclidean",
 ``euclidean = topology open``);

val OPEN_EMPTY = store_thm ("OPEN_EMPTY",
  ``open {}``,
  REWRITE_TAC[open_def, NOT_IN_EMPTY]);

val OPEN_UNIV = store_thm ("OPEN_UNIV",
 ``open univ(:real)``,
  REWRITE_TAC[open_def, IN_UNIV] THEN MESON_TAC[REAL_LT_01]);

val OPEN_INTER = store_thm ("OPEN_INTER",
  ``!s t. open s /\ open t ==> open (s INTER t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC [open_def] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REWRITE_TAC [IN_INTER] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x`) THEN
  STRIP_TAC THEN STRIP_TAC THEN FULL_SIMP_TAC real_ss [] THEN
  Cases_on `e < e'` THENL [EXISTS_TAC ``e:real`` THEN
  ASM_REWRITE_TAC [] THEN GEN_TAC THEN
  UNDISCH_TAC (Term `!x'. dist (x',x) < e ==> x' IN s`) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN RW_TAC std_ss [] THEN
  UNDISCH_TAC (Term `!x'. dist (x',x) < e' ==> x' IN t`) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN
  KNOW_TAC ``dist (x',x) < e'`` THENL [MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  RW_TAC std_ss [] THEN Cases_on `e' < e` THEN
  EXISTS_TAC ``e':real`` THEN ASM_REWRITE_TAC [],
  Cases_on `e' < e` THENL [EXISTS_TAC ``e':real`` THEN
  ASM_REWRITE_TAC [] THEN GEN_TAC THEN
  UNDISCH_TAC (Term `!x'. dist (x',x) < e' ==> x' IN t`) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN
  RW_TAC std_ss [] THEN
  UNDISCH_TAC (Term `!x'. dist (x',x) < e ==> x' IN s`) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN
  KNOW_TAC ``dist (x',x) < e`` THENL [MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``e':real`` THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  RW_TAC std_ss [],
  FULL_SIMP_TAC std_ss [REAL_NOT_LT] THEN KNOW_TAC ``(e:real) = e'`` THENL
  [METIS_TAC [REAL_LE_ANTISYM], ALL_TAC] THEN DISCH_TAC THEN
  EXISTS_TAC ``e:real`` THEN CONJ_TAC THEN FULL_SIMP_TAC real_ss []]]);

val OPEN_BIGUNION = store_thm ("OPEN_BIGUNION",
 ``(!s. s IN f ==> open s) ==> open(BIGUNION f)``,
  REWRITE_TAC[open_def, IN_BIGUNION] THEN MESON_TAC[]);

val OPEN_EXISTS_IN = store_thm ("OPEN_EXISTS_IN",
 ``!P Q:'a->real->bool.
        (!a. P a ==> open {x | Q a x}) ==> open {x | ?a. P a /\ Q a x}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``open(BIGUNION {{x | Q (a:'a) (x:real)} | P a})`` MP_TAC THENL
   [MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN
    METIS_TAC [], MATCH_MP_TAC (TAUT `(a <=> b) ==> a ==> b`) THEN AP_TERM_TAC THEN
    SIMP_TAC std_ss [EXTENSION, IN_BIGUNION, GSPECIFICATION] THEN
    SET_TAC[]]);

val OPEN_EXISTS = store_thm ("OPEN_EXISTS",
 ``!Q:'a->real->bool. (!a. open {x | Q a x}) ==> open {x | ?a. Q a x}``,
  MP_TAC(ISPEC ``\x:'a. T`` OPEN_EXISTS_IN) THEN REWRITE_TAC[]);

val OPEN_IN = store_thm ("OPEN_IN",
 ``!s:real->bool. open s <=> open_in euclidean s``,
  GEN_TAC THEN REWRITE_TAC[euclidean] THEN CONV_TAC SYM_CONV THEN
  AP_THM_TAC THEN REWRITE_TAC[GSYM(CONJUNCT2 topology_tybij)] THEN
  SIMP_TAC std_ss [REWRITE_RULE[IN_DEF] istopology] THEN
  REWRITE_TAC[OPEN_EMPTY, OPEN_INTER, SUBSET_DEF] THEN
  MESON_TAC[IN_DEF, OPEN_BIGUNION]);

val TOPSPACE_EUCLIDEAN = store_thm ("TOPSPACE_EUCLIDEAN",
 ``topspace euclidean = univ(:real)``,
  SIMP_TAC std_ss [topspace, EXTENSION, IN_UNIV, IN_BIGUNION, GSPECIFICATION] THEN
  MESON_TAC[OPEN_UNIV, IN_UNIV, OPEN_IN]);

val TOPSPACE_EUCLIDEAN_SUBTOPOLOGY = store_thm ("TOPSPACE_EUCLIDEAN_SUBTOPOLOGY",
 ``!s. topspace (subtopology euclidean s) = s``,
  REWRITE_TAC[TOPSPACE_EUCLIDEAN, TOPSPACE_SUBTOPOLOGY, INTER_UNIV]);

val OPEN_IN_REFL = store_thm ("OPEN_IN_REFL",
 ``!s:real->bool. open_in (subtopology euclidean s) s``,
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV]);

val CLOSED_IN_REFL = store_thm ("CLOSED_IN_REFL",
 ``!s:real->bool. closed_in (subtopology euclidean s) s``,
  REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV]);

val CLOSED_IN = store_thm ("CLOSED_IN",
 ``!s:real->bool. closed s <=> closed_in euclidean s``,
  REWRITE_TAC[closed_def, closed_in, TOPSPACE_EUCLIDEAN, OPEN_IN, SUBSET_UNIV]);

val OPEN_UNION = store_thm ("OPEN_UNION",
 ``!s t. open s /\ open t ==> open(s UNION t)``,
  REWRITE_TAC [open_def] THEN REPEAT STRIP_TAC THEN POP_ASSUM MP_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `x`) THEN
  POP_ASSUM (MP_TAC o Q.SPEC `x`) THEN
  REPEAT STRIP_TAC THEN Cases_on `x IN s` THENL
  [FULL_SIMP_TAC std_ss [] THEN EXISTS_TAC ``e:real`` THEN
   FULL_SIMP_TAC std_ss [IN_UNION], FULL_SIMP_TAC std_ss [IN_UNION] THEN
   EXISTS_TAC ``e:real`` THEN FULL_SIMP_TAC std_ss [IN_UNION]]);

val OPEN_SUB_OPEN = store_thm ("OPEN_SUB_OPEN",
 ``!s. open s <=> !x. x IN s ==> ?t. open t /\ x IN t /\ t SUBSET s``,
 GEN_TAC THEN EQ_TAC THENL
 [RW_TAC std_ss [] THEN EXISTS_TAC ``s:real->bool`` THEN
  ASM_REWRITE_TAC [SUBSET_REFL], DISCH_TAC THEN
  REWRITE_TAC [open_def] THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `x`) THEN DISCH_TAC THEN DISCH_TAC THEN
  FULL_SIMP_TAC std_ss [open_def] THEN
  UNDISCH_TAC (Term `!x. x IN t ==> ?e. 0 < e /\ !x'. dist (x',x) < e ==> x' IN t `)
  THEN DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x`) THEN
  RW_TAC std_ss [] THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC []
  THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN
  RW_TAC std_ss [] THEN METIS_TAC [SUBSET_DEF]]);

val CLOSED_EMPTY = store_thm ("CLOSED_EMPTY",
 ``closed {}``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_EMPTY]);

val CLOSED_UNIV = store_thm ("CLOSED_UNIV",
 ``closed(UNIV:real->bool)``,
  REWRITE_TAC[CLOSED_IN, GSYM TOPSPACE_EUCLIDEAN, CLOSED_IN_TOPSPACE]);

val CLOSED_UNION = store_thm ("CLOSED_UNION",
 ``!s t. closed s /\ closed t ==> closed(s UNION t)``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_UNION]);

val CLOSED_INTER = store_thm ("CLOSED_INTER",
 ``!s t. closed s /\ closed t ==> closed(s INTER t)``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_INTER]);

val CLOSED_BIGINTER = store_thm ("CLOSED_BIGINTER",
 ``!f. (!s:real->bool. s IN f ==> closed s) ==> closed(BIGINTER f)``,
  REWRITE_TAC[CLOSED_IN] THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_BIGINTER, BIGINTER_EMPTY] THEN
  REWRITE_TAC[GSYM TOPSPACE_EUCLIDEAN, CLOSED_IN_TOPSPACE]);

val BIGINTER_GSPEC = store_thm ("BIGINTER_GSPEC",
 ``(!P f. BIGINTER {f x | P x} = {a | !x. P x ==> a IN (f x)}) /\
   (!P f. BIGINTER {f x y | P x y} = {a | !x y. P x y ==> a IN (f x y)}) /\
   (!P f. BIGINTER {f x y z | P x y z} =
                {a | !x y z. P x y z ==> a IN (f x y z)})``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGINTER, GSPECIFICATION, EXISTS_PROD] THEN MESON_TAC[]);

val CLOSED_FORALL_IN = store_thm ("CLOSED_FORALL_IN",
 ``!P Q:'a->real->bool.
        (!a. P a ==> closed {x | Q a x}) ==> closed {x | !a. P a ==> Q a x}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``closed(BIGINTER {{x | Q (a:'a) (x:real)} | P a})`` MP_TAC THENL
   [MATCH_MP_TAC CLOSED_BIGINTER THEN ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC],
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SIMP_TAC std_ss [BIGINTER_GSPEC] THEN
    SET_TAC[]]);

val CLOSED_FORALL = store_thm ("CLOSED_FORALL",
 ``!Q:'a->real->bool. (!a. closed {x | Q a x}) ==> closed {x | !a. Q a x}``,
  MP_TAC(ISPEC ``\x:'a. T`` CLOSED_FORALL_IN) THEN REWRITE_TAC[]);

val OPEN_CLOSED = store_thm ("OPEN_CLOSED",
 ``!s:real->bool. open s <=> closed(UNIV DIFF s)``,
  SIMP_TAC std_ss [OPEN_IN, CLOSED_IN, TOPSPACE_EUCLIDEAN, SUBSET_UNIV,
           OPEN_IN_CLOSED_IN_EQ]);

val OPEN_DIFF = store_thm ("OPEN_DIFF",
 ``!s t. open s /\ closed t ==> open(s DIFF t)``,
  REWRITE_TAC[OPEN_IN, CLOSED_IN, OPEN_IN_DIFF]);

val CLOSED_DIFF = store_thm ("CLOSED_DIFF",
 ``!s t. closed s /\ open t ==> closed(s DIFF t)``,
  REWRITE_TAC[OPEN_IN, CLOSED_IN, CLOSED_IN_DIFF]);

val OPEN_BIGINTER = store_thm ("OPEN_BIGINTER",
  ``!s. FINITE s /\ (!t. t IN s ==> open t) ==> (open (BIGINTER s))``,
  REWRITE_TAC [GSYM AND_IMP_INTRO] THEN GEN_TAC THEN
  KNOW_TAC `` (!t. t IN s ==> open t) ==> open (BIGINTER s) <=>
         (\x. (!t. t IN x ==> open t) ==> open (BIGINTER x)) s`` THENL
  [SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
   MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
   REWRITE_TAC [BIGINTER_INSERT, BIGINTER_EMPTY, OPEN_UNIV,
   IN_INSERT] THEN MESON_TAC [OPEN_INTER]);

val CLOSED_BIGUNION = store_thm ("CLOSED_BIGUNION",
 ``!s. FINITE s /\ (!t. t IN s ==> closed t) ==> closed(BIGUNION s)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s. ((!t. t IN s ==> closed t) ==> closed(BIGUNION s)) <=>
             (\s. (!t. t IN s ==> closed t) ==> closed(BIGUNION s)) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_INSERT, BIGUNION_EMPTY, CLOSED_EMPTY, IN_INSERT] THEN
  MESON_TAC[CLOSED_UNION]);

(* ------------------------------------------------------------------------- *)
(* Open and closed balls.                                                    *)
(* ------------------------------------------------------------------------- *)

val ball = new_definition ("ball",
  ``ball(x,e) = { y | dist(x,y) < e}``);

val cball = new_definition ("cball",
  ``cball(x,e) = { y | dist(x,y) <= e}``);

val sphere = new_definition ("sphere",
  ``sphere(x,e) = { y | dist(x,y) = e}``);

val IN_BALL = store_thm ("IN_BALL",
 ``!x y e. y IN ball(x,e) <=> dist(x,y) < e``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [ball, GSPECIFICATION]);

val IN_CBALL = store_thm ("IN_CBALL",
 ``!x y e. y IN cball(x,e) <=> dist(x,y) <= e``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [cball, GSPECIFICATION]);

val IN_SPHERE = store_thm ("IN_SPHERE",
 ``!x y e. y IN sphere(x,e) <=> (dist(x,y) = e)``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [sphere, GSPECIFICATION]);

val IN_BALL_0 = store_thm ("IN_BALL_0",
 ``!x e. x IN ball(0,e) <=> abs(x) < e``,
  REWRITE_TAC [IN_BALL, dist, REAL_SUB_LZERO, ABS_NEG]);

val IN_CBALL_0 = store_thm ("IN_CBALL_0",
 ``!x e. x IN cball(0,e) <=> abs(x) <= e``,
  REWRITE_TAC[IN_CBALL, dist, REAL_SUB_LZERO, ABS_NEG]);

val IN_SPHERE_0 = store_thm ("IN_SPHERE_0",
 ``!x e. x IN sphere(0,e) <=> (abs(x) = e)``,
  REWRITE_TAC[IN_SPHERE, dist, REAL_SUB_LZERO, ABS_NEG]);

val BALL_TRIVIAL = store_thm ("BALL_TRIVIAL",
 ``!x. ball(x,&0) = {}``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_SING, NOT_IN_EMPTY, dist] THEN REAL_ARITH_TAC);

val CBALL_TRIVIAL = store_thm ("CBALL_TRIVIAL",
 ``!x. cball(x,&0) = {x}``,
  REWRITE_TAC[EXTENSION, IN_CBALL, IN_SING, NOT_IN_EMPTY, dist] THEN REAL_ARITH_TAC);

val CENTRE_IN_CBALL = store_thm ("CENTRE_IN_CBALL",
 ``!x e. x IN cball(x,e) <=> &0 <= e``,
  MESON_TAC[IN_CBALL, DIST_REFL]);

val BALL_SUBSET_CBALL = store_thm ("BALL_SUBSET_CBALL",
 ``!x e. ball(x,e) SUBSET cball(x,e)``,
  REWRITE_TAC[IN_BALL, IN_CBALL, SUBSET_DEF] THEN REAL_ARITH_TAC);

val SPHERE_SUBSET_CBALL = store_thm ("SPHERE_SUBSET_CBALL",
 ``!x e. sphere(x,e) SUBSET cball(x,e)``,
  REWRITE_TAC[IN_SPHERE, IN_CBALL, SUBSET_DEF] THEN REAL_ARITH_TAC);

val SUBSET_BALL = store_thm ("SUBSET_BALL",
 ``!x d e. d <= e ==> ball(x,d) SUBSET ball(x,e)``,
  REWRITE_TAC[SUBSET_DEF, IN_BALL] THEN MESON_TAC[REAL_LTE_TRANS]);

val SUBSET_CBALL = store_thm ("SUBSET_CBALL",
 ``!x d e. d <= e ==> cball(x,d) SUBSET cball(x,e)``,
  REWRITE_TAC[SUBSET_DEF, IN_CBALL] THEN MESON_TAC[REAL_LE_TRANS]);

val BALL_MAX_UNION = store_thm ("BALL_MAX_UNION",
  ``!a r s. ball(a,max r s) = ball(a,r) UNION ball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_BALL, IN_UNION, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LT_MAX]);

val BALL_MIN_INTER = store_thm ("BALL_MIN_INTER",
  ``!a r s. ball(a,min r s) = ball(a,r) INTER ball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_BALL, IN_INTER, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LT_MIN]);

val CBALL_MAX_UNION = store_thm ("CBALL_MAX_UNION",
  ``!a r s. cball(a,max r s) = cball(a,r) UNION cball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_CBALL, IN_UNION, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LE_MAX]);

val CBALL_MIN_INTER = store_thm ("CBALL_MIN_INTER",
  ``!x d e. cball(x,min d e) = cball(x,d) INTER cball(x,e)``,
    rpt GEN_TAC
 >> REWRITE_TAC [EXTENSION, IN_INTER, IN_CBALL, dist]
 >> Q.X_GEN_TAC `a` >> Q.ABBREV_TAC `b = abs (x - a)`
 >> REWRITE_TAC [REAL_LE_MIN]);

val BALL_TRANSLATION = store_thm ("BALL_TRANSLATION",
 ``!a x r. ball(a + x,r) = IMAGE (\y. a + y) (ball(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_BALL, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val CBALL_TRANSLATION = store_thm ("CBALL_TRANSLATION",
 ``!a x r. cball(a + x,r) = IMAGE (\y. a + y) (cball(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_CBALL, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val SPHERE_TRANSLATION = store_thm ("SPHERE_TRANSLATION",
 ``!a x r. sphere(a + x,r) = IMAGE (\y. a + y) (sphere(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_SPHERE, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val BALL_LINEAR_IMAGE = store_thm ("BALL_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (ball(f x,r) = IMAGE f (ball(x,r)))``,
  REWRITE_TAC[ball] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val CBALL_LINEAR_IMAGE = store_thm ("CBALL_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (cball(f x,r) = IMAGE f (cball(x,r)))``,
  REWRITE_TAC[cball] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val SPHERE_LINEAR_IMAGE = store_thm ("SPHERE_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (sphere(f x,r) = IMAGE f (sphere(x,r)))``,
  REWRITE_TAC[sphere] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val BALL_SCALING = store_thm ("BALL_SCALING",
 ``!c. &0 < c ==> !x r. ball(c * x,c * r) = IMAGE (\x. c * x) (ball(x,r))``,
  REWRITE_TAC [IMAGE_DEF, IN_BALL] THEN BETA_TAC THEN
  SIMP_TAC std_ss [ball, EXTENSION, GSPECIFICATION, dist] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL [DISCH_TAC THEN
  EXISTS_TAC ``x' / c:real`` THEN
  FULL_SIMP_TAC std_ss [REAL_DIV_LMUL, REAL_POS_NZ] THEN
  KNOW_TAC `` abs (x - x' / c) < r <=> abs c * abs (x - x' / c) < c * r:real`` THENL
  [FULL_SIMP_TAC std_ss [abs, REAL_LT_IMP_LE, REAL_LT_LMUL], ALL_TAC] THEN
  DISC_RW_KILL THEN REWRITE_TAC [GSYM ABS_MUL] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_DIV_LMUL, REAL_POS_NZ],
  STRIP_TAC THEN FULL_SIMP_TAC std_ss [GSYM dist, DIST_MUL, abs,
                 REAL_LT_IMP_LE, REAL_LT_LMUL]]);

val CBALL_SCALING = store_thm ("CBALL_SCALING",
 ``!c. &0 < c ==> !x r. cball(c * x,c * r) = IMAGE (\x. c * x) (cball(x,r))``,
  REWRITE_TAC [IMAGE_DEF, IN_CBALL] THEN BETA_TAC THEN
  SIMP_TAC std_ss [cball, EXTENSION, GSPECIFICATION, dist] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL [DISCH_TAC THEN
  EXISTS_TAC ``x' / c:real`` THEN
  FULL_SIMP_TAC std_ss [REAL_DIV_LMUL, REAL_POS_NZ] THEN
  KNOW_TAC `` abs (x - x' / c) <= r <=> abs c * abs (x - x' / c) <= c * r:real`` THENL
  [FULL_SIMP_TAC std_ss [abs, REAL_LT_IMP_LE, REAL_LE_LMUL], ALL_TAC] THEN
  DISC_RW_KILL THEN REWRITE_TAC [GSYM ABS_MUL] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_DIV_LMUL, REAL_POS_NZ],
  STRIP_TAC THEN FULL_SIMP_TAC std_ss [GSYM dist, DIST_MUL, abs,
                 REAL_LT_IMP_LE, REAL_LE_LMUL]]);

val CBALL_DIFF_BALL = store_thm ("CBALL_DIFF_BALL",
 ``!a r. cball(a,r) DIFF ball(a,r) = sphere(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_DIFF, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val BALL_UNION_SPHERE = store_thm ("BALL_UNION_SPHERE",
 ``!a r. ball(a,r) UNION sphere(a,r) = cball(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_UNION, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val SPHERE_UNION_BALL = store_thm ("SPHERE_UNION_BALL",
 ``!a r. sphere(a,r) UNION ball(a,r)  = cball(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_UNION, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val CBALL_DIFF_SPHERE = store_thm ("CBALL_DIFF_SPHERE",
 ``!a r. cball(a,r) DIFF sphere(a,r) = ball(a,r)``,
  REWRITE_TAC[EXTENSION, IN_DIFF, IN_SPHERE, IN_BALL, IN_CBALL] THEN
  REAL_ARITH_TAC);

val OPEN_BALL = store_thm ("OPEN_BALL",
 ``!x e. open(ball(x,e))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_def, ball] THEN
  FULL_SIMP_TAC std_ss [GSPECIFICATION] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  MESON_TAC [REAL_SUB_LT, REAL_LT_SUB_LADD, REAL_ADD_SYM, REAL_LET_TRANS,
  DIST_TRIANGLE_ALT]);

val CENTRE_IN_BALL = store_thm ("CENTRE_IN_BALL",
 ``!x e. x IN ball(x,e) <=> &0 < e``,
  MESON_TAC[IN_BALL, DIST_REFL]);

val OPEN_CONTAINS_BALL = store_thm ("OPEN_CONTAINS_BALL",
 ``!s. open s <=> !x. x IN s ==> ?e. &0 < e /\ ball(x,e) SUBSET s``,
  REWRITE_TAC[open_def, SUBSET_DEF, IN_BALL] THEN SIMP_TAC std_ss [DIST_SYM]);

val OPEN_CONTAINS_BALL_EQ = store_thm ("OPEN_CONTAINS_BALL_EQ",
 ``!s. open s ==> (!x. x IN s <=> ?e. &0 < e /\ ball(x,e) SUBSET s)``,
  MESON_TAC[OPEN_CONTAINS_BALL, SUBSET_DEF, CENTRE_IN_BALL]);

val BALL_EQ_EMPTY = store_thm ("BALL_EQ_EMPTY",
 ``!x e. (ball(x,e) = {}) <=> e <= &0``,
  REWRITE_TAC[EXTENSION, IN_BALL, NOT_IN_EMPTY, REAL_NOT_LT] THEN
  MESON_TAC[DIST_POS_LE, REAL_LE_TRANS, DIST_REFL]);

val BALL_EMPTY = store_thm ("BALL_EMPTY",
 ``!x e. e <= &0 ==> (ball(x,e) = {})``,
  REWRITE_TAC[BALL_EQ_EMPTY]);

val OPEN_CONTAINS_CBALL = store_thm ("OPEN_CONTAINS_CBALL",
 ``!s. open s <=> !x. x IN s ==> ?e. &0 < e /\ cball(x,e) SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[OPEN_CONTAINS_BALL] THEN EQ_TAC THENL
   [ALL_TAC, ASM_MESON_TAC[SUBSET_TRANS, BALL_SUBSET_CBALL]] THEN
   KNOW_TAC ``!x. (x IN s ==> ?e. 0 < e /\ cball (x,e) SUBSET s) =
         (\x:real. x IN s ==> ?e. 0 < e /\ cball (x,e) SUBSET s) x`` THENL
   [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
   KNOW_TAC ``!x. (x IN s ==> ?e. 0 < e /\ ball (x,e) SUBSET s) =
         (\x:real. x IN s ==> ?e. 0 < e /\ ball (x,e) SUBSET s) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC MONO_ALL THEN GEN_TAC THEN BETA_TAC THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e / &2:real`` THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  SUBGOAL_THEN ``e / &2 < e:real`` (fn th => ASM_MESON_TAC[th, REAL_LET_TRANS]) THEN
  UNDISCH_TAC ``0 < e:real`` THEN SIMP_TAC arith_ss [REAL_LT_HALF2]);

val OPEN_CONTAINS_CBALL_EQ = store_thm ("OPEN_CONTAINS_CBALL_EQ",
 ``!s. open s ==> (!x. x IN s <=> ?e. &0 < e /\ cball(x,e) SUBSET s)``,
  MESON_TAC[OPEN_CONTAINS_CBALL, SUBSET_DEF, REAL_LT_IMP_LE, CENTRE_IN_CBALL]);

val SPHERE_EQ_EMPTY = store_thm ("SPHERE_EQ_EMPTY",
 ``!a:real r. (sphere(a,r) = {}) <=> r < &0``,
  SIMP_TAC std_ss [sphere, EXTENSION, GSPECIFICATION, NOT_IN_EMPTY] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [REAL_NOT_LT] THEN
  UNDISCH_TAC ``!x. dist (a,x) <> r`` THEN
  FULL_SIMP_TAC std_ss [REAL_LE_LT, dist] THENL
  [EXISTS_TAC ``a - r:real`` THEN POP_ASSUM MP_TAC THEN
  REAL_ARITH_TAC, EXISTS_TAC ``a:real`` THEN
  METIS_TAC [REAL_SUB_REFL, EQ_SYM_EQ, ABS_0]], DISCH_TAC THEN
  ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN CCONTR_TAC THEN
  UNDISCH_TAC ``r < 0:real`` THEN FULL_SIMP_TAC std_ss [REAL_NOT_LT, DIST_POS_LE]]);

val SPHERE_EMPTY = store_thm ("SPHERE_EMPTY",
 ``!a:real r. r < &0 ==> (sphere(a,r) = {})``,
  REWRITE_TAC[SPHERE_EQ_EMPTY]);

val NEGATIONS_BALL = store_thm ("NEGATIONS_BALL",
 ``!r. IMAGE (\x:real. -x) (ball(0:real,r)) = ball(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_BALL_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

val NEGATIONS_CBALL = store_thm ("NEGATIONS_CBALL",
 ``!r. IMAGE (\x. -x) (cball(0:real,r)) = cball(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_CBALL_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

val NEGATIONS_SPHERE = store_thm ("NEGATIONS_SPHERE",
 ``!r. IMAGE (\x. -x) (sphere(0:real,r)) = sphere(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_SPHERE_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

(* ------------------------------------------------------------------------- *)
(* Basic "localization" results are handy for connectedness.                 *)
(* ------------------------------------------------------------------------- *)

val OPEN_IN_OPEN = store_thm ("OPEN_IN_OPEN",
 ``!s:real->bool u.
        open_in (subtopology euclidean u) s <=> ?t. open t /\ (s = u INTER t)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY, GSYM OPEN_IN] THEN
  SIMP_TAC std_ss [INTER_ACI]);

val OPEN_IN_INTER_OPEN = store_thm ("OPEN_IN_INTER_OPEN",
 ``!s t u:real->bool.
        open_in (subtopology euclidean u) s /\ open t
        ==> open_in (subtopology euclidean u) (s INTER t)``,
  SIMP_TAC std_ss [OPEN_IN_OPEN] THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[INTER_ASSOC, OPEN_INTER]);

val OPEN_IN_OPEN_INTER = store_thm ("OPEN_IN_OPEN_INTER",
 ``!u s. open s ==> open_in (subtopology euclidean u) (u INTER s)``,
  REWRITE_TAC[OPEN_IN_OPEN] THEN MESON_TAC[]);

val OPEN_OPEN_IN_TRANS = store_thm ("OPEN_OPEN_IN_TRANS",
 ``!s t. open s /\ open t /\ t SUBSET s
         ==> open_in (subtopology euclidean s) t``,
  MESON_TAC[OPEN_IN_OPEN_INTER, SET_RULE ``(t:real->bool) SUBSET s ==> (t = s INTER t)``]);

val OPEN_SUBSET = store_thm ("OPEN_SUBSET",
 ``!s t:real->bool.
        s SUBSET t /\ open s ==> open_in (subtopology euclidean t) s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[OPEN_IN_OPEN] THEN
  EXISTS_TAC ``s:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CLOSED_IN_CLOSED = store_thm ("CLOSED_IN_CLOSED",
 ``!s:real->bool u.
    closed_in (subtopology euclidean u) s <=> ?t. closed t /\ (s = u INTER t)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [CLOSED_IN_SUBTOPOLOGY, GSYM CLOSED_IN] THEN
  SIMP_TAC std_ss [INTER_ACI]);

val CLOSED_SUBSET_EQ = store_thm ("CLOSED_SUBSET_EQ",
 ``!u s:real->bool.
        closed s ==> (closed_in (subtopology euclidean u) s <=> s SUBSET u)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
    REWRITE_TAC[CLOSED_IN_CLOSED] THEN EXISTS_TAC ``s:real->bool`` THEN
    REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CLOSED_IN_INTER_CLOSED = store_thm ("CLOSED_IN_INTER_CLOSED",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\ closed t
        ==> closed_in (subtopology euclidean u) (s INTER t)``,
  SIMP_TAC std_ss [CLOSED_IN_CLOSED] THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[INTER_ASSOC, CLOSED_INTER]);

val CLOSED_IN_CLOSED_INTER = store_thm ("CLOSED_IN_CLOSED_INTER",
 ``!u s. closed s ==> closed_in (subtopology euclidean u) (u INTER s)``,
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN MESON_TAC[]);

val CLOSED_SUBSET = store_thm ("CLOSED_SUBSET",
 ``!s t:real->bool.
        s SUBSET t /\ closed s ==> closed_in (subtopology euclidean t) s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``s:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val OPEN_IN_SUBSET_TRANS = store_thm ("OPEN_IN_SUBSET_TRANS",
 ``!s t u:real->bool.
        open_in (subtopology euclidean u) s /\ s SUBSET t /\ t SUBSET u
        ==> open_in (subtopology euclidean t) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_EXISTS_AND_THM] THEN
  SET_TAC[]);

val CLOSED_IN_SUBSET_TRANS = store_thm ("CLOSED_IN_SUBSET_TRANS",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\ s SUBSET t /\ t SUBSET u
        ==> closed_in (subtopology euclidean t) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [CLOSED_IN_CLOSED] THEN
  REPEAT STRIP_TAC THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val open_in = store_thm ("open_in",
 ``!u s:real->bool.
        open_in (subtopology euclidean u) s <=>
          s SUBSET u /\
          !x. x IN s ==> ?e. &0 < e /\
                             !x'. x' IN u /\ dist(x',x) < e ==> x' IN s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY, GSYM OPEN_IN] THEN EQ_TAC THENL
   [REWRITE_TAC[open_def] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[INTER_SUBSET, IN_INTER],
    ALL_TAC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN DISCH_TAC THEN
  FULL_SIMP_TAC std_ss [GSYM RIGHT_EXISTS_IMP_THM] THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN DISCH_THEN(X_CHOOSE_TAC ``d:real->real``) THEN
  EXISTS_TAC ``BIGUNION {b | ?x:real. (b = ball(x,d x)) /\ x IN s}`` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC OPEN_BIGUNION THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN METIS_TAC [LEFT_EXISTS_IMP_THM, OPEN_BALL],
    GEN_REWR_TAC I [EXTENSION] THEN
    SIMP_TAC std_ss [IN_INTER, IN_BIGUNION, GSPECIFICATION] THEN
    ASM_MESON_TAC[SUBSET_DEF, DIST_REFL, DIST_SYM, IN_BALL]]);

val OPEN_IN_CONTAINS_BALL = store_thm ("OPEN_IN_CONTAINS_BALL",
 ``!s t:real->bool.
        open_in (subtopology euclidean t) s <=>
        s SUBSET t /\
        !x. x IN s ==> ?e. &0 < e /\ ball(x,e) INTER t SUBSET s``,
  SIMP_TAC std_ss [open_in, INTER_DEF, SUBSET_DEF, GSPECIFICATION, IN_BALL] THEN
  MESON_TAC[DIST_SYM]);

val OPEN_IN_CONTAINS_CBALL = store_thm ("OPEN_IN_CONTAINS_CBALL",
 ``!s t:real->bool.
        open_in (subtopology euclidean t) s <=>
        s SUBSET t /\
        !x. x IN s ==> ?e. &0 < e /\ cball(x,e) INTER t SUBSET s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_CONTAINS_BALL] THEN
  AP_TERM_TAC THEN REWRITE_TAC[IN_BALL, IN_INTER, SUBSET_DEF, IN_CBALL] THEN
  MESON_TAC[METIS [REAL_LT_HALF1, REAL_LT_HALF2, REAL_LET_TRANS]
    ``&0 < e:real ==> &0 < e / &2 /\ (x <= e / &2 ==> x < e)``,
            REAL_LT_IMP_LE]);

(* ------------------------------------------------------------------------- *)
(* These "transitivity" results are handy too.                               *)
(* ------------------------------------------------------------------------- *)

val OPEN_IN_TRANS = store_thm ("OPEN_IN_TRANS",
 ``!s t u. open_in (subtopology euclidean t) s /\
           open_in (subtopology euclidean u) t
           ==> open_in (subtopology euclidean u) s``,
  ASM_MESON_TAC[OPEN_IN_OPEN, OPEN_IN, OPEN_INTER, INTER_ASSOC]);

val OPEN_IN_TRANS_EQ = store_thm ("OPEN_IN_TRANS_EQ",
 ``!s t:real->bool.
        (!u. open_in (subtopology euclidean t) u
             ==> open_in (subtopology euclidean s) t)
        <=> open_in (subtopology euclidean s) t``,
  MESON_TAC[OPEN_IN_TRANS, OPEN_IN_REFL]);

val OPEN_IN_OPEN_TRANS = store_thm ("OPEN_IN_OPEN_TRANS",
 ``!s t. open_in (subtopology euclidean t) s /\ open t ==> open s``,
  REWRITE_TAC[ONCE_REWRITE_RULE[GSYM SUBTOPOLOGY_UNIV] OPEN_IN] THEN
  REWRITE_TAC[OPEN_IN_TRANS]);

val CLOSED_IN_TRANS = store_thm ("CLOSED_IN_TRANS",
 ``!s t u. closed_in (subtopology euclidean t) s /\
           closed_in (subtopology euclidean u) t
           ==> closed_in (subtopology euclidean u) s``,
  ASM_MESON_TAC[CLOSED_IN_CLOSED, CLOSED_IN, CLOSED_INTER, INTER_ASSOC]);

val CLOSED_IN_TRANS_EQ = store_thm ("CLOSED_IN_TRANS_EQ",
 ``!s t:real->bool.
        (!u. closed_in (subtopology euclidean t) u
             ==> closed_in (subtopology euclidean s) t)
        <=> closed_in (subtopology euclidean s) t``,
  MESON_TAC[CLOSED_IN_TRANS, CLOSED_IN_REFL]);

val CLOSED_IN_CLOSED_TRANS = store_thm ("CLOSED_IN_CLOSED_TRANS",
 ``!s t. closed_in (subtopology euclidean t) s /\ closed t ==> closed s``,
  REWRITE_TAC[ONCE_REWRITE_RULE[GSYM SUBTOPOLOGY_UNIV] CLOSED_IN] THEN
  REWRITE_TAC[CLOSED_IN_TRANS]);

val OPEN_IN_SUBTOPOLOGY_INTER_SUBSET = store_thm ("OPEN_IN_SUBTOPOLOGY_INTER_SUBSET",
 ``!s u v. open_in (subtopology euclidean u) (u INTER s) /\ v SUBSET u
           ==> open_in (subtopology euclidean v) (v INTER s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [OPEN_IN_OPEN, GSYM LEFT_EXISTS_AND_THM] THEN
  STRIP_TAC THEN EXISTS_TAC ``t:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val OPEN_IN_OPEN_EQ = store_thm ("OPEN_IN_OPEN_EQ",
 ``!s t. open s
         ==> (open_in (subtopology euclidean s) t <=> open t /\ t SUBSET s)``,
  MESON_TAC[OPEN_OPEN_IN_TRANS, OPEN_IN_OPEN_TRANS, open_in]);

val CLOSED_IN_CLOSED_EQ = store_thm ("CLOSED_IN_CLOSED_EQ",
 ``!s t. closed s
         ==> (closed_in (subtopology euclidean s) t <=>
              closed t /\ t SUBSET s)``,
  MESON_TAC[CLOSED_SUBSET, CLOSED_IN_CLOSED_TRANS, closed_in,
            TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]);

(* ------------------------------------------------------------------------- *)
(* Line segments, with open/closed overloading of (a,b) and [a,b].           *)
(* ------------------------------------------------------------------------- *)

val closed_segment = new_definition ("closed_segment",
  ``closed_segment (l:(real#real)list) =
   {((&1:real) - u) * FST(HD l) + u * SND(HD l) | &0 <= u /\ u <= &1}``);

val open_segment = new_definition ("open_segment",
 ``open_segment(a,b) = closed_segment[a,b] DIFF {a;b}``);

val OPEN_SEGMENT_ALT = store_thm ("OPEN_SEGMENT_ALT",
 ``!a b:real.
        ~(a = b)
        ==> (open_segment(a,b) = {(&1 - u) * a + u * b | &0 < u /\ u < &1:real})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[open_segment, closed_segment, FST, SND, HD] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_INSERT, NOT_IN_EMPTY, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
  AP_TERM_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM] THEN
  X_GEN_TAC ``u:real`` THEN ASM_CASES_TAC ``x:real = (&1 - u) * a + u * b`` THEN
  ASM_REWRITE_TAC[REAL_LE_LT,
    REAL_ARITH ``((&1 - u) * a + u * b = a) <=> (u * (b - a) = 0:real)``,
    REAL_ARITH ``((&1 - u) * a + u * b = b) <=> ((&1 - u) * (b - a) = 0:real)``,
    REAL_ENTIRE, REAL_SUB_0] THEN UNDISCH_TAC ``a <> b:real`` THEN DISCH_TAC THEN
        POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN DISCH_TAC THEN
        ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC);

val _ = overload_on ("segment", ``open_segment``);
val _ = overload_on ("segment", ``closed_segment``);

val segment = store_thm ("segment",
 ``(segment[a,b] = {(&1 - u) * a + u * b | &0 <= u /\ u <= &1:real}) /\
   (segment(a,b) = segment[a,b] DIFF {a;b:real})``,
  REWRITE_TAC[open_segment, closed_segment, HD]);

val SEGMENT_REFL = store_thm ("SEGMENT_REFL",
 ``(!a. segment[a,a] = {a}) /\
   (!a. segment(a,a) = {})``,
  REWRITE_TAC[segment, REAL_ARITH ``(&1 - u) * a + u * a = a:real``] THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[REAL_POS]] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION] THEN REPEAT GEN_TAC THEN
  EQ_TAC THEN REWRITE_TAC [IN_SING] THENL [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN EXISTS_TAC ``1:real`` THEN REAL_ARITH_TAC);

val IN_SEGMENT = store_thm ("IN_SEGMENT",
 ``!a b x:real.
        ((x IN segment[a,b] <=>
         ?u. &0 <= u /\ u <= &1 /\ (x = (&1 - u) * a + u * b:real))) /\
        ((x IN segment(a,b) <=>
         ~(a = b) /\ ?u. &0 < u /\ u < &1 /\ (x = (&1 - u) * a + u * b:real)))``,
  REPEAT STRIP_TAC THENL
   [SIMP_TAC std_ss [segment, GSPECIFICATION, CONJ_ASSOC], ALL_TAC] THEN
  ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, NOT_IN_EMPTY] THEN
  ASM_SIMP_TAC std_ss [OPEN_SEGMENT_ALT, GSPECIFICATION, CONJ_ASSOC] THEN METIS_TAC []);

val SEGMENT_SYM = store_thm ("SEGMENT_SYM",
 ``(!a b:real. segment[a,b] = segment[b,a]) /\
   (!a b:real. segment(a,b) = segment(b,a))``,
  MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN
  SIMP_TAC std_ss [open_segment] THEN
  CONJ_TAC THENL [ALL_TAC, SIMP_TAC std_ss [INSERT_COMM, INSERT_INSERT]] THEN
  REWRITE_TAC[EXTENSION, IN_SEGMENT] THEN REPEAT GEN_TAC THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_TAC ``u:real``) THEN EXISTS_TAC ``&1 - u:real`` THEN
  ASM_REWRITE_TAC[] THEN
  REPEAT CONJ_TAC THEN TRY ASM_ARITH_TAC THEN ASM_REAL_ARITH_TAC);

val ENDS_IN_SEGMENT = store_thm ("ENDS_IN_SEGMENT",
 ``!a b. a IN segment[a,b] /\ b IN segment[a,b]``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [segment, GSPECIFICATION] THENL
   [EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1:real``] THEN
  (CONJ_TAC THENL [REAL_ARITH_TAC, REAL_ARITH_TAC]));

val ENDS_NOT_IN_SEGMENT =  store_thm ("ENDS_NOT_IN_SEGMENT",
 ``!a b. ~(a IN segment(a,b)) /\ ~(b IN segment(a,b))``,
  REWRITE_TAC[open_segment] THEN SET_TAC[]);

val SEGMENT_CLOSED_OPEN = store_thm ("SEGMENT_CLOSED_OPEN",
 ``!a b. segment[a,b] = segment(a,b) UNION {a;b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_segment] THEN MATCH_MP_TAC(SET_RULE
   ``a IN s /\ b IN s ==> (s = (s DIFF {a;b}) UNION {a;b})``) THEN
  REWRITE_TAC[ENDS_IN_SEGMENT]);

val SEGMENT_OPEN_SUBSET_CLOSED = store_thm ("SEGMENT_OPEN_SUBSET_CLOSED",
 ``!a b. segment(a,b) SUBSET segment[a,b]``,
  REWRITE_TAC[CONJUNCT2(SPEC_ALL segment)] THEN SET_TAC[]);

val MIDPOINT_IN_SEGMENT = store_thm ("MIDPOINT_IN_SEGMENT",
 ``(!a b:real. midpoint(a,b) IN segment[a,b]) /\
   (!a b:real. midpoint(a,b) IN segment(a,b) <=> ~(a = b))``,
  REWRITE_TAC[IN_SEGMENT] THEN REPEAT STRIP_TAC THENL
   [ALL_TAC, ASM_CASES_TAC ``a:real = b`` THEN ASM_REWRITE_TAC[]] THEN
  EXISTS_TAC ``&1 / &2:real`` THEN REWRITE_TAC[midpoint] THEN
  REWRITE_TAC [REAL_HALF_BETWEEN] THEN
  REWRITE_TAC [METIS [REAL_HALF_DOUBLE, REAL_EQ_SUB_RADD]
   ``1 - 1 / 2 = 1 / 2:real``] THEN REWRITE_TAC [GSYM REAL_LDISTRIB] THEN
   REWRITE_TAC [REAL_INV_1OVER]);

val BETWEEN_IN_SEGMENT = store_thm ("BETWEEN_IN_SEGMENT",
 ``!x a b:real. between x (a,b) <=> x IN segment[a,b]``,
  REPEAT GEN_TAC THEN REWRITE_TAC[between] THEN
  ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, IN_SING] THENL
  [REWRITE_TAC [dist] THEN REAL_ARITH_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [segment, GSPECIFICATION] THEN EQ_TAC THENL
   [DISCH_THEN(ASSUME_TAC o SYM) THEN
    EXISTS_TAC ``dist(a:real,x) / dist(a,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ, DIST_POS_LT] THEN CONJ_TAC
    THENL [FIRST_ASSUM(SUBST1_TAC o SYM) THEN
    ASM_REWRITE_TAC [dist] THEN REWRITE_TAC [REAL_SUB_RDISTRIB, REAL_MUL_LID] THEN
        ONCE_REWRITE_TAC [REAL_ARITH ``(x = a - y + z) = (y - z = a - x:real)``] THEN
        REWRITE_TAC [GSYM REAL_SUB_LDISTRIB] THEN KNOW_TAC ``(a - b:real) <> 0`` THENL
        [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN ASM_SIMP_TAC std_ss [GSYM ABS_DIV] THEN
        Cases_on `0 < a - b:real` THENL
        [ASM_SIMP_TAC std_ss [GSYM REAL_EQ_RDIV_EQ] THEN REWRITE_TAC [ABS_REFL] THEN
         ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_MUL_LZERO] THEN
         FULL_SIMP_TAC std_ss [dist] THEN ASM_REAL_ARITH_TAC,
         FULL_SIMP_TAC std_ss [REAL_NOT_LT, REAL_LE_LT] THENL
         [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
         POP_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_LT_NEG] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-0 = 0:real) /\ (-(a - b) = (b - a:real))``] THEN
         DISCH_TAC THEN ONCE_REWRITE_TAC [REAL_ARITH ``((a - b) = -(b - a:real))``] THEN
         ONCE_ASM_REWRITE_TAC [REAL_ARITH ``a * -b = -a * b:real``] THEN
         ASM_SIMP_TAC std_ss [GSYM REAL_EQ_RDIV_EQ] THEN REWRITE_TAC [real_div] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-a * b = -(a * b:real))``] THEN
         REWRITE_TAC [REAL_EQ_NEG] THEN KNOW_TAC ``(b - a:real) <> 0`` THENL
         [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN ASM_SIMP_TAC std_ss [GSYM REAL_NEG_INV] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-(a * b) = (a * -b:real))``] THEN
         FULL_SIMP_TAC std_ss [REAL_NEG_NEG, dist] THEN
         REWRITE_TAC [ABS_REFL, GSYM real_div] THEN
         ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_MUL_LZERO] THEN
         ASM_REAL_ARITH_TAC], ALL_TAC] THEN FULL_SIMP_TAC std_ss [dist] THEN
         ASM_REAL_ARITH_TAC, ALL_TAC] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[dist] THEN
    SIMP_TAC std_ss [REAL_ARITH ``a - ((&1 - u) * a + u * b) = u * (a - b:real)``,
                REAL_ARITH ``((&1 - u) * a + u * b) - b = (&1 - u) * (a - b:real)``,
                ABS_MUL, GSYM REAL_ADD_RDISTRIB] THEN
        FULL_SIMP_TAC std_ss [REAL_ARITH ``u <= 1 <=> 0 <= 1 - u:real``, GSYM ABS_REFL] THEN
        REAL_ARITH_TAC);

val REAL_CONVEX_BOUND_LE = store_thm ("REAL_CONVEX_BOUND_LE",
 ``!x y a u v. x <= a /\ y <= a /\ &0 <= u /\ &0 <= v /\ (u + v = &1:real)
   ==> u * x + v * y <= a:real``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``(u + v) * a:real`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SIMP_TAC std_ss [REAL_LE_REFL, REAL_MUL_LID]] THEN
  ASM_SIMP_TAC std_ss [REAL_ADD_RDISTRIB] THEN MATCH_MP_TAC REAL_LE_ADD2 THEN
  UNDISCH_TAC ``0 <= v:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN
  STRIP_TAC THEN UNDISCH_TAC ``0 <= u:real`` THEN
  GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN DISCH_TAC THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [REAL_LE_LT, REAL_MUL_LZERO]);

val IN_SEGMENT_COMPONENT = store_thm ("IN_SEGMENT_COMPONENT",
 ``!a b x:real i. x IN segment[a,b]
        ==> min (a) (b) <= x /\ x <= max (a) (b)``,
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IN_SEGMENT]) THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``t:real`` STRIP_ASSUME_TAC) THEN
  ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [REAL_ARITH ``c <= u * a + t * b <=> u * -a + t * -b <= -c:real``] THEN
  MATCH_MP_TAC REAL_CONVEX_BOUND_LE THEN
  RW_TAC real_ss [] THEN
  ASM_REAL_ARITH_TAC);

val SEGMENT_TRANSLATION = store_thm ("SEGMENT_TRANSLATION",
 ``(!c a b. segment[c + a,c + b] = IMAGE (\x. c + x) (segment[a,b])) /\
   (!c a b. segment(c + a,c + b) = IMAGE (\x. c + x) (segment(a,b)))``,
  SIMP_TAC std_ss [EXTENSION, IN_SEGMENT, IN_IMAGE] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(&1 - u) * (c + a) + u * (c + b) =
                            c + (&1 - u) * a + u * b:real``] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(c + a:real = c + b) <=> (a = b)``] THEN
  CONJ_TAC THEN
  (REPEAT GEN_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN EXISTS_TAC ``(1 - u) * a + u * b:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_ADD_ASSOC] THEN EXISTS_TAC ``u:real`` THEN
        ASM_SIMP_TAC std_ss [],
        REPEAT STRIP_TAC THEN EXISTS_TAC ``u:real`` THEN
        ASM_SIMP_TAC std_ss [REAL_ADD_ASSOC]]));

val CLOSED_SEGMENT_LINEAR_IMAGE = store_thm ("CLOSED_SEGMENT_LINEAR_IMAGE",
 ``!f a b. linear f
           ==> (segment[f a,f b] = IMAGE f (segment[a,b]))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[EXTENSION, IN_IMAGE, IN_SEGMENT] THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_CMUL th)]) THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_ADD th)]) THEN
  MESON_TAC[]);

val OPEN_SEGMENT_LINEAR_IMAGE = store_thm ("OPEN_SEGMENT_LINEAR_IMAGE",
 ``!f:real->real a b.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (segment(f a,f b) = IMAGE f (segment(a,b)))``,
  REWRITE_TAC[open_segment, closed_segment, FST, SND, HD] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION, IN_DIFF] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [EXISTS_TAC ``(1 - u) * a + u * b:real`` THEN
   CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
   CONJ_TAC THENL [EXISTS_TAC ``u:real`` THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
   ASM_SET_TAC [],
   CONJ_TAC THENL [EXISTS_TAC ``u:real`` THEN METIS_TAC [], ALL_TAC] THEN
   ASM_SET_TAC []]);

val IN_OPEN_SEGMENT = store_thm ("IN_OPEN_SEGMENT",
 ``!a b x:real.
        x IN segment(a,b) <=> x IN segment[a,b] /\ ~(x = a) /\ ~(x = b)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_segment, IN_DIFF] THEN SET_TAC[]);

val IN_OPEN_SEGMENT_ALT = store_thm ("IN_OPEN_SEGMENT_ALT",
 ``!a b x:real.
        x IN segment(a,b) <=>
        x IN segment[a,b] /\ ~(x = a) /\ ~(x = b) /\ ~(a = b)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, IN_SING, NOT_IN_EMPTY] THEN
  ASM_MESON_TAC[IN_OPEN_SEGMENT]);

val COLLINEAR_DIST_IN_CLOSED_SEGMENT = store_thm ("COLLINEAR_DIST_IN_CLOSED_SEGMENT",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)
           ==> x IN segment[a,b]``,
  REWRITE_TAC[GSYM BETWEEN_IN_SEGMENT, COLLINEAR_DIST_BETWEEN]);

val COLLINEAR_DIST_IN_OPEN_SEGMENT = store_thm ("COLLINEAR_DIST_IN_OPEN_SEGMENT",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b)
           ==> x IN segment(a,b)``,
  REWRITE_TAC[IN_OPEN_SEGMENT] THEN
  METIS_TAC[COLLINEAR_DIST_IN_CLOSED_SEGMENT, REAL_LT_LE, DIST_SYM]);

val DIST_IN_OPEN_CLOSED_SEGMENT = store_thm ("DIST_IN_OPEN_CLOSED_SEGMENT",
 ``(!a b x:real.
    x IN segment[a,b] ==> dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)) /\
   (!a b x:real.
    x IN segment(a,b) ==> dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b))``,
  SIMP_TAC std_ss [IN_SEGMENT, GSYM RIGHT_EXISTS_AND_THM, LEFT_IMP_EXISTS_THM, dist,
           REAL_ARITH
    ``(((&1 - u) * a + u * b) - a:real = u * (b - a)) /\
      (((&1 - u) * a + u * b) - b = -(&1 - u) * (b - a))``] THEN
  REWRITE_TAC[ABS_MUL, ABS_NEG] THEN ONCE_REWRITE_TAC [ABS_SUB] THEN CONJ_TAC THEN
  REPEAT GEN_TAC THEN STRIP_TAC THENL
   [ONCE_REWRITE_TAC [REAL_ARITH
     ``x * y <= abs (b - a) <=> x * y <= abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ARITH ``x * y <= y <=> x * y <= &1 * y:real``] THEN
    CONJ_TAC THEN MATCH_MP_TAC REAL_LE_RMUL_IMP THEN
    REWRITE_TAC[ABS_POS] THEN ASM_REAL_ARITH_TAC,
    ONCE_REWRITE_TAC [REAL_ARITH
     ``x * y < abs (b - a) <=> x * y < abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ARITH ``x * y < y <=> x * y < &1 * y:real``] THEN
    CONJ_TAC THEN MATCH_MP_TAC REAL_LT_RMUL_IMP THEN
    ASM_REAL_ARITH_TAC]);

val DIST_IN_CLOSED_SEGMENT = store_thm ("DIST_IN_CLOSED_SEGMENT",
  ``(!a b x:real.
    x IN segment[a,b] ==> dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b))``,
  REWRITE_TAC [DIST_IN_OPEN_CLOSED_SEGMENT]);

val DIST_IN_OPEN_SEGMENT = store_thm ("DIST_IN_OPEN_SEGMENT",
  ``(!a b x:real.
    x IN segment(a,b) ==> dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b))``,
  REWRITE_TAC [DIST_IN_OPEN_CLOSED_SEGMENT]);

(* ------------------------------------------------------------------------- *)
(* Connectedness.                                                            *)
(* ------------------------------------------------------------------------- *)

val connected = new_definition ("connected",
  ``connected s <=>
      ~(?e1 e2. open e1 /\ open e2 /\ s SUBSET (e1 UNION e2) /\
                (e1 INTER e2 INTER s = {}) /\
                ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))``);

val CONNECTED_CLOSED = store_thm ("CONNECTED_CLOSED",
 ``!s:real->bool.
        connected s <=>
        ~(?e1 e2. closed e1 /\ closed e2 /\ s SUBSET (e1 UNION e2) /\
                  (e1 INTER e2 INTER s = {}) /\
                  ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))``,
  GEN_TAC THEN REWRITE_TAC[connected] THEN AP_TERM_TAC THEN
  EQ_TAC THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC [``univ(:real) DIFF e1``, ``univ(:real) DIFF e2``] THEN
  ASM_REWRITE_TAC[GSYM closed_def, GSYM OPEN_CLOSED] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CONNECTED_OPEN_IN = store_thm ("CONNECTED_OPEN_IN",
 ``!s. connected s <=>
           ~(?e1 e2.
                 open_in (subtopology euclidean s) e1 /\
                 open_in (subtopology euclidean s) e2 /\
                 s SUBSET e1 UNION e2 /\
                 (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\
                 ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[connected, OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SET_TAC[]);

val CONNECTED_OPEN_IN_EQ = store_thm ("CONNECTED_OPEN_IN_EQ",
 ``!s. connected s <=>
           ~(?e1 e2.
                 open_in (subtopology euclidean s) e1 /\
                 open_in (subtopology euclidean s) e2 /\
                 (e1 UNION e2 = s) /\ (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\ ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_OPEN_IN] THEN
  AP_TERM_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[OPEN_IN_CLOSED_IN_EQ,
   TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]) THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CONNECTED_CLOSED_IN = store_thm ("CONNECTED_CLOSED_IN",
 ``!s. connected s <=>
           ~(?e1 e2.
                 closed_in (subtopology euclidean s) e1 /\
                 closed_in (subtopology euclidean s) e2 /\
                 s SUBSET e1 UNION e2 /\
                 (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\
                 ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_CLOSED, CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SET_TAC[]);

val CONNECTED_CLOSED_IN_EQ = store_thm ("CONNECTED_CLOSED_IN_EQ",
 ``!s. connected s <=>
           ~(?e1 e2.
                 closed_in (subtopology euclidean s) e1 /\
                 closed_in (subtopology euclidean s) e2 /\
                 (e1 UNION e2 = s) /\ (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\ ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_CLOSED_IN] THEN
  AP_TERM_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]) THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val EXISTS_DIFF = store_thm ("EXISTS_DIFF",
 ``(?s:'a->bool. P(UNIV DIFF s)) <=> (?s. P s)``,
  MESON_TAC[prove(``UNIV DIFF (UNIV DIFF s) = s``,SET_TAC[])]);

val CONNECTED_CLOPEN = store_thm ("CONNECTED_CLOPEN",
 ``!s. connected s <=>
        !t. open_in (subtopology euclidean s) t /\
            closed_in (subtopology euclidean s) t ==> (t = {}) \/ (t = s)``,
  GEN_TAC THEN REWRITE_TAC[connected, OPEN_IN_OPEN, CLOSED_IN_CLOSED] THEN
  REWRITE_TAC [METIS [GSYM EXISTS_DIFF] ``!e1. (?e2. open e2) <=>
                              ?e2. open (univ(:real) DIFF e2)``] THEN
  KNOW_TAC ``(?e1 e2. open e1 /\ open e2 /\ s SUBSET e1 UNION e2 /\
        (e1 INTER e2 INTER s = {}) /\ e1 INTER s <> {} /\
        e2 INTER s <> {}) <=>
             (?e1 e2. open e1 /\ open (univ(:real) DIFF e2) /\
                    s SUBSET e1 UNION (univ(:real) DIFF e2) /\
        (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
        (univ(:real) DIFF e2) INTER s <> {})`` THENL
  [EQ_TAC THENL [STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
   ASM_SIMP_TAC std_ss [EXISTS_DIFF] THEN METIS_TAC [],
   METIS_TAC [GSYM EXISTS_DIFF]], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `(~a <=> b) <=> (a <=> ~b)`] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, GSYM CONJ_ASSOC, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c /\ d <=> b /\ a /\ c /\ d`] THEN
  KNOW_TAC ``(?t. (?t'. closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
             (?t t'. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [GSYM closed_def] THEN
  KNOW_TAC ``((?e1 e2. closed e2 /\ open e1 /\ s SUBSET e1 UNION (univ(:real) DIFF e2) /\
       (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
       (univ(:real) DIFF e2) INTER s <> {}) <=> ?t t'. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
            ((?e2 e1. closed e2 /\ open e1 /\ s SUBSET e1 UNION (univ(:real) DIFF e2) /\
       (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
       (univ(:real) DIFF e2) INTER s <> {}) <=> ?t' t. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN AP_TERM_TAC THEN ABS_TAC THEN
  KNOW_TAC ``(?t. (closed e2 /\ (t = s INTER e2)) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
             (?t' t.(closed e2 /\ (t = s INTER e2)) /\
      (open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [METIS_TAC [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN AP_TERM_TAC THEN ABS_TAC THEN
  REWRITE_TAC[TAUT `(a /\ b) /\ (c /\ d) /\ e <=> a /\ c /\ b /\ d /\ e`] THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  AP_TERM_TAC THEN AP_TERM_TAC THEN SET_TAC[]);

val CONNECTED_CLOSED_SET = store_thm ("CONNECTED_CLOSED_SET",
 ``!s:real->bool.
        closed s
        ==> (connected s <=>
             ~(?e1 e2. closed e1 /\ closed e2 /\ ~(e1 = {}) /\ ~(e2 = {}) /\
                       (e1 UNION e2 = s) /\ (e1 INTER e2 = {})))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC [CONNECTED_CLOSED, GSYM MONO_NOT_EQ] THEN
    STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
    EXISTS_TAC ``e2:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    SIMP_TAC std_ss [] THEN SET_TAC[],
    REWRITE_TAC [CONNECTED_CLOSED_IN, GSYM MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [PULL_EXISTS] THEN
    SIMP_TAC std_ss [CLOSED_IN_CLOSED, LEFT_IMP_EXISTS_THM, GSYM AND_IMP_INTRO] THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s INTER u:real->bool``, ``s INTER v:real->bool``] THEN
    ASM_SIMP_TAC std_ss [CLOSED_INTER] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CONNECTED_OPEN_SET = store_thm ("CONNECTED_OPEN_SET",
 ``!s:real->bool.
        open s
        ==> (connected s <=>
             ~(?e1 e2. open e1 /\ open e2 /\ ~(e1 = {}) /\ ~(e2 = {}) /\
                       (e1 UNION e2 = s) /\ (e1 INTER e2 = {})))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[connected, GSYM MONO_NOT_EQ] THEN
    STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
    EXISTS_TAC ``e2:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    SIMP_TAC std_ss [] THEN SET_TAC[],
    REWRITE_TAC [CONNECTED_OPEN_IN, GSYM MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [PULL_EXISTS] THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_IMP_EXISTS_THM, GSYM AND_IMP_INTRO] THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s INTER u:real->bool``, ``s INTER v:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_INTER] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CONNECTED_IFF_CONNECTABLE_POINTS = store_thm ("CONNECTED_IFF_CONNECTABLE_POINTS",
 ``!s:real->bool.
        connected s <=>
        !a b. a IN s /\ b IN s
              ==> ?t. connected t /\ t SUBSET s /\ a IN t /\ b IN t``,
  GEN_TAC THEN EQ_TAC THENL [MESON_TAC[SUBSET_REFL], DISCH_TAC] THEN
  SIMP_TAC std_ss [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
                    ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
                      ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))``] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``a:real``) (X_CHOOSE_TAC ``b:real``)) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``a:real``, ``b:real``]) THEN
  ASM_REWRITE_TAC[connected] THEN
  DISCH_THEN(CHOOSE_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC)) THEN
  REWRITE_TAC[] THEN
  MAP_EVERY EXISTS_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  ASM_SET_TAC[]);

val CONNECTED_EMPTY = store_thm ("CONNECTED_EMPTY",
 ``connected {}``,
  REWRITE_TAC[connected, INTER_EMPTY]);

val CONNECTED_SING = store_thm ("CONNECTED_SING",
 ``!a. connected{a}``,
  REWRITE_TAC[connected] THEN SET_TAC[]);

val CONNECTED_REAL_LEMMA = store_thm ("CONNECTED_REAL_LEMMA",
 ``!f:real->real a b e1 e2.
        a <= b /\ f(a) IN e1 /\ f(b) IN e2 /\
        (!e x. a <= x /\ x <= b /\ &0 < e
               ==> ?d. &0 < d /\
                       !y. abs(y - x) < d ==> dist(f(y),f(x)) < e) /\
        (!y. y IN e1 ==> ?e. &0 < e /\ !y'. dist(y',y) < e ==> y' IN e1) /\
        (!y. y IN e2 ==> ?e. &0 < e /\ !y'. dist(y',y) < e ==> y' IN e2) /\
        ~(?x. a <= x /\ x <= b /\ f(x) IN e1 /\ f(x) IN e2)
        ==> ?x. a <= x /\ x <= b /\ ~(f(x) IN e1) /\ ~(f(x) IN e2)``,
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``\c. !x:real. a <= x /\ x <= c ==> (f(x):real) IN e1``
              REAL_COMPLETE) THEN
  SIMP_TAC std_ss [] THEN
  KNOW_TAC ``(?x:real. !x'. a <= x' /\ x' <= x ==> (f x'):real IN e1) /\
     (?M. !x. (!x'. a <= x' /\ x' <= x ==> f x' IN e1) ==> x <= M)`` THENL
  [METIS_TAC[REAL_LT_IMP_LE, REAL_LE_TOTAL, REAL_LE_ANTISYM],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN ``a <= x /\ x <= b:real`` STRIP_ASSUME_TAC THENL
  [METIS_TAC[REAL_LT_IMP_LE, REAL_LE_TOTAL, REAL_LE_ANTISYM], ALL_TAC] THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN ``!z:real. a <= z /\ z < x ==> (f(z):real) IN e1`` ASSUME_TAC THENL
   [METIS_TAC[REAL_NOT_LT, REAL_LT_IMP_LE], ALL_TAC] THEN
  REPEAT STRIP_TAC THENL
   [SUBGOAL_THEN
     ``?d:real. &0 < d /\ !y. abs(y - x) < d ==> (f(y):real) IN e1``
    STRIP_ASSUME_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    METIS_TAC[REAL_ARITH ``z <= x + e /\ e < d ==> z < x \/ abs(z - x) < d:real``,
                  REAL_ARITH ``&0 < e ==> ~(x + e <= x:real)``, REAL_DOWN],
    SUBGOAL_THEN
     ``?d:real. &0 < d /\ !y. abs(y - x) < d ==> (f(y):real) IN e2``
    STRIP_ASSUME_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    MP_TAC(SPECL [``x - a:real``, ``d:real``] REAL_DOWN2) THEN
    KNOW_TAC ``0 < x - a:real /\ 0 < d:real`` THENL
     [METIS_TAC[REAL_LT_LE, REAL_SUB_LT], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    METIS_TAC[REAL_ARITH ``e < x - a ==> a <= x - e:real``,
                  REAL_ARITH ``&0 < e /\ x <= b ==> x - e <= b:real``,
      REAL_ARITH ``&0 < e /\ e < d ==> x - e < x /\ abs((x - e) - x) < d:real``]]);

val CONNECTED_SEGMENT = store_thm ("CONNECTED_SEGMENT",
 ``(!a b:real. connected(segment[a,b])) /\
   (!a b:real. connected(segment(a,b)))``,
  CONJ_TAC THEN REPEAT GEN_TAC THENL
 [ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [SEGMENT_REFL, CONNECTED_EMPTY, CONNECTED_SING] THEN
  ASM_SIMP_TAC std_ss [connected, OPEN_SEGMENT_ALT, CONJUNCT1 segment,
               NOT_EXISTS_THM] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
   ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
     ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))`` ] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  PURE_ONCE_REWRITE_TAC[INTER_COMM] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REWRITE_TAC [IN_INTER] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, LEFT_IMP_EXISTS_THM] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``e2:real->bool``, ``e1:real->bool``, ``v:real``, ``u:real``] THEN
  KNOW_TAC ``!(u :real) (v :real). (\u v. !(e1 :real -> bool) (e2 :real -> bool).
      (e1 INTER e2 INTER
       {((1 :real) - u) * (a :real) + u * (b :real) |
        (0 :real) <= u /\ u <= (1 :real)} =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b |
       (0 :real) <= u /\ u <= (1 :real)} SUBSET e1 UNION e2 /\
      (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) <= u /\ u <= (1 :real) /\
      ((1 :real) - u) * a + u * b IN e1 ==>
      ~((0 :real) <= v) \/ ~(v <= (1 :real)) \/
      ((1 :real) - v) * a + v * b NOTIN e2) u v`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN BETA_TAC THEN
    GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV)
        [UNION_COMM, INTER_COMM] THEN
   KNOW_TAC ``(!(e1 :real -> bool) (e2 :real -> bool).
       (e1 INTER e2 INTER
        {((1 :real) - u) * (a :real) + u * (b :real) |
         (0 :real) <= u /\ u <= (1 :real)} =
        ({} :real -> bool)) /\
       {((1 :real) - u) * a + u * b |
        (0 :real) <= u /\ u <= (1 :real)} SUBSET e1 UNION e2 /\
       (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
       (0 :real) <= (u :real) /\ u <= (1 :real) /\
       ((1 :real) - u) * a + u * b IN e1 ==>
       ~((0 :real) <= (v :real)) \/ ~(v <= (1 :real)) \/
       ((1 :real) - v) * a + v * b NOTIN e2) <=>
    !(e2 :real -> bool) (e1 :real -> bool).
      ({((1 :real) - u) * a + u * b |
        (0 :real) <= u /\ u <= (1 :real)} INTER (e1 INTER e2) =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b |
       (0 :real) <= u /\ u <= (1 :real)} SUBSET e2 UNION e1 /\
      (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) <= v /\ v <= (1 :real) /\
      ((1 :real) - v) * a + v * b IN e1 ==>
      ~((0 :real) <= u) \/ ~(u <= (1 :real)) \/
      ((1 :real) - u) * a + u * b NOTIN e2`` THENL
        [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    SIMP_TAC std_ss [UNION_ACI, INTER_ACI] THEN METIS_TAC[],
    ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL
   [``\u. (&1 - u) * a + u * b:real``, ``u:real``, ``v:real``,
    ``e1:real->bool``, ``e2:real->bool``]
    CONNECTED_REAL_LEMMA) THEN BETA_TAC THEN
  ASM_REWRITE_TAC [GSYM open_def, REAL_POS, NOT_IMP] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``e:real``, ``x:real``] THEN STRIP_TAC THEN
    EXISTS_TAC ``e / dist(a:real,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, GSYM DIST_NZ] THEN
    GEN_TAC THEN REWRITE_TAC[dist] THEN STRIP_TAC THEN
    ASM_SIMP_TAC std_ss [ABS_MUL, GSYM REAL_LT_RDIV_EQ, GSYM ABS_NZ, REAL_SUB_0,
                 ABS_NEG, REAL_ARITH
     ``((&1 - y') * a + y' * b) - ((&1 - x') * a + x' * b):real =
       -((y' - x') * (a - b))``],
    RULE_ASSUM_TAC(SIMP_RULE std_ss [EXTENSION, IN_INTER, GSPECIFICATION,
                                SUBSET_DEF, IN_UNION, NOT_IN_EMPTY]) THEN
    METIS_TAC[REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]], ALL_TAC] THEN
  ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [SEGMENT_REFL, CONNECTED_EMPTY, CONNECTED_SING] THEN
  ASM_SIMP_TAC std_ss [connected, OPEN_SEGMENT_ALT, CONJUNCT1 segment,
               NOT_EXISTS_THM] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
   ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
     ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))`` ] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  PURE_ONCE_REWRITE_TAC[INTER_COMM] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REWRITE_TAC [IN_INTER] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, LEFT_IMP_EXISTS_THM] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``e2:real->bool``, ``e1:real->bool``, ``v:real``, ``u:real``] THEN
  KNOW_TAC ``!(u :real) (v :real). (\u v. !(e1 :real -> bool) (e2 :real -> bool).
      (e1 INTER e2 INTER
       {((1 :real) - u) * (a :real) + u * (b :real) |
        (0 :real) < u /\ u < (1 :real)} =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
      e1 UNION e2 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) < u /\ u < (1 :real) /\
      ((1 :real) - u) * a + u * b IN e1 ==>
      ~((0 :real) < v) \/ ~(v < (1 :real)) \/
      ((1 :real) - v) * a + v * b NOTIN e2) u v`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN BETA_TAC THEN
    GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV)
        [UNION_COMM, INTER_COMM] THEN
   KNOW_TAC `` (!(e1 :real -> bool) (e2 :real -> bool).
       (e1 INTER e2 INTER
        {((1 :real) - u) * (a :real) + u * (b :real) |
         (0 :real) < u /\ u < (1 :real)} =
        ({} :real -> bool)) /\
       {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
       e1 UNION e2 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
       (0 :real) < (u :real) /\ u < (1 :real) /\
       ((1 :real) - u) * a + u * b IN e1 ==>
       ~((0 :real) < (v :real)) \/ ~(v < (1 :real)) \/
       ((1 :real) - v) * a + v * b NOTIN e2) <=>
    !(e2 :real -> bool) (e1 :real -> bool).
      ({((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} INTER
       (e1 INTER e2) =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
      e2 UNION e1 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) < v /\ v < (1 :real) /\
      ((1 :real) - v) * a + v * b IN e1 ==>
      ~((0 :real) < u) \/ ~(u < (1 :real)) \/
      ((1 :real) - u) * a + u * b NOTIN e2`` THENL
        [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    SIMP_TAC std_ss [UNION_ACI, INTER_ACI] THEN METIS_TAC[],
    ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL
   [``\u. (&1 - u) * a + u * b:real``, ``u:real``, ``v:real``,
    ``e1:real->bool``, ``e2:real->bool``]
    CONNECTED_REAL_LEMMA) THEN BETA_TAC THEN
  ASM_REWRITE_TAC [GSYM open_def, REAL_POS, NOT_IMP] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``e:real``, ``x:real``] THEN STRIP_TAC THEN
    EXISTS_TAC ``e / dist(a:real,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, GSYM DIST_NZ] THEN
    GEN_TAC THEN REWRITE_TAC[dist] THEN STRIP_TAC THEN
    ASM_SIMP_TAC std_ss [ABS_MUL, GSYM REAL_LT_RDIV_EQ, GSYM ABS_NZ, REAL_SUB_0,
                 ABS_NEG, REAL_ARITH
     ``((&1 - y') * a + y' * b) - ((&1 - x') * a + x' * b):real =
       -((y' - x') * (a - b))``],
    RULE_ASSUM_TAC(SIMP_RULE std_ss [EXTENSION, IN_INTER, GSPECIFICATION,
                                SUBSET_DEF, IN_UNION, NOT_IN_EMPTY]) THEN
    METIS_TAC[REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]]);

val CONNECTED_UNIV = store_thm ("CONNECTED_UNIV",
 ``connected univ(:real)``,
  ONCE_REWRITE_TAC[CONNECTED_IFF_CONNECTABLE_POINTS] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN
  REWRITE_TAC[IN_UNIV, SUBSET_UNIV] THEN
  EXISTS_TAC ``segment[a:real,b]`` THEN
  ASM_SIMP_TAC std_ss [CONNECTED_SEGMENT, ENDS_IN_SEGMENT]);

val CLOPEN = store_thm ("CLOPEN",
 ``!s. closed s /\ open s <=> (s = {}) \/ (s = univ(:real))``,
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY, OPEN_EMPTY, CLOSED_UNIV, OPEN_UNIV] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONNECTED_CLOPEN] CONNECTED_UNIV) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_UNIV, GSYM OPEN_IN, GSYM CLOSED_IN]);

val CONNECTED_BIGUNION = store_thm ("CONNECTED_BIGUNION",
 ``!P:(real->bool)->bool.
        (!s. s IN P ==> connected s) /\ ~(BIGINTER P = {})
        ==> connected(BIGUNION P)``,
  GEN_TAC THEN REWRITE_TAC[connected] THEN STRIP_TAC THEN
  CCONTR_TAC THEN POP_ASSUM (MP_TAC o REWRITE_RULE [REAL_NEG_NEG]) THEN
  STRIP_TAC THEN UNDISCH_TAC ``~(BIGINTER P :real->bool = {})`` THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_BIGINTER] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``(a:real) IN e1 \/ a IN e2`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[],
    UNDISCH_TAC ``~(e2 INTER BIGUNION P:real->bool = {})``,
    UNDISCH_TAC ``~(e1 INTER BIGUNION P:real->bool = {})``] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER, IN_BIGUNION] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real``
   (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!t:real->bool. t IN P ==> a IN t`` THEN
  DISCH_THEN(MP_TAC o SPEC ``s:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``s:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM (MP_TAC o SPECL [``e1:real->bool``, ``e2:real->bool``]) THEN
  ASM_SET_TAC[]);

val CONNECTED_UNION = store_thm ("CONNECTED_UNION",
 ``!s t:real->bool.
        connected s /\ connected t /\ ~(s INTER t = {})
        ==> connected (s UNION t)``,
  REWRITE_TAC[GSYM BIGUNION_2, GSYM BIGINTER_2] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN
  ASM_SET_TAC[]);

val CONNECTED_DIFF_OPEN_FROM_CLOSED = store_thm ("CONNECTED_DIFF_OPEN_FROM_CLOSED",
 ``!s t u:real->bool.
        s SUBSET t /\ t SUBSET u /\
        open s /\ closed t /\ connected u /\ connected(t DIFF s)
        ==> connected(u DIFF s)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``v:real->bool``, ``w:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``connected(t DIFF s:real->bool)`` THEN SIMP_TAC std_ss [connected] THEN
  MAP_EVERY EXISTS_TAC [``v:real->bool``, ``w:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC  THENL [ASM_SET_TAC [], ALL_TAC] THEN
  CONJ_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t)) [``v:real->bool``, ``w:real->bool``] THEN
  KNOW_TAC ``(!v:real->bool w:real->bool.
      ~(w INTER (u DIFF s) = {}) /\ ~(v INTER (u DIFF s) = {}) /\
      (v INTER w INTER (u DIFF s) = {}) /\ u DIFF s SUBSET v UNION w /\
      open w /\ open v /\ connected u /\ closed t /\ open s /\
      t SUBSET u /\ s SUBSET t
      ==> ~(v INTER (u DIFF s) = {}) /\ ~(w INTER (u DIFF s) = {}) /\
          (w INTER v INTER (u DIFF s) = {}) /\ u DIFF s SUBSET w UNION v /\
          open v /\ open w /\ connected u /\ closed t /\ open s /\
          t SUBSET u /\ s SUBSET t) /\
 (!w v. (~(w INTER (u DIFF s) = {}) /\ ~(v INTER (u DIFF s) = {}) /\
       (v INTER w INTER (u DIFF s) = {}) /\ u DIFF s SUBSET v UNION w /\
       open w /\ open v /\ connected u /\ closed t /\ open s /\
       t SUBSET u /\ s SUBSET t) /\ (w INTER (t DIFF s) = {})
      ==> F)`` THENL
  [CONJ_TAC THENL [SIMP_TAC std_ss [CONJ_ACI, INTER_ACI, UNION_ACI], ALL_TAC] THEN
  REPEAT STRIP_TAC THEN UNDISCH_TAC ``connected u`` THEN
  GEN_REWR_TAC LAND_CONV [connected] THEN SIMP_TAC std_ss [] THEN
  MAP_EVERY EXISTS_TAC [``v UNION s:real->bool``, ``w DIFF t:real->bool``] THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION, OPEN_DIFF] THEN ASM_SET_TAC[], METIS_TAC []]);

val CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE = store_thm
  ("CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE",
 ``!f:(real->bool)->bool f'.
         pairwise DISJOINT f /\ pairwise DISJOINT f' /\
        (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
        (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
        (BIGUNION f = BIGUNION f')
        ==> (f = f')``,
  GEN_REWR_TAC (funpow 2 BINDER_CONV o RAND_CONV) [EXTENSION] THEN
  KNOW_TAC ``(!f f'.
      pairwise DISJOINT f /\ pairwise DISJOINT f' /\
      (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
      (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
      (BIGUNION f = BIGUNION f')
      ==> pairwise DISJOINT f' /\ pairwise DISJOINT f /\
          (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
          (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
          (BIGUNION f' = BIGUNION f)) /\
 (!f f' x. (pairwise DISJOINT f /\ pairwise DISJOINT f' /\
       (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
       (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
       (BIGUNION f = BIGUNION f')) /\ x IN f ==> x IN f')`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  GEN_TAC THEN GEN_TAC THEN X_GEN_TAC ``s:real->bool`` THEN STRIP_TAC THEN
  SUBGOAL_THEN
   ``?t a:real. t IN f' /\ a IN s /\ a IN t`` STRIP_ASSUME_TAC
  THENL [ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``s:real->bool = t`` (fn th => ASM_REWRITE_TAC[th]) THEN
  REWRITE_TAC[EXTENSION] THEN POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``s:real->bool``, ``t:real->bool``,
    ``f:(real->bool)->bool``, ``f':(real->bool)->bool``] THEN
  KNOW_TAC ``(!f f' s t.
      a IN t /\ a IN s /\ t IN f' /\ s IN f /\
      (BIGUNION f = BIGUNION f') /\
      (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
      (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
      pairwise DISJOINT f' /\ pairwise DISJOINT f
      ==> a IN s /\ a IN t /\ s IN f /\ t IN f' /\
          (BIGUNION f' = BIGUNION f) /\
          (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
          (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
          pairwise DISJOINT f /\ pairwise DISJOINT f') /\
 (!f f' s t x.
      (a IN t /\ a IN s /\ t IN f' /\ s IN f /\
       (BIGUNION f = BIGUNION f') /\
       (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
       (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
       pairwise DISJOINT f' /\ pairwise DISJOINT f) /\
      x IN s ==> x IN t)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  X_GEN_TAC ``b:real`` THEN STRIP_TAC THEN
  UNDISCH_TAC
   ``!s:real->bool. s IN f ==> open s /\ connected s /\ ~(s = {})`` THEN
  DISCH_THEN(MP_TAC o SPEC ``s:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN ASM_CASES_TAC ``(b:real) IN t`` THEN
  ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``connected(s:real->bool)`` THEN
  REWRITE_TAC[connected] THEN
  MAP_EVERY EXISTS_TAC
   [``t:real->bool``, ``BIGUNION(f' DELETE (t:real->bool))``] THEN
  REPEAT STRIP_TAC THENL
   [ASM_SIMP_TAC std_ss [],
    MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SIMP_TAC std_ss [IN_DELETE],
    REWRITE_TAC[GSYM BIGUNION_INSERT] THEN ASM_SET_TAC[],
    MATCH_MP_TAC(SET_RULE ``(t INTER u = {}) ==> (t INTER u INTER s = {})``) THEN
    SIMP_TAC std_ss [INTER_BIGUNION, EMPTY_BIGUNION, FORALL_IN_GSPEC] THEN
    REWRITE_TAC [IN_DELETE, GSYM DISJOINT_DEF] THEN ASM_MESON_TAC[pairwise],
    ASM_SET_TAC[], ASM_SET_TAC[]]);

val CONNECTED_FROM_CLOSED_UNION_AND_INTER = store_thm ("CONNECTED_FROM_CLOSED_UNION_AND_INTER",
 ``!s t:real->bool.
        closed s /\ closed t /\ connected(s UNION t) /\ connected(s INTER t)
        ==> connected s /\ connected t``,
  KNOW_TAC ``(!s t. closed s /\ closed t /\
       connected (s UNION t) /\ connected (s INTER t)
      ==> closed t /\ closed s /\ connected (t UNION s) /\
          connected (t INTER s)) /\
 (!s t. closed s /\ closed t /\ connected (s UNION t) /\
        connected (s INTER t) ==> connected s)`` THENL
  [ALL_TAC, MESON_TAC []] THEN
  CONJ_TAC THENL [SIMP_TAC std_ss [UNION_COMM, INTER_COMM], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_CLOSED_SET] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  ASM_CASES_TAC
   ``~(s INTER t SUBSET (u:real->bool)) /\ ~(s INTER t SUBSET v)``
  THENL
   [UNDISCH_TAC ``connected(s INTER t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CLOSED] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC [],
    POP_ASSUM (MP_TAC o REWRITE_RULE [DE_MORGAN_THM]) THEN
    STRIP_TAC THEN UNDISCH_TAC ``connected(s UNION t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CLOSED] THENL
     [MAP_EVERY EXISTS_TAC [``t UNION u:real->bool``, ``v:real->bool``] THEN
      ASM_SIMP_TAC std_ss [CLOSED_UNION] THEN ASM_SET_TAC[],
      MAP_EVERY EXISTS_TAC [``t UNION v:real->bool``, ``u:real->bool``] THEN
      ASM_SIMP_TAC std_ss [CLOSED_UNION] THEN ASM_SET_TAC[]]]);

val CONNECTED_FROM_OPEN_UNION_AND_INTER = store_thm ("CONNECTED_FROM_OPEN_UNION_AND_INTER",
 ``!s t:real->bool.
        open s /\ open t /\ connected(s UNION t) /\ connected(s INTER t)
        ==> connected s /\ connected t``,

  KNOW_TAC ``(!s t.
      open s /\ open t /\ connected (s UNION t) /\ connected (s INTER t)
      ==> open t /\ open s /\ connected (t UNION s) /\ connected (t INTER s)) /\
 (!s t.
      open s /\ open t /\ connected (s UNION t) /\ connected (s INTER t)
      ==> connected s)`` THENL
  [ALL_TAC, MESON_TAC []] THEN
  CONJ_TAC THENL [SIMP_TAC std_ss [UNION_COMM, INTER_COMM], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_OPEN_SET] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN ASM_CASES_TAC
   ``~(s INTER t SUBSET (u:real->bool)) /\ ~(s INTER t SUBSET v)``
  THENL
   [UNDISCH_TAC ``connected(s INTER t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [connected] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
    POP_ASSUM (MP_TAC o REWRITE_RULE [DE_MORGAN_THM]) THEN
    STRIP_TAC THEN UNDISCH_TAC ``connected(s UNION t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [connected] THENL
     [MAP_EVERY EXISTS_TAC [``t UNION u:real->bool``, ``v:real->bool``] THEN
      ASM_SIMP_TAC std_ss [OPEN_UNION] THEN ASM_SET_TAC[],
      MAP_EVERY EXISTS_TAC [``t UNION v:real->bool``, ``u:real->bool``] THEN
      ASM_SIMP_TAC std_ss [OPEN_UNION] THEN ASM_SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Sort of induction principle for connected sets.                           *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_INDUCTION = store_thm ("CONNECTED_INDUCTION",
 ``!P Q s:real->bool. connected s /\
     (!t a. open_in (subtopology euclidean s) t /\ a IN t
     ==> ?z. z IN t /\ P z) /\ (!a. a IN s
       ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
       !x y. x IN t /\ y IN t /\ P x /\ P y /\ Q x ==> Q y)
          ==> !a b. a IN s /\ b IN s /\ P a /\ P b /\ Q a ==> Q b``,
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC I [TAUT `p <=> ~ ~p`] THEN DISCH_TAC THEN
  UNDISCH_TAC ``connected s`` THEN GEN_REWR_TAC LAND_CONV [CONNECTED_OPEN_IN] THEN
  REWRITE_TAC[] THEN MAP_EVERY EXISTS_TAC
  [``{b:real | ?t. open_in (subtopology euclidean s) t /\
                   b IN t /\ !x. x IN t /\ P x ==> Q x}``,
   ``{b:real | ?t. open_in (subtopology euclidean s) t /\
                 b IN t /\ !x. x IN t /\ P x ==> ~(Q x)}``]   THEN
  REPEAT CONJ_TAC THENL
  [ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
   X_GEN_TAC ``c:real`` THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
   ASM_SET_TAC[],
   ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
   X_GEN_TAC ``c:real`` THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNION] THEN
   X_GEN_TAC ``c:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``c:real``) THEN ASM_SET_TAC[],
   KNOW_TAC ``!x. ~((?t. open_in (subtopology euclidean s) t /\
            x IN t /\ (!x. x IN t /\ P x ==> Q x)) /\
       (?t. open_in (subtopology euclidean s) t /\ x IN t /\
            (!x. x IN t /\ P x ==> ~Q x)))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [EXTENSION, IN_INTER, NOT_IN_EMPTY, GSPECIFICATION]] THEN
   X_GEN_TAC ``c:real`` THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC)) THEN
   FIRST_X_ASSUM(MP_TAC o SPECL [``t INTER u:real->bool``, ``c:real``]) THEN
   ASM_SIMP_TAC std_ss [OPEN_IN_INTER] THEN ASM_SET_TAC[],
   ASM_SET_TAC[], ASM_SET_TAC[]]);

val CONNECTED_EQUIVALENCE_RELATION_GEN = store_thm ("CONNECTED_EQUIVALENCE_RELATION_GEN",
 ``!P R s:real->bool. connected s /\ (!x y. R x y ==> R y x) /\
     (!x y z. R x y /\ R y z ==> R x z) /\
     (!t a. open_in (subtopology euclidean s) t /\ a IN t
    ==> ?z. z IN t /\ P z) /\ (!a. a IN s
      ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x y. x IN t /\ y IN t /\ P x /\ P y ==> R x y)
        ==> !a b. a IN s /\ b IN s /\ P a /\ P b ==> R a b``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN
  ``!a:real. a IN s /\ P a
  ==> !b c. b IN s /\ c IN s /\ P b /\ P c /\ R a b ==> R a c``
  MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[]] THEN
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC CONNECTED_INDUCTION THEN
  ASM_REWRITE_TAC [] THEN
  X_GEN_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `b:real`) THEN
  METIS_TAC[]);

val CONNECTED_INDUCTION_SIMPLE = store_thm ("CONNECTED_INDUCTION_SIMPLE",
 ``!P s:real->bool. connected s /\
    (!a. a IN s
    ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x y. x IN t /\ y IN t /\ P x ==> P y)
      ==> !a b. a IN s /\ b IN s /\ P a ==> P b``,
  MP_TAC(ISPEC ``\x:real. T`` CONNECTED_INDUCTION) THEN
  REWRITE_TAC[] THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``Q:real->bool``, ``s:real->bool``] THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`Q:real->bool`, `s:real->bool`]) THEN
  METIS_TAC[]);

val CONNECTED_EQUIVALENCE_RELATION = store_thm ("CONNECTED_EQUIVALENCE_RELATION",
 ``!R s:real->bool. connected s /\
     (!x y. R x y ==> R y x) /\
     (!x y z. R x y /\ R y z ==> R x z) /\
     (!a. a IN s
     ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x. x IN t ==> R a x)
      ==> !a b. a IN s /\ b IN s ==> R a b``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN
  ``!a:real. a IN s ==> !b c. b IN s /\ c IN s /\ R a b ==> R a c``
  MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[]] THEN
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC CONNECTED_INDUCTION_SIMPLE THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Limit points.                                                             *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "limit_point_of" (Infix(NONASSOC, 450));

val limit_point_of = new_definition ("limit_point_of",
 ``x limit_point_of s <=>
        !t. x IN t /\ open t ==> ?y. ~(y = x) /\ y IN s /\ y IN t``);

val LIMPT_SUBSET = store_thm ("LIMPT_SUBSET",
 ``!x s t. x limit_point_of s /\ s SUBSET t ==> x limit_point_of t``,
  REWRITE_TAC[limit_point_of, SUBSET_DEF] THEN MESON_TAC[]);

val LIMPT_APPROACHABLE = store_thm ("LIMPT_APPROACHABLE",
 ``!x s. x limit_point_of s <=>
                !e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ dist(x',x) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[limit_point_of] THEN
  MESON_TAC[open_def, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL, IN_BALL]);

val lemma = prove (
 ``&0 < d:real ==> x <= d / &2 ==> x < d``,
 SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LT] THEN REAL_ARITH_TAC);

val APPROACHABLE_LT_LE = store_thm ("APPROACHABLE_LT_LE",
 ``!P f. (?d:real. &0 < d /\ !x. f(x) < d ==> P x) =
         (?d:real. &0 < d /\ !x. f(x) <= d ==> P x)``,
  MESON_TAC[REAL_LT_IMP_LE, lemma, REAL_LT_HALF1]);

val LIMPT_APPROACHABLE_LE = store_thm ("LIMPT_APPROACHABLE_LE",
 ``!x s. x limit_point_of s <=>
                !e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ dist(x',x) <= e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  MATCH_MP_TAC(TAUT `(~a <=> ~b) ==> (a <=> b)`) THEN
  KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e) <=>
            (\e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e)) e`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) <= e) <=>
            (\e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) <= e)) e `` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [NOT_FORALL_THM] THEN BETA_TAC THEN REWRITE_TAC [NOT_IMP] THEN
  KNOW_TAC ``!x'' x'. ( x'' IN s /\ x'' <> x /\ dist (x'',x) < x') <=>
            (\x''. x'' IN s /\ x'' <> x /\ dist (x'',x) < x') x''`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!x'' x'. ( x'' IN s /\ x'' <> x /\ dist (x'',x) <= x') <=>
            (\x''. x'' IN s /\ x'' <> x /\ dist (x'',x) <= x') x''`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [NOT_EXISTS_THM] THEN BETA_TAC THEN
  SIMP_TAC std_ss [TAUT `~(a /\ b /\ c) <=> c ==> ~(a /\ b)`, APPROACHABLE_LT_LE]);

val REAL_CHOOSE_SIZE = store_thm ("REAL_CHOOSE_SIZE",
 ``!c. &0 <= c ==> (?x. abs x = c:real)``,
  METIS_TAC [ABS_REFL]);

val LIMPT_UNIV = store_thm ("LIMPT_UNIV",
 ``!x:real. x limit_point_of UNIV``,
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNIV] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?c:real. abs(c) = e / &2`` CHOOSE_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_CHOOSE_SIZE, REAL_LT_HALF1, REAL_LT_IMP_LE],
    ALL_TAC] THEN
  EXISTS_TAC ``x + c:real`` THEN
  REWRITE_TAC[dist, REAL_ADD_RID_UNIQ] THEN ASM_REWRITE_TAC[REAL_ADD_SUB] THEN
  ASM_REWRITE_TAC [REAL_LT_HALF2] THEN KNOW_TAC ``0 < abs c:real`` THENL
  [ASM_SIMP_TAC std_ss [REAL_LT_HALF1], METIS_TAC [ABS_NZ]]);

val CLOSED_LIMPT = store_thm ("CLOSED_LIMPT",
 ``!s. closed s <=> !x. x limit_point_of s ==> x IN s``,
  REWRITE_TAC[closed_def] THEN ONCE_REWRITE_TAC[OPEN_SUB_OPEN] THEN
  REWRITE_TAC[limit_point_of, IN_DIFF, IN_UNIV, SUBSET_DEF] THEN MESON_TAC[]);

val LIMPT_EMPTY = store_thm ("LIMPT_EMPTY",
 ``!x. ~(x limit_point_of {})``,
  REWRITE_TAC[LIMPT_APPROACHABLE, NOT_IN_EMPTY] THEN MESON_TAC[REAL_LT_01]);

val NO_LIMIT_POINT_IMP_CLOSED = store_thm ("NO_LIMIT_POINT_IMP_CLOSED",
 ``!s. ~(?x. x limit_point_of s) ==> closed s``,
  MESON_TAC[CLOSED_LIMPT]);

val CLOSED_POSITIVE_ORTHANT = store_thm ("CLOSED_POSITIVE_ORTHANT",
 ``closed {x:real | &0 <= x}``,
  REWRITE_TAC[CLOSED_LIMPT, LIMPT_APPROACHABLE] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``-(x:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RNEG, REAL_ADD_LID, NOT_EXISTS_THM] THEN
  X_GEN_TAC ``y:real`` THEN ONCE_REWRITE_TAC [METIS []``(a = b) <=> ~(a <> b:real)``] THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM] THEN
  MATCH_MP_TAC(TAUT `(a ==> ~c) ==> ~(a /\ b /\ c)`) THEN DISCH_TAC THEN
  MATCH_MP_TAC(REAL_ARITH ``!b. abs x <= b /\ b <= a ==> ~(a + x < &0:real)``) THEN
  EXISTS_TAC ``abs(y - x :real)`` THEN ASM_SIMP_TAC std_ss [dist, REAL_LE_REFL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``x < &0 /\ &0 <= y:real ==> abs(x) <= abs(y - x)``]);

val FINITE_SET_AVOID = store_thm ("FINITE_SET_AVOID",
 ``!a:real s. FINITE s
   ==> ?d. &0 < d /\ !x. x IN s /\ ~(x = a) ==> d <= dist(a,x)``,
  GEN_TAC THEN
  KNOW_TAC ``!s. (?d. 0 < d /\ !x:real. x IN s /\ x <> a ==> d <= dist (a,x)) <=>
             (\s. ?d. 0 < d /\ !x:real. x IN s /\ x <> a ==> d <= dist (a,x)) s `` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[NOT_IN_EMPTY] THEN
  CONJ_TAC THENL [MESON_TAC[REAL_LT_01], ALL_TAC] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``x:real``] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN DISCH_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``x:real = a`` THEN REWRITE_TAC[IN_INSERT] THENL
  [ASM_MESON_TAC[], ALL_TAC] THEN
  EXISTS_TAC ``min d (dist(a:real,x))`` THEN
  ASM_REWRITE_TAC[REAL_LT_MIN, GSYM DIST_NZ, REAL_MIN_LE] THEN
  ASM_MESON_TAC[REAL_LE_REFL]);

val LIMIT_POINT_FINITE = store_thm ("LIMIT_POINT_FINITE",
 ``!s a. FINITE s ==> ~(a limit_point_of s)``,
  REWRITE_TAC[LIMPT_APPROACHABLE, GSYM REAL_NOT_LE] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM, REAL_NOT_LE,
   REAL_NOT_LT, TAUT `~(a /\ b /\ c) <=> a /\ b ==> ~c`] THEN
  MESON_TAC[FINITE_SET_AVOID, DIST_SYM]);

val LIMPT_SING = store_thm ("LIMPT_SING",
 ``!x y:real. ~(x limit_point_of {y})``,
  SIMP_TAC std_ss [LIMIT_POINT_FINITE, FINITE_SING]);

val LIMIT_POINT_UNION = store_thm ("LIMIT_POINT_UNION",
 ``!s t x:real. x limit_point_of (s UNION t) <=>
                x limit_point_of s \/ x limit_point_of t``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
  [ALL_TAC, MESON_TAC[LIMPT_SUBSET, SUBSET_UNION]] THEN
  REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNION] THEN DISCH_TAC THEN
  MATCH_MP_TAC(TAUT `(~a ==> b) ==> a \/ b`) THEN
  KNOW_TAC ``!e. &0 < e /\ ~(?x'. x' IN s /\ ~(x' = x) /\ dist (x',x) < e)
     ==> (!e. &0 < e ==> (?x'. x' IN t /\ ~(x' = x) /\ dist (x',x) < e))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [NOT_FORALL_THM, LEFT_IMP_EXISTS_THM, NOT_IMP]] THEN
  X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min d e:real``) THEN ASM_MESON_TAC[REAL_LT_MIN]);

val LIMPT_INSERT = store_thm ("LIMPT_INSERT",
 ``!s x y:real. x limit_point_of (y INSERT s) <=> x limit_point_of s``,
  ONCE_REWRITE_TAC[SET_RULE ``y:real INSERT s = {y} UNION s``] THEN
  REWRITE_TAC[LIMIT_POINT_UNION] THEN
  SIMP_TAC std_ss [FINITE_SING, LIMIT_POINT_FINITE]);

val LIMPT_OF_LIMPTS = store_thm ("LIMPT_OF_LIMPTS",
 ``!x:real s. x limit_point_of {y | y limit_point_of s}
          ==> x limit_point_of s``,
  SIMP_TAC std_ss [LIMPT_APPROACHABLE, GSPECIFICATION] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  DISCH_THEN (X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``dist(y:real,x)``) THEN
  ASM_SIMP_TAC std_ss [DIST_POS_LT] THEN
  DISCH_THEN (X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``z:real`` THEN
  ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL
  [FIRST_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o LAND_CONV) [DIST_SYM] THEN
   REWRITE_TAC [dist] THEN REAL_ARITH_TAC, ALL_TAC] THEN
  FULL_SIMP_TAC std_ss [dist, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

val CLOSED_LIMPTS = store_thm ("CLOSED_LIMPTS",
 ``!s. closed {x:real | x limit_point_of s}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, GSPECIFICATION, LIMPT_OF_LIMPTS]);

val DISCRETE_IMP_CLOSED = store_thm ("DISCRETE_IMP_CLOSED",
 ``!s:real->bool e. &0 < e /\
    (!x y. x IN s /\ y IN s /\ abs(y - x) < e ==> (y = x))
    ==> closed s``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!x:real. ~(x limit_point_of s)``
  (fn th => MESON_TAC[th, CLOSED_LIMPT]) THEN
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  REWRITE_TAC[REAL_LT_HALF1, ASSUME ``&0 < e:real``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min (e / &2) (dist(x:real,y))``) THEN
  ASM_REWRITE_TAC [REAL_LT_MIN, REAL_LT_HALF1] THEN
  KNOW_TAC ``0 < dist(x,y:real)`` THENL
  [ASM_SIMP_TAC std_ss [DIST_POS_LT], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``y:real``, ``z:real``]) THEN
  ASM_SIMP_TAC arith_ss [GSYM dist] THEN CONJ_TAC THENL
  [MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist(z,x) + dist(x,y:real)`` THEN
   METIS_TAC [DIST_TRIANGLE, GSYM REAL_HALF_DOUBLE, REAL_LT_ADD2, DIST_SYM],
   REPEAT (POP_ASSUM MP_TAC) THEN REWRITE_TAC [dist, DIST_NZ] THEN
   REAL_ARITH_TAC]);

val LIMPT_OF_UNIV = store_thm ("LIMPT_OF_UNIV",
 ``!x. x limit_point_of univ(:real)``,
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNIV] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``0 <= e / 2:real`` THENL
  [METIS_TAC [REAL_LT_HALF1, REAL_LE_LT], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN STRIP_TAC THEN EXISTS_TAC ``y:real`` THEN
  CONJ_TAC THENL [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN
  ASM_REWRITE_TAC [DIST_NZ, REAL_LT_HALF1], MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``e / 2:real`` THEN METIS_TAC [REAL_LT_HALF2, REAL_LE_LT, DIST_SYM]]);

val LIMPT_OF_OPEN_IN = store_thm ("LIMPT_OF_OPEN_IN",
 ``!s t x:real. open_in (subtopology euclidean s) t /\
                x limit_point_of s /\ x IN t
                ==> x limit_point_of t``,
  REWRITE_TAC[open_in, SUBSET_DEF, LIMPT_APPROACHABLE] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!x. x IN t ==>
    ?e. 0 < e /\ !x'. x' IN s /\ dist (x',x) < e ==> x' IN t`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``min d e / &2:real``) THEN
  KNOW_TAC ``0 < min d e / 2:real`` THENL [REWRITE_TAC [min_def] THEN
  METIS_TAC [REAL_LT_HALF1], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN STRIP_TAC THEN EXISTS_TAC ``x':real`` THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN TRY (FIRST_X_ASSUM MATCH_MP_TAC) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``min d e / 2:real`` THEN ASM_REWRITE_TAC [] THEN
  MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
  METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2]);

val LIMPT_OF_OPEN = store_thm ("LIMPT_OF_OPEN",
 ``!s x:real. open s /\ x IN s ==> x limit_point_of s``,
  REWRITE_TAC[OPEN_IN] THEN ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN
  MESON_TAC[LIMPT_OF_OPEN_IN, LIMPT_OF_UNIV]);

val OPEN_IN_SING = store_thm ("OPEN_IN_SING",
 ``!s a. open_in (subtopology euclidean s) {a} <=>
   a IN s /\ ~(a limit_point_of s)``,
  REWRITE_TAC[open_in, LIMPT_APPROACHABLE, SING_SUBSET, IN_SING] THEN
  METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Interior of a set.                                                        *)
(* ------------------------------------------------------------------------- *)

val interior = new_definition ("interior",
  ``interior s = {x | ?t. open t /\ x IN t /\ t SUBSET s}``);

val INTERIOR_EQ = store_thm ("INTERIOR_EQ",
 ``!s. (interior s = s) <=> open s``,
  GEN_TAC THEN REWRITE_TAC[EXTENSION, interior] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN GEN_REWR_TAC RAND_CONV [OPEN_SUB_OPEN]
  THEN MESON_TAC[SUBSET_DEF]);

val INTERIOR_OPEN = store_thm ("INTERIOR_OPEN",
 ``!s. open s ==> (interior s = s)``,
  MESON_TAC[INTERIOR_EQ]);

val INTERIOR_EMPTY = store_thm ("INTERIOR_EMPTY",
 ``interior {} = {}``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_EMPTY]);

val INTERIOR_UNIV = store_thm ("INTERIOR_UNIV",
 ``interior univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_UNIV]);

val OPEN_INTERIOR = store_thm ("OPEN_INTERIOR",
 ``!s. open(interior s)``,
  GEN_TAC THEN REWRITE_TAC[interior] THEN GEN_REWR_TAC I [OPEN_SUB_OPEN] THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_INTERIOR = store_thm ("INTERIOR_INTERIOR",
 ``!s. interior(interior s) = interior s``,
  MESON_TAC[INTERIOR_EQ, OPEN_INTERIOR]);

val INTERIOR_SUBSET = store_thm ("INTERIOR_SUBSET",
 ``!s. (interior s) SUBSET s``,
  SIMP_TAC std_ss [SUBSET_DEF, interior, GSPECIFICATION] THEN MESON_TAC[]);

val SUBSET_INTERIOR_EQ = store_thm ("SUBSET_INTERIOR_EQ",
 ``!s:real->bool. s SUBSET interior s <=> open s``,
  REWRITE_TAC[GSYM INTERIOR_EQ,
  SET_RULE ``!(s:real->bool) t. (s = t) <=> s SUBSET t /\ t SUBSET s``,
  INTERIOR_SUBSET]);

val SUBSET_INTERIOR = store_thm ("SUBSET_INTERIOR",
 ``!s t. s SUBSET t ==> (interior s) SUBSET (interior t)``,
  SIMP_TAC std_ss [interior, SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_MAXIMAL = store_thm ("INTERIOR_MAXIMAL",
 ``!s t. t SUBSET s /\ open t ==> t SUBSET (interior s)``,
  SIMP_TAC std_ss[interior, SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_MAXIMAL_EQ = store_thm ("INTERIOR_MAXIMAL_EQ",
 ``!s t:real->bool. open s ==> (s SUBSET interior t <=> s SUBSET t)``,
  MESON_TAC[INTERIOR_MAXIMAL, SUBSET_TRANS, INTERIOR_SUBSET]);

val INTERIOR_UNIQUE = store_thm ("INTERIOR_UNIQUE",
 ``!s t. t SUBSET s /\ open t /\ (!t'. t' SUBSET s /\ open t' ==> t' SUBSET t)
         ==> (interior s = t)``,
  MESON_TAC[SUBSET_ANTISYM, INTERIOR_MAXIMAL, INTERIOR_SUBSET, OPEN_INTERIOR]);

val IN_INTERIOR = store_thm ("IN_INTERIOR",
 ``!x s. x IN interior s <=> ?e. &0 < e /\ ball(x,e) SUBSET s``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[OPEN_CONTAINS_BALL, SUBSET_TRANS, CENTRE_IN_BALL, OPEN_BALL]);

val OPEN_SUBSET_INTERIOR = store_thm ("OPEN_SUBSET_INTERIOR",
 ``!s t. open s ==> (s SUBSET interior t <=> s SUBSET t)``,
  MESON_TAC[INTERIOR_MAXIMAL, INTERIOR_SUBSET, SUBSET_TRANS]);

val INTERIOR_INTER = store_thm ("INTERIOR_INTER",
 ``!s t:real->bool. interior(s INTER t) = interior s INTER interior t``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [REWRITE_TAC[SUBSET_INTER] THEN CONJ_TAC THEN
    MATCH_MP_TAC SUBSET_INTERIOR THEN REWRITE_TAC[INTER_SUBSET],
    MATCH_MP_TAC INTERIOR_MAXIMAL THEN SIMP_TAC std_ss [OPEN_INTER, OPEN_INTERIOR] THEN
    MATCH_MP_TAC(SET_RULE
      ``s SUBSET s' /\ t SUBSET t' ==> s INTER t SUBSET s' INTER t'``) THEN
    REWRITE_TAC[INTERIOR_SUBSET]]);

val INTERIOR_FINITE_BIGINTER = store_thm ("INTERIOR_FINITE_BIGINTER",
 ``!s:(real->bool)->bool.
        FINITE s ==> (interior(BIGINTER s) = BIGINTER(IMAGE interior s))``,
  GEN_TAC THEN KNOW_TAC ``(interior (BIGINTER s) = BIGINTER (IMAGE interior s)) =
  (\s:(real->bool)->bool. (interior (BIGINTER s) = BIGINTER (IMAGE interior s))) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGINTER_EMPTY, BIGINTER_INSERT, INTERIOR_UNIV, IMAGE_EMPTY,
  IMAGE_INSERT] THEN SIMP_TAC std_ss [INTERIOR_INTER]);

val INTERIOR_BIGINTER_SUBSET = store_thm ("INTERIOR_BIGINTER_SUBSET",
 ``!f. interior(BIGINTER f) SUBSET BIGINTER (IMAGE interior f)``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERIOR, IN_BIGINTER, FORALL_IN_IMAGE] THEN
  MESON_TAC[]);

val UNION_INTERIOR_SUBSET = store_thm ("UNION_INTERIOR_SUBSET",
 ``!s t:real->bool.
        interior s UNION interior t SUBSET interior(s UNION t)``,
  SIMP_TAC std_ss [INTERIOR_MAXIMAL_EQ, OPEN_UNION, OPEN_INTERIOR] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(SET_RULE
   ``s SUBSET s' /\ t SUBSET t' ==> (s UNION t) SUBSET (s' UNION t')``) THEN
  REWRITE_TAC[INTERIOR_SUBSET]);

val INTERIOR_EQ_EMPTY = store_thm ("INTERIOR_EQ_EMPTY",
 ``!s:real->bool. (interior s = {}) <=> !t. open t /\ t SUBSET s ==> (t = {})``,
  MESON_TAC[INTERIOR_MAXIMAL_EQ, SUBSET_EMPTY,
            OPEN_INTERIOR, INTERIOR_SUBSET]);

val INTERIOR_EQ_EMPTY_ALT = store_thm ("INTERIOR_EQ_EMPTY_ALT",
 ``!s:real->bool. (interior s = {}) <=>
  !t. open t /\ ~(t = {}) ==> ~(t DIFF s = {})``,
  GEN_TAC THEN REWRITE_TAC[INTERIOR_EQ_EMPTY] THEN SET_TAC[]);

val INTERIOR_LIMIT_POINT = store_thm ("INTERIOR_LIMIT_POINT",
 ``!s x:real. x IN interior s ==> x limit_point_of s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [IN_INTERIOR, GSPECIFICATION, SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[LIMPT_APPROACHABLE] THEN X_GEN_TAC ``d:real`` THEN
  DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``min d e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``0 <= min d e / 2:real`` THENL
  [METIS_TAC [min_def, REAL_LE_LT, REAL_LT_HALF1], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  EXISTS_TAC ``y:real`` THEN REPEAT CONJ_TAC THENL
  [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
   METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2],
   CONV_TAC (RAND_CONV SYM_CONV) THEN REWRITE_TAC[DIST_NZ] THEN
   ASM_REWRITE_TAC [] THEN METIS_TAC [min_def, REAL_LE_LT, REAL_LT_HALF1],
   ONCE_REWRITE_TAC[DIST_SYM] THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
   METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2]]);

val INTERIOR_SING = store_thm ("INTERIOR_SING",
  ``!a:real. interior {a} = {}``,
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN
  MESON_TAC[INTERIOR_LIMIT_POINT, LIMPT_SING]);

val INTERIOR_CLOSED_UNION_EMPTY_INTERIOR = store_thm ("INTERIOR_CLOSED_UNION_EMPTY_INTERIOR",
 ``!s t:real->bool. closed(s) /\ (interior(t) = {})
                ==> (interior(s UNION t) = interior(s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, SUBSET_UNION] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTERIOR, IN_INTER, IN_UNION] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN
  ASM_REWRITE_TAC[] THEN X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``(y:real) limit_point_of s``
   (fn th => ASM_MESON_TAC[CLOSED_LIMPT, th]) THEN
  REWRITE_TAC[IN_INTERIOR, NOT_IN_EMPTY, LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?z:real. ~(z IN t) /\ ~(z = y) /\ dist(z,y) < d /\ dist(x,z) < e``
   (fn th => ASM_MESON_TAC[th, IN_BALL]) THEN
  UNDISCH_TAC ``y IN ball (x,e)`` THEN REWRITE_TAC [IN_BALL] THEN
  DISCH_TAC THEN UNDISCH_TAC ``interior t = {}`` THEN
  GEN_REWR_TAC LAND_CONV [EXTENSION] THEN
  KNOW_TAC ``(!x e. ~(&0 < e /\ ball (x,e) SUBSET t))
   ==> (?z. ~(z IN t) /\ ~(z = y) /\ dist (z,y) < d /\ dist (x,z) < e)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [IN_INTERIOR, NOT_IN_EMPTY, NOT_EXISTS_THM]] THEN
  ABBREV_TAC ``k = min d (e - dist(x:real,y))`` THEN
  SUBGOAL_THEN ``&0 < k:real`` ASSUME_TAC THENL
  [METIS_TAC [min_def, REAL_SUB_LT], ALL_TAC] THEN
  SUBGOAL_THEN ``?w:real. dist(y,w) = k / &2`` CHOOSE_TAC THENL
  [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_HALF, REAL_LT_IMP_LE], ALL_TAC] THEN
  DISCH_THEN(MP_TAC o SPECL [``w:real``, ``k / &4:real``]) THEN
  ASM_SIMP_TAC arith_ss [SUBSET_DEF, NOT_FORALL_THM, REAL_LT_DIV, REAL_LT,
  NOT_IMP, IN_BALL] THEN DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN
  EXISTS_TAC ``z:real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN REPEAT CONJ_TAC THENL
  [CCONTR_TAC THEN FULL_SIMP_TAC std_ss [DIST_SYM] THEN
   UNDISCH_TAC `` dist (w,y) < k / 4`` THEN ASM_REWRITE_TAC [REAL_NOT_LT, REAL_LE_LT] THEN
   DISJ1_TAC THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD],
   MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (z, w) + dist (w, y:real)`` THEN
   REWRITE_TAC [DIST_TRIANGLE] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d (e - dist (x,y))`` THEN
   ASM_REWRITE_TAC [REAL_MIN_LE1] THEN
   GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN REWRITE_TAC [REAL_LT_RADD] THEN
   MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``k / 4:real`` THEN
   ASM_REWRITE_TAC [] THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD],
   Cases_on `d <= (e - dist (x,y))` THENL
   [ALL_TAC, FULL_SIMP_TAC std_ss [min_def] THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``(a - b = c) = (a = c + b:real)``] THEN
    ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``dist (x, y) + dist (y, z:real)`` THEN
    REWRITE_TAC [DIST_TRIANGLE, REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``dist (y,w) + dist (w, z:real)`` THEN ASM_REWRITE_TAC [DIST_TRIANGLE] THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN REWRITE_TAC [REAL_LT_LADD] THEN
    MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``k / 4:real`` THEN
    ASM_REWRITE_TAC [] THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
    [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
    REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
    SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
    ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
    GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD]] THEN
   FULL_SIMP_TAC std_ss [min_def, REAL_LE_SUB_LADD] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``d + dist (x,y)`` THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN
   MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (x, y) + dist (y, z:real)`` THEN
   REWRITE_TAC [DIST_TRIANGLE, REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist (y,w) + dist (w, z:real)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
   ASM_REWRITE_TAC [] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
   ASM_REWRITE_TAC [REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
   EXISTS_TAC ``k / 4:real`` THEN ASM_REWRITE_TAC [] THEN
   KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD]]);

val INTERIOR_UNION_EQ_EMPTY = store_thm ("INTERIOR_UNION_EQ_EMPTY",
 ``!s t:real->bool. closed s \/ closed t
        ==> ((interior(s UNION t) = {}) <=>
             (interior s = {}) /\ (interior t = {}))``,
REPEAT GEN_TAC THEN DISCH_TAC THEN EQ_TAC THENL
[ASM_MESON_TAC[SUBSET_UNION, SUBSET_INTERIOR, SUBSET_EMPTY],
 ASM_MESON_TAC[UNION_COMM, INTERIOR_CLOSED_UNION_EMPTY_INTERIOR]]);

val INTERIOR_UNIONS_OPEN_SUBSETS = store_thm ("INTERIOR_UNIONS_OPEN_SUBSETS",
 ``!s:real->bool. BIGUNION {t | open t /\ t SUBSET s} = interior s``,
  GEN_TAC THEN CONV_TAC SYM_CONV THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  SIMP_TAC std_ss [OPEN_BIGUNION, GSPECIFICATION] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* More variants of the Archimedian property and useful consequences.        *)
(* ------------------------------------------------------------------------- *)

val REAL_ARCH_INV = store_thm ("REAL_ARCH_INV",
 ``!e. &0 < e <=> ?n. ~(n = 0) /\ &0:real < inv(&n) /\ inv(&n) < e:real``,
  GEN_TAC THEN EQ_TAC THENL [ALL_TAC, MESON_TAC[REAL_LT_TRANS]] THEN
  DISCH_TAC THEN MP_TAC(SPEC ``inv(e:real)`` REAL_BIGNUM) THEN
  STRIP_TAC THEN EXISTS_TAC ``n:num`` THEN
  ASM_MESON_TAC[REAL_LT_INV, REAL_INV_INV, REAL_LT_INV_EQ, REAL_LT_TRANS,
                REAL_LT_ANTISYM]);

val REAL_POW_LBOUND = store_thm ("REAL_POW_LBOUND",
 ``!x:real n. &0 <= x ==> &1 + &n * x <= (&1 + x) pow n``,
  GEN_TAC THEN SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN DISCH_TAC THEN
  INDUCT_TAC THEN
  REWRITE_TAC[pow, REAL_MUL_LZERO, REAL_ADD_RID, REAL_LE_REFL] THEN
  REWRITE_TAC[GSYM REAL_OF_NUM_SUC] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``(&1 + x) * (&1 + &n * x:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL, REAL_ARITH ``&0 <= x:real ==> &0 <= &1 + x``,
                       REAL_LE_MUL, REAL_LE_LMUL_IMP, REAL_POS, pow, REAL_ARITH
   ``&1 + (n + &1) * x:real <= (&1 + x) * (&1 + n * x) <=> &0 <= n * x * x``]);

val REAL_ARCH_POW = store_thm ("REAL_ARCH_POW",
 ``!x:real y. &1 < x ==> ?n. y < x pow n``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``x:real - &1`` REAL_ARCH) THEN ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(MP_TAC o SPEC ``y:real``) THEN STRIP_TAC THEN
  EXISTS_TAC ``n:num`` THEN MATCH_MP_TAC REAL_LTE_TRANS THEN
  EXISTS_TAC ``&1 + &n * (x:real - &1)`` THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``x:real < y ==> x < &1 + y``] THEN
  ASM_MESON_TAC[REAL_POW_LBOUND, REAL_SUB_ADD2, REAL_ARITH
    ``&1 < x:real ==> &0 <= x - &1``]);

val REAL_ARCH_POW2 = store_thm ("REAL_ARCH_POW2",
 ``!x:real. ?n. x < &2:real pow n``,
  SIMP_TAC std_ss [REAL_ARCH_POW, REAL_ARITH ``1 < 2:real``]);

val REAL_ARCH_POW_INV = store_thm ("REAL_ARCH_POW_INV",
 ``!x:real y. &0 < y /\ x < &1 ==> ?n. x pow n < y``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``&0 < x:real`` THENL
   [ALL_TAC, ASM_MESON_TAC[POW_1, REAL_LET_TRANS, REAL_NOT_LT]] THEN
  SUBGOAL_THEN ``inv(&1) < inv(x:real)`` MP_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_LT_INV], REWRITE_TAC[REAL_INV1]] THEN
  DISCH_THEN(MP_TAC o SPEC ``inv(y:real)`` o MATCH_MP REAL_ARCH_POW) THEN
  STRIP_TAC THEN EXISTS_TAC ``n:num`` THEN
  GEN_REWR_TAC BINOP_CONV [GSYM REAL_INV_INV] THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_POW_INV, REAL_LT_INV_EQ, REAL_LT_INV]);

val FORALL_POS_MONO = store_thm ("FORALL_POS_MONO",
 ``!P. (!d e:real. d < e /\ P d ==> P e) /\ (!n. ~(n = 0) ==> P(inv(&n)))
       ==> !e. &0 < e ==> P e``,
  MESON_TAC[REAL_ARCH_INV, REAL_LT_TRANS]);

val FORALL_SUC = store_thm ("FORALL_SUC",
 ``(!n. n <> 0 ==> P n) <=> !n. P (SUC n)``,
  EQ_TAC THENL [RW_TAC arith_ss [SUC_NOT, REAL_OF_NUM_EQ],
  METIS_TAC [REAL_NZ_IMP_LT, SUC_PRE, REAL_LT, REAL_OF_NUM_EQ]]);

val LT_NZ = store_thm ("LT_NZ",
 ``!n:num. 0 < n <=> ~(n = 0)``,
  INDUCT_TAC THEN ASM_SIMP_TAC std_ss [NOT_SUC, LT, EQ_SYM_EQ] THEN
  TAUT_TAC);

val REAL_ARCH_RDIV_EQ_0 = store_thm ("REAL_ARCH_RDIV_EQ_0",
 ``!x c:real. &0 <= x /\ &0 <= c /\ (!m. 0 < m ==> &m * x <= c) ==> (x = &0)``,
  SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, GSYM REAL_NOT_LT] THEN REPEAT STRIP_TAC THEN
  POP_ASSUM (STRIP_ASSUME_TAC o SPEC ``c:real`` o MATCH_MP REAL_ARCH) THEN
  ASM_CASES_TAC ``n=0:num`` THENL
   [POP_ASSUM SUBST_ALL_TAC THEN
    RULE_ASSUM_TAC (REWRITE_RULE [REAL_MUL_LZERO]) THEN
    ASM_MESON_TAC [REAL_LET_ANTISYM],
    ASM_MESON_TAC [REAL_LET_ANTISYM, REAL_MUL_SYM, LT_NZ]]);

(* ------------------------------------------------------------------------- *)
(* Closure of a set.                                                         *)
(* ------------------------------------------------------------------------- *)

val closure = new_definition ("closure",
  ``closure s = s UNION {x | x limit_point_of s}``);

val CLOSURE_APPROACHABLE = store_thm ("CLOSURE_APPROACHABLE",
 ``!x s. x IN closure(s) <=> !e. &0 < e ==> ?y. y IN s /\ dist(y,x) < e``,
  SIMP_TAC std_ss [closure, LIMPT_APPROACHABLE, IN_UNION, GSPECIFICATION] THEN
  MESON_TAC[DIST_REFL]);

val CLOSURE_NONEMPTY_OPEN_INTER = store_thm ("CLOSURE_NONEMPTY_OPEN_INTER",
 ``!s x:real. x IN closure s <=> !t. x IN t /\ open t ==> ~(s INTER t = {})``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION] THEN
  REWRITE_TAC[limit_point_of] THEN SET_TAC[]);

val CLOSURE_INTERIOR = store_thm ("CLOSURE_INTERIOR",
 ``!s:real->bool. closure s = UNIV DIFF (interior (UNIV DIFF s))``,
  SIMP_TAC std_ss [EXTENSION, closure, IN_UNION, IN_DIFF, IN_UNIV, interior,
              GSPECIFICATION, limit_point_of, SUBSET_DEF] THEN
  MESON_TAC[]);

val INTERIOR_CLOSURE = store_thm ("INTERIOR_CLOSURE",
 ``!s:real->bool. interior s = UNIV DIFF (closure (UNIV DIFF s))``,
  REWRITE_TAC[CLOSURE_INTERIOR, SET_RULE ``!s t. UNIV DIFF (UNIV DIFF t) = t``]);

val CLOSED_CLOSURE = store_thm ("CLOSED_CLOSURE",
 ``!s. closed(closure s)``,
  REWRITE_TAC[closed_def, CLOSURE_INTERIOR, SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``,
              OPEN_INTERIOR]);

val CLOSURE_HULL = store_thm ("CLOSURE_HULL",
 ``!s. closure s = closed hull s``,
  GEN_TAC THEN MATCH_MP_TAC(GSYM HULL_UNIQUE) THEN
  REWRITE_TAC[CLOSED_CLOSURE, SUBSET_DEF] THEN
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, CLOSED_LIMPT] THEN
  MESON_TAC[limit_point_of]);

val CLOSURE_EQ = store_thm ("CLOSURE_EQ",
 ``!s. (closure s = s) <=> closed s``,
  SIMP_TAC std_ss [CLOSURE_HULL, HULL_EQ, CLOSED_BIGINTER]);

val CLOSURE_CLOSED = store_thm ("CLOSURE_CLOSED",
 ``!s. closed s ==> (closure s = s)``,
  MESON_TAC[CLOSURE_EQ]);

val CLOSURE_CLOSURE = store_thm ("CLOSURE_CLOSURE",
 ``!s. closure(closure s) = closure s``,
  REWRITE_TAC[CLOSURE_HULL, HULL_HULL]);

val CLOSURE_SUBSET = store_thm ("CLOSURE_SUBSET",
 ``!s. s SUBSET (closure s)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_SUBSET]);

val SUBSET_CLOSURE = store_thm ("SUBSET_CLOSURE",
 ``!s t. s SUBSET t ==> (closure s) SUBSET (closure t)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_MONO]);

val CLOSURE_UNION = store_thm ("CLOSURE_UNION",
 ``!s t:real->bool. closure(s UNION t) = closure s UNION closure t``,
  REWRITE_TAC[LIMIT_POINT_UNION, closure] THEN SET_TAC[]);

val CLOSURE_INTER_SUBSET = store_thm ("CLOSURE_INTER_SUBSET",
 ``!s t. closure(s INTER t) SUBSET closure(s) INTER closure(t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SUBSET_INTER] THEN
  CONJ_TAC THEN MATCH_MP_TAC SUBSET_CLOSURE THEN SET_TAC[]);

val CLOSURE_BIGINTER_SUBSET = store_thm ("CLOSURE_BIGINTER_SUBSET",
 ``!f. closure(BIGINTER f) SUBSET BIGINTER (IMAGE closure f)``,
  REWRITE_TAC[SET_RULE ``s SUBSET BIGINTER f <=> !t. t IN f ==> s SUBSET t``] THEN
  REWRITE_TAC[FORALL_IN_IMAGE] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SUBSET_CLOSURE THEN ASM_SET_TAC[]);

val CLOSURE_MINIMAL = store_thm ("CLOSURE_MINIMAL",
 ``!s t. s SUBSET t /\ closed t ==> (closure s) SUBSET t``,
  REWRITE_TAC[HULL_MINIMAL, CLOSURE_HULL]);

val CLOSURE_MINIMAL_EQ = store_thm ("CLOSURE_MINIMAL_EQ",
 ``!s t:real->bool. closed t ==> (closure s SUBSET t <=> s SUBSET t)``,
  MESON_TAC[SUBSET_TRANS, CLOSURE_SUBSET, CLOSURE_MINIMAL]);

val CLOSURE_UNIQUE = store_thm ("CLOSURE_UNIQUE",
 ``!s t. s SUBSET t /\ closed t /\
  (!t'. s SUBSET t' /\ closed t' ==> t SUBSET t')
   ==> (closure s = t)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_UNIQUE]);

val CLOSURE_EMPTY = store_thm ("CLOSURE_EMPTY",
 ``closure {} = {}``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_EMPTY]);

val CLOSURE_UNIV = store_thm ("CLOSURE_UNIV",
 ``closure univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_UNIV]);

val CLOSURE_BIGUNION = store_thm ("CLOSURE_BIGUNION",
 ``!f. FINITE f ==> (closure(BIGUNION f) = BIGUNION {closure s | s IN f})``,
  KNOW_TAC ``!f. (closure(BIGUNION f) = BIGUNION {closure s | s IN f}) =
             (\f. closure(BIGUNION f) = BIGUNION {closure s | s IN f}) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [BIGUNION_EMPTY, BIGUNION_INSERT, SET_RULE ``{f x | x IN {}} = {}``,
  SET_RULE ``{f x | x IN a INSERT s} = (f a) INSERT {f x | x IN s}``] THEN
  SIMP_TAC std_ss [CLOSURE_EMPTY, CLOSURE_UNION]);

val CLOSURE_EQ_EMPTY = store_thm ("CLOSURE_EQ_EMPTY",
 ``!s. (closure s = {}) <=> (s = {})``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CLOSURE_EMPTY] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (t = {}) ==> (s = {})``) THEN
  REWRITE_TAC[CLOSURE_SUBSET]);

val CLOSURE_SUBSET_EQ = store_thm ("CLOSURE_SUBSET_EQ",
 ``!s:real->bool. closure s SUBSET s <=> closed s``,
  GEN_TAC THEN REWRITE_TAC[GSYM CLOSURE_EQ] THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[]);

val OPEN_INTER_CLOSURE_EQ_EMPTY = store_thm ("OPEN_INTER_CLOSURE_EQ_EMPTY",
 ``!s t:real->bool.
        open s ==> ((s INTER (closure t) = {}) <=> (s INTER t = {}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [MP_TAC(ISPEC ``t:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[], ALL_TAC] THEN
  DISCH_TAC THEN REWRITE_TAC[CLOSURE_INTERIOR] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (s INTER (UNIV DIFF t) = {})``) THEN
  ASM_SIMP_TAC std_ss [OPEN_SUBSET_INTERIOR] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CLOSURE_OPEN_IN_INTER_CLOSURE = store_thm ("CLOSURE_OPEN_IN_INTER_CLOSURE",
 ``!s t u:real->bool.
     open_in (subtopology euclidean u) s /\ t SUBSET u
     ==> (closure(s INTER closure t) = closure(s INTER t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, SUBSET_CLOSURE, SET_RULE
  ``t SUBSET u ==> s INTER t SUBSET s INTER u``] THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_APPROACHABLE] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, IN_INTER, CLOSURE_APPROACHABLE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN
  REWRITE_TAC [open_in] THEN REWRITE_TAC[SUBSET_DEF] THEN
  DISCH_THEN(CONJUNCTS_THEN(MP_TAC o SPEC ``y:real``)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?y'. y' IN t /\ dist (y',y) < e`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``min d (e / &2:real)``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, REAL_LT_MIN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  POP_ASSUM MP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist(z,y) + dist(y,x)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LT_ADD2 THEN ASM_REWRITE_TAC []);

val CLOSURE_OPEN_INTER_CLOSURE = store_thm ("CLOSURE_OPEN_INTER_CLOSURE",
 ``!s t:real->bool.
   open s ==> (closure(s INTER closure t) = closure(s INTER t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSURE_OPEN_IN_INTER_CLOSURE THEN
  EXISTS_TAC ``univ(:real)`` THEN
  ASM_REWRITE_TAC[SUBSET_UNIV, GSYM OPEN_IN, SUBTOPOLOGY_UNIV]);

val OPEN_INTER_CLOSURE_SUBSET = store_thm ("OPEN_INTER_CLOSURE_SUBSET",
 ``!s t:real->bool.
        open s ==> (s INTER (closure t)) SUBSET closure(s INTER t)``,
  REPEAT STRIP_TAC THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_INTER, closure, IN_UNION, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  DISJ2_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``open s`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``x limit_point_of t`` THEN REWRITE_TAC [LIMPT_APPROACHABLE] THEN
  DISCH_THEN(MP_TAC o SPEC ``min d e:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_MIN, IN_INTER] THEN STRIP_TAC THEN
  EXISTS_TAC ``x':real`` THEN ASM_MESON_TAC[]);

val CLOSURE_OPEN_INTER_SUPERSET = store_thm ("CLOSURE_OPEN_INTER_SUPERSET",
 ``!s t:real->bool.
        open s /\ s SUBSET closure t ==> (closure(s INTER t) = closure s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, INTER_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN REWRITE_TAC[CLOSED_CLOSURE] THEN
  W(MP_TAC o PART_MATCH (rand o rand) OPEN_INTER_CLOSURE_SUBSET o rand o snd) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] SUBSET_TRANS) THEN
  ASM_SET_TAC[]);

val CLOSURE_COMPLEMENT = store_thm ("CLOSURE_COMPLEMENT",
 ``!s:real->bool. closure(UNIV DIFF s) = UNIV DIFF interior(s)``,
  REWRITE_TAC[SET_RULE ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_CLOSURE]);

val INTERIOR_COMPLEMENT = store_thm ("INTERIOR_COMPLEMENT",
 ``!s:real->bool. interior(UNIV DIFF s) = UNIV DIFF closure(s)``,
  REWRITE_TAC[SET_RULE ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``] THEN
  REWRITE_TAC[GSYM CLOSURE_INTERIOR]);

val CONNECTED_INTERMEDIATE_CLOSURE = store_thm ("CONNECTED_INTERMEDIATE_CLOSURE",
 ``!s t:real->bool.
   connected s /\ s SUBSET t /\ t SUBSET closure s ==> connected t``,
  REPEAT GEN_TAC THEN
  KNOW_TAC ``(!e1 e2.
      ~(open e1 /\ open e2 /\
        s SUBSET e1 UNION e2 /\ (e1 INTER e2 INTER s = {}) /\
        ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))) /\
        s SUBSET t /\ t SUBSET closure s
 ==> (!e1 e2.
          ~(open e1 /\ open e2 /\
            t SUBSET e1 UNION e2 /\ (e1 INTER e2 INTER t = {}) /\
            ~(e1 INTER t = {}) /\ ~(e2 INTER t = {})))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [connected, NOT_EXISTS_THM]] THEN
  STRIP_TAC THEN MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPECL [``u:real->bool``, ``v:real->bool``]) THEN
  ASM_REWRITE_TAC[] THEN ASSUME_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[GSYM DE_MORGAN_THM] THEN STRIP_TAC THENL
  [SUBGOAL_THEN ``(closure s) SUBSET (univ(:real) DIFF u)`` MP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_REWRITE_TAC[GSYM OPEN_CLOSED], ALL_TAC],
  SUBGOAL_THEN ``(closure s) SUBSET (univ(:real) DIFF v)`` MP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_REWRITE_TAC[GSYM OPEN_CLOSED],
   ALL_TAC]] THEN ASM_SET_TAC[]);

val CONNECTED_CLOSURE = store_thm ("CONNECTED_CLOSURE",
 ``!s:real->bool. connected s ==> connected(closure s)``,
  MESON_TAC[CONNECTED_INTERMEDIATE_CLOSURE, CLOSURE_SUBSET, SUBSET_REFL]);

val CONNECTED_UNION_STRONG = store_thm ("CONNECTED_UNION_STRONG",
 ``!s t:real->bool.
    connected s /\ connected t /\ ~(closure s INTER t = {})
    ==> connected(s UNION t)``,
  REPEAT STRIP_TAC THEN
  POP_ASSUM (MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``p:real``) THEN
  SUBGOAL_THEN ``s UNION t = ((p:real) INSERT s) UNION t`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC CONNECTED_UNION THEN ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
  [MATCH_MP_TAC CONNECTED_INTERMEDIATE_CLOSURE THEN
   EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
   MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
   ASM_SET_TAC[]]);

val INTERIOR_DIFF = store_thm ("INTERIOR_DIFF",
 ``!s t. interior(s DIFF t) = interior(s) DIFF closure(t)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  REWRITE_TAC[INTERIOR_INTER, CLOSURE_INTERIOR] THEN SET_TAC[]);

val LIMPT_OF_CLOSURE = store_thm ("LIMPT_OF_CLOSURE",
 ``!x:real s. x limit_point_of closure s <=> x limit_point_of s``,
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, LIMIT_POINT_UNION] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT `(q ==> p) ==> (p \/ q <=> p)`) THEN
  REWRITE_TAC[LIMPT_OF_LIMPTS]);

val CLOSED_IN_LIMPT = store_thm ("CLOSED_IN_LIMPT",
 ``!s t. closed_in (subtopology euclidean t) s <=>
    s SUBSET t /\ !x:real. x limit_point_of s /\ x IN t ==> x IN s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN EQ_TAC THENL
  [DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [IN_INTER] THEN
  ASM_MESON_TAC[CLOSED_LIMPT, LIMPT_SUBSET, INTER_SUBSET],
  STRIP_TAC THEN EXISTS_TAC ``closure s :real->bool`` THEN
  REWRITE_TAC[CLOSED_CLOSURE] THEN REWRITE_TAC[closure] THEN
  ASM_SET_TAC[]]);

val CLOSED_IN_INTER_CLOSURE = store_thm ("CLOSED_IN_INTER_CLOSURE",
 ``!s t:real->bool.
    closed_in (subtopology euclidean s) t <=> (s INTER closure t = t)``,
  REWRITE_TAC[closure, CLOSED_IN_LIMPT] THEN SET_TAC[]);

val INTERIOR_CLOSURE_IDEMP = store_thm ("INTERIOR_CLOSURE_IDEMP",
 ``!s:real->bool.
    interior(closure(interior(closure s))) = interior(closure s)``,
  GEN_TAC THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  ASM_MESON_TAC[OPEN_INTERIOR, CLOSURE_SUBSET, CLOSURE_CLOSURE, SUBSET_TRANS,
                OPEN_SUBSET_INTERIOR, SUBSET_CLOSURE, INTERIOR_SUBSET]);

val CLOSURE_INTERIOR_IDEMP = store_thm ("CLOSURE_INTERIOR_IDEMP",
 ``!s:real->bool.
    closure(interior(closure(interior s))) = closure(interior s)``,
  GEN_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = t) <=> (UNIV DIFF s = UNIV DIFF t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_COMPLEMENT, GSYM CLOSURE_COMPLEMENT] THEN
  REWRITE_TAC[INTERIOR_CLOSURE_IDEMP]);

val NOWHERE_DENSE_UNION = store_thm ("NOWHERE_DENSE_UNION",
 ``!s t:real->bool.
   (interior(closure(s UNION t)) = {}) <=>
   (interior(closure s) = {}) /\ (interior(closure t) = {})``,
  SIMP_TAC std_ss [CLOSURE_UNION, INTERIOR_UNION_EQ_EMPTY, CLOSED_CLOSURE]);

val NOWHERE_DENSE = store_thm ("NOWHERE_DENSE",
 ``!s:real->bool. (interior(closure s) = {}) <=>
              !t. open t /\ ~(t = {})
          ==> ?u. open u /\ ~(u = {}) /\ u SUBSET t /\ (u INTER s = {})``,
  GEN_TAC THEN REWRITE_TAC[INTERIOR_EQ_EMPTY_ALT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THENL
  [EXISTS_TAC ``t DIFF closure s:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, CLOSED_CLOSURE] THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[],
  FIRST_X_ASSUM(MP_TAC o SPEC ``t:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``u:real->bool``, ``s:real->bool``]
  OPEN_INTER_CLOSURE_EQ_EMPTY) THEN ASM_SET_TAC[]]);

val INTERIOR_CLOSURE_INTER_OPEN = store_thm ("INTERIOR_CLOSURE_INTER_OPEN",
 ``!s t:real->bool. open s /\ open t
        ==> (interior(closure(s INTER t)) =
             interior(closure s) INTER interior(closure t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[SET_RULE
  ``(u = s INTER t) <=> s INTER t SUBSET u /\ u SUBSET s /\ u SUBSET t``] THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, SUBSET_CLOSURE, INTER_SUBSET] THEN
  MATCH_MP_TAC INTERIOR_MAXIMAL THEN SIMP_TAC std_ss [OPEN_INTER, OPEN_INTERIOR] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET t <=> (s INTER (UNIV DIFF t) = {})``,
   GSYM INTERIOR_COMPLEMENT] THEN
  REWRITE_TAC[GSYM INTERIOR_INTER] THEN
  REWRITE_TAC[INTERIOR_EQ_EMPTY] THEN
  X_GEN_TAC ``u:real->bool`` THEN STRIP_TAC THEN
  MP_TAC(ISPECL [``u INTER s:real->bool``, ``t:real->bool``]
   OPEN_INTER_CLOSURE_EQ_EMPTY) THEN
  MP_TAC(ISPECL [``u:real->bool``, ``s:real->bool``]
   OPEN_INTER_CLOSURE_EQ_EMPTY) THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER] THEN ASM_SET_TAC[]);

val CLOSURE_INTERIOR_UNION_CLOSED = store_thm ("CLOSURE_INTERIOR_UNION_CLOSED",
 ``!s t:real->bool. closed s /\ closed t
        ==> (closure (interior (s UNION t)) =
             closure (interior s) UNION closure(interior t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[closed_def] THEN
  DISCH_THEN(MP_TAC o MATCH_MP INTERIOR_CLOSURE_INTER_OPEN) THEN
  REWRITE_TAC[CLOSURE_COMPLEMENT, INTERIOR_COMPLEMENT,
  SET_RULE ``(UNIV DIFF s) INTER (UNIV DIFF t) = UNIV DIFF (s UNION t)``] THEN
  SET_TAC[]);

val REGULAR_OPEN_INTER = store_thm ("REGULAR_OPEN_INTER",
 ``!s t:real->bool.
    (interior(closure s) = s) /\ (interior(closure t) = t)
     ==> (interior(closure(s INTER t)) = s INTER t)``,
  MESON_TAC[INTERIOR_CLOSURE_INTER_OPEN, OPEN_INTERIOR]);

val REGULAR_CLOSED_UNION = store_thm ("REGULAR_CLOSED_UNION",
 ``!s t:real->bool.
  (closure(interior s) = s) /\ (closure(interior t) = t)
   ==> (closure(interior(s UNION t)) = s UNION t)``,
  MESON_TAC[CLOSURE_INTERIOR_UNION_CLOSED, CLOSED_CLOSURE]);

val REGULAR_CLOSED_BIGUNION = store_thm ("REGULAR_CLOSED_BIGUNION",
 ``!f:(real->bool)->bool.
    FINITE f /\ (!t. t IN f ==> (closure(interior t) = t))
    ==> (closure(interior(BIGUNION f)) = BIGUNION f)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!f. ((!t. t IN f ==> (closure(interior t) = t))
         ==> (closure(interior(BIGUNION f)) = BIGUNION f)) =
           (\f. (!t. t IN f ==> (closure(interior t) = t))
         ==> (closure(interior(BIGUNION f)) = BIGUNION f)) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_INSERT, BIGUNION_EMPTY, INTERIOR_EMPTY, CLOSURE_EMPTY] THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, REGULAR_CLOSED_UNION]);

val DIFF_CLOSURE_SUBSET = store_thm ("DIFF_CLOSURE_SUBSET",
 ``!s t:real->bool. closure(s) DIFF closure t SUBSET closure(s DIFF t)``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``univ(:real) DIFF closure t``, ``s:real->bool``]
   OPEN_INTER_CLOSURE_SUBSET) THEN
  REWRITE_TAC[SET_RULE ``(UNIV DIFF t) INTER s = s DIFF t``] THEN
  REWRITE_TAC[GSYM closed_def, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_TRANS) THEN
  MATCH_MP_TAC SUBSET_CLOSURE THEN
  MATCH_MP_TAC(SET_RULE ``t SUBSET u ==> s DIFF u SUBSET s DIFF t``) THEN
  REWRITE_TAC[CLOSURE_SUBSET]);

val DENSE_OPEN_INTER = store_thm ("DENSE_OPEN_INTER",
 ``!s t u:real->bool.
  (open_in (subtopology euclidean u) s /\ t SUBSET u \/
   open_in (subtopology euclidean u) t /\ s SUBSET u)
   ==> (u SUBSET closure (s INTER t) <=>
        u SUBSET closure s /\ u SUBSET closure t)``,
  KNOW_TAC ``((!s t u.
      (u SUBSET closure (s INTER t) <=>
       u SUBSET closure s /\ u SUBSET closure t)
      ==> (u SUBSET closure (t INTER s) <=>
           u SUBSET closure t /\ u SUBSET closure s)) /\
 (!s t u.
      open_in (subtopology euclidean u) s /\ t SUBSET u
      ==> (u SUBSET closure (s INTER t) <=>
           u SUBSET closure s /\ u SUBSET closure t)))`` THENL
  [ALL_TAC, METIS_TAC []] THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [INTER_COMM, CONJ_ACI], ALL_TAC] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN EQ_TAC THENL
  [ASM_MESON_TAC[SUBSET_TRANS, SUBSET_CLOSURE, INTER_SUBSET], ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_APPROACHABLE] THEN DISCH_TAC THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(CONJUNCTS_THEN2 (MP_TAC o SPEC ``x:real``) ASSUME_TAC) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN REWRITE_TAC [open_in] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTER] THEN
  DISCH_THEN(CONJUNCTS_THEN (MP_TAC o SPEC ``y:real``)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d (e / &2):real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_LT_MIN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN ASM_SIMP_TAC std_ss [] THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist(z,y) + dist(y,x)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LT_ADD2 THEN ASM_REWRITE_TAC []);

(* ------------------------------------------------------------------------- *)
(* Frontier (aka boundary).                                                  *)
(* ------------------------------------------------------------------------- *)

val frontier = new_definition ("frontier",
  ``frontier s = (closure s) DIFF (interior s)``);

val FRONTIER_CLOSED = store_thm ("FRONTIER_CLOSED",
 ``!s. closed(frontier s)``,
  SIMP_TAC std_ss [frontier, CLOSED_DIFF, CLOSED_CLOSURE, OPEN_INTERIOR]);

val FRONTIER_CLOSURES = store_thm ("FRONTIER_CLOSURES",
 ``!s:real->bool. frontier s = (closure s) INTER (closure(UNIV DIFF s))``,
  REWRITE_TAC[frontier, INTERIOR_CLOSURE,
   SET_RULE ``s DIFF (UNIV DIFF t) = s INTER t``]);

val FRONTIER_STRADDLE = store_thm ("FRONTIER_STRADDLE",
 ``!a:real s.
    a IN frontier s <=> !e. &0 < e ==> (?x. x IN s /\ dist(a,x) < e) /\
    (?x. ~(x IN s) /\ dist(a,x) < e)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[FRONTIER_CLOSURES, IN_INTER] THEN
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, limit_point_of,
  IN_UNIV, IN_DIFF] THEN
  ASM_MESON_TAC[IN_BALL, SUBSET_DEF, OPEN_CONTAINS_BALL,
  CENTRE_IN_BALL, OPEN_BALL, DIST_REFL]);

val FRONTIER_SUBSET_CLOSED = store_thm ("FRONTIER_SUBSET_CLOSED",
 ``!s. closed s ==> (frontier s) SUBSET s``,
  METIS_TAC[frontier, CLOSURE_CLOSED, DIFF_SUBSET]);

val FRONTIER_EMPTY = store_thm ("FRONTIER_EMPTY",
 ``frontier {} = {}``,
  REWRITE_TAC[frontier, CLOSURE_EMPTY, EMPTY_DIFF]);

val FRONTIER_UNIV = store_thm ("FRONTIER_UNIV",
 ``frontier univ(:real) = {}``,
  REWRITE_TAC[frontier, CLOSURE_UNIV, INTERIOR_UNIV] THEN SET_TAC[]);

val FRONTIER_SUBSET_EQ = store_thm ("FRONTIER_SUBSET_EQ",
 ``!s:real->bool. (frontier s) SUBSET s <=> closed s``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [FRONTIER_SUBSET_CLOSED] THEN
  REWRITE_TAC[frontier] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (SET_RULE
  ``s DIFF t SUBSET u ==> t SUBSET u ==> s SUBSET u``)) THEN
  REWRITE_TAC[INTERIOR_SUBSET, CLOSURE_SUBSET_EQ]);

val FRONTIER_COMPLEMENT = store_thm ("FRONTIER_COMPLEMENT",
 ``!s:real->bool. frontier(UNIV DIFF s) = frontier s``,
  REWRITE_TAC[frontier, CLOSURE_COMPLEMENT, INTERIOR_COMPLEMENT] THEN
  SET_TAC[]);

val FRONTIER_DISJOINT_EQ = store_thm ("FRONTIER_DISJOINT_EQ",
 ``!s. ((frontier s) INTER s = {}) <=> open s``,
  ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT, OPEN_CLOSED] THEN
  REWRITE_TAC[GSYM FRONTIER_SUBSET_EQ] THEN SET_TAC[]);

val FRONTIER_INTER_SUBSET = store_thm ("FRONTIER_INTER_SUBSET",
 ``!s t. frontier(s INTER t) SUBSET frontier(s) UNION frontier(t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTER] THEN
  MATCH_MP_TAC(SET_RULE ``cst SUBSET cs INTER ct
  ==> cst DIFF (s INTER t) SUBSET (cs DIFF s) UNION (ct DIFF t)``) THEN
  REWRITE_TAC[CLOSURE_INTER_SUBSET]);

val FRONTIER_UNION_SUBSET = store_thm ("FRONTIER_UNION_SUBSET",
 ``!s t:real->bool. frontier(s UNION t) SUBSET frontier s UNION frontier t``,
  ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT] THEN
  REWRITE_TAC[SET_RULE ``u DIFF (s UNION t) = (u DIFF s) INTER (u DIFF t)``] THEN
  REWRITE_TAC[FRONTIER_INTER_SUBSET]);

val FRONTIER_INTERIORS = store_thm ("FRONTIER_INTERIORS",
 ``!s. frontier s = univ(:real) DIFF interior(s) DIFF interior(univ(:real) DIFF s)``,
  REWRITE_TAC[frontier, CLOSURE_INTERIOR] THEN SET_TAC[]);

val FRONTIER_FRONTIER_SUBSET = store_thm ("FRONTIER_FRONTIER_SUBSET",
 ``!s:real->bool. frontier(frontier s) SUBSET frontier s``,
  GEN_TAC THEN GEN_REWR_TAC LAND_CONV [frontier] THEN
  SIMP_TAC std_ss [CLOSURE_CLOSED, FRONTIER_CLOSED] THEN SET_TAC[]);

val INTERIOR_FRONTIER = store_thm ("INTERIOR_FRONTIER",
 ``!s:real->bool.
    interior(frontier s) = interior(closure s) DIFF closure(interior s)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_COMPLEMENT, GSYM INTERIOR_INTER, frontier] THEN
  GEN_TAC THEN AP_TERM_TAC THEN SET_TAC[]);

val INTERIOR_FRONTIER_EMPTY = store_thm ("INTERIOR_FRONTIER_EMPTY",
 ``!s:real->bool. open s \/ closed s ==> (interior(frontier s) = {})``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[INTERIOR_FRONTIER] THEN
  ASM_SIMP_TAC std_ss [CLOSURE_CLOSED, INTERIOR_OPEN] THEN
  REWRITE_TAC[SET_RULE ``(s DIFF t = {}) <=> s SUBSET t``] THEN
  REWRITE_TAC[INTERIOR_SUBSET, CLOSURE_SUBSET]);

val FRONTIER_FRONTIER = store_thm ("FRONTIER_FRONTIER",
 ``!s:real->bool. open s \/ closed s ==> (frontier(frontier s) = frontier s)``,
  GEN_TAC THEN GEN_REWR_TAC (RAND_CONV o LAND_CONV) [frontier] THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [INTERIOR_FRONTIER_EMPTY, CLOSURE_CLOSED, FRONTIER_CLOSED] THEN
  REWRITE_TAC[DIFF_EMPTY]);

val FRONTIER_FRONTIER_FRONTIER = store_thm ("FRONTIER_FRONTIER_FRONTIER",
 ``!s:real->bool. frontier(frontier(frontier s)) = frontier(frontier s)``,
  SIMP_TAC std_ss [FRONTIER_FRONTIER, FRONTIER_CLOSED]);

val lemma = prove (
 ``!s t x. x IN frontier s /\ x IN interior t ==> x IN frontier(s INTER t)``,
  REWRITE_TAC[FRONTIER_STRADDLE, IN_INTER, IN_INTERIOR, SUBSET_DEF, IN_BALL] THEN
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (X_CHOOSE_TAC ``d:real``)) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min d e:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_MIN] THEN ASM_MESON_TAC[]);

val UNION_FRONTIER = store_thm ("UNION_FRONTIER",
 ``!s t:real->bool. frontier(s) UNION frontier(t) =
   frontier(s UNION t) UNION frontier(s INTER t) UNION
   frontier(s) INTER frontier(t)``,
  REWRITE_TAC[SET_EQ_SUBSET, UNION_SUBSET,
   FRONTIER_UNION_SUBSET, FRONTIER_INTER_SUBSET,
   SET_RULE ``s INTER t SUBSET s UNION t``] THEN
  REWRITE_TAC[GSYM UNION_SUBSET] THEN REWRITE_TAC[SUBSET_DEF, IN_UNION] THEN
  KNOW_TAC ``((!s t x. x IN frontier s
      ==> x IN frontier (s UNION t) \/
          x IN frontier (s INTER t) \/
          x IN frontier s INTER frontier t) /\
 (!s t x.
      x IN frontier (s UNION t) \/
      x IN frontier (s INTER t) \/
      x IN frontier s INTER frontier t <=>
      x IN frontier (t UNION s) \/
      x IN frontier (t INTER s) \/
      x IN frontier t INTER frontier s))`` THENL
  [ALL_TAC, METIS_TAC []] THEN CONJ_TAC THENL
  [REPEAT STRIP_TAC, SIMP_TAC std_ss [UNION_COMM, INTER_COMM]] THEN
  ASM_CASES_TAC ``(x:real) IN frontier t`` THEN ASM_REWRITE_TAC[IN_INTER] THEN
  POP_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o RAND_CONV o RAND_CONV)
   [FRONTIER_INTERIORS] THEN
  REWRITE_TAC[DE_MORGAN_THM, IN_DIFF, IN_UNIV] THEN
  GEN_REWR_TAC RAND_CONV [DISJ_SYM] THEN MATCH_MP_TAC MONO_OR THEN
  ASM_SIMP_TAC std_ss [lemma] THEN
  POP_ASSUM MP_TAC THEN ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT] THEN
  SIMP_TAC std_ss [lemma, SET_RULE
  ``UNIV DIFF (s UNION t) = (UNIV DIFF s) INTER (UNIV DIFF t)``]);

val CONNECTED_INTER_FRONTIER = store_thm ("CONNECTED_INTER_FRONTIER",
 ``!s t:real->bool.
    connected s /\ ~(s INTER t = {}) /\ ~(s DIFF t = {})
    ==> ~(s INTER frontier t = {})``,
  REWRITE_TAC[FRONTIER_INTERIORS] THEN REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected s`` THEN REWRITE_TAC [CONNECTED_OPEN_IN] THEN
  MAP_EVERY EXISTS_TAC
   [``s INTER interior t:real->bool``,
    ``s INTER (interior(univ(:real) DIFF t))``] THEN
  SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_INTERIOR] THEN
  MAP_EVERY (MP_TAC o C ISPEC INTERIOR_SUBSET)
   [``t:real->bool``, ``univ(:real) DIFF t``] THEN
  ASM_SET_TAC[]);

val INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER = store_thm ("INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER",
 ``!s:real->bool. closed s /\ (interior s = {}) <=>
                ?t. open t /\ (s = frontier t)``,
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [EXISTS_TAC ``univ(:real) DIFF s`` THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, OPEN_UNIV, FRONTIER_COMPLEMENT] THEN
  ASM_SIMP_TAC std_ss [frontier, CLOSURE_CLOSED, DIFF_EMPTY],
  ASM_SIMP_TAC std_ss [FRONTIER_CLOSED, INTERIOR_FRONTIER_EMPTY]]);

val FRONTIER_UNION = store_thm ("FRONTIER_UNION",
 ``!s t:real->bool. (closure s INTER closure t = {})
    ==> (frontier(s UNION t) = frontier(s) UNION frontier(t))``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[FRONTIER_UNION_SUBSET] THEN
  GEN_REWR_TAC RAND_CONV [frontier] THEN
  REWRITE_TAC[CLOSURE_UNION] THEN MATCH_MP_TAC(SET_RULE
  ``(fs SUBSET cs /\ ft SUBSET ct) /\ (k INTER fs = {}) /\ (k INTER ft = {})
    ==> (fs UNION ft) SUBSET (cs UNION ct) DIFF k``) THEN
  CONJ_TAC THENL [REWRITE_TAC[frontier] THEN SET_TAC[], ALL_TAC] THEN
  CONJ_TAC THENL [ALL_TAC,
   ONCE_REWRITE_TAC[UNION_COMM] THEN
   RULE_ASSUM_TAC(ONCE_REWRITE_RULE[INTER_COMM])] THEN
   FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
   ``(s INTER t = {}) ==> s' SUBSET s /\ (s' INTER u INTER (UNIV DIFF t) = {})
     ==> (u INTER s' = {})``)) THEN
  REWRITE_TAC[frontier, DIFF_SUBSET, GSYM INTERIOR_COMPLEMENT] THENL
  [KNOW_TAC ``(closure s DIFF interior s) INTER
                     interior (s UNION t) INTER
            interior (univ(:real) DIFF t) =
              (closure s DIFF interior s) INTER
           interior ((s UNION t) INTER (univ(:real) DIFF t))`` THENL
   [METIS_TAC [INTERIOR_INTER, INTER_ASSOC], ALL_TAC] THEN DISC_RW_KILL,
   KNOW_TAC ``(closure t DIFF interior t) INTER
                    interior (t UNION s) INTER
           interior (univ(:real) DIFF s) =
             (closure t DIFF interior t) INTER
           interior ((t UNION s) INTER (univ(:real) DIFF s))`` THENL
   [METIS_TAC [INTERIOR_INTER, INTER_ASSOC], ALL_TAC] THEN DISC_RW_KILL] THEN
  REWRITE_TAC[SET_RULE ``(s UNION t) INTER (UNIV DIFF t) = s DIFF t``] THEN
  MATCH_MP_TAC(SET_RULE
  ``ti SUBSET si ==> ((c DIFF si) INTER ti = {})``) THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, DIFF_SUBSET]);

val CLOSURE_UNION_FRONTIER = store_thm ("CLOSURE_UNION_FRONTIER",
 ``!s:real->bool. closure s = s UNION frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier] THEN
  MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  SET_TAC[]);

val FRONTIER_INTERIOR_SUBSET = store_thm ("FRONTIER_INTERIOR_SUBSET",
 ``!s:real->bool. frontier(interior s) SUBSET frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTERIOR] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> s DIFF u SUBSET t DIFF u``) THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, INTERIOR_SUBSET]);

val FRONTIER_CLOSURE_SUBSET = store_thm ("FRONTIER_CLOSURE_SUBSET",
 ``!s:real->bool. frontier(closure s) SUBSET frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier, CLOSURE_CLOSURE] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> u DIFF t SUBSET u DIFF s``) THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, CLOSURE_SUBSET]);

val SET_DIFF_FRONTIER = store_thm ("SET_DIFF_FRONTIER",
 ``!s:real->bool. s DIFF frontier s = interior s``,
  GEN_TAC THEN REWRITE_TAC[frontier] THEN
  MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  SET_TAC[]);

val FRONTIER_INTER_SUBSET_INTER = store_thm ("FRONTIER_INTER_SUBSET_INTER",
 ``!s t:real->bool.
   frontier(s INTER t) SUBSET closure s INTER frontier t UNION
   frontier s INTER closure t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTER] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
   CLOSURE_INTER_SUBSET) THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* A variant of nets (slightly non-standard but good for our purposes).      *)
(* ------------------------------------------------------------------------- *)

val isnet = new_definition("isnet",
 ``!g. isnet g = !x y. (!z. g z x ==> g z y) \/
                       (!z. g z y ==> g z x)``);

val net_tydef = new_type_definition
 ("net",
  prove (``?(g:'a->'a->bool). isnet g``,
        EXISTS_TAC ``\x:'a y:'a. F`` THEN REWRITE_TAC[isnet]));

val net_ty_bij = define_new_type_bijections
    {name="net_tybij",
     ABS="mk_net", REP="netord",tyax=net_tydef};

val net_tybij = store_thm ("net_tybij",
  ``(!a. mk_net (netord a) = a) /\
    (!r. (!x y. (!z. r z x ==> r z y) \/ (!z. r z y ==> r z x)) <=>
          (netord (mk_net r) = r))``,
  SIMP_TAC std_ss [net_ty_bij, GSYM isnet]);

val NET = store_thm ("NET",
 ``!n x y. (!z. netord n z x ==> netord n z y) \/
           (!z. netord n z y ==> netord n z x)``,
   REWRITE_TAC[net_tybij, ETA_AX]);

val OLDNET = store_thm ("OLDNET",
 ``!n x y. netord n x x /\ netord n y y
           ==> ?z. netord n z z /\
                   !w. netord n w z ==> netord n w x /\ netord n w y``,
  MESON_TAC[NET]);

val NET_DILEMMA = store_thm ("NET_DILEMMA",
 ``!net. (?a. (?x. netord net x a) /\ (!x. netord net x a ==> P x)) /\
         (?b. (?x. netord net x b) /\ (!x. netord net x b ==> Q x))
         ==> ?c. (?x. netord net x c) /\ (!x. netord net x c ==> P x /\ Q x)``,
  MESON_TAC[NET]);

(* ------------------------------------------------------------------------- *)
(* Common nets and the "within" modifier for nets.                           *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "within" (Infix(NONASSOC, 450));
val _ = set_fixity "in_direction" (Infix(NONASSOC, 450));

val at = new_definition ("at",
  ``at a = mk_net(\x y. &0 < dist(x,a) /\ dist(x,a) <= dist(y,a))``);

val at_infinity = new_definition ("at_infinity",
  ``at_infinity = mk_net(\x y. abs(x) >= abs(y))``);

val at_posinfinity = new_definition ("at_posinfinity",
  ``at_posinfinity = mk_net(\x y:real. x >= y)``);

val at_neginfinity = new_definition ("at_neginfinity",
  ``at_neginfinity = mk_net(\x y:real. x <= y)``);

val sequentially = new_definition ("sequentially",
  ``sequentially = mk_net(\m:num n. m >= n)``);

val within = new_definition ("within",
  ``(net within s) = mk_net(\x y. netord net x y /\ x IN s)``);

val in_direction = new_definition ("in_direction",
  ``(a in_direction v) = ((at a) within {b | ?c. &0 <= c /\ (b - a = c * v)})``);

(* ------------------------------------------------------------------------- *)
(* Prove that they are all nets.                                             *)
(* ------------------------------------------------------------------------- *)

fun NET_PROVE_TAC [def] =
  SIMP_TAC std_ss [GSYM FUN_EQ_THM, def] THEN
  REWRITE_TAC [ETA_AX] THEN
  ASM_SIMP_TAC std_ss [GSYM(CONJUNCT2 net_tybij)];

val AT = store_thm ("AT",
 ``!a:real x y.
        netord(at a) x y <=> &0 < dist(x,a) /\ dist(x,a) <= dist(y,a)``,
  GEN_TAC THEN NET_PROVE_TAC[at] THEN
  METIS_TAC[REAL_LE_TOTAL, REAL_LE_REFL, REAL_LE_TRANS, REAL_LET_TRANS]);

val AT_INFINITY = store_thm ("AT_INFINITY",
 ``!x y. netord at_infinity x y <=> abs(x) >= abs(y)``,
  NET_PROVE_TAC[at_infinity] THEN
  REWRITE_TAC[real_ge, REAL_LE_REFL] THEN
  MESON_TAC[REAL_LE_TOTAL, REAL_LE_REFL, REAL_LE_TRANS]);

val AT_POSINFINITY = store_thm ("AT_POSINFINITY",
 ``!x y. netord at_posinfinity x y <=> x >= y``,
  NET_PROVE_TAC[at_posinfinity] THEN
  REWRITE_TAC[real_ge, REAL_LE_REFL] THEN
  MESON_TAC[REAL_LE_TOTAL, REAL_LE_REFL, REAL_LE_TRANS]);

val AT_NEGINFINITY = store_thm ("AT_NEGINFINITY",
 ``!x y. netord at_neginfinity x y <=> x <= y``,
  NET_PROVE_TAC[at_neginfinity] THEN
  REWRITE_TAC[real_ge, REAL_LE_REFL] THEN
  MESON_TAC[REAL_LE_TOTAL, REAL_LE_REFL, REAL_LE_TRANS]);

val SEQUENTIALLY = store_thm ("SEQUENTIALLY",
 ``!m n. netord sequentially m n <=> m >= n``,
  NET_PROVE_TAC[sequentially] THEN REWRITE_TAC[GREATER_EQ, LESS_EQ_REFL] THEN
  MESON_TAC[LESS_EQ_CASES, LESS_EQ_REFL, LESS_EQ_TRANS]);

val WITHIN = store_thm ("WITHIN",
 ``!n s x y. netord(n within s) x y <=> netord n x y /\ x IN s``,
  GEN_TAC THEN GEN_TAC THEN SIMP_TAC std_ss [within, GSYM FUN_EQ_THM] THEN
  REWRITE_TAC[GSYM(CONJUNCT2 net_tybij), ETA_AX] THEN
  METIS_TAC[NET]);

val IN_DIRECTION = store_thm ("IN_DIRECTION",
 ``!a v x y. netord(a in_direction v) x y <=>
                &0 < dist(x,a) /\ dist(x,a) <= dist(y,a) /\
                 ?c. &0 <= c /\ (x - a = c * v)``,
  SIMP_TAC std_ss [WITHIN, AT, in_direction, GSPECIFICATION] THEN METIS_TAC []);

val WITHIN_UNIV = store_thm ("WITHIN_UNIV",
 ``!x:real. (at x within UNIV) = at x``,
  REWRITE_TAC[within, at, IN_UNIV] THEN REWRITE_TAC[ETA_AX, net_tybij]);

val WITHIN_WITHIN = store_thm ("WITHIN_WITHIN",
 ``!net s t. ((net within s) within t) = (net within (s INTER t))``,
  ONCE_REWRITE_TAC[within] THEN
  REWRITE_TAC[WITHIN, IN_INTER, GSYM CONJ_ASSOC]);

(* ------------------------------------------------------------------------- *)
(* Identify trivial limits, where we can't approach arbitrarily closely.     *)
(* ------------------------------------------------------------------------- *)

val trivial_limit = new_definition ("trivial_limit",
  ``trivial_limit net <=>
     (!a:'a b. a = b) \/
     ?a:'a b. ~(a = b) /\ !x. ~(netord(net) x a) /\ ~(netord(net) x b)``);

val TRIVIAL_LIMIT_WITHIN = store_thm ("TRIVIAL_LIMIT_WITHIN",
 ``!a:real. trivial_limit (at a within s) <=> ~(a limit_point_of s)``,
  REWRITE_TAC[trivial_limit, LIMPT_APPROACHABLE_LE, WITHIN, AT, DIST_NZ] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(DISJ_CASES_THEN MP_TAC) THENL
     [MESON_TAC[REAL_LT_01, REAL_LT_REFL, REAL_CHOOSE_DIST,
                DIST_REFL, REAL_LT_IMP_LE],
      DISCH_THEN(X_CHOOSE_THEN ``b:real`` (X_CHOOSE_THEN ``c:real``
        STRIP_ASSUME_TAC)) THEN
      SUBGOAL_THEN ``&0 < dist(a,b:real) \/ &0 < dist(a,c:real)`` MP_TAC THEN
      ASM_MESON_TAC[DIST_TRIANGLE, DIST_SYM, GSYM DIST_NZ, GSYM DIST_EQ_0,
                    REAL_ARITH ``x:real <= &0 + &0 ==> ~(&0 < x)``]],
    KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ 0 < dist (x',a) /\ dist (x',a) <= e) =
           (\e. 0 < e ==> ?x'. x' IN s /\ 0 < dist (x',a) /\ dist (x',a) <= e) e`` THENL
    [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
    REWRITE_TAC[NOT_FORALL_THM] THEN BETA_TAC THEN REWRITE_TAC [NOT_IMP] THEN
    SIMP_TAC std_ss [GSYM LEFT_EXISTS_IMP_THM] THEN
    STRIP_TAC THEN DISJ2_TAC THEN
    EXISTS_TAC ``a:real`` THEN
    SUBGOAL_THEN ``?b:real. dist(a,b) = x`` MP_TAC THENL
     [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_LT_IMP_LE], ALL_TAC] THEN
    STRIP_TAC THEN EXISTS_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
    DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
    ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_NZ, DIST_SYM]]);

val TRIVIAL_LIMIT_AT = store_thm ("TRIVIAL_LIMIT_AT",
 ``!a. ~(trivial_limit (at a))``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN, LIMPT_UNIV]);

val TRIVIAL_LIMIT_AT_INFINITY = store_thm ("TRIVIAL_LIMIT_AT_INFINITY",
 ``~(trivial_limit at_infinity)``,
  REWRITE_TAC[trivial_limit, AT_INFINITY, real_ge] THEN
  MESON_TAC[REAL_LE_REFL, REAL_CHOOSE_SIZE, REAL_LT_01, REAL_LT_LE]);

val TRIVIAL_LIMIT_AT_POSINFINITY = store_thm ("TRIVIAL_LIMIT_AT_POSINFINITY",
 ``~(trivial_limit at_posinfinity)``,
  REWRITE_TAC[trivial_limit, AT_POSINFINITY, DE_MORGAN_THM] THEN
  CONJ_TAC THENL
   [DISCH_THEN(MP_TAC o SPECL [``&0:real``, ``&1:real``]) THEN REAL_ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[DE_MORGAN_THM, NOT_EXISTS_THM, real_ge, REAL_NOT_LE] THEN
  MESON_TAC[REAL_LT_TOTAL, REAL_LT_ANTISYM]);

val TRIVIAL_LIMIT_AT_NEGINFINITY = store_thm ("TRIVIAL_LIMIT_AT_NEGINFINITY",
 ``~(trivial_limit at_neginfinity)``,
  REWRITE_TAC[trivial_limit, AT_NEGINFINITY, DE_MORGAN_THM] THEN
  CONJ_TAC THENL
   [DISCH_THEN(MP_TAC o SPECL [``&0:real``, ``&1:real``]) THEN REAL_ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[DE_MORGAN_THM, NOT_EXISTS_THM, real_ge, REAL_NOT_LE] THEN
  MESON_TAC[REAL_LT_TOTAL, REAL_LT_ANTISYM]);

val TRIVIAL_LIMIT_SEQUENTIALLY = store_thm ("TRIVIAL_LIMIT_SEQUENTIALLY",
 ``~(trivial_limit sequentially)``,
  REWRITE_TAC[trivial_limit, SEQUENTIALLY] THEN
  MESON_TAC[GREATER_EQ, LESS_EQ_REFL, SUC_NOT]);

val LIM_WITHIN_CLOSED_TRIVIAL = store_thm ("LIM_WITHIN_CLOSED_TRIVIAL",
 ``!a s. closed s /\ ~(a IN s) ==> trivial_limit (at a within s)``,
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN] THEN MESON_TAC[CLOSED_LIMPT]);

val NONTRIVIAL_LIMIT_WITHIN = store_thm ("NONTRIVIAL_LIMIT_WITHIN",
 ``!net s. trivial_limit net ==> trivial_limit(net within s)``,
  REWRITE_TAC[trivial_limit, WITHIN] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some property holds "sufficiently close" to the limit point.              *)
(* ------------------------------------------------------------------------- *)

val eventually = new_definition ("eventually",
 ``eventually p net <=>
        trivial_limit net \/
        ?y. (?x. netord net x y) /\ (!x. netord net x y ==> p x)``);

val EVENTUALLY_HAPPENS = store_thm ("EVENTUALLY_HAPPENS",
 ``!net p. eventually p net ==> trivial_limit net \/ ?x. p x``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_WITHIN_LE = store_thm ("EVENTUALLY_WITHIN_LE",
 ``!s a:real p.
     eventually p (at a within s) <=>
        ?d. &0 < d /\ !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) <= d ==> p(x)``,
  REWRITE_TAC[eventually, AT, WITHIN, TRIVIAL_LIMIT_WITHIN] THEN
  REWRITE_TAC[LIMPT_APPROACHABLE_LE, DIST_NZ] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [MESON_TAC[REAL_LTE_TRANS], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC(TAUT `(a ==> b) ==> ~a \/ b`) THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?b:real. dist(a,b) = d`` MP_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_LT_IMP_LE], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
  ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_NZ, DIST_SYM]);

val EVENTUALLY_WITHIN = store_thm ("EVENTUALLY_WITHIN",
 ``!s a:real p.
     eventually p (at a within s) <=>
        ?d. &0 < d /\ !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) < d ==> p(x)``,
  REWRITE_TAC[EVENTUALLY_WITHIN_LE] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c ==> d <=> c ==> a /\ b ==> d`] THEN
  SIMP_TAC std_ss [APPROACHABLE_LT_LE]);

val EVENTUALLY_AT = store_thm ("EVENTUALLY_AT",
 ``!a p. eventually p (at a) <=>
         ?d. &0 < d /\ !x. &0 < dist(x,a) /\ dist(x,a) < d ==> p(x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[EVENTUALLY_WITHIN, IN_UNIV]);

val EVENTUALLY_SEQUENTIALLY = store_thm ("EVENTUALLY_SEQUENTIALLY",
 ``!p. eventually p sequentially <=> ?N. !n. N <= n ==> p n``,
  REWRITE_TAC[eventually, SEQUENTIALLY, GREATER_EQ, LESS_EQ_REFL,
    TRIVIAL_LIMIT_SEQUENTIALLY] THEN  MESON_TAC[LESS_EQ_REFL]);

val EVENTUALLY_AT_INFINITY = store_thm ("EVENTUALLY_AT_INFINITY",
 ``!p. eventually p at_infinity <=> ?b. !x. abs(x) >= b ==> p x``,
  SIMP_TAC std_ss [eventually, AT_INFINITY, TRIVIAL_LIMIT_AT_INFINITY] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
  MESON_TAC[real_ge, REAL_LE_REFL, REAL_CHOOSE_SIZE,
    REAL_ARITH ``&0 <= b:real \/ (!x. x >= &0 ==> x >= b)``]);

val EVENTUALLY_AT_POSINFINITY = store_thm ("EVENTUALLY_AT_POSINFINITY",
 ``!p. eventually p at_posinfinity <=> ?b. !x. x >= b ==> p x``,
  REWRITE_TAC[eventually, TRIVIAL_LIMIT_AT_POSINFINITY, AT_POSINFINITY] THEN
  MESON_TAC[REAL_ARITH ``x >= x``]);

val EVENTUALLY_AT_NEGINFINITY = store_thm ("EVENTUALLY_AT_NEGINFINITY",
 ``!p. eventually p at_neginfinity <=> ?b. !x. x <= b ==> p x``,
  REWRITE_TAC[eventually, TRIVIAL_LIMIT_AT_NEGINFINITY, AT_NEGINFINITY] THEN
  MESON_TAC[REAL_LE_REFL]);

val EVENTUALLY_AT_INFINITY_POS = store_thm ("EVENTUALLY_AT_INFINITY_POS",
 ``!p:real->bool.
        eventually p at_infinity <=> ?b. &0 < b /\ !x. abs x >= b ==> p x``,
  GEN_TAC THEN REWRITE_TAC[EVENTUALLY_AT_INFINITY, real_ge] THEN
  MESON_TAC[REAL_ARITH ``&0 < abs b + &1 /\ (abs b + &1 <= x ==> b <= x:real)``]);

val ALWAYS_EVENTUALLY = store_thm ("ALWAYS_EVENTUALLY",
 ``(!x. p x) ==> eventually p net``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[eventually, trivial_limit] THEN
  MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Combining theorems for "eventually". *)
(* ------------------------------------------------------------------------- *)

val EVENTUALLY_AND = store_thm ("EVENTUALLY_AND",
 ``!net:('a net) p q.
   eventually (\x. p x /\ q x) net <=>
   eventually p net /\ eventually q net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[eventually] THEN
  ASM_CASES_TAC ``trivial_limit(net:('a net))`` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THEN SIMP_TAC std_ss [NET_DILEMMA] THENL [MESON_TAC [], ALL_TAC] THEN
  DISCH_TAC THEN MATCH_MP_TAC NET_DILEMMA THEN METIS_TAC []);

val EVENTUALLY_MONO = store_thm ("EVENTUALLY_MONO",
 ``!net:('a net) p q.
  (!x. p x ==> q x) /\ eventually p net
    ==> eventually q net``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_MP = store_thm ("EVENTUALLY_MP",
 ``!net:('a net) p q.
  eventually (\x. p x ==> q x) net /\ eventually p net
  ==> eventually q net``,
  REWRITE_TAC[GSYM EVENTUALLY_AND] THEN
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_FALSE = store_thm ("EVENTUALLY_FALSE",
 ``!net. eventually (\x. F) net <=> trivial_limit net``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_TRUE = store_thm ("EVENTUALLY_TRUE",
 ``!net. eventually (\x. T) net <=> T``,
  REWRITE_TAC[eventually, trivial_limit] THEN MESON_TAC[]);

val NOT_EVENTUALLY = store_thm ("NOT_EVENTUALLY",
 ``!net p. (!x. ~(p x)) /\ ~(trivial_limit net) ==> ~(eventually p net)``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_FORALL = store_thm ("EVENTUALLY_FORALL",
 ``!net:('a net) p s:'b->bool.
  FINITE s /\ ~(s = {})
  ==> (eventually (\x. !a. a IN s ==> p a x) net <=>
   !a. a IN s ==> eventually (p a) net)``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s:'b->bool. (s <> ({} :'b -> bool) ==>
   (eventually (\(x :'a). !(a :'b). a IN s ==> (p :'b -> 'a -> bool) a x)
   (net :'a net) <=> !(a :'b). a IN s ==> eventually (p a) net)) =
             (\s. s <> ({} :'b -> bool) ==>
   (eventually (\(x :'a). !(a :'b). a IN s ==> (p :'b -> 'a -> bool) a x)
   (net :'a net) <=> !(a :'b). a IN s ==> eventually (p a) net)) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, EVENTUALLY_AND, ETA_AX] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``t:'b->bool``, ``b:'b``] THEN
  ASM_CASES_TAC ``t:'b->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, EVENTUALLY_TRUE] THEN METIS_TAC []);

val FORALL_EVENTUALLY = store_thm ("FORALL_EVENTUALLY",
 ``!net:('a net) p s:'b->bool.
   FINITE s /\ ~(s = {})
   ==> ((!a. a IN s ==> eventually (p a) net) <=>
   eventually (\x. !a. a IN s ==> p a x) net)``,
  SIMP_TAC std_ss [EVENTUALLY_FORALL]);

(* ------------------------------------------------------------------------- *)
(* Limits, defined as vacuously true when the limit is trivial.              *)
(* ------------------------------------------------------------------------- *)

val _ = hide "-->";

val tendsto = new_infixr_definition("tendsto",
  ``$--> f l net = !e. &0 < e ==> eventually (\x. dist(f(x),l) < e) net``,750);

val lim_def = new_definition ("lim_def",
 ``lim_def net f = @l. (f --> l) net``);

val _ = overload_on ("lim",``lim_def``);

val LIM = store_thm ("LIM",
 ``(f --> l) net <=>
        trivial_limit net \/
        !e. &0 < e ==> ?y. (?x. netord(net) x y) /\
                           !x. netord(net) x y ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, eventually] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Show that they yield usual definitions in the various cases.              *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_LE = store_thm ("LIM_WITHIN_LE",
 ``!f:real->real l a s.
        (f --> l)(at a within s) <=>
           !e. &0 < e ==> ?d. &0 < d /\
                              !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) <= d
                                   ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN_LE]);

val LIM_WITHIN = store_thm ("LIM_WITHIN",
 ``!f:real->real l a s.
      (f --> l) (at a within s) <=>
        !e. &0 < e
            ==> ?d. &0 < d /\
                    !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) < d
                    ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN] THEN MESON_TAC[]);

val LIM_AT_LE = store_thm ("LIM_AT_LE",
 ``!f l a. (f --> l) (at a) <=>
           !e. &0 < e
               ==> ?d. &0 < d /\
                       !x. &0 < dist(x,a) /\ dist(x,a) <= d
                           ==> dist (f x,l) < e``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[LIM_WITHIN_LE, IN_UNIV]);

val LIM_AT = store_thm ("LIM_AT",
 ``!f l:real a:real.
      (f --> l) (at a) <=>
              !e. &0 < e
                  ==> ?d. &0 < d /\ !x. &0 < dist(x,a) /\ dist(x,a) < d
                          ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT] THEN MESON_TAC[]);

val LIM_AT_INFINITY = store_thm ("LIM_AT_INFINITY",
 ``!f l. (f --> l) at_infinity <=>
               !e. &0 < e ==> ?b. !x. abs(x) >= b ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_AT_INFINITY] THEN MESON_TAC[]);

val LIM_AT_INFINITY_POS = store_thm ("LIM_AT_INFINITY_POS",
 ``!f l. (f --> l) at_infinity <=>
         !e. &0 < e ==> ?b. &0 < b /\ !x. abs x >= b ==> dist(f x,l) < e``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [LIM_AT_INFINITY] THEN
  METIS_TAC[REAL_ARITH ``&0 < abs b + &1 /\ (x >= abs b + &1 ==> x >= b)``]);

val LIM_AT_POSINFINITY = store_thm ("LIM_AT_POSINFINITY",
 ``!f l. (f --> l) at_posinfinity <=>
               !e. &0 < e ==> ?b. !x. x >= b ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT_POSINFINITY] THEN MESON_TAC[]);

val LIM_AT_NEGINFINITY = store_thm ("LIM_AT_NEGINFINITY",
 ``!f l. (f --> l) at_neginfinity <=>
               !e. &0 < e ==> ?b. !x. x <= b ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT_NEGINFINITY] THEN MESON_TAC[]);

val LIM_SEQUENTIALLY = store_thm ("LIM_SEQUENTIALLY",
 ``!s l. (s --> l) sequentially <=>
          !e. &0 < e ==> ?N. !n. N <= n ==> dist(s(n),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_SEQUENTIALLY] THEN MESON_TAC[]);

val LIM_EVENTUALLY = store_thm ("LIM_EVENTUALLY",
 ``!net f l. eventually (\x. f x = l) net ==> (f --> l) net``,
  REWRITE_TAC[eventually, LIM] THEN MESON_TAC[DIST_REFL]);

val LIM_POSINFINITY_SEQUENTIALLY = store_thm ("LIM_POSINFINITY_SEQUENTIALLY",
 ``!f l. (f --> l) at_posinfinity ==> ((\n. f(&n)) --> l) sequentially``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[LIM_AT_POSINFINITY, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real``) THEN
  MP_TAC(ISPEC ``B:real`` SIMP_REAL_ARCH) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``N:num`` THEN POP_ASSUM MP_TAC THEN
  REPEAT STRIP_TAC THEN BETA_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM REAL_OF_NUM_LE]) THEN
  METIS_TAC [real_ge, REAL_LE_TRANS]);

val LIM_INFINITY_POSINFINITY = store_thm ("LIM_INFINITY_POSINFINITY",
 ``!f l:real. (f --> l) at_infinity ==> (f --> l) at_posinfinity``,
  SIMP_TAC std_ss [LIM_AT_INFINITY, LIM_AT_POSINFINITY, o_THM] THEN
  METIS_TAC[dist, REAL_ARITH ``x >= b ==> abs(x) >= b:real``]);

(* ------------------------------------------------------------------------- *)
(* The expected monotonicity property.                                       *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_EMPTY = store_thm ("LIM_WITHIN_EMPTY",
 ``!f l x. (f --> l) (at x within {})``,
  REWRITE_TAC[LIM_WITHIN, NOT_IN_EMPTY] THEN MESON_TAC[REAL_LT_01]);

val LIM_WITHIN_SUBSET = store_thm ("LIM_WITHIN_SUBSET",
 ``!f l a s.
    (f --> l) (at a within s) /\ t SUBSET s ==> (f --> l) (at a within t)``,
  REWRITE_TAC[LIM_WITHIN, SUBSET_DEF] THEN MESON_TAC[]);

val LIM_UNION = store_thm ("LIM_UNION",
 ``!f x l s t.
        (f --> l) (at x within s) /\ (f --> l) (at x within t)
        ==> (f --> l) (at x within (s UNION t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM_WITHIN, IN_UNION] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``d1:real``) (X_CHOOSE_TAC ``d2:real``)) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_MESON_TAC[REAL_LT_MIN]);

val LIM_UNION_UNIV = store_thm ("LIM_UNION_UNIV",
 ``!f x l s t.
        (f --> l) (at x within s) /\ (f --> l) (at x within t) /\
        (s UNION t = univ(:real)) ==> (f --> l) (at x)``,
  MESON_TAC[LIM_UNION, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Composition of limits.                                                    *)
(* ------------------------------------------------------------------------- *)

val LIM_COMPOSE_WITHIN = store_thm ("LIM_COMPOSE_WITHIN",
 ``!net f:'a->real g:real->real s y z.
    (f --> y) net /\
    eventually (\w. f w IN s /\ ((f w = y) ==> (g y = z))) net /\
    (g --> z) (at y within s)
    ==> ((g o f) --> z) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[tendsto, CONJ_ASSOC] THEN
  KNOW_TAC ``(!e. (&0 < e ==> eventually (\x. dist ((f:'a->real) x,y) < e) net) /\
             eventually (\w. f w IN s /\ ((f w = y) ==> ((g:real->real) y = z))) net) /\
   (!e. &0 < e ==> eventually (\x. dist (g x,z) < e) (at y within s))
   ==> (!e. &0 < e ==> eventually (\x. dist ((g o f) x,z) < e) net)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [LEFT_AND_FORALL_THM]] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  STRIP_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[EVENTUALLY_WITHIN, GSYM DIST_NZ, o_DEF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!e. (0 < e ==> eventually (\x. dist (f x,y) < e) net) /\
        eventually (\w. f w IN s /\ ((f:'a->real w = y) ==> (g:real->real y = z))) net`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``d:real``) THEN
  ASM_REWRITE_TAC[GSYM EVENTUALLY_AND] THEN BETA_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  ASM_MESON_TAC[DIST_REFL]);

val LIM_COMPOSE_AT = store_thm ("LIM_COMPOSE_AT",
 ``!net f:'a->real g:real->real y z.
    (f --> y) net /\
    eventually (\w. (f w = y) ==> (g y = z)) net /\
    (g --> z) (at y)
    ==> ((g o f) --> z) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``net:('a)net``, ``f:'a->real``, ``g:real->real``,
                 ``univ(:real)``, ``y:real``, ``z:real``]
        LIM_COMPOSE_WITHIN) THEN
  ASM_REWRITE_TAC[IN_UNIV, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Interrelations between restricted and unrestricted limits.                *)
(* ------------------------------------------------------------------------- *)

val LIM_AT_WITHIN = store_thm ("LIM_AT_WITHIN",
 ``!f l a s. (f --> l)(at a) ==> (f --> l)(at a within s)``,
  REWRITE_TAC[LIM_AT, LIM_WITHIN] THEN MESON_TAC[]);

val LIM_WITHIN_OPEN = store_thm ("LIM_WITHIN_OPEN",
 ``!f l a:real s.
     a IN s /\ open s ==> ((f --> l)(at a within s) <=> (f --> l)(at a))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [LIM_AT_WITHIN] THEN
  REWRITE_TAC[LIM_AT, LIM_WITHIN] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
   DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``open s`` THEN GEN_REWR_TAC LAND_CONV [open_def] THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(SPECL [``d1:real``, ``d2:real``] REAL_DOWN2) THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[REAL_LT_TRANS]);

(* ------------------------------------------------------------------------- *)
(* Segment of natural numbers starting at a specific number.                 *)
(* ------------------------------------------------------------------------- *)

val from_def = Define
   `from n = {m:num | n <= m}`;

val FROM_0 = store_thm ("FROM_0",
  ``from 0 = univ(:num)``,
    REWRITE_TAC [from_def, ZERO_LESS_EQ, GSPEC_T]);

val IN_FROM = store_thm ("IN_FROM",
  ``!m n. m IN from n <=> n <= m``,
    SIMP_TAC std_ss [from_def, GSPECIFICATION]);

val DISJOINT_COUNT_FROM = store_thm
  ("DISJOINT_COUNT_FROM", ``!n. DISJOINT (count n) (from n)``,
    RW_TAC arith_ss [from_def, count_def, DISJOINT_DEF, Once EXTENSION, NOT_IN_EMPTY,
                     GSPECIFICATION, IN_INTER]);

val DISJOINT_FROM_COUNT = store_thm
  ("DISJOINT_FROM_COUNT", ``!n. DISJOINT (from n) (count n)``,
    RW_TAC std_ss [Once DISJOINT_SYM, DISJOINT_COUNT_FROM]);

val UNION_COUNT_FROM = store_thm
  ("UNION_COUNT_FROM", ``!n. (count n) UNION (from n) = UNIV``,
    RW_TAC arith_ss [from_def, count_def, Once EXTENSION, NOT_IN_EMPTY,
                     GSPECIFICATION, IN_UNION, IN_UNIV]);

val UNION_FROM_COUNT = store_thm
  ("UNION_FROM_COUNT", ``!n. (from n) UNION (count n) = UNIV``,
    RW_TAC std_ss [Once UNION_COMM, UNION_COUNT_FROM]);

val FROM_INTER_NUMSEG_GEN = store_thm ("FROM_INTER_NUMSEG_GEN",
 ``!k m n. (from k) INTER (m..n) = (if m < k then k..n else m..n)``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [from_def, GSPECIFICATION, IN_INTER, IN_NUMSEG, EXTENSION] THEN
  ARITH_TAC);

val FROM_INTER_NUMSEG_MAX = store_thm ("FROM_INTER_NUMSEG_MAX",
 ``!m n p. from p INTER (m..n) = (MAX p m..n)``,
  SIMP_TAC arith_ss [EXTENSION, IN_INTER, IN_NUMSEG, IN_FROM] THEN ARITH_TAC);

val FROM_INTER_NUMSEG = store_thm ("FROM_INTER_NUMSEG",
 ``!k n. (from k) INTER (0:num..n) = k..n``,
  SIMP_TAC std_ss [from_def, GSPECIFICATION, IN_INTER, IN_NUMSEG, EXTENSION] THEN
  ARITH_TAC);

val INFINITE_FROM = store_thm ("INFINITE_FROM",
  ``!n. INFINITE(from n)``,
   GEN_TAC THEN KNOW_TAC ``from n = univ(:num) DIFF {i | i < n}`` THENL
  [SIMP_TAC std_ss [EXTENSION, from_def, IN_DIFF, IN_UNIV, GSPECIFICATION] THEN
   ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC INFINITE_DIFF_FINITE THEN
   REWRITE_TAC [FINITE_NUMSEG_LT, num_INFINITE]]);

(* ------------------------------------------------------------------------- *)
(* More limit point characterizations.                                       *)
(* ------------------------------------------------------------------------- *)

val WLOG_LT = store_thm ("WLOG_LT",
 ``(!m:num. P m m) /\ (!m n. P m n <=> P n m) /\ (!m n. m < n ==> P m n)
   ==> !m y. P m y``,
  METIS_TAC[LESS_LESS_CASES]);

val LT_EXISTS = store_thm ("LT_EXISTS",
 ``!m n. (m < n) <=> (?d. n = m + SUC d)``,
  GEN_TAC THEN INDUCT_TAC THEN SIMP_TAC std_ss [LESS_THM, ADD_CLAUSES, SUC_NOT] THEN
  ASM_REWRITE_TAC[INV_SUC_EQ] THEN EQ_TAC THENL
   [DISCH_THEN(DISJ_CASES_THEN2 SUBST1_TAC MP_TAC) THENL
     [EXISTS_TAC ``0:num`` THEN REWRITE_TAC[ADD_CLAUSES],
      DISCH_THEN(X_CHOOSE_THEN ``d:num`` SUBST1_TAC) THEN
      EXISTS_TAC ``SUC d`` THEN REWRITE_TAC[ADD_CLAUSES]],
  SIMP_TAC std_ss [LEFT_EXISTS_IMP_THM] THEN
  KNOW_TAC ``((?d. n = m + d) ==> (m = n) \/ ?d. n = m + SUC d) =
             (!d. (n = m + d) ==> (m = n) \/ ?d. n = m + SUC d)`` THENL
  [EQ_TAC THENL [SIMP_TAC std_ss [LEFT_EXISTS_IMP_THM],
   STRIP_TAC THEN STRIP_TAC THEN POP_ASSUM MP_TAC THEN
   POP_ASSUM (MP_TAC o Q.SPEC `d:num`) THEN FULL_SIMP_TAC std_ss []],
   ALL_TAC] THEN DISC_RW_KILL THEN
    INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES, INV_SUC_EQ] THEN
    DISCH_THEN SUBST1_TAC THEN REWRITE_TAC[] THEN DISJ2_TAC THEN
    EXISTS_TAC ``d:num`` THEN METIS_TAC[INV_SUC_EQ, ADD_COMM]]);

val TRANSITIVE_STEPWISE_LT_EQ = store_thm ("TRANSITIVE_STEPWISE_LT_EQ",
 ``!R. (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m < n ==> R m n) <=> (!n. R n (SUC n)))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC std_ss [LESS_THM] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [LT_EXISTS] THEN
  KNOW_TAC ``(!m n. (?d. n = m + SUC d) ==> R m n) =
              (!m d n. (n = m + SUC d) ==> R m (m + SUC d))`` THENL
  [METIS_TAC [LEFT_EXISTS_IMP_THM, SWAP_FORALL_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN GEN_TAC THEN
  SIMP_TAC std_ss [LEFT_FORALL_IMP_THM, EXISTS_REFL, ADD_CLAUSES] THEN
  INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES] THEN ASM_MESON_TAC[]);

val TRANSITIVE_STEPWISE_LT = store_thm ("TRANSITIVE_STEPWISE_LT",
 ``!R. (!x y z. R x y /\ R y z ==> R x z) /\ (!n. R n (SUC n))
       ==> !m n. m < n ==> R m n``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(a ==> (c <=> b)) ==> a /\ b ==> c`) THEN
  MATCH_ACCEPT_TAC TRANSITIVE_STEPWISE_LT_EQ);

val LIMPT_SEQUENTIAL_INJ = store_thm ("LIMPT_SEQUENTIAL_INJ",
 ``!x:real s.
      x limit_point_of s <=>
             ?f. (!n. f(n) IN (s DELETE x)) /\
                 (!m n. (f m = f n) <=> (m = n)) /\
                 (f --> x) sequentially``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[LIMPT_APPROACHABLE, LIM_SEQUENTIALLY, IN_DELETE] THEN
  EQ_TAC THENL [ALL_TAC, MESON_TAC[GREATER_EQ, LESS_EQ_REFL]] THEN
  KNOW_TAC ``(!e. 0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e) =
             (!e. ?x'. &0 < e ==> x' IN s /\ ~(x' = x) /\ dist (x',x) < e)`` THENL
  [SIMP_TAC std_ss [GSYM RIGHT_EXISTS_IMP_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN STRIP_TAC THEN
  KNOW_TAC ``?z. (z 0 = f (&1)) /\
    (!n. z (SUC n):real = f (min (inv(&2 pow (SUC n))) (dist(z n,x))))`` THENL
  [RW_TAC real_ss [num_Axiom], ALL_TAC] THEN STRIP_TAC THEN
  EXISTS_TAC ``z:num->real`` THEN
  SUBGOAL_THEN
   ``!n. z(n) IN s /\ ~(z n:real = x) /\ dist(z n,x) < inv(&2 pow n)``
  ASSUME_TAC THENL
   [INDUCT_TAC THEN ASM_REWRITE_TAC[] THENL [REWRITE_TAC [pow, REAL_INV1] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_01], FIRST_X_ASSUM(MP_TAC o SPEC
     ``min (inv(&2 pow (SUC n))) (dist(z n:real,x))``) THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MIN, REAL_LT_INV_EQ, REAL_POW_LT, DIST_POS_LT,
                         REAL_ARITH ``0:real < 2``]],
    ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
     [KNOW_TAC ``!m:num n. (((z:num->real) m = z n) <=> (m = n)) =
                    (\m n. ((z m = z n) <=> (m = n))) m n`` THENL
     [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
     MATCH_MP_TAC WLOG_LT THEN BETA_TAC THEN SIMP_TAC std_ss [EQ_SYM_EQ] THEN
      SUBGOAL_THEN ``!m n:num. m < n ==> dist(z n:real,x) < dist(z m,x)``
       (fn th => MESON_TAC[th, REAL_LT_REFL, LESS_REFL]) THEN
      KNOW_TAC ``!m n:num.  (dist (z n,x) < dist (z m,x)) =
                     (\m n.  dist (z n,x) < dist (z m,x)) m n`` THENL
      [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
      MATCH_MP_TAC TRANSITIVE_STEPWISE_LT THEN BETA_TAC THEN
      CONJ_TAC THENL [REAL_ARITH_TAC, GEN_TAC THEN ASM_REWRITE_TAC[]] THEN
      FIRST_X_ASSUM(MP_TAC o SPEC
       ``min (inv(&2 pow (SUC n))) (dist(z n:real,x))``) THEN
      ASM_SIMP_TAC std_ss [REAL_LT_MIN, REAL_LT_INV_EQ, REAL_POW_LT,
      REAL_ARITH ``0:real < 2``, DIST_POS_LT],
      X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
      MP_TAC(ISPECL [``inv(&2:real)``, ``e:real``] REAL_ARCH_POW_INV) THEN
      ASM_SIMP_TAC std_ss [REAL_INV_1OVER, REAL_HALF_BETWEEN] THEN
      DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
      FULL_SIMP_TAC std_ss [GSYM REAL_INV_1OVER, REAL_POW_INV] THEN
      X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN MATCH_MP_TAC REAL_LT_TRANS THEN
      EXISTS_TAC ``inv (2:real pow N)`` THEN ASM_REWRITE_TAC [] THEN
      MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``inv(&2:real pow n)`` THEN
      ASM_REWRITE_TAC [] THEN REWRITE_TAC [REAL_INV_1OVER] THEN
      SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_POW_LT, REAL_ARITH ``0 < 2:real``] THEN
      ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN
      REWRITE_TAC [GSYM REAL_INV_1OVER, GSYM real_div] THEN SIMP_TAC std_ss [REAL_LE_RDIV_EQ,
      REAL_POW_LT, REAL_MUL_LID, REAL_ARITH ``0 < 2:real``] THEN
      FULL_SIMP_TAC std_ss [REAL_LE_LT, LESS_OR_EQ] THEN DISJ1_TAC THEN
      MATCH_MP_TAC REAL_POW_MONO_LT THEN ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC]]);

val LIMPT_SEQUENTIAL = store_thm ("LIMPT_SEQUENTIAL",
 ``!x:real s.
      x limit_point_of s <=>
             ?f. (!n. f(n) IN (s DELETE x)) /\ (f --> x) sequentially``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[LIMPT_SEQUENTIAL_INJ] THEN MESON_TAC[],
    REWRITE_TAC[LIMPT_APPROACHABLE, LIM_SEQUENTIALLY, IN_DELETE] THEN
    MESON_TAC[GREATER_EQ, LESS_EQ_REFL]]);

val INFINITE_SUPERSET = store_thm ("INFINITE_SUPERSET",
 ``!s t. INFINITE s /\ s SUBSET t ==> INFINITE t``,
  REWRITE_TAC[] THEN MESON_TAC[SUBSET_FINITE_I]);

val LIMPT_INFINITE_OPEN_BALL_CBALL = store_thm ("LIMPT_INFINITE_OPEN_BALL_CBALL",
 ``(!s x:real.
        x limit_point_of s <=> !t. x IN t /\ open t ==> INFINITE(s INTER t)) /\
   (!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER ball(x,e))) /\
   (!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER cball(x,e)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(q ==> p) /\ (r ==> s) /\ (s ==> q) /\ (p ==> r)
    ==> (p <=> q) /\ (p <=> r) /\ (p <=> s)`) THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[limit_point_of, SET_RULE
     ``(?y. ~(y = x) /\ y IN s /\ y IN t) <=> ~(s INTER t SUBSET {x})``] THEN
    MESON_TAC[SUBSET_FINITE_I, FINITE_SING],
    MESON_TAC[INFINITE_SUPERSET, BALL_SUBSET_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    MESON_TAC[INFINITE_SUPERSET, OPEN_CONTAINS_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    REWRITE_TAC[LIMPT_SEQUENTIAL_INJ, IN_DELETE, FORALL_AND_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``f:num->real`` STRIP_ASSUME_TAC) THEN
    X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``(f --> x) sequentially`` THEN
    GEN_REWR_TAC LAND_CONV [LIM_SEQUENTIALLY] THEN
    DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN
    ASM_REWRITE_TAC[GSYM(ONCE_REWRITE_RULE[DIST_SYM] IN_BALL)] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
    MATCH_MP_TAC INFINITE_SUPERSET THEN
    EXISTS_TAC ``IMAGE (f:num->real) (from N)`` THEN
    ASM_SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_FROM, IN_INTER] THEN
    ASM_MESON_TAC[IMAGE_11_INFINITE, INFINITE_FROM]]);

val LIMPT_INFINITE_OPEN = store_thm ("LIMPT_INFINITE_OPEN",
 ``(!s x:real.
        x limit_point_of s <=> !t. x IN t /\ open t ==> INFINITE(s INTER t))``,
  SIMP_TAC std_ss [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val LIMPT_INFINITE_BALL = store_thm ("LIMPT_INFINITE_BALL",
 ``(!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER ball(x,e)))``,
  METIS_TAC [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val LIMPT_INFINITE_CBALL = store_thm ("LIMPT_INFINITE_CBALL",
 ``(!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER cball(x,e)))``,
  METIS_TAC [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val INFINITE_OPEN_IN = store_thm ("INFINITE_OPEN_IN",
 ``!u s:real->bool.
      open_in (subtopology euclidean u) s /\ (?x. x IN s /\ x limit_point_of u)
      ==> INFINITE s``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN
  REWRITE_TAC [OPEN_IN_OPEN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``x limit_point_of u`` THEN REWRITE_TAC [LIMPT_INFINITE_OPEN] THEN
  FIRST_X_ASSUM SUBST_ALL_TAC THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Condensation points.                                                      *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "condensation_point_of" (Infix(NONASSOC, 450));

val condensation_point_of = new_definition ("condensation_point_of",
 ``x condensation_point_of s <=>
        !t. x IN t /\ open t ==> ~COUNTABLE(s INTER t)``);

val CONDENSATION_POINT_OF_SUBSET = store_thm ("CONDENSATION_POINT_OF_SUBSET",
 ``!x:real s t.
        x condensation_point_of s /\ s SUBSET t ==> x condensation_point_of t``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  REWRITE_TAC[condensation_point_of] THEN
  DISCH_TAC THEN X_GEN_TAC ``t':real->bool`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `t':real->bool`) THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[GSYM MONO_NOT_EQ] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] COUNTABLE_SUBSET) THEN
  ASM_SET_TAC[]);

val CONDENSATION_POINT_IMP_LIMPT = store_thm ("CONDENSATION_POINT_IMP_LIMPT",
 ``!x s. x condensation_point_of s ==> x limit_point_of s``,
  REWRITE_TAC[condensation_point_of, LIMPT_INFINITE_OPEN] THEN
  MESON_TAC[FINITE_IMP_COUNTABLE]);

val CONDENSATION_POINT_INFINITE_BALL_CBALL = store_thm ("CONDENSATION_POINT_INFINITE_BALL_CBALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER ball(x,e))) /\
   (!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER cball(x,e)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(p ==> q) /\ (q ==> r) /\ (r ==> p)
    ==> (p <=> q) /\ (p <=> r)`) THEN
  REWRITE_TAC[condensation_point_of] THEN REPEAT CONJ_TAC THENL
   [MESON_TAC[OPEN_BALL, CENTRE_IN_BALL],
    MESON_TAC[BALL_SUBSET_CBALL, COUNTABLE_SUBSET,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    MESON_TAC[COUNTABLE_SUBSET, OPEN_CONTAINS_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``]]);

val CONDENSATION_POINT_INFINITE_BALL = store_thm ("CONDENSATION_POINT_INFINITE_BALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER ball(x,e)))``,
  METIS_TAC [CONDENSATION_POINT_INFINITE_BALL_CBALL]);

val CONDENSATION_POINT_INFINITE_CBALL = store_thm ("CONDENSATION_POINT_INFINITE_CBALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER cball(x,e)))``,
  METIS_TAC [CONDENSATION_POINT_INFINITE_BALL_CBALL]);

(* ------------------------------------------------------------------------- *)
(* Basic arithmetical combining theorems for limits.                         *)
(* ------------------------------------------------------------------------- *)

val LIM_LINEAR = store_thm ("LIM_LINEAR",
 ``!net:('a)net h f l.
        (f --> l) net /\ linear h ==> ((\x. h(f x)) --> h l) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
    MATCH_MP LINEAR_BOUNDED_POS) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?y. (?x. netord net x y) /\
          !x. netord net x y ==> dist (f x,l) < e`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / B:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, dist, GSYM LINEAR_SUB, REAL_LT_RDIV_EQ] THEN
  ASM_MESON_TAC[REAL_LET_TRANS, REAL_MUL_SYM]);

val LIM_CONST = store_thm ("LIM_CONST",
 ``!net a:real. ((\x. a) --> a) net``,
  SIMP_TAC std_ss [LIM, DIST_REFL, trivial_limit] THEN MESON_TAC[]);

val LIM_CMUL = store_thm ("LIM_CMUL",
 ``!f l c. (f --> l) net ==> ((\x. c * f x) --> (c * l)) net``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_LINEAR THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[ETA_AX]
    (MATCH_MP LINEAR_COMPOSE_CMUL LINEAR_ID)] THEN
  REWRITE_TAC [linear] THEN REAL_ARITH_TAC);

val LIM_CMUL_EQ = store_thm ("LIM_CMUL_EQ",
 ``!net f l c.
        ~(c = &0) ==> (((\x. c * f x) --> (c * l)) net <=> (f --> l) net)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [LIM_CMUL] THEN
  DISCH_THEN(MP_TAC o SPEC ``inv c:real`` o MATCH_MP LIM_CMUL) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID, ETA_AX]);

val LIM_NEG = store_thm ("LIM_NEG",
 ``!net f l:real. (f --> l) net ==> ((\x. -(f x)) --> -l) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM, dist] THEN
  SIMP_TAC std_ss [REAL_ARITH ``-x - -y = -(x - y:real)``, ABS_NEG]);

val LIM_NEG_EQ = store_thm ("LIM_NEG_EQ",
 ``!net f l:real. ((\x. -(f x)) --> -l) net <=> (f --> l) net``,
  REPEAT GEN_TAC THEN EQ_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG) THEN
  SIMP_TAC std_ss [REAL_NEG_NEG, ETA_AX]);

val LIM_ADD = store_thm ("LIM_ADD",
 ``!net:('a)net f g l m.
    (f --> l) net /\ (g --> m) net ==> ((\x. f(x) + g(x)) --> (l + m)) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN
  ASM_SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  KNOW_TAC ``!x y. (dist(f x, l) < e / 2:real) =
              (\x. (dist(f x, l) < e / 2:real)) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!x y. (dist(g x, m) < e / 2:real) =
              (\x. (dist(g x, m) < e / 2:real)) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  DISCH_THEN(MP_TAC o MATCH_MP NET_DILEMMA) THEN BETA_TAC THEN
  STRIP_TAC THEN EXISTS_TAC ``c:'a`` THEN CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
  GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN REPEAT STRIP_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist (f x', l) + dist (g x', m)`` THEN
  METIS_TAC[REAL_LT_HALF1, REAL_LT_ADD2, DIST_TRIANGLE_ADD, GSYM REAL_HALF_DOUBLE]);

val lemma = prove (
 ``abs(x - y) <= abs(a - b) ==> dist(a,b) < e ==> dist(x,y) < e``,
  REWRITE_TAC [dist] THEN REAL_ARITH_TAC);

val LIM_ABS = store_thm ("LIM_ABS",
 ``!net:('a)net f:'a->real l.
     (f --> l) net
     ==> ((\x. abs(f(x))) --> (abs(l)):real) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``y:'a`` THEN POP_ASSUM MP_TAC THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  STRIP_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x:'a`` THEN ASM_REWRITE_TAC [],
   ALL_TAC] THEN DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `x:'a`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  MATCH_MP_TAC lemma THEN BETA_TAC THEN
  REAL_ARITH_TAC);

val LIM_SUB = store_thm ("LIM_SUB",
 ``!net:('a)net f g l m.
    (f --> l) net /\ (g --> m) net ==> ((\x. f(x) - g(x)) --> (l - m)) net``,
  REWRITE_TAC[real_sub] THEN ASM_SIMP_TAC std_ss [LIM_ADD, LIM_NEG]);

val LIM_MAX = store_thm ("LIM_MAX",
 ``!net:('a)net f g l:real m:real.
    (f --> l) net /\ (g --> m) net
    ==> ((\x. max (f(x)) (g(x)))
         --> (max (l) (m)):real) net``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LIM_ADD) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LIM_SUB) THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ABS) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  DISCH_THEN(MP_TAC o SPEC ``inv(&2:real)`` o MATCH_MP LIM_CMUL) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN BINOP_TAC THEN
  SIMP_TAC std_ss [FUN_EQ_THM, max_def, abs] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC arith_ss [REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN (RW_TAC arith_ss [REAL_SUB_LE] THENL
  [REPEAT (POP_ASSUM MP_TAC) THEN RW_TAC std_ss [AND_IMP_INTRO, REAL_LE_ANTISYM, REAL_SUB_REFL,
    REAL_ADD_LID] THEN  REWRITE_TAC [GSYM REAL_DOUBLE],
   REWRITE_TAC [REAL_ARITH ``a - b + (a + b) = a + a - b + b:real``, REAL_SUB_ADD, REAL_DOUBLE],
   REWRITE_TAC [REAL_ARITH ``-(a - b) + (a + b) = b + b - a + a:real``,
    REAL_SUB_ADD, REAL_DOUBLE],
   FULL_SIMP_TAC real_ss [REAL_NOT_LE] THEN METIS_TAC [REAL_LT_ANTISYM]]));

val LIM_MIN = store_thm ("LIM_MIN",
 ``!net:('a)net f g l:real m:real.
    (f --> l) net /\ (g --> m) net
    ==> ((\x. min (f(x)) (g(x)))
         --> (min (l) (m)):real) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN(MP_TAC o MATCH_MP LIM_NEG)) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG o MATCH_MP LIM_MAX) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN
  Reverse BINOP_TAC >- PROVE_TAC [GSYM REAL_MIN_MAX, REAL_MIN_ACI] THEN
  SIMP_TAC std_ss [FUN_EQ_THM] THEN
  GEN_TAC >> PROVE_TAC [GSYM REAL_MIN_MAX, REAL_MIN_ACI]);

val LIM_NULL = store_thm ("LIM_NULL",
 ``!net f l. (f --> l) net <=> ((\x. f(x) - l) --> 0) net``,
  SIMP_TAC arith_ss [LIM, dist, REAL_SUB_RZERO]);

val LIM_NULL_ABS = store_thm ("LIM_NULL_ABS",
 ``!net f. (f --> 0) net <=> ((\x. (abs(f x))) --> 0) net``,
  SIMP_TAC std_ss [LIM, dist, REAL_SUB_RZERO, ABS_ABS]);

val LIM_NULL_CMUL_EQ = store_thm ("LIM_NULL_CMUL_EQ",
 ``!net f c.
        ~(c = &0) ==> (((\x. c * f x) --> 0) net <=> (f --> 0) net)``,
  METIS_TAC[LIM_CMUL_EQ, REAL_MUL_RZERO]);

val LIM_NULL_CMUL = store_thm ("LIM_NULL_CMUL",
 ``!net f c. (f --> 0) net ==> ((\x. c * f x) --> 0) net``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THEN
  ASM_SIMP_TAC std_ss [LIM_NULL_CMUL_EQ, REAL_MUL_LZERO, LIM_CONST]);

val LIM_NULL_ADD = store_thm ("LIM_NULL_ADD",
 ``!net f g:'a->real.
        (f --> 0) net /\ (g --> 0) net
        ==> ((\x. f x + g x) --> 0) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  REWRITE_TAC[REAL_ADD_LID]);

val LIM_NULL_SUB = store_thm ("LIM_NULL_SUB",
 ``!net f g:'a->real.
        (f --> 0) net /\ (g --> 0) net
        ==> ((\x. f x - g x) --> 0) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN
  REWRITE_TAC[REAL_SUB_RZERO]);

val LIM_NULL_COMPARISON = store_thm ("LIM_NULL_COMPARISON",
 ``!net f g. eventually (\x. abs(f x) <= g x) net /\
             ((\x. (g x)) --> 0) net
             ==> (f --> 0) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [tendsto, RIGHT_AND_FORALL_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  SIMP_TAC arith_ss [dist, REAL_SUB_RZERO] THEN REAL_ARITH_TAC);

val LIM_COMPONENT = store_thm ("LIM_COMPONENT",
 ``!net f i l:real. (f --> l) net
       ==> ((\a. f(a)) --> l) net``,
  REWRITE_TAC[LIM, dist] THEN
  METIS_TAC[REAL_LET_TRANS]);

val LIM_TRANSFORM_BOUND = store_thm ("LIM_TRANSFORM_BOUND",
 ``!f g. eventually (\n. abs(f n) <= abs(g n)) net /\ (g --> 0) net
         ==> (f --> 0) net``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [tendsto, RIGHT_AND_FORALL_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  SIMP_TAC arith_ss [dist, REAL_SUB_RZERO] THEN REAL_ARITH_TAC);

val LIM_NULL_CMUL_BOUNDED = store_thm ("LIM_NULL_CMUL_BOUNDED",
 ``!f g:'a->real B.
        eventually (\a. (g a = 0) \/ abs(f a) <= B) net /\
        (g --> 0) net
        ==> ((\n. f n * g n) --> 0) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[tendsto] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / (abs B + &1:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_ARITH ``&0 < abs x + &1:real``] THEN
  UNDISCH_TAC ``eventually
        (\(a :'a). ((g :'a -> real) a = (0 :real)) \/
           abs ((f :'a -> real) a) <= (B :real)) (net :'a net)`` THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MP) THEN
  SIMP_TAC std_ss [dist, REAL_SUB_RZERO, o_THM, ABS_MUL] THEN
  MATCH_MP_TAC ALWAYS_EVENTUALLY THEN X_GEN_TAC ``x:'a`` THEN BETA_TAC THEN
  ASM_CASES_TAC ``(g:'a->real) x = 0`` THEN
  ASM_SIMP_TAC std_ss [ABS_0, REAL_MUL_RZERO] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``B * e / (abs B + &1:real)`` THEN CONJ_TAC THENL
  [ONCE_REWRITE_TAC [real_div] THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC REAL_LE_MUL2 THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC std_ss [REAL_ABS_POS, REAL_LT_IMP_LE], ALL_TAC] THEN
  SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``&0 < abs x + &1:real``] THEN
  MATCH_MP_TAC(REAL_ARITH
   ``e * B <= e * abs B /\ &0 < e ==> B * e < e * (abs B + &1:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN REAL_ARITH_TAC);

val LIM_SUM = store_thm ("LIM_SUM",
 ``!net f:'a->'b->real l s.
        FINITE s /\ (!i. i IN s ==> ((f i) --> (l i)) net)
        ==> ((\x. sum s (\i. f i x)) --> sum s l) net``,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s:'a->bool. ( (!(i :'a). i IN s ==>
     ((f :'a -> 'b -> real) i --> (l :'a -> real) i) (net :'b net)) ==>
  ((\(x :'b). sum s (\(i :'a). f i x)) --> sum s l) net) =
                       (\s. (!(i :'a). i IN s ==>
     ((f :'a -> 'b -> real) i --> (l :'a -> real) i) (net :'b net)) ==>
  ((\(x :'b). sum s (\(i :'a). f i x)) --> sum s l) net)  s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES, LIM_CONST, LIM_ADD, IN_INSERT, ETA_AX] THEN
  METIS_TAC [SUM_CLAUSES, LIM_CONST, LIM_ADD, IN_INSERT, ETA_AX]);

val LIM_NULL_SUM = store_thm ("LIM_NULL_SUM",
 ``!net f:'a->'b->real s.
  FINITE s /\ (!a. a IN s ==> ((\x. f x a) --> 0) net)
  ==> ((\x. sum s (f x)) --> 0) net``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!a. (\x. f x a) = (\a. (\x. f x a)) a``] THEN
  ONCE_REWRITE_TAC [METIS [] ``0:real = (\a. 0) (a:'b)``] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUM) THEN BETA_TAC THEN
   ONCE_REWRITE_TAC [METIS [] ``!i. (\i. f x i) = (\i. f x) i``] THEN
  METIS_TAC [SUM_0, ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Deducing things about the limit from the elements.                        *)
(* ------------------------------------------------------------------------- *)

val LIM_IN_CLOSED_SET = store_thm ("LIM_IN_CLOSED_SET",
 ``!net f:'a->real s l.
    closed s /\ eventually (\x. f(x) IN s) net /\
    ~(trivial_limit net) /\ (f --> l) net
    ==> l IN s``,
  REWRITE_TAC[closed_def] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(SET_RULE ``~(x IN (UNIV DIFF s)) ==> x IN s``) THEN
  DISCH_TAC THEN UNDISCH_TAC ``open (univ(:real) DIFF s)`` THEN
  GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_BALL] THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `l:real`) THEN
  KNOW_TAC ``~(?e. &0 < e /\ (!x. dist (l,x) < e ==>
                x IN univ(:real) /\ ~(x IN s)))`` THENL
  [ALL_TAC, ASM_SIMP_TAC std_ss [SUBSET_DEF, IN_BALL, IN_DIFF, IN_UNION]] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``((f:'a->real) --> l) net`` THEN GEN_REWR_TAC LAND_CONV [tendsto] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  UNDISCH_TAC ``eventually (\x. (f:'a->real) x IN s) net`` THEN
  ASM_REWRITE_TAC[GSYM EVENTUALLY_AND, TAUT `a ==> ~b <=> ~(a /\ b)`] THEN
  MATCH_MP_TAC NOT_EVENTUALLY THEN ASM_MESON_TAC[DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Need to prove closed(cball(x,e)) before deducing this as a corollary.     *)
(* ------------------------------------------------------------------------- *)

val LIM_ABS_UBOUND = store_thm ("LIM_ABS_UBOUND",
 ``!net:('a)net f (l:real) b.
   ~(trivial_limit net) /\ (f --> l) net /\
   eventually (\x. abs(f x) <= b) net
   ==> abs(l) <= b``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[LIM] THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[eventually] THEN
  STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?x:'a. dist(f(x):real,l) < abs(l:real) - b /\ abs(f x) <= b``
   (CHOOSE_THEN MP_TAC) THENL [ASM_MESON_TAC[NET], ALL_TAC] THEN
  REWRITE_TAC[REAL_NOT_LT, REAL_LE_SUB_RADD, DE_MORGAN_THM, dist] THEN
  REAL_ARITH_TAC);

val LIM_ABS_LBOUND = store_thm ("LIM_ABS_LBOUND",
 ``!net:('a)net f (l:real) b.
   ~(trivial_limit net) /\ (f --> l) net /\
   eventually (\x. b <= abs(f x)) net
   ==> b <= abs(l)``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[LIM] THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[eventually] THEN
  STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?x:'a. dist(f(x):real,l) < b - abs(l:real) /\ b <= abs(f x)``
   (CHOOSE_THEN MP_TAC) THENL [ASM_MESON_TAC[NET], ALL_TAC] THEN
  REWRITE_TAC[REAL_NOT_LT, REAL_LE_SUB_RADD, DE_MORGAN_THM, dist] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Uniqueness of the limit, when nontrivial. *)
(* ------------------------------------------------------------------------- *)

val LIM_UNIQUE = store_thm ("LIM_UNIQUE",
 ``!net:('a)net f l:real l'.
  ~(trivial_limit net) /\ (f --> l) net /\ (f --> l') net ==> (l = l')``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(ASSUME_TAC o REWRITE_RULE[REAL_SUB_REFL] o MATCH_MP LIM_SUB) THEN
  SUBGOAL_THEN ``!e. &0 < e ==> abs(l:real - l') <= e`` MP_TAC THENL
  [GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC LIM_ABS_UBOUND THEN
   MAP_EVERY EXISTS_TAC [``net:('a)net``, ``\x:'a. 0:real``] THEN
   ASM_SIMP_TAC std_ss [ABS_0, REAL_LT_IMP_LE, eventually] THEN
   ASM_MESON_TAC[trivial_limit],
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN REWRITE_TAC[DIST_NZ, dist] THEN
  DISCH_TAC THEN DISCH_THEN(MP_TAC o SPEC ``abs(l - l':real) / &2``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_RDIV_EQ, REAL_LE_RDIV_EQ, REAL_LT] THEN
  UNDISCH_TAC ``&0 < abs(l - l':real)`` THEN REAL_ARITH_TAC]);

val TENDSTO_LIM = store_thm ("TENDSTO_LIM",
 ``!net f l. ~(trivial_limit net) /\ (f --> l) net ==> (lim net f = l)``,
  REWRITE_TAC[lim_def] THEN METIS_TAC[LIM_UNIQUE]);

val LIM_CONST_EQ = store_thm ("LIM_CONST_EQ",
 ``!net:('a net) c d:real.
  ((\x. c) --> d) net <=> trivial_limit net \/ (c = d)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``trivial_limit (net:'a net)`` THEN ASM_REWRITE_TAC[] THENL
  [ASM_REWRITE_TAC[LIM], ALL_TAC] THEN
  EQ_TAC THEN SIMP_TAC std_ss [LIM_CONST] THEN DISCH_TAC THEN
  MATCH_MP_TAC(SPEC ``net:'a net`` LIM_UNIQUE) THEN
  EXISTS_TAC ``(\x. c):'a->real`` THEN ASM_REWRITE_TAC[LIM_CONST]);

(* ------------------------------------------------------------------------- *)
(* Some unwieldy but occasionally useful theorems about uniform limits.      *)
(* ------------------------------------------------------------------------- *)

val UNIFORM_LIM_ADD = store_thm ("UNIFORM_LIM_ADD",
 ``!net:('a)net P f g l m.
  (!e:real. &0 < e
   ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
  (!e:real. &0 < e
   ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
    ==> !e. &0 < e ==> eventually (\x. !n. P n
     ==> abs((f n x + g n x) - (l n + m n)) < e) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  GEN_TAC THEN REWRITE_TAC[GSYM FORALL_AND_THM] THEN
  BETA_TAC THEN STRIP_TAC THEN X_GEN_TAC ``n:'b`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  REWRITE_TAC [REAL_ADD2_SUB2] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs ((f:'b->'a->real) n x - l n) + abs (-g n x - -m n):real`` THEN
  ASM_REAL_ARITH_TAC);

val UNIFORM_LIM_SUB = store_thm ("UNIFORM_LIM_SUB",
 ``!net:('a)net P f g l m.
  (!e:real. &0 < e
   ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
  (!e:real. &0 < e
   ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
    ==> !e. &0 < e ==> eventually (\x. !n. P n
     ==> abs((f n x - g n x) - (l n - m n)) < e) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  GEN_TAC THEN REWRITE_TAC[GSYM FORALL_AND_THM] THEN
  BETA_TAC THEN STRIP_TAC THEN X_GEN_TAC ``n:'b`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  REWRITE_TAC [REAL_ARITH ``abs (f n x - g n x - (l n - m n)):real =
                            abs (f n x + -g n x - (l n + -m n))``] THEN
  REWRITE_TAC [REAL_ADD2_SUB2] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs ((f:'b->'a->real) n x - l n) + abs (-g n x - -m n):real`` THEN
  REWRITE_TAC [ABS_TRIANGLE] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
  ASM_REWRITE_TAC [REAL_ARITH ``-a - -b = - (a - b):real``, ABS_NEG]);

(* ------------------------------------------------------------------------- *)
(* Limit under bilinear function, uniform version first.                     *)
(* ------------------------------------------------------------------------- *)

val UNIFORM_LIM_BILINEAR = store_thm ("UNIFORM_LIM_BILINEAR",
 ``!net:('a)net P (h:real->real->real) f g l m b1 b2.
        bilinear h /\
        eventually (\x. !n. P n ==> abs(l n) <= b1) net /\
        eventually (\x. !n. P n ==> abs(m n) <= b2) net /\
        (!e. &0 < e
             ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
        (!e. &0 < e
             ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
        ==> !e. &0 < e
             ==> eventually (\x. !n. P n
                 ==> abs(h (f n x) (g n x) - h (l n) (m n)) < e) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o  MATCH_MP
   BILINEAR_BOUNDED_POS) THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, RIGHT_AND_FORALL_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``min (abs b2 + &1:real) (e / &2 / (B * (abs b1 + abs b2 + &2)))``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_HALF1, REAL_LT_DIV, REAL_LT_MUL, REAL_LT_MIN,
               REAL_ARITH ``&0 < abs x + &1:real``,
               REAL_ARITH ``&0 < abs x + abs y + &2:real``] THEN
  REWRITE_TAC[GSYM EVENTUALLY_AND] THEN BETA_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  X_GEN_TAC ``x:'a`` THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH
    ``h a b - h c d :real = (h a b - h a d) + (h a d - h c d)``] THEN
  ASM_SIMP_TAC std_ss [GSYM BILINEAR_LSUB, GSYM BILINEAR_RSUB] THEN
  MATCH_MP_TAC ABS_TRIANGLE_LT THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP
   (MESON[REAL_LE_ADD2, REAL_LET_TRANS]
     ``(!x y. abs(h x y:real) <= B * abs x * abs y)
       ==> B * abs a * abs b + B * abs c * abs d < e
           ==> abs(h a b) + abs(h c d) < e``)) THEN
  REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC(METIS [REAL_LT_ADD2, REAL_HALF_DOUBLE, REAL_MUL_SYM]
   ``x * B < e / &2:real /\ y * B < e / &2:real ==> B * x + B * y < e``) THEN
  CONJ_TAC THEN ASM_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ] THENL
   [ONCE_REWRITE_TAC[REAL_MUL_SYM], ALL_TAC] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``e / &2 / (B * (abs b1 + abs b2 + &2)) *
             (abs b1 + abs b2 + &1:real)`` THEN
  (CONJ_TAC THENL
    [MATCH_MP_TAC REAL_LE_MUL2 THEN
     ASM_SIMP_TAC std_ss [ABS_POS, REAL_LT_IMP_LE] THEN
     ASM_SIMP_TAC std_ss [REAL_ARITH ``a <= b2 ==> a <= abs b1 + abs b2 + &1:real``] THEN
     ASM_MESON_TAC[REAL_ARITH
       ``abs(f - l:real) < abs b2 + &1 /\ abs(l) <= b1
        ==> abs(f) <= abs b1 + abs b2 + &1``],
     ONCE_REWRITE_TAC[real_div] THEN
     KNOW_TAC ``(abs b1 + abs b2 + 2) <> 0:real`` THENL
     [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
      MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``2:real`` THEN
      REWRITE_TAC [REAL_LE_ADDL] THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
      ONCE_REWRITE_TAC [REAL_ARITH ``0 = 0 + 0:real``] THEN MATCH_MP_TAC REAL_LE_ADD2 THEN
      REWRITE_TAC [ABS_POS], ALL_TAC] THEN DISCH_TAC THEN
     ASM_SIMP_TAC arith_ss [REAL_LT_LMUL, REAL_LT_HALF1, GSYM REAL_MUL_ASSOC,
                  REAL_INV_MUL, REAL_LT_IMP_NE] THEN REWRITE_TAC [REAL_MUL_ASSOC] THEN
     REWRITE_TAC[METIS [real_div, REAL_MUL_RID, REAL_ARITH ``a * b * c = a * c * b:real``]
                 ``B * inv x * y < B <=> B * y / x < B * &1:real``] THEN
     ASM_SIMP_TAC arith_ss [REAL_LT_INV_EQ, REAL_LT_LMUL, REAL_LT_LDIV_EQ, REAL_MUL_RID,
                  REAL_ARITH ``&0 < abs x + abs y + &2:real``] THEN
     REAL_ARITH_TAC]));

val LIM_BILINEAR = store_thm ("LIM_BILINEAR",
 ``!net:('a)net (h:real->real->real) f g l m.
        (f --> l) net /\ (g --> m) net /\ bilinear h
        ==> ((\x. h (f x) (g x)) --> (h l m)) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [``net:('a)net``, ``\x:one. T``, ``h:real->real->real``,
    ``\n:one. (f:'a->real)``, ``\n:one. (g:'a->real)``,
    ``\n:one. (l:real)``, ``\n:one. (m:real)``,
    ``abs(l:real)``, ``abs(m:real)``]
   UNIFORM_LIM_BILINEAR) THEN
  ASM_REWRITE_TAC[REAL_LE_REFL, EVENTUALLY_TRUE] THEN
  ASM_SIMP_TAC std_ss [GSYM dist, GSYM tendsto]);

(* ------------------------------------------------------------------------- *)
(* These are special for limits out of the same vector space. *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_ID = store_thm ("LIM_WITHIN_ID",
 ``!a s. ((\x. x) --> a) (at a within s)``,
  REWRITE_TAC[LIM_WITHIN] THEN MESON_TAC[]);

val LIM_AT_ID = store_thm ("LIM_AT_ID",
 ``!a. ((\x. x) --> a) (at a)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN REWRITE_TAC[LIM_WITHIN_ID]);

val LIM_AT_ZERO = store_thm ("LIM_AT_ZERO",
 ``!f:real->real l a.
    (f --> l) (at a) <=> ((\x. f(a + x)) --> l) (at(0))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM_AT] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  ASM_CASES_TAC ``&0 < d:real`` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``x:real`` THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC ``a + x:real``) THEN
   SIMP_TAC std_ss [dist, REAL_ADD_SUB, REAL_SUB_RZERO],
  FIRST_X_ASSUM(MP_TAC o SPEC ``x - a:real``) THEN
  SIMP_TAC std_ss [dist, REAL_SUB_RZERO, REAL_SUB_ADD2]]);

(* ------------------------------------------------------------------------- *)
(* It's also sometimes useful to extract the limit point from the net. *)
(* ------------------------------------------------------------------------- *)

val netlimit = new_definition ("netlimit",
 ``netlimit net = @a. !x. ~(netord net x a)``);

val NETLIMIT_WITHIN = store_thm ("NETLIMIT_WITHIN",
 ``!a:real s. ~(trivial_limit (at a within s))
    ==> (netlimit (at a within s) = a)``,
  REWRITE_TAC[trivial_limit, netlimit, AT, WITHIN, DE_MORGAN_THM] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SELECT_UNIQUE THEN REWRITE_TAC[] THEN
  SUBGOAL_THEN
   ``!x:real. ~(&0 < dist(x,a) /\ dist(x,a) <= dist(a,a) /\ x IN s)``
    ASSUME_TAC THENL
    [ASM_MESON_TAC[DIST_REFL, REAL_NOT_LT], ASM_MESON_TAC[]]);

val NETLIMIT_AT = store_thm ("NETLIMIT_AT",
 ``!a. netlimit(at a) = a``,
  GEN_TAC THEN ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MATCH_MP_TAC NETLIMIT_WITHIN THEN
  SIMP_TAC std_ss [TRIVIAL_LIMIT_AT, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Transformation of limit. *)
(* ------------------------------------------------------------------------- *)

val LIM_TRANSFORM = store_thm ("LIM_TRANSFORM",
 ``!net f g l.
  ((\x. f x - g x) --> 0) net /\ (f --> l) net ==> (g --> l) net``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG) THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_THM_TAC THEN BINOP_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM] THEN
  REAL_ARITH_TAC);

val LIM_TRANSFORM_EVENTUALLY = store_thm ("LIM_TRANSFORM_EVENTUALLY",
 ``!net f g l.
   eventually (\x. f x = g x) net /\ (f --> l) net ==> (g --> l) net``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  KNOW_TAC ``((\ (x:'a). f x - g x) --> (0:real)) net`` THENL
  [METIS_TAC [LIM_EVENTUALLY], ALL_TAC] THEN
  METIS_TAC[LIM_TRANSFORM]);

val LIM_TRANSFORM_WITHIN = store_thm ("LIM_TRANSFORM_WITHIN",
  ``!f g x s d. &0 < d /\
  (!x'. x' IN s /\ &0 < dist(x',x) /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
  (f --> l) (at x within s) ==> (g --> l) (at x within s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] LIM_TRANSFORM) THEN
  REWRITE_TAC[LIM_WITHIN] THEN REPEAT STRIP_TAC THEN EXISTS_TAC ``d:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_REFL, DIST_REFL]);

val LIM_TRANSFORM_AT = store_thm ("LIM_TRANSFORM_AT",
 ``!f g x d. &0 < d /\
  (!x'. &0 < dist(x',x) /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
  (f --> l) (at x) ==> (g --> l) (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN MESON_TAC[LIM_TRANSFORM_WITHIN]);

val LIM_TRANSFORM_EQ = store_thm ("LIM_TRANSFORM_EQ",
 ``!net f:'a->real g l.
  ((\x. f x - g x) --> 0) net ==> ((f --> l) net <=> (g --> l) net)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  DISCH_TAC THEN MATCH_MP_TAC LIM_TRANSFORM THENL
  [EXISTS_TAC ``f:'a->real`` THEN ASM_REWRITE_TAC[],
  EXISTS_TAC ``g:'a->real`` THEN ASM_REWRITE_TAC[] THEN
  ONCE_REWRITE_TAC[GSYM LIM_NEG_EQ] THEN BETA_TAC THEN
  ASM_REWRITE_TAC[REAL_NEG_SUB, REAL_NEG_0]]);

val LIM_TRANSFORM_WITHIN_SET = store_thm ("LIM_TRANSFORM_WITHIN_SET",
 ``!f a s t.
  eventually (\x. x IN s <=> x IN t) (at a)
  ==> ((f --> l) (at a within s) <=> (f --> l) (at a within t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[EVENTUALLY_AT, LIM_WITHIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

val LIM_TRANSFORM_WITHIN_SET_IMP = store_thm ("LIM_TRANSFORM_WITHIN_SET_IMP",
 ``!f l a s t.
  eventually (\x. x IN t ==> x IN s) (at a) /\ (f --> l) (at a within s)
  ==> (f --> l) (at a within t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO, EVENTUALLY_AT, LIM_WITHIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Common case assuming being away from some crucial point like 0.           *)
(* ------------------------------------------------------------------------- *)

val LIM_TRANSFORM_AWAY_WITHIN = store_thm ("LIM_TRANSFORM_AWAY_WITHIN",
 ``!f:real->real g a b s. ~(a = b) /\
  (!x. x IN s /\ ~(x = a) /\ ~(x = b) ==> (f(x) = g(x))) /\
  (f --> l) (at a within s) ==> (g --> l) (at a within s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_WITHIN THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``dist(a:real,b)``] THEN
  ASM_REWRITE_TAC[GSYM DIST_NZ] THEN X_GEN_TAC ``y:real`` THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_MESON_TAC[DIST_SYM, REAL_LT_REFL]);

val LIM_TRANSFORM_AWAY_AT = store_thm ("LIM_TRANSFORM_AWAY_AT",
 ``!f:real->real g a b. ~(a = b) /\
  (!x. ~(x = a) /\ ~(x = b) ==> (f(x) = g(x))) /\
  (f --> l) (at a) ==> (g --> l) (at a)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MESON_TAC[LIM_TRANSFORM_AWAY_WITHIN]);

(* ------------------------------------------------------------------------- *)
(* Alternatively, within an open set. *)
(* ------------------------------------------------------------------------- *)

val LIM_TRANSFORM_WITHIN_OPEN = store_thm ("LIM_TRANSFORM_WITHIN_OPEN",
 ``!f g:real->real s a l. open s /\ a IN s /\
  (!x. x IN s /\ ~(x = a) ==> (f x = g x)) /\
  (f --> l) (at a) ==> (g --> l) (at a)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_AT THEN
  EXISTS_TAC ``f:real->real`` THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``open s`` THEN GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_BALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN POP_ASSUM MP_TAC THEN
  REWRITE_TAC[SUBSET_DEF, IN_BALL] THEN ASM_MESON_TAC[DIST_NZ, DIST_SYM]);

val LIM_TRANSFORM_WITHIN_OPEN_IN = store_thm ("LIM_TRANSFORM_WITHIN_OPEN_IN",
 ``!f g:real->real s t a l.
  open_in (subtopology euclidean t) s /\ a IN s /\
  (!x. x IN s /\ ~(x = a) ==> (f x = g x)) /\
  (f --> l) (at a within t) ==> (g --> l) (at a within t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_WITHIN THEN
  EXISTS_TAC ``f:real->real`` THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``open_in (subtopology euclidean t) s`` THEN
  GEN_REWR_TAC LAND_CONV [OPEN_IN_CONTAINS_BALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real`` o CONJUNCT2) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN POP_ASSUM MP_TAC THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTER, IN_BALL] THEN ASM_MESON_TAC[DIST_NZ, DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Another quite common idiom of an explicit conditional in a sequence. *)
(* ------------------------------------------------------------------------- *)

val LIM_CASES_FINITE_SEQUENTIALLY = store_thm ("LIM_CASES_FINITE_SEQUENTIALLY",
 ``!f g l. FINITE {n | P n}
  ==> (((\n. if P n then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] LIM_TRANSFORM_EVENTUALLY) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  SIMP_TAC std_ss [GSPECIFICATION, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``N:num`` THEN DISCH_TAC THEN SIMP_TAC std_ss [EVENTUALLY_SEQUENTIALLY] THEN
  EXISTS_TAC ``N + 1:num`` THEN
  METIS_TAC[ARITH_PROVE ``~(x <= n:num /\ n + 1 <= x)``]);

val lemma = prove (
 ``(if p then x else y) = (if ~p then y else x)``,
 RW_TAC std_ss []);

val LIM_CASES_COFINITE_SEQUENTIALLY = store_thm ("LIM_CASES_COFINITE_SEQUENTIALLY",
 ``!f g l. FINITE {n | ~P n}
  ==> (((\n. if P n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially)``,
  ONCE_REWRITE_TAC[lemma] THEN
  SIMP_TAC std_ss [LIM_CASES_FINITE_SEQUENTIALLY]);

val LIM_CASES_SEQUENTIALLY = store_thm ("LIM_CASES_SEQUENTIALLY",
 ``!f g l m. (((\n. if m <= n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially) /\
   (((\n. if m < n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially) /\
   (((\n. if n <= m then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially) /\
   (((\n. if n < m then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially)``,
  SIMP_TAC std_ss [LIM_CASES_FINITE_SEQUENTIALLY, LIM_CASES_COFINITE_SEQUENTIALLY,
  NOT_LESS, NOT_LESS_EQUAL, FINITE_NUMSEG_LT, FINITE_NUMSEG_LE]);

(* ------------------------------------------------------------------------- *)
(* A congruence rule allowing us to transform limits assuming not at point.  *)
(* ------------------------------------------------------------------------- *)

val LIM_CONG_WITHIN = store_thm ("LIM_CONG_WITHIN",
 ``(!x. ~(x = a) ==> (f x = g x))
  ==> (((\x. f x) --> l) (at a within s) <=> ((g --> l) (at a within s)))``,
 REWRITE_TAC[LIM_WITHIN, GSYM DIST_NZ] THEN SIMP_TAC std_ss []);

val LIM_CONG_AT = store_thm ("LIM_CONG_AT",
 ``(!x. ~(x = a) ==> (f x = g x))
  ==> (((\x. f x) --> l) (at a) <=> ((g --> l) (at a)))``,
 REWRITE_TAC[LIM_AT, GSYM DIST_NZ] THEN SIMP_TAC std_ss []);

(* ------------------------------------------------------------------------- *)
(* Useful lemmas on closure and set of possible sequential limits.           *)
(* ------------------------------------------------------------------------- *)

val CLOSURE_SEQUENTIAL = store_thm ("CLOSURE_SEQUENTIAL",
 ``!s l:real.
  l IN closure(s) <=> ?x. (!n. x(n) IN s) /\ (x --> l) sequentially``,
  SIMP_TAC std_ss [closure, IN_UNION, LIMPT_SEQUENTIAL, GSPECIFICATION, IN_DELETE] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `((b ==> c) /\ (~a /\ c ==> b)) /\ (a ==> c) ==> (a \/ b <=> c)`) THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN DISCH_TAC THEN
  EXISTS_TAC ``\n:num. l:real`` THEN ASM_REWRITE_TAC[LIM_CONST]);

val CLOSED_CONTAINS_SEQUENTIAL_LIMIT = store_thm ("CLOSED_CONTAINS_SEQUENTIAL_LIMIT",
 ``!s x l:real.
  closed s /\ (!n. x n IN s) /\ (x --> l) sequentially ==> l IN s``,
  MESON_TAC[CLOSURE_SEQUENTIAL, CLOSURE_CLOSED]);

val CLOSED_SEQUENTIAL_LIMITS = store_thm ("CLOSED_SEQUENTIAL_LIMITS",
 ``!s. closed s <=>
   !x l. (!n. x(n) IN s) /\ (x --> l) sequentially ==> l IN s``,
  MESON_TAC[CLOSURE_SEQUENTIAL, CLOSURE_CLOSED,
  CLOSED_LIMPT, LIMPT_SEQUENTIAL, IN_DELETE]);

val CLOSED_APPROACHABLE = store_thm ("CLOSED_APPROACHABLE",
 ``!x s. closed s
  ==> ((!e. &0 < e ==> ?y. y IN s /\ dist(y,x) < e) <=> x IN s)``,
  MESON_TAC[CLOSURE_CLOSED, CLOSURE_APPROACHABLE]);

val IN_CLOSURE_DELETE = store_thm ("IN_CLOSURE_DELETE",
 ``!s x:real. x IN closure(s DELETE x) <=> x limit_point_of s``,
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, LIMPT_APPROACHABLE, IN_DELETE, CONJ_ASSOC]);

val DENSE_IMP_PERFECT = store_thm ("DENSE_IMP_PERFECT",
 ``!s. (closure s = univ(:real)) ==> !x. x IN s ==> x limit_point_of s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  KNOW_TAC ``~(!x'. ~(x' = x) /\ dist (x',x) < e ==> ~(x' IN s))`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``~(?y. dist (x,y) = e / &2)`` THENL
  [ALL_TAC, ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, REAL_LT_HALF1]] THEN
  DISCH_THEN(X_CHOOSE_TAC ``y:real``) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``y:real`` o MATCH_MP (SET_RULE
   ``(s = UNIV) ==> !x. x IN s``)) THEN
  REWRITE_TAC[CLOSURE_APPROACHABLE] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_HALF, NOT_EXISTS_THM] THEN
  X_GEN_TAC ``z:real`` THEN FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN
  ASM_CASES_TAC ``(z:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [] THEN STRIP_TAC THENL
  [METIS_TAC [REAL_LE_LT, REAL_NOT_LT], ALL_TAC] THEN
  DISCH_TAC THEN UNDISCH_TAC ``~(dist (z,x) < e)`` THEN REWRITE_TAC [] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (z,y) + dist (y,x)`` THEN
  REWRITE_TAC [DIST_TRIANGLE] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
  ASM_REWRITE_TAC [] THEN METIS_TAC [REAL_LT_RADD, DIST_SYM]);

val DENSE_LIMIT_POINTS = store_thm ("DENSE_LIMIT_POINTS",
 ``!x. ({x | x limit_point_of s} = univ(:real)) <=> (closure s = univ(:real))``,
  GEN_TAC THEN EQ_TAC THENL [SIMP_TAC std_ss [closure] THEN SET_TAC[], DISCH_TAC] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DENSE_IMP_PERFECT) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[closure]) THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some other lemmas about sequences.                                        *)
(* ------------------------------------------------------------------------- *)

val SEQ_OFFSET = store_thm ("SEQ_OFFSET",
 ``!f l k. (f --> l) sequentially ==> ((\i. f(i + k)) --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N <= n ==> N <= n + k:num``]);

val SEQ_OFFSET_NEG = store_thm ("SEQ_OFFSET_NEG",
 ``!f l k. (f --> l) sequentially ==> ((\i. f(i - k)) --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N + k <= n ==> N <= n - k:num``]);

val SEQ_OFFSET_REV = store_thm ("SEQ_OFFSET_REV",
 ``!f l k. ((\i. f(i + k)) --> l) sequentially ==> (f --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N + k <= n ==> N <= n - k /\ ((n - k) + k = n:num)``]);

val SEQ_HARMONIC_OFFSET = store_thm ("SEQ_HARMONIC_OFFSET",
 ``!a. ((\n. inv(&n + a)) --> 0) sequentially``,
  GEN_TAC THEN REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  ASSUME_TAC REAL_ARCH_INV THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_REWRITE_TAC [] THEN DISCH_THEN (X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  X_CHOOSE_THEN ``M:num`` STRIP_ASSUME_TAC
  (SPEC ``-a:real`` SIMP_REAL_ARCH) THEN
  EXISTS_TAC ``M + N:num`` THEN REWRITE_TAC[DIST_0] THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``inv (&N:real)`` THEN
  KNOW_TAC ``(&n + a:real) <> 0`` THENL
  [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   UNDISCH_TAC ``-a <= &M:real`` THEN
   GEN_REWR_TAC LAND_CONV [GSYM REAL_LE_NEG] THEN REWRITE_TAC [REAL_NEG_NEG] THEN
   DISCH_TAC THEN FULL_SIMP_TAC arith_ss [GSYM REAL_LE, GSYM REAL_ADD] THEN
   KNOW_TAC ``&M + &N + (-&M) <= &n + a:real`` THENL
   [FULL_SIMP_TAC arith_ss [REAL_LE_ADD2], ALL_TAC] THEN
   REWRITE_TAC [GSYM real_sub] THEN ONCE_REWRITE_TAC [REAL_ADD_COMM] THEN
   REWRITE_TAC [REAL_ADD_SUB_ALT] THEN DISCH_TAC THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``&N:real`` THEN
   FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ], ALL_TAC] THEN DISCH_TAC THEN
  BETA_TAC THEN ASM_SIMP_TAC arith_ss [ABS_INV] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM REAL_OF_NUM_LE, GSYM REAL_OF_NUM_ADD]) THEN
  ASM_REAL_ARITH_TAC);

val SEQ_HARMONIC = store_thm ("SEQ_HARMONIC",
 ``((\n. inv(&n)) --> 0) sequentially``,
  MP_TAC(SPEC ``&0:real`` SEQ_HARMONIC_OFFSET) THEN REWRITE_TAC[REAL_ADD_RID]);

(* ------------------------------------------------------------------------- *)
(* More properties of closed balls.                                          *)
(* ------------------------------------------------------------------------- *)

val CLOSED_CBALL = store_thm ("CLOSED_CBALL",
 ``!x:real e. closed(cball(x,e))``,
  REWRITE_TAC[CLOSED_SEQUENTIAL_LIMITS, IN_CBALL, dist] THEN
  GEN_TAC THEN GEN_TAC THEN X_GEN_TAC ``s:num->real`` THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_ABS_UBOUND) THEN
  EXISTS_TAC ``\n. x - (s:num->real) n`` THEN
  REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY, EVENTUALLY_SEQUENTIALLY] THEN
  ASM_SIMP_TAC std_ss [LIM_SUB, LIM_CONST, SEQUENTIALLY]);

val IN_INTERIOR_CBALL = store_thm ("IN_INTERIOR_CBALL",
 ``!x s. x IN interior s <=> ?e. &0 < e /\ cball(x,e) SUBSET s``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[OPEN_CONTAINS_CBALL, SUBSET_TRANS,
  BALL_SUBSET_CBALL, CENTRE_IN_BALL, OPEN_BALL]);

val LIMPT_BALL = store_thm ("LIMPT_BALL",
 ``!x:real y e. y limit_point_of ball(x,e) <=> &0 < e /\ y IN cball(x,e)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``&0 < e:real`` THENL
  [ALL_TAC, ASM_MESON_TAC[LIMPT_EMPTY, REAL_NOT_LT, BALL_EQ_EMPTY]] THEN
  ASM_REWRITE_TAC[] THEN EQ_TAC THENL
  [MESON_TAC[CLOSED_CBALL, CLOSED_LIMPT, LIMPT_SUBSET, BALL_SUBSET_CBALL],
   REWRITE_TAC[IN_CBALL, LIMPT_APPROACHABLE, IN_BALL]] THEN
  DISCH_TAC THEN X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``y:real = x`` THEN ASM_REWRITE_TAC[DIST_NZ] THENL
  [MP_TAC(SPECL [``d:real``, ``e:real``] REAL_DOWN2) THEN
   ASM_REWRITE_TAC[] THEN
   GEN_MESON_TAC 0 40 1 [REAL_CHOOSE_DIST, DIST_SYM, REAL_LT_IMP_LE],
   ALL_TAC] THEN
  MP_TAC(SPECL [``abs(y:real - x)``, ``d:real``] REAL_DOWN2) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[DIST_NZ, dist]) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``(y:real) - (k / dist(y,x)) * (y - x)`` THEN
  REWRITE_TAC[dist, REAL_ARITH ``(y - c * z) - y = -c * z:real``] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, ABS_NEG, REAL_POS_NZ] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC[REAL_ARITH ``x - (y - k * (y - x)) = (&1 - k) * (x - y:real)``] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``&0 < k ==> &0 < abs k:real``, ABS_MUL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``&0 < k /\ k < d ==> abs k < d:real``] THEN
  MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``abs(x:real - y)`` THEN
  ASM_REWRITE_TAC[] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
  KNOW_TAC ``0:real < abs (x - y)`` THENL [ASM_MESON_TAC[ABS_SUB], ALL_TAC] THEN
  DISCH_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_RMUL] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < k /\ k < &1 ==> abs(&1 - k) < &1:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ, REAL_MUL_LZERO,
   REAL_MUL_LID]);

val CLOSURE_BALL = store_thm ("CLOSURE_BALL",
 ``!x:real e. &0 < e ==> (closure(ball(x,e)) = cball(x,e))``,
  SIMP_TAC std_ss [EXTENSION, closure, GSPECIFICATION, IN_UNION, LIMPT_BALL] THEN
  REWRITE_TAC[IN_BALL, IN_CBALL] THEN REAL_ARITH_TAC);

val INTERIOR_BALL = store_thm ("INTERIOR_BALL",
 ``!a r. interior(ball(a,r)) = ball(a,r)``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_BALL]);

val INTERIOR_CBALL = store_thm ("INTERIOR_CBALL",
 ``!x:real e. interior(cball(x,e)) = ball(x,e)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``&0 <= e:real`` THENL
  [ALL_TAC,
   SUBGOAL_THEN ``(cball(x:real,e) = {}) /\ (ball(x:real,e) = {})``
    (fn th => REWRITE_TAC[th, INTERIOR_EMPTY]) THEN
   REWRITE_TAC[IN_BALL, IN_CBALL, EXTENSION, NOT_IN_EMPTY] THEN
   CONJ_TAC THEN X_GEN_TAC ``y:real`` THEN
   MP_TAC(ISPECL [``x:real``, ``y:real``] DIST_POS_LE) THEN
   POP_ASSUM MP_TAC THEN REAL_ARITH_TAC] THEN
  MATCH_MP_TAC INTERIOR_UNIQUE THEN
  REWRITE_TAC[BALL_SUBSET_CBALL, OPEN_BALL] THEN
  X_GEN_TAC ``t:real->bool`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_CBALL, IN_BALL, REAL_LT_LE] THEN STRIP_TAC THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
  UNDISCH_TAC ``open t`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``z:real``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``d:real`` MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_CASES_TAC ``z:real = x`` THENL
  [FIRST_X_ASSUM SUBST_ALL_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_TAC ``k:real`` o MATCH_MP REAL_DOWN) THEN
  SUBGOAL_THEN ``?w:real. dist(w,x) = k`` STRIP_ASSUME_TAC THENL
  [ASM_MESON_TAC[REAL_CHOOSE_DIST, DIST_SYM, REAL_LT_IMP_LE],
   ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_SYM]],
  RULE_ASSUM_TAC(REWRITE_RULE[DIST_NZ]) THEN
  DISCH_THEN(MP_TAC o SPEC ``z + ((d / &2) / dist(z,x)) * (z - x:real)``) THEN
  FULL_SIMP_TAC arith_ss [dist, REAL_ADD_SUB, ABS_MUL, ABS_DIV,
  ABS_ABS, ABS_N, REAL_POS_NZ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, GSYM dist, REAL_POS_NZ] THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_LT] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``abs d < d * &2 <=> &0 < d:real``] THEN
  DISCH_THEN(ANTE_RES_THEN MP_TAC) THEN REWRITE_TAC[dist] THEN
  REWRITE_TAC[REAL_ARITH ``x - (z + k * (z - x)) = (&1 + k) * (x - z:real)``] THEN
  REWRITE_TAC[REAL_NOT_LE, ABS_MUL] THEN
  GEN_REWR_TAC LAND_CONV [GSYM REAL_MUL_LID] THEN
  ONCE_REWRITE_TAC[ABS_SUB] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RMUL, GSYM dist] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < x ==> &1:real < abs(&1 + x)``) THEN
  ONCE_REWRITE_TAC[DIST_SYM] THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT, dist]]);

val FRONTIER_BALL = store_thm ("FRONTIER_BALL",
 ``!a e. &0 < e ==> (frontier(ball(a,e)) = sphere(a,e))``,
  SIMP_TAC std_ss [frontier, sphere, CLOSURE_BALL, INTERIOR_OPEN, OPEN_BALL,
   REAL_LT_IMP_LE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION, IN_BALL, IN_CBALL] THEN
  REAL_ARITH_TAC);

val FRONTIER_CBALL = store_thm ("FRONTIER_CBALL",
 ``!a e. (frontier(cball(a,e)) = sphere(a,e))``,
  SIMP_TAC std_ss [frontier, sphere, INTERIOR_CBALL, CLOSED_CBALL, CLOSURE_CLOSED,
   REAL_LT_IMP_LE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, SPECIFICATION, IN_BALL, IN_CBALL, dist] THEN
  GEN_REWR_TAC (QUANT_CONV o QUANT_CONV o QUANT_CONV o RAND_CONV) [GSYM SPECIFICATION] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN REAL_ARITH_TAC);

val CBALL_EQ_EMPTY = store_thm ("CBALL_EQ_EMPTY",
 ``!x e. (cball(x,e) = {}) <=> e < &0``,
  REWRITE_TAC[EXTENSION, IN_CBALL, NOT_IN_EMPTY, REAL_NOT_LE] THEN
  MESON_TAC[DIST_POS_LE, DIST_REFL, REAL_LTE_TRANS]);

val CBALL_EMPTY = store_thm ("CBALL_EMPTY",
 ``!x e. e < &0 ==> (cball(x,e) = {})``,
 REWRITE_TAC[CBALL_EQ_EMPTY]);

val CBALL_EQ_SING = store_thm ("CBALL_EQ_SING",
 ``!x:real e. (cball(x,e) = {x}) <=> (e = &0)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[EXTENSION, IN_CBALL, IN_SING] THEN
  EQ_TAC THENL [ALL_TAC, MESON_TAC[DIST_LE_0]] THEN
  DISCH_THEN(fn th => MP_TAC(SPEC ``x + (e / &2) * 1:real`` th) THEN
  MP_TAC(SPEC ``x:real`` th)) THEN
  REWRITE_TAC[dist, REAL_ARITH ``x - (x + e):real = -e``,
   REAL_ARITH ``(x + e = x) <=> (e:real = 0)``] THEN
  REWRITE_TAC[ABS_NEG, ABS_MUL, REAL_ENTIRE, ABS_0, REAL_SUB_REFL] THEN
  SIMP_TAC std_ss [ABS_1, REAL_ARITH ``~(1 = 0:real)``] THEN
  SIMP_TAC arith_ss [REAL_MUL_RID, REAL_EQ_LDIV_EQ,
   REAL_ARITH ``0 < 2:real``, REAL_MUL_LZERO] THEN
  GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN RW_TAC arith_ss [] THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN ASM_REWRITE_TAC [abs] THEN
  COND_CASES_TAC THENL
  [FULL_SIMP_TAC std_ss [REAL_LE_LT] THEN DISJ1_TAC THEN
   ASM_SIMP_TAC std_ss [REAL_LT_HALF2], ALL_TAC] THEN
  UNDISCH_TAC ``0 < e:real`` THEN GEN_REWR_TAC LAND_CONV [GSYM REAL_LT_HALF1] THEN
  DISCH_TAC THEN FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN METIS_TAC [REAL_LT_ANTISYM]);

val CBALL_SING = store_thm ("CBALL_SING",
 ``!x e. (e = &0) ==> (cball(x,e) = {x})``,
 REWRITE_TAC[CBALL_EQ_SING]);

val SPHERE_SING = store_thm ("SPHERE_SING",
 ``!x e. (e = &0) ==> (sphere(x,e) = {x})``,
  SIMP_TAC std_ss [sphere, DIST_EQ_0, GSPEC_EQ, GSPEC_EQ2]);

val SPHERE_EQ_SING = store_thm ("SPHERE_EQ_SING",
 ``!a:real r x. (sphere(a,r) = {x}) <=> (x = a) /\ (r = &0)``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [SPHERE_SING] THEN
  ASM_CASES_TAC ``r < &0:real`` THEN ASM_SIMP_TAC std_ss [SPHERE_EMPTY, NOT_INSERT_EMPTY] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN ASM_SIMP_TAC std_ss [SPHERE_SING] THENL
  [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC(SET_RULE
   ``!y. (x IN s ==> y IN s /\ ~(y = x)) ==> ~(s = {x})``) THEN
  EXISTS_TAC ``a - (x - a):real`` THEN REWRITE_TAC[IN_SPHERE] THEN
  REWRITE_TAC [dist] THEN REPEAT(POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* For points in the interior, localization of limits makes no difference.   *)
(* ------------------------------------------------------------------------- *)

val EVENTUALLY_WITHIN_INTERIOR = store_thm ("EVENTUALLY_WITHIN_INTERIOR",
 ``!p s x.
  x IN interior s
  ==> (eventually p (at x within s) <=> eventually p (at x))``,
  REWRITE_TAC[EVENTUALLY_WITHIN, EVENTUALLY_AT, IN_INTERIOR] THEN
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min (d:real) e`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[DIST_SYM]);

val LIM_WITHIN_INTERIOR = store_thm ("LIM_WITHIN_INTERIOR",
 ``!f l s x. x IN interior s
   ==> ((f --> l) (at x within s) <=> (f --> l) (at x))``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN_INTERIOR]);

val NETLIMIT_WITHIN_INTERIOR = store_thm ("NETLIMIT_WITHIN_INTERIOR",
 ``!s x:real. x IN interior s ==> (netlimit(at x within s) = x)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC NETLIMIT_WITHIN THEN
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP(REWRITE_RULE[OPEN_CONTAINS_BALL]
   (SPEC_ALL OPEN_INTERIOR))) THEN
  ASM_MESON_TAC[LIMPT_SUBSET, LIMPT_BALL, CENTRE_IN_CBALL, REAL_LT_IMP_LE,
   SUBSET_TRANS, INTERIOR_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* A non-singleton connected set is perfect (i.e. has no isolated points). *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_IMP_PERFECT = store_thm ("CONNECTED_IMP_PERFECT",
 ``!s x:real.
   connected s /\ ~(?a. s = {a}) /\ x IN s ==> x limit_point_of s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[limit_point_of] THEN
  X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `(~p ==> F) ==> p`) THEN DISCH_TAC THEN
  KNOW_TAC ``open t`` THENL [ASM_REWRITE_TAC [], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_CBALL] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``connected s`` THEN GEN_REWR_TAC LAND_CONV [CONNECTED_CLOPEN] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `{x:real}`) THEN
  REWRITE_TAC[NOT_IMP] THEN REPEAT CONJ_TAC THENL
  [REWRITE_TAC[OPEN_IN_OPEN] THEN EXISTS_TAC ``t:real->bool`` THEN
   ASM_SET_TAC[],
   REWRITE_TAC[CLOSED_IN_CLOSED] THEN
   EXISTS_TAC ``cball(x:real,e)`` THEN REWRITE_TAC[CLOSED_CBALL] THEN
   REWRITE_TAC[EXTENSION, IN_INTER, IN_SING] THEN
   ASM_MESON_TAC[CENTRE_IN_CBALL, SUBSET_DEF, REAL_LT_IMP_LE],
  ASM_SET_TAC[]]);

val CONNECTED_IMP_PERFECT_CLOSED = store_thm ("CONNECTED_IMP_PERFECT_CLOSED",
 ``!s x. connected s /\ closed s /\ ~(?a. s = {a})
   ==> (x limit_point_of s <=> x IN s)``,
  MESON_TAC[CONNECTED_IMP_PERFECT, CLOSED_LIMPT]);

(* ------------------------------------------------------------------------- *)
(* Boundedness.                                                              *)
(* ------------------------------------------------------------------------- *)

val bounded_def = new_definition ("bounded_def",
  ``bounded_def s <=> ?a. !x:real. x IN s ==> abs(x) <= a``);

val _ = overload_on ("bounded",``bounded_def``);

val BOUNDED_EMPTY = store_thm ("BOUNDED_EMPTY",
 ``bounded {}``,
  REWRITE_TAC[bounded_def, NOT_IN_EMPTY]);

val BOUNDED_SUBSET = store_thm ("BOUNDED_SUBSET",
 ``!s t. bounded t /\ s SUBSET t ==> bounded s``,
  MESON_TAC[bounded_def, SUBSET_DEF]);

val BOUNDED_INTERIOR = store_thm ("BOUNDED_INTERIOR",
 ``!s:real->bool. bounded s ==> bounded(interior s)``,
  MESON_TAC[BOUNDED_SUBSET, INTERIOR_SUBSET]);

val BOUNDED_CLOSURE = store_thm ("BOUNDED_CLOSURE",
 ``!s:real->bool. bounded s ==> bounded(closure s)``,
  REWRITE_TAC[bounded_def, CLOSURE_SEQUENTIAL] THEN
  GEN_TAC THEN STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN
  GEN_TAC THEN
  METIS_TAC[REWRITE_RULE[eventually] LIM_ABS_UBOUND,
   TRIVIAL_LIMIT_SEQUENTIALLY, trivial_limit]);

val BOUNDED_CLOSURE_EQ = store_thm ("BOUNDED_CLOSURE_EQ",
 ``!s:real->bool. bounded(closure s) <=> bounded s``,
  GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_CLOSURE] THEN
  MESON_TAC[BOUNDED_SUBSET, CLOSURE_SUBSET]);

val BOUNDED_CBALL = store_thm ("BOUNDED_CBALL",
 ``!x:real e. bounded(cball(x,e))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[bounded_def] THEN
  EXISTS_TAC ``abs(x:real) + e`` THEN REWRITE_TAC[IN_CBALL, dist] THEN
  REAL_ARITH_TAC);

val BOUNDED_BALL = store_thm ("BOUNDED_BALL",
 ``!x e. bounded(ball(x,e))``,
  MESON_TAC[BALL_SUBSET_CBALL, BOUNDED_CBALL, BOUNDED_SUBSET]);

val FINITE_IMP_BOUNDED = store_thm ("FINITE_IMP_BOUNDED",
 ``!s:real->bool. FINITE s ==> bounded s``,
  KNOW_TAC ``!s:real->bool. (bounded s) = (\s. bounded s) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN REWRITE_TAC[BOUNDED_EMPTY] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[bounded_def, IN_INSERT] THEN GEN_TAC THEN X_GEN_TAC ``x:real`` THEN
  REWRITE_TAC [AND_IMP_INTRO] THEN STRIP_TAC THEN
  EXISTS_TAC ``abs(x:real) + abs a`` THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[ABS_POS, REAL_ARITH
   ``(y <= b /\ &0 <= x ==> y <= x + abs b) /\ x <= x + abs b:real``]);

val BOUNDED_UNION = store_thm ("BOUNDED_UNION",
 ``!s t. bounded (s UNION t) <=> bounded s /\ bounded t``,
  REWRITE_TAC[bounded_def, IN_UNION] THEN MESON_TAC[REAL_LE_MAX]);

val BOUNDED_BIGUNION = store_thm ("BOUNDED_BIGUNION",
 ``!f. FINITE f /\ (!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!f. ((!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)) =
             (\f. (!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_EMPTY, BOUNDED_EMPTY, IN_INSERT, BIGUNION_INSERT] THEN
  MESON_TAC[BOUNDED_UNION]);

val BOUNDED_POS = store_thm ("BOUNDED_POS",
 ``!s. bounded s <=> ?b. &0 < b /\ !x. x IN s ==> abs(x) <= b``,
  REWRITE_TAC[bounded_def] THEN
  METIS_TAC[REAL_ARITH ``&0 < &1 + abs(y) /\ (x <= y ==> x:real <= &1 + abs(y))``]);

val BOUNDED_POS_LT = store_thm ("BOUNDED_POS_LT",
 ``!s. bounded s <=> ?b. &0 < b /\ !x. x IN s ==> abs(x) < b``,
  REWRITE_TAC[bounded_def] THEN
  MESON_TAC[REAL_LT_IMP_LE,
   REAL_ARITH ``&0 < &1 + abs(y) /\ (x <= y ==> x < &1 + abs(y:real))``]);

val BOUNDED_INTER = store_thm ("BOUNDED_INTER",
 ``!s t. bounded s \/ bounded t ==> bounded (s INTER t)``,
  MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET]);

val BOUNDED_DIFF = store_thm ("BOUNDED_DIFF",
 ``!s t. bounded s ==> bounded (s DIFF t)``,
  METIS_TAC[BOUNDED_SUBSET, DIFF_SUBSET]);

val BOUNDED_INSERT = store_thm ("BOUNDED_INSERT",
 ``!x s. bounded(x INSERT s) <=> bounded s``,
  ONCE_REWRITE_TAC[SET_RULE ``x INSERT s = {x} UNION s``] THEN
  SIMP_TAC std_ss [BOUNDED_UNION, FINITE_IMP_BOUNDED, FINITE_EMPTY, FINITE_INSERT]);

val BOUNDED_SING = store_thm ("BOUNDED_SING",
 ``!a. bounded {a}``,
  REWRITE_TAC[BOUNDED_INSERT, BOUNDED_EMPTY]);

val BOUNDED_BIGINTER = store_thm ("BOUNDED_BIGINTER",
 ``!f:(real->bool)->bool.
    (?s:real->bool. s IN f /\ bounded s) ==> bounded(BIGINTER f)``,
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] BOUNDED_SUBSET) THEN
  ASM_SET_TAC[]);

val NOT_BOUNDED_UNIV = store_thm ("NOT_BOUNDED_UNIV",
 ``~(bounded univ(:real))``,
  SIMP_TAC std_ss [BOUNDED_POS, NOT_FORALL_THM, NOT_EXISTS_THM, IN_UNIV,
                   DE_MORGAN_THM, REAL_NOT_LE] THEN
  X_GEN_TAC ``B:real`` THEN ASM_CASES_TAC ``&0 < B:real`` THEN ASM_REWRITE_TAC[] THEN
  EXISTS_TAC ``(B + &1):real`` THEN REAL_ARITH_TAC);

val COBOUNDED_IMP_UNBOUNDED = store_thm ("COBOUNDED_IMP_UNBOUNDED",
 ``!s. bounded(univ(:real) DIFF s) ==> ~bounded s``,
  GEN_TAC THEN REWRITE_TAC[TAUT `a ==> ~b <=> ~(a /\ b)`] THEN
  REWRITE_TAC[GSYM BOUNDED_UNION, SET_RULE ``UNIV DIFF s UNION s = UNIV``] THEN
  REWRITE_TAC[NOT_BOUNDED_UNIV]);

val BOUNDED_LINEAR_IMAGE = store_thm ("BOUNDED_LINEAR_IMAGE",
 ``!f:real->real s. bounded s /\ linear f ==> bounded(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``B1:real``) MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_TAC ``B2:real`` o MATCH_MP LINEAR_BOUNDED_POS) THEN
  EXISTS_TAC ``B2 * B1:real`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL, FORALL_IN_IMAGE] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``B2 * abs(x:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL]);

val BOUNDED_SCALING = store_thm ("BOUNDED_SCALING",
 ``!c s. bounded s ==> bounded (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC BOUNDED_LINEAR_IMAGE THEN
  ASM_SIMP_TAC std_ss [LINEAR_COMPOSE_CMUL, LINEAR_ID]);

val BOUNDED_NEGATIONS = store_thm ("BOUNDED_NEGATIONS",
 ``!s. bounded s ==> bounded (IMAGE (\x. -x) s)``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``-&1:real`` o MATCH_MP BOUNDED_SCALING) THEN
  REWRITE_TAC[bounded_def, IN_IMAGE, REAL_MUL_LNEG, REAL_MUL_LID]);

val BOUNDED_TRANSLATION = store_thm ("BOUNDED_TRANSLATION",
 ``!a:real s. bounded s ==> bounded (IMAGE (\x. a + x) s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real``) THEN
  EXISTS_TAC ``B + abs(a:real)`` THEN POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN REAL_ARITH_TAC);

val BOUNDED_TRANSLATION_EQ = store_thm ("BOUNDED_TRANSLATION_EQ",
 ``!a s. bounded (IMAGE (\x:real. a + x) s) <=> bounded s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o SPEC ``-a:real`` o MATCH_MP BOUNDED_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val BOUNDED_DIFFS = store_thm ("BOUNDED_DIFFS",
 ``!s t:real->bool.
  bounded s /\ bounded t ==> bounded {x - y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``B:real``) (X_CHOOSE_TAC ``C:real``)) THEN
  EXISTS_TAC ``B + C:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  CONJ_TAC THENL [MATCH_MP_TAC REAL_LT_ADD THEN ASM_REWRITE_TAC [], REPEAT STRIP_TAC] THEN
  ASM_REWRITE_TAC[] THEN KNOW_TAC ``abs p_1 <= B:real /\ abs p_2 <= C:real`` THENL
  [ASM_SET_TAC [], ALL_TAC] THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs p_1 + abs p_2:real`` THEN REWRITE_TAC [real_sub, ABS_TRIANGLE] THEN
  CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC [ABS_NEG]);

val BOUNDED_SUMS = store_thm ("BOUNDED_SUMS",
 ``!s t:real->bool.
   bounded s /\ bounded t ==> bounded {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``B:real``) (X_CHOOSE_TAC ``C:real``)) THEN
  EXISTS_TAC ``B + C:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  CONJ_TAC THENL [MATCH_MP_TAC REAL_LT_ADD THEN ASM_REWRITE_TAC [], REPEAT STRIP_TAC] THEN
  ASM_REWRITE_TAC[] THEN KNOW_TAC ``abs p_1 <= B:real /\ abs p_2 <= C:real`` THENL
  [ASM_SET_TAC [], ALL_TAC] THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs p_1 + abs p_2:real`` THEN REWRITE_TAC [ABS_TRIANGLE] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC []);

val BOUNDED_SUMS_IMAGE = store_thm ("BOUNDED_SUMS_IMAGE",
 ``!f g t. bounded {f x | x IN t} /\ bounded {g x | x IN t}
    ==> bounded {f x + g x | x IN t}``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_SUMS) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] BOUNDED_SUBSET) THEN
  REWRITE_TAC [SUBSET_DEF] THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC []);

val BOUNDED_SUMS_IMAGES = store_thm ("BOUNDED_SUMS_IMAGES",
 ``!f:'a->'b->real t s. FINITE s /\
     (!a. a IN s ==> bounded {f x a | x IN t})
     ==> bounded { sum s (f x) | x IN t}``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s. ((!a. a IN s ==> bounded {(f:'a->'b->real) x a | x IN t}) ==>
                                  bounded {sum s (f x) | x IN t}) =
             (\s. (!a. a IN s ==> bounded {f x a | x IN t}) ==>
                                  bounded {sum s (f x) | x IN t}) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES] THEN CONJ_TAC THENL
  [DISCH_THEN(K ALL_TAC) THEN MATCH_MP_TAC BOUNDED_SUBSET THEN
   EXISTS_TAC ``{0:real}`` THEN
   SIMP_TAC std_ss [FINITE_IMP_BOUNDED, FINITE_EMPTY, FINITE_INSERT] THEN SET_TAC[],
   ALL_TAC] THEN REPEAT STRIP_TAC THEN
  KNOW_TAC ``bounded {(f:'a->'b->real) x e | x IN t} /\
             bounded {sum s ((f:'a->'b->real) x) | x IN t}`` THENL
  [ALL_TAC, METIS_TAC [BOUNDED_SUMS_IMAGE]] THEN ASM_SIMP_TAC std_ss [IN_INSERT]);

val BOUNDED_SUBSET_BALL = store_thm ("BOUNDED_SUBSET_BALL",
 ``!s x:real. bounded(s) ==> ?r. &0 < r /\ s SUBSET ball(x,r)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``&2 * B + abs(x:real)`` THEN
  ASM_SIMP_TAC std_ss [ABS_POS, REAL_ARITH
   ``&0 < B /\ &0 <= x ==> &0 < &2 * B + x:real``] THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_REWRITE_TAC[IN_BALL, dist] THEN
  UNDISCH_TAC ``&0 < B:real`` THEN REAL_ARITH_TAC);

val BOUNDED_SUBSET_CBALL = store_thm ("BOUNDED_SUBSET_CBALL",
 ``!s x:real. bounded(s) ==> ?r. &0 < r /\ s SUBSET cball(x,r)``,
  MESON_TAC[BOUNDED_SUBSET_BALL, SUBSET_TRANS, BALL_SUBSET_CBALL]);

val UNBOUNDED_INTER_COBOUNDED = store_thm ("UNBOUNDED_INTER_COBOUNDED",
 ``!s t. ~bounded s /\ bounded(univ(:real) DIFF t) ==> ~(s INTER t = {})``,
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> s SUBSET univ(:real) DIFF t``] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val COBOUNDED_INTER_UNBOUNDED = store_thm ("COBOUNDED_INTER_UNBOUNDED",
 ``!s t. bounded(univ(:real) DIFF s) /\ ~bounded t ==> ~(s INTER t = {})``,
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> t SUBSET univ(:real) DIFF s``] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val SUBSPACE_BOUNDED_EQ_TRIVIAL = store_thm ("SUBSPACE_BOUNDED_EQ_TRIVIAL",
 ``!s:real->bool. subspace s ==> (bounded s <=> (s = {0}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [BOUNDED_SING] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (SET_RULE
  ``~(s = {a}) ==> a IN s ==> ?b. b IN s /\ ~(b = a)``)) THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_0] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real`` STRIP_ASSUME_TAC) THEN
  SIMP_TAC std_ss [bounded_def, NOT_EXISTS_THM] THEN X_GEN_TAC ``B:real`` THEN
  EXISTS_TAC ``(B + &1) / abs v * v:real`` THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM ABS_ZERO]) THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_MUL, ABS_MUL, ABS_DIV, ABS_ABS] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, ABS_ZERO] THEN REAL_ARITH_TAC);

val BOUNDED_COMPONENTWISE = store_thm ("BOUNDED_COMPONENTWISE",
 ``!s:real->bool.
   bounded s <=> bounded (IMAGE (\x. x) s)``,
 METIS_TAC [IMAGE_ID]);

(* ------------------------------------------------------------------------- *)
(* Some theorems on sups and infs using the notion "bounded".                *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_HAS_SUP = store_thm ("BOUNDED_HAS_SUP",
 ``!s. bounded s /\ ~(s = {})
    ==> (!x. x IN s ==> x <= sup s) /\
    (!b. (!x. x IN s ==> x <= b) ==> sup s <= b)``,
  REWRITE_TAC[bounded_def, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[SUP, REAL_ARITH ``abs(x) <= a ==> x <= a:real``]);

val SUP_INSERT = store_thm ("SUP_INSERT",
 ``!x s:real->bool. bounded s
   ==> (sup(x INSERT s) = if s = {} then x else (max x (sup s)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_SUP_UNIQUE THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_SING] THENL
  [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
   REWRITE_TAC[REAL_LE_MAX, REAL_LT_MAX, IN_INSERT] THEN
   MP_TAC(ISPEC ``s:real->bool`` BOUNDED_HAS_SUP) THEN ASM_REWRITE_TAC[] THEN
   REPEAT STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_REFL, REAL_NOT_LT]);

val BOUNDED_HAS_INF = store_thm ("BOUNDED_HAS_INF",
 ``!s. bounded s /\ ~(s = {})
   ==> (!x. x IN s ==> inf s <= x) /\
   (!b. (!x. x IN s ==> b <= x) ==> b <= inf s)``,
  REWRITE_TAC[bounded_def, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[INF, REAL_ARITH ``abs(x) <= a ==> -a <= x:real``]);

val INF_INSERT = store_thm ("INF_INSERT",
 ``!x s. bounded s
   ==> (inf(x INSERT s) = if s = {} then x else (min x (inf s)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_INF_UNIQUE THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_SING] THENL
  [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
   REWRITE_TAC[REAL_MIN_LE, REAL_MIN_LT, IN_INSERT] THEN
   MP_TAC(ISPEC ``s:real->bool`` BOUNDED_HAS_INF) THEN ASM_REWRITE_TAC[] THEN
   REPEAT STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_REFL, REAL_NOT_LT]);

(* ------------------------------------------------------------------------- *)
(* Subset and overlapping relations on balls.                                *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``(!a':real r r'.
       cball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r < &0) /\
     (!a':real r r'.
       cball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r < r' \/ r < &0)``,
    CONJ_TAC THENL
    [KNOW_TAC ``(!a' r r'.
  cball (a,r) SUBSET cball (a',r') <=> dist (a,a') + r <= r' \/ r < 0) =
               (!r r' a.
  cball (a,r) SUBSET cball (0,r') <=> dist (a,0) + r <= r' \/ r < 0)`` THENL
  [EQ_TAC THENL
   [DISCH_TAC THEN REPEAT GEN_TAC THEN
    FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
     REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``a - (a - b) = b:real``] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
    [DISCH_TAC THEN GEN_TAC THEN
     POP_ASSUM (MP_TAC o Q.SPEC `-(a - a' - x:real)`) THEN
     REWRITE_TAC [ABS_NEG] THEN REAL_ARITH_TAC, ALL_TAC] THEN
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a + a' - x:real)`) THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN
  FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
   REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN GEN_TAC THEN
   POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
  REAL_ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC[] THEN POP_ASSUM K_TAC],
    KNOW_TAC ``(!a' r r'.
  cball (a,r) SUBSET ball (a',r') <=> dist (a,a') + r < r' \/ r < 0) =
               (!r r' a.
  cball (a,r) SUBSET ball (0,r') <=> dist (a,0) + r < r' \/ r < 0)`` THENL
  [EQ_TAC THENL
   [DISCH_TAC THEN REPEAT GEN_TAC THEN
    FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
     REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``a - (a - b) = b:real``] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
    [DISCH_TAC THEN GEN_TAC THEN
     POP_ASSUM (MP_TAC o Q.SPEC `-(a - a' - x:real)`) THEN
     REWRITE_TAC [ABS_NEG] THEN REAL_ARITH_TAC, ALL_TAC] THEN
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a + a' - x:real)`) THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN
  FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
   REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN GEN_TAC THEN
   POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
  REAL_ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC[] THEN POP_ASSUM K_TAC]] THEN
   (REPEAT GEN_TAC THEN REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_BALL] THEN
    EQ_TAC THENL
    [REWRITE_TAC[DIST_0],
     REWRITE_TAC [dist] THEN REAL_ARITH_TAC] THEN
    DISJ_CASES_TAC(REAL_ARITH ``r < &0 \/ &0 <= r:real``) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN DISJ1_TAC THEN
    ASM_CASES_TAC ``a:real = 0`` THENL
     [FIRST_X_ASSUM(MP_TAC o SPEC ``r:real``) THEN
      ASM_SIMP_TAC std_ss [DIST_0, ABS_MUL, LESS_EQ_REFL] THEN
      ASM_REAL_ARITH_TAC,
      FIRST_X_ASSUM(MP_TAC o SPEC ``(&1 + r / abs(a)) * a:real``) THEN
      SIMP_TAC std_ss [dist, REAL_ARITH ``a - (&1 + x) * a:real = -(x * a)``] THEN
      ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, ABS_NEG, REAL_POS,
                   REAL_LE_DIV, ABS_POS, REAL_ADD_RDISTRIB, REAL_DIV_RMUL,
               ABS_ZERO, REAL_ARITH ``&0 <= x ==> (abs(&1 + x) = &1 + x:real)``] THEN
      ASM_REAL_ARITH_TAC]));

val tac = DISCH_THEN(MP_TAC o MATCH_MP SUBSET_CLOSURE) THEN
          ASM_SIMP_TAC std_ss [CLOSED_CBALL, CLOSURE_CLOSED, CLOSURE_BALL];

val SUBSET_BALLS = store_thm ("SUBSET_BALLS",
 ``(!a a':real r r'.
      ball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r <= r' \/ r <= &0) /\
   (!a a':real r r'.
      ball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r <= &0) /\
   (!a a':real r r'.
      cball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r < r' \/ r < &0) /\
   (!a a':real r r'.
      cball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r < &0)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  KNOW_TAC ``(!a a':real r r'.
  (ball (a,r) SUBSET ball (a',r') <=>
   dist (a,a') + r <= r' \/ r <= 0) /\
  (ball (a,r) SUBSET cball (a',r') <=>
   dist (a,a') + r <= r' \/ r <= 0) /\
  (cball (a,r) SUBSET ball (a',r') <=>
     dist (a,a') + r < r' \/ r < 0) /\
  (cball (a,r) SUBSET cball (a',r') <=>
    dist (a,a') + r <= r' \/ r < 0)) =
   (!a:real r r'.
  (ball (a,r) SUBSET ball (0,r') <=>
   dist (a,0) + r <= r' \/ r <= 0) /\
  (ball (a,r) SUBSET cball (0,r') <=>
   dist (a,0) + r <= r' \/ r <= 0) /\
  (cball (a,r) SUBSET ball (0,r') <=>
     dist (a,0) + r < r' \/ r < 0) /\
  (cball (a,r) SUBSET cball (0,r') <=>
    dist (a,0) + r <= r' \/ r < 0))`` THENL
 [EQ_TAC THENL
  [DISCH_TAC THEN REPEAT GEN_TAC THEN METIS_TAC [], ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [DIST_0] THEN
  FULL_SIMP_TAC std_ss [cball, ball, dist, SUBSET_DEF, GSPECIFICATION] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [EQ_SYM_EQ] THEN
  REPEAT STRIP_TAC THENL
  [UNDISCH_TAC ``abs (a - a') + r <= r' \/ r <= 0 <=>
        !x:real. abs (a - a' - x) < r ==> abs x < r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r <= r' \/ r <= 0 <=>
        !x:real. abs (a - a' - x) < r ==> abs x <= r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r < r' \/ r < 0 <=>
        !x:real. abs (a - a' - x) <= r ==> abs x < r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r <= r' \/ r < 0 <=>
        !x:real. abs (a - a' - x) <= r ==> abs x <= r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC]],
 DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  REPEAT STRIP_TAC THEN
  (EQ_TAC THENL
    [ALL_TAC, REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL, dist] THEN REAL_ARITH_TAC]) THEN
  MATCH_MP_TAC(SET_RULE
   ``((s = {}) <=> q) /\ (s SUBSET t /\ ~(s = {}) /\ ~(t = {}) ==> p)
    ==> s SUBSET t ==> p \/ q``) THEN
  SIMP_TAC std_ss [BALL_EQ_EMPTY, CBALL_EQ_EMPTY, REAL_NOT_LE, REAL_NOT_LT] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THENL
   [tac, tac, ALL_TAC, ALL_TAC] THEN REWRITE_TAC[lemma] THEN
  REPEAT(POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

(* NOTE: this proof needs 10s to finish (last step created 2048*4 subgoals *)
val INTER_BALLS_EQ_EMPTY = store_thm
  ("INTER_BALLS_EQ_EMPTY",
 ``(!a b:real r s. (ball(a,r) INTER ball(b,s) = {}) <=>
                     r <= &0 \/ s <= &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (ball(a,r) INTER cball(b,s) = {}) <=>
                     r <= &0 \/ s < &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (cball(a,r) INTER ball(b,s) = {}) <=>
                     r < &0 \/ s <= &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (cball(a,r) INTER cball(b,s) = {}) <=>
                     r < &0 \/ s < &0 \/ r + s < dist(a,b))``,
  REPEAT STRIP_TAC THENL
  [KNOW_TAC ``!b:real. 0 <= b ==>
               !r s:real. ((ball (0,r) INTER ball (b,s) = {}) <=>
                r <= 0 \/ s <= 0 \/ r + s <= dist (0,b))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [ball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]],

   KNOW_TAC ``!b:real. 0 <= b ==>
               !r s:real. ((ball (0,r) INTER cball (b,s) = {}) <=>
                r <= 0 \/ s < 0 \/ r + s <= dist (0,b))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]],

   KNOW_TAC ``!b:real. 0 <= b ==>
               !r s:real. ((cball (0,r) INTER ball (b,s) = {}) <=>
                r < 0 \/ s <= 0 \/ r + s <= dist (0,b))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]],

   KNOW_TAC ``!b:real. 0 <= b ==>
               !r s:real. ((cball (0,r) INTER cball (b,s) = {}) <=>
                r < 0 \/ s < 0 \/ r + s < dist (0,b))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]]] THEN

  REPEAT STRIP_TAC THEN
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY, IN_INTER, IN_CBALL, IN_BALL] THEN
  (EQ_TAC THENL
    [ALL_TAC, SPEC_TAC(``b:real``,``v:real``) THEN
              REWRITE_TAC [dist] THEN REAL_ARITH_TAC]) THEN
  DISCH_THEN(MP_TAC o GEN ``c:real`` o SPEC ``c:real``) THEN
  SIMP_TAC std_ss [ABS_MUL, LESS_EQ_REFL, dist, ABS_NEG,
           REAL_SUB_LZERO, GSYM REAL_SUB_RDISTRIB, REAL_MUL_RID] THEN
  ASM_REWRITE_TAC[abs] THEN REWRITE_TAC[GSYM abs] THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``min b r:real`` th) THEN
    MP_TAC(SPEC ``max (&0) (b - s:real)`` th) THEN
    MP_TAC(SPEC ``(r + (b - s)) / &2:real`` th)) THEN
  REWRITE_TAC [real_div] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a - b * c = a * 1 - b * c:real``] THEN
  REWRITE_TAC [METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``, real_div]
   ``1 = 2 * inv 2:real``, REAL_ARITH ``a * (b * c) = (a * b) * c:real``] THEN
  REWRITE_TAC [GSYM REAL_SUB_RDISTRIB] THEN
  SIMP_TAC std_ss [real_div, ABS_MUL, REAL_ARITH ``2 <> 0:real``, ABS_INV, ABS_N] THEN
  SIMP_TAC std_ss [GSYM real_div] THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_LE_RDIV_EQ,
                       REAL_LT_LDIV_EQ, REAL_LE_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN

  RW_TAC bool_ss [abs, max_def, min_def] THEN (* 2048 subgoals (each) *)
  ASM_REAL_ARITH_TAC THEN
  PRINT_TAC "stage work in INTER_BALLS_EQ_EMPTY");

(* ------------------------------------------------------------------------- *)
(* Every closed set is a G_Delta.                                            *)
(* ------------------------------------------------------------------------- *)

val CLOSED_AS_GDELTA = store_thm ("CLOSED_AS_GDELTA",
 ``!s:real->bool. closed s ==> ?g. COUNTABLE g /\
   (!u. u IN g ==> open u) /\ (BIGINTER g = s)``,
  REPEAT STRIP_TAC THEN EXISTS_TAC
   ``{ BIGUNION { ball(x:real,inv(&n + &1)) | x IN s} | n IN univ(:num)}`` THEN
  SIMP_TAC std_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, NUM_COUNTABLE] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, OPEN_BIGUNION, OPEN_BALL] THEN
  MATCH_MP_TAC(SET_RULE
   ``(closure s = s) /\ s SUBSET t /\ t SUBSET closure s ==> (t = s)``) THEN
  ASM_REWRITE_TAC[CLOSURE_EQ] THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [SUBSET_BIGINTER, FORALL_IN_IMAGE, IN_UNIV] THEN
   X_GEN_TAC ``n:num`` THEN SIMP_TAC std_ss [BIGUNION_IMAGE, SUBSET_DEF, GSPECIFICATION] THEN
   X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN EXISTS_TAC ``x:real`` THEN
   ASM_REWRITE_TAC[CENTRE_IN_BALL, REAL_LT_INV_EQ] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``1:real`` THEN CONJ_TAC THENL
   [REAL_ARITH_TAC, ALL_TAC] THEN REWRITE_TAC [REAL_LE_ADDL, REAL_POS],
   SIMP_TAC std_ss [SUBSET_DEF, CLOSURE_APPROACHABLE, BIGINTER_IMAGE, IN_UNIV] THEN
   X_GEN_TAC ``x:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, BIGUNION_IMAGE] THEN
   DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
   POP_ASSUM MP_TAC THEN GEN_REWR_TAC LAND_CONV [REAL_ARCH_INV] THEN
   DISCH_THEN(X_CHOOSE_THEN ``n:num`` STRIP_ASSUME_TAC) THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``n:num``) THEN REWRITE_TAC[IN_BALL] THEN
   DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
   POP_ASSUM MP_TAC THEN MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
   MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LT_TRANS) THEN
   FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT] REAL_LT_TRANS)) THEN
   MATCH_MP_TAC REAL_LT_INV2 THEN
   REWRITE_TAC[REAL_OF_NUM_ADD, REAL_LT] THEN CONJ_TAC THENL
   [FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ, GSYM REAL_LT],
    FULL_SIMP_TAC arith_ss [REAL_LT_ADDR]]]);

(* ------------------------------------------------------------------------- *)
(* Compactness (the definition is the one based on convegent subsequences).  *)
(* ------------------------------------------------------------------------- *)

val compact = new_definition ("compact",
 ``compact s <=> !f:num->real. (!n. f(n) IN s)
   ==> ?l r. l IN s /\ (!m n:num. m < n ==> r(m) < r(n)) /\
       ((f o r) --> l) sequentially``);

val MONOTONE_BIGGER = store_thm ("MONOTONE_BIGGER",
 ``!r. (!m n. m < n ==> r(m) < r(n)) ==> !n:num. n <= r(n)``,
  GEN_TAC THEN DISCH_TAC THEN INDUCT_TAC THEN
  METIS_TAC[ZERO_LESS_EQ, ARITH_PROVE ``n <= m /\ m < p ==> SUC n <= p``, LT]);

val LIM_SUBSEQUENCE = store_thm ("LIM_SUBSEQUENCE",
 ``!s r l. (!m n. m < n ==> r(m) < r(n)) /\ (s --> l) sequentially
  ==> (s o r --> l) sequentially``,
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  MESON_TAC[MONOTONE_BIGGER, LESS_EQ_TRANS]);

val MONOTONE_SUBSEQUENCE = store_thm ("MONOTONE_SUBSEQUENCE",
 ``!s:num->real. ?r:num->num.
   (!m n. m < n ==> r(m) < r(n)) /\
  ((!m n. m <= n ==> s(r(m)) <= s(r(n))) \/
   (!m n. m <= n ==> s(r(n)) <= s(r(m))))``,
  GEN_TAC THEN
  ASM_CASES_TAC ``!n:num. ?p. n < p /\ !m. p <= m ==> s(m):real <= s(p)`` THEN
  POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, NOT_IMP, DE_MORGAN_THM] THEN
  SIMP_TAC std_ss [RIGHT_OR_EXISTS_THM, SKOLEM_THM, REAL_NOT_LE, REAL_NOT_LT] THENL
  [ABBREV_TAC ``N = 0:num``, DISCH_THEN(X_CHOOSE_THEN ``N:num`` MP_TAC)] THEN
  DISCH_THEN(X_CHOOSE_THEN ``next:num->num`` STRIP_ASSUME_TAC) THEN
  (KNOW_TAC ``(?r. (r 0 = (next:num->num) (SUC N)) /\
             (!n. r (SUC n) = (next:num->num) (r n)))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC]) THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THENL
  [SUBGOAL_THEN ``!m:num n:num. r n <= m ==> s(m) <= s(r n):real``
   ASSUME_TAC THEN TRY CONJ_TAC THEN TRY DISJ2_TAC THEN
   GEN_TAC THEN INDUCT_TAC THEN ASM_SIMP_TAC std_ss [LT, LE] THEN
   ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL, LESS_IMP_LESS_OR_EQ, LESS_TRANS],
   SUBGOAL_THEN ``!n. N < (r:num->num) n`` ASSUME_TAC THEN
   TRY(CONJ_TAC THENL [GEN_TAC, DISJ1_TAC THEN GEN_TAC]) THEN
   INDUCT_TAC THEN ASM_SIMP_TAC std_ss [LT, LE] THEN
   TRY STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
   ASM_MESON_TAC[REAL_LT_REFL, LT_LE, LESS_LESS_EQ_TRANS, REAL_LE_REFL,
    REAL_LT_LE, REAL_LE_TRANS, LT]]);

val CONVERGENT_BOUNDED_INCREASING = store_thm ("CONVERGENT_BOUNDED_INCREASING",
 ``!s:num->real b. (!m n. m <= n ==> s m <= s n) /\ (!n. abs(s n) <= b)
   ==> ?l. !e. &0 < e ==> ?N. !n. N <= n ==> abs(s n - l) < e``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``\x. ?n. (s:num->real) n = x`` REAL_COMPLETE) THEN BETA_TAC THEN
  KNOW_TAC ``(?x:real n:num. s n = x) /\ (?M. !x. (?n. s n = x) ==> x <= M)`` THENL
  [ASM_MESON_TAC[REAL_ARITH ``abs(x:real) <= b ==> x <= b``],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN EXISTS_TAC ``l:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``l - e:real``) THEN
  METIS_TAC[REAL_ARITH ``&0:real < e ==> ~(l <= l - e)``,
  REAL_ARITH ``x <= y /\ y <= l /\ ~(x <= l - e) ==> abs(y - l) < e:real``]);

val CONVERGENT_BOUNDED_MONOTONE = store_thm ("CONVERGENT_BOUNDED_MONOTONE",
 ``!s:num->real b. (!n. abs(s n) <= b) /\
   ((!m n. m <= n ==> s m <= s n) \/
    (!m n. m <= n ==> s n <= s m))
   ==> ?l. !e. &0 < e ==> ?N. !n. N <= n ==> abs(s n - l) < e``,
  REPEAT STRIP_TAC THENL
  [ASM_MESON_TAC[CONVERGENT_BOUNDED_INCREASING], ALL_TAC] THEN
  MP_TAC(SPEC ``\n. -((s:num->real) n)`` CONVERGENT_BOUNDED_INCREASING) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_NEG2, ABS_NEG] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x - -l) = abs(-x - l:real)``]);

val COMPACT_REAL_LEMMA = store_thm ("COMPACT_REAL_LEMMA",
 ``!s b. (!n:num. abs(s n) <= b)
   ==> ?l r. (!m n:num. m < n ==> r(m) < r(n)) /\
   !e. &0:real < e ==> ?N. !n. N <= n ==> abs(s(r n) - l) < e``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  KNOW_TAC ``?(r :num -> num) (l :real).
  (!(m :num) (n :num). m < n ==> r m < r n) /\
  !(e :real).
    (0 :real) < e ==>
    ?(N :num).
      !(n :num). N <= n ==> abs ((s :num -> real) (r n) - l) < e`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  MP_TAC(SPEC ``s:num->real`` MONOTONE_SUBSEQUENCE) THEN
  DISCH_THEN (X_CHOOSE_TAC ``r:num->num``) THEN EXISTS_TAC ``r:num->num`` THEN
  ASM_SIMP_TAC std_ss [] THEN POP_ASSUM MP_TAC THEN STRIP_TAC THENL
  [MP_TAC(SPEC ``\n. ((s:num->real) ((r:num->num) n))`` CONVERGENT_BOUNDED_INCREASING),
   MP_TAC(SPEC ``\n. -((s:num->real) ((r:num->num) n))`` CONVERGENT_BOUNDED_INCREASING)] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_NEG2, ABS_NEG] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x - -l) = abs(-x - l:real)``]);

val COMPACT_LEMMA = store_thm ("COMPACT_LEMMA",
``!s. bounded s /\ (!n. (x:num->real) n IN s)
      ==> ?l:real r. (!m n. m < n ==> r m < (r:num->num) n) /\
      !e. &0 < e ==> ?N. !n i. N <= n ==> abs(x(r n) - l) < e``,
  METIS_TAC [COMPACT_REAL_LEMMA, bounded_def]);

val BOUNDED_CLOSED_IMP_COMPACT = store_thm ("BOUNDED_CLOSED_IMP_COMPACT",
 ``!s:real->bool. bounded s /\ closed s ==> compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[compact] THEN
  X_GEN_TAC ``x:num->real`` THEN DISCH_TAC THEN
  MP_TAC(ISPEC ``s:real->bool`` COMPACT_LEMMA) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC [``l:real``, ``r:num->num``] THEN
  ASM_SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC(TAUT `(b ==> a) /\ b ==> a /\ b`) THEN
  REPEAT STRIP_TAC THENL
  [FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CLOSED_SEQUENTIAL_LIMITS]) THEN
   EXISTS_TAC ``(x:num->real) o (r:num->num)`` THEN
   ASM_SIMP_TAC std_ss [o_THM], ALL_TAC] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, REAL_HALF,
   ARITH_PROVE ``0:num < n <=> ~(n = 0)``] THEN
  STRIP_TAC THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN
  REWRITE_TAC[dist] THEN REPEAT STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  GEN_REWR_TAC LAND_CONV [GSYM REAL_ADD_RID] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
  UNDISCH_TAC `` !n:num. N <= n ==> abs (x ((r:num->num) n) - l) < e / 2:real`` THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `n:num`) THEN
  ASM_REWRITE_TAC [] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  METIS_TAC [REAL_LT_HALF1]);

(* ------------------------------------------------------------------------- *)
(* Completeness.                                                             *)
(* ------------------------------------------------------------------------- *)

val cauchy = new_definition ("cauchy",
  ``cauchy (s:num->real) <=>
     !e. &0 < e ==> ?N. !m n. m >= N /\ n >= N ==> dist(s m,s n) < e``);

val complete = new_definition ("complete",
  ``complete s <=>
     !f:num->real. (!n. f n IN s) /\ cauchy f
                      ==> ?l. l IN s /\ (f --> l) sequentially``);

val CAUCHY = store_thm ("CAUCHY",
 ``!s:num->real.
      cauchy s <=> !e. &0 < e ==> ?N. !n. n >= N ==> dist(s n,s N) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[cauchy, GREATER_EQ] THEN EQ_TAC THENL
   [MESON_TAC[LESS_EQ_REFL], DISCH_TAC] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  MESON_TAC[DIST_TRIANGLE_HALF_L]);

val CONVERGENT_IMP_CAUCHY = store_thm ("CONVERGENT_IMP_CAUCHY",
 ``!s l. (s --> l) sequentially ==> cauchy s``,
  REWRITE_TAC[LIM_SEQUENTIALLY, cauchy] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  ASM_MESON_TAC[GREATER_EQ, LESS_EQ_REFL, DIST_TRIANGLE_HALF_L]);

val GREATER_EQ_REFL = store_thm ("GREATER_EQ_REFL",
  ``!m:num. m >= m``,
  REWRITE_TAC [GREATER_EQ, LESS_EQ_REFL]);

val UPPER_BOUND_FINITE_SET_REAL = store_thm ("UPPER_BOUND_FINITE_SET_REAL",
 ``!f:('a->real) s. FINITE(s) ==> ?a. !x. x IN s ==> f(x) <= a``,
  REPEAT GEN_TAC THEN
  KNOW_TAC `` (?a. !x. x IN s ==> (f:'a->real) x <= a) =
          (\s. ?a. !x. x IN s ==> (f:'a->real) x <= a) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[IN_INSERT, NOT_IN_EMPTY] THEN
  MESON_TAC[REAL_LE_TOTAL, REAL_LE_REFL, REAL_LE_TRANS]);

val CAUCHY_IMP_BOUNDED = store_thm ("CAUCHY_IMP_BOUNDED",
 ``!s:num->real. cauchy s ==> bounded {y | ?n. y = s n}``,
  REWRITE_TAC[cauchy, bounded_def, GSPECIFICATION] THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``&1:real``) THEN REWRITE_TAC[REAL_LT_01] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` (MP_TAC o SPEC ``N:num``)) THEN
  REWRITE_TAC[GREATER_EQ_REFL] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``!n:num. N <= n ==> abs(s n :real) <= abs(s N) + &1:real``
  ASSUME_TAC THENL
   [ASM_MESON_TAC[GREATER_EQ, dist, DIST_SYM, ABS_TRIANGLE_SUB,
                  REAL_ARITH ``a <= b + c /\ c < &1 ==> a <= b + &1:real``],
    MP_TAC(ISPECL [``\n:num. abs(s n :real)``, ``0..N``]
                  UPPER_BOUND_FINITE_SET_REAL) THEN
    SIMP_TAC std_ss [FINITE_NUMSEG, IN_NUMSEG, LESS_EQ_0, GSYM LEFT_EXISTS_IMP_THM] THEN
    ASM_MESON_TAC[LESS_EQ_CASES,
                  REAL_ARITH ``x <= a \/ x <= b ==> x <= abs a + abs b:real``]]);

val COMPACT_IMP_COMPLETE = store_thm ("COMPACT_IMP_COMPLETE",
 ``!s:real->bool. compact s ==> complete s``,
  GEN_TAC THEN REWRITE_TAC[complete, compact] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `f:num->real`) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN EXISTS_TAC ``l:real`` THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP] LIM_ADD)) THEN
  DISCH_THEN(MP_TAC o SPEC ``\n. (f:num->real)(n) - f(r n)``) THEN
  DISCH_THEN(MP_TAC o SPEC ``0:real``) THEN ASM_SIMP_TAC std_ss [o_THM] THEN
  SIMP_TAC std_ss [REAL_ADD_RID, REAL_SUB_ADD2, ETA_AX] THEN
  DISCH_THEN MATCH_MP_TAC THEN
  UNDISCH_TAC ``cauchy f`` THEN GEN_REWR_TAC LAND_CONV [cauchy] THEN
  SIMP_TAC std_ss [GE, LIM, SEQUENTIALLY, dist, REAL_SUB_RZERO] THEN
  SUBGOAL_THEN ``!n:num. n <= r(n)`` MP_TAC THENL [INDUCT_TAC, ALL_TAC] THEN
  ASM_MESON_TAC[LESS_EQ_TRANS, LESS_EQ_REFL, LT, LESS_EQ_LESS_TRANS, ZERO_LESS_EQ, LE_SUC_LT]);

val COMPLETE_UNIV = store_thm ("COMPLETE_UNIV",
 ``complete univ(:real)``,
  REWRITE_TAC[complete, IN_UNIV] THEN X_GEN_TAC ``x:num->real`` THEN
  DISCH_TAC THEN FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_IMP_BOUNDED) THEN
  DISCH_THEN(ASSUME_TAC o MATCH_MP BOUNDED_CLOSURE) THEN
  MP_TAC(ISPEC ``closure {y:real | ?n:num. y = x n}``
   COMPACT_IMP_COMPLETE) THEN
  ASM_SIMP_TAC std_ss [BOUNDED_CLOSED_IMP_COMPACT, CLOSED_CLOSURE, complete] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:num->real``) THEN
  KNOW_TAC ``(!n. x n IN closure {y | ?n. y = x n}) /\ cauchy x`` THENL
  [ALL_TAC, MESON_TAC[]] THEN
  ASM_SIMP_TAC std_ss [closure, GSPECIFICATION, IN_UNION] THEN MESON_TAC[]);

val COMPLETE_EQ_CLOSED = store_thm ("COMPLETE_EQ_CLOSED",
 ``!s:real->bool. complete s <=> closed s``,
  GEN_TAC THEN EQ_TAC THENL
  [REWRITE_TAC[complete, CLOSED_LIMPT, LIMPT_SEQUENTIAL] THEN
   SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN GEN_TAC THEN
   SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN DISCH_TAC THEN
   GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `f:num->real`) THEN
   MESON_TAC[CONVERGENT_IMP_CAUCHY, IN_DELETE, LIM_UNIQUE,
    TRIVIAL_LIMIT_SEQUENTIALLY],
   REWRITE_TAC[complete, CLOSED_SEQUENTIAL_LIMITS] THEN DISCH_TAC THEN
   X_GEN_TAC ``f:num->real`` THEN STRIP_TAC THEN
   MP_TAC(REWRITE_RULE[complete] COMPLETE_UNIV) THEN
   DISCH_THEN(MP_TAC o SPEC ``f:num->real``) THEN
   ASM_REWRITE_TAC[IN_UNIV] THEN ASM_MESON_TAC[]]);

val CONVERGENT_EQ_CAUCHY = store_thm ("CONVERGENT_EQ_CAUCHY",
 ``!s. (?l. (s --> l) sequentially) <=> cauchy s``,
  GEN_TAC THEN EQ_TAC THENL
  [METIS_TAC [LEFT_IMP_EXISTS_THM, CONVERGENT_IMP_CAUCHY],
   REWRITE_TAC[REWRITE_RULE[complete, IN_UNIV] COMPLETE_UNIV]]);

val CONVERGENT_IMP_BOUNDED = store_thm ("CONVERGENT_IMP_BOUNDED",
 ``!s l. (s --> l) sequentially ==> bounded (IMAGE s univ(:num))``,
  SIMP_TAC std_ss [LEFT_FORALL_IMP_THM, CONVERGENT_EQ_CAUCHY] THEN
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP CAUCHY_IMP_BOUNDED) THEN
  REWRITE_TAC [bounded_def] THEN SET_TAC []);

(* ------------------------------------------------------------------------- *)
(* Total boundedness.                                                        *)
(* ------------------------------------------------------------------------- *)

val COMPACT_IMP_TOTALLY_BOUNDED = store_thm
  ("COMPACT_IMP_TOTALLY_BOUNDED",
 ``!s:real->bool. compact s
   ==> !e. &0 < e ==> ?k. FINITE k /\ k SUBSET s /\
       s SUBSET (BIGUNION (IMAGE (\x. ball(x,e)) k))``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  REWRITE_TAC[TAUT `~(a /\ b /\ c) <=> a /\ b ==> ~c`, SUBSET_DEF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``?x:num->real. !n. x(n) IN s /\ !m. m < n ==> ~(dist(x(m),x(n)) < e)``
   MP_TAC THENL
  [SUBGOAL_THEN
   ``?x:num->real.
     !n. x(n) = @y. y IN s /\ !m. m < n ==> ~(dist(x(m),y) < e)``
     MP_TAC THENL
   [KNOW_TAC ``?(x :num -> real). !(n :num). x n =
    (\x n. @(y :real). y IN (s :real -> bool) /\
      !(m :num). m < n ==> ~((dist (x m,y) :real) < (e :real))) x n`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC(MATCH_MP WF_REC WF_num) THEN SIMP_TAC std_ss [], ALL_TAC] THEN
    DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN EXISTS_TAC ``x:num->real`` THEN
    KNOW_TAC ``!(n :num). (\n. (x :num -> real) n IN (s :real -> bool) /\
     !(m :num). m < n ==> ~((dist (x m,x n) :real) < (e :real))) n`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC COMPLETE_INDUCTION THEN X_GEN_TAC ``n:num`` THEN
    BETA_TAC THEN FIRST_X_ASSUM(SUBST1_TAC o SPEC ``n:num``) THEN STRIP_TAC THEN
    CONV_TAC SELECT_CONV THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (x:num->real) {m | m < n}``) THEN
    SIMP_TAC std_ss [IMAGE_FINITE, FINITE_NUMSEG_LT, NOT_FORALL_THM, NOT_IMP] THEN
    SIMP_TAC std_ss [IN_BIGUNION, IN_IMAGE, GSPECIFICATION] THEN METIS_TAC[IN_BALL],
    ALL_TAC] THEN
   SIMP_TAC std_ss [compact, NOT_FORALL_THM] THEN
   DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN EXISTS_TAC ``x:num->real`` THEN
   POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN
   STRIP_TAC THEN ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN REPEAT STRIP_TAC THEN
   CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
   FIRST_X_ASSUM(MP_TAC o MATCH_MP CONVERGENT_IMP_CAUCHY) THEN
   REWRITE_TAC[cauchy] THEN DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN
   ASM_SIMP_TAC std_ss [o_THM, NOT_EXISTS_THM, NOT_IMP, NOT_FORALL_THM, NOT_IMP] THEN
   X_GEN_TAC ``N:num`` THEN MAP_EVERY EXISTS_TAC [``N:num``, ``SUC N``] THEN
   CONJ_TAC THENL [ARITH_TAC, ASM_MESON_TAC[LT]]);

(* ------------------------------------------------------------------------- *)
(* Heine-Borel theorem (following Burkill & Burkill vol. 2) *)
(* ------------------------------------------------------------------------- *)

val HEINE_BOREL_LEMMA = store_thm ("HEINE_BOREL_LEMMA",
 ``!s:real->bool. compact s
    ==> !t. s SUBSET (BIGUNION t) /\ (!b. b IN t ==> open b)
       ==> ?e. &0 < e /\
           !x. x IN s ==> ?b. b IN t /\ ball(x,e) SUBSET b``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(CHOOSE_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT_01, REAL_ARITH ``x <= y ==> x < y + &1:real``,
   FORALL_AND_THM, REAL_POS, NOT_FORALL_THM, NOT_IMP, SKOLEM_THM, compact] THEN
  DISCH_THEN (X_CHOOSE_TAC ``f:num->real``) THEN
  EXISTS_TAC ``f:num->real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``?b:real->bool. l IN b /\ b IN t`` STRIP_ASSUME_TAC THENL
  [ASM_MESON_TAC[SUBSET_DEF, IN_BIGUNION], ALL_TAC] THEN
  SUBGOAL_THEN ``?e. &0 < e /\ !z:real. dist(z,l) < e ==> z IN b``
   STRIP_ASSUME_TAC THENL [ASM_MESON_TAC[open_def], ALL_TAC] THEN
  UNDISCH_TAC ``(f o r:num->num --> l:real) sequentially`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  SUBGOAL_THEN ``&0 < e / &2:real`` (fn th =>
   REWRITE_TAC [th, o_THM] THEN MP_TAC(ONCE_REWRITE_RULE [REAL_ARCH_INV] th))
   THENL [ASM_REWRITE_TAC[REAL_HALF], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N1:num`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N2:num`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``(r:num->num)(N1 + N2)``, ``b:real->bool``]) THEN
  ASM_REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN MATCH_MP_TAC DIST_TRIANGLE_HALF_R THEN
  EXISTS_TAC ``(f:num->real)(r(N1 + N2:num))`` THEN CONJ_TAC THENL
  [ALL_TAC, FIRST_X_ASSUM MATCH_MP_TAC THEN ARITH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IN_BALL]) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x < a ==> x < b:real``) THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``inv(&N1:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE] THEN REWRITE_TAC[real_div, REAL_MUL_LID] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN
  REWRITE_TAC[REAL_OF_NUM_ADD, REAL_OF_NUM_LE, REAL_LT] THEN
  ASM_MESON_TAC[ARITH_PROVE ``(~(n = 0) ==> 0 < n:num)``, LESS_EQ_ADD, MONOTONE_BIGGER,
   LESS_IMP_LESS_OR_EQ, LESS_EQ_TRANS]);

val COMPACT_IMP_HEINE_BOREL = store_thm
  ("COMPACT_IMP_HEINE_BOREL",
 ``!s. compact (s:real->bool)
  ==> !f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
  ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f')``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``f:(real->bool)->bool`` o
   MATCH_MP HEINE_BOREL_LEMMA) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real->real->bool``) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``e:real`` o
   MATCH_MP COMPACT_IMP_TOTALLY_BOUNDED) THEN
  ASM_SIMP_TAC std_ss [BIGUNION_IMAGE, SUBSET_DEF, GSPECIFICATION] THEN
  REWRITE_TAC[IN_BIGUNION, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (B:real->real->bool) k`` THEN
  ASM_SIMP_TAC std_ss [IMAGE_FINITE, SUBSET_DEF, IN_IMAGE, LEFT_IMP_EXISTS_THM] THEN
  ASM_MESON_TAC[IN_BALL]);

(* ------------------------------------------------------------------------- *)
(* Bolzano-Weierstrass property.                                             *)
(* ------------------------------------------------------------------------- *)

val HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS = store_thm
  ("HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS",
 ``!s:real->bool.
  (!f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
   ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f'))
   ==> !t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, limit_point_of] THEN REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[TAUT `a ==> b /\ c ==> d <=> c ==> ~d ==> a ==> ~b`] THEN
  KNOW_TAC ``t SUBSET s
       ==> (!x. ?t'. ~(x IN s:real->bool /\
                 (x IN t' /\ open t' ==> (?y. ~(y = x) /\ y IN t /\ y IN t'))))
       ==> (!f. (!t. t IN f ==> open t) /\ s SUBSET BIGUNION f
              ==> (?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET BIGUNION f'))
        ==> ~INFINITE t`` THENL
  [ALL_TAC, SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, RIGHT_AND_FORALL_THM] THEN
   METIS_TAC []] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_TAC ``f:real->real->bool``) THEN
  DISCH_THEN(MP_TAC o SPEC
   ``{t:real->bool | ?x:real. x IN s /\ (t = f x)}``) THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_BIGUNION, NOT_IMP] THEN
  KNOW_TAC ``(!t. (?x. x IN s:real->bool /\ (t = f x)) ==> open t) /\
     (!x. x IN s ==> ?s'. x IN s' /\ ?x. x IN s /\ (s' = f x))`` THENL
  [METIS_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN
  EXISTS_TAC ``{x:real | x IN t /\ (f(x):real->bool) IN g}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC FINITE_IMAGE_INJ_GENERAL THEN ASM_MESON_TAC[SUBSET_DEF],
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real`` THEN
   DISCH_TAC THEN SUBGOAL_THEN ``(u:real) IN s`` ASSUME_TAC THEN
   ASM_MESON_TAC[SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* Complete the chain of compactness variants.                               *)
(* ------------------------------------------------------------------------- *)

val BOLZANO_WEIERSTRASS_IMP_BOUNDED = store_thm ("BOLZANO_WEIERSTRASS_IMP_BOUNDED",
 ``!s:real->bool.
   (!t. INFINITE t /\ t SUBSET s ==> ?x. x limit_point_of t)
   ==> bounded s``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [compact, bounded_def] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, SKOLEM_THM, NOT_IMP] THEN
  REWRITE_TAC[REAL_NOT_LE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``beyond:real->real``) THEN
  KNOW_TAC ``?f. (f(0) = beyond(&0)) /\
   (!n. f(SUC n) = beyond(abs(f n) + &1):real)`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (x:num->real) UNIV`` THEN
  SUBGOAL_THEN
  ``!m n. m < n ==> abs((x:num->real) m) + &1 < abs(x n)``
   ASSUME_TAC THENL
  [GEN_TAC THEN INDUCT_TAC THEN ASM_REWRITE_TAC[LT] THEN
   ASM_MESON_TAC[REAL_LT_TRANS, REAL_ARITH ``b < b + &1:real``],
   ALL_TAC] THEN
  SUBGOAL_THEN ``!m n. ~(m = n) ==> &1 < dist((x:num->real) m,x n)``
  ASSUME_TAC THENL
  [REPEAT GEN_TAC THEN REPEAT_TCL DISJ_CASES_THEN ASSUME_TAC
   (SPECL [``m:num``, ``n:num``] LT_CASES) THEN
   ASM_MESON_TAC[dist, LT_CASES, ABS_TRIANGLE_SUB, ABS_SUB,
    REAL_ARITH ``x + &1 < y /\ y <= x + d ==> &1 < d:real``],
   ALL_TAC] THEN
  REPEAT CONJ_TAC THENL
  [ASM_MESON_TAC[IMAGE_11_INFINITE, num_INFINITE, DIST_REFL,
   REAL_ARITH ``~(&1 < &0:real)``],
  SIMP_TAC std_ss [SUBSET_DEF, IN_IMAGE, IN_UNIV, LEFT_IMP_EXISTS_THM] THEN
  INDUCT_TAC THEN METIS_TAC[], ALL_TAC] THEN
  X_GEN_TAC ``l:real`` THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  SIMP_TAC std_ss [IN_IMAGE, IN_UNIV, GSYM LEFT_EXISTS_AND_THM] THEN
  KNOW_TAC ``~(!(e :real). (0 :real) < e ==>
      (?(x'' :num) (x' :real). (x' = (x :num -> real) x'') /\ (x' <> (l :real)) /\
        ((dist (x',l) :real) < e)))`` THENL
  [ALL_TAC, METIS_TAC []] THEN SIMP_TAC std_ss [UNWIND_THM2] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  FIRST_ASSUM(MP_TAC o SPEC ``&1 / &2:real``) THEN
  REWRITE_TAC [METIS [REAL_HALF_BETWEEN] ``0 < 1 / 2:real``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:num`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``dist((x:num->real) k,l)``) THEN
  ASM_SIMP_TAC std_ss [DIST_POS_LT] THEN
  X_GEN_TAC ``m:num`` THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  ASM_CASES_TAC ``m:num = k`` THEN
  ASM_MESON_TAC[DIST_TRIANGLE_HALF_L, REAL_LT_TRANS, REAL_LT_REFL]);

val INF_FINITE_LEMMA = store_thm ("INF_FINITE_LEMMA",
 ``!s. FINITE s /\ ~(s = {}) ==> ?b:real. b IN s /\ !x. x IN s ==> b <= x``,
  REWRITE_TAC[CONJ_EQ_IMP] THEN
  ONCE_REWRITE_TAC [METIS [] ``!s. ( s <> {} ==> ?b. b IN s /\ !x. x IN s ==> b <= x) =                        (\s.  s <> {} ==> ?b:real. b IN s /\ !x. x IN s ==> b <= x) s``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[NOT_INSERT_EMPTY, IN_INSERT] THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  MESON_TAC[REAL_LE_TOTAL, REAL_LE_TRANS]);

val INF_FINITE = store_thm ("INF_FINITE",
 ``!s:real->bool. FINITE s /\ ~(s = {}) ==> (inf s) IN s /\ !x. x IN s ==> inf s <= x``,
  GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP INF_FINITE_LEMMA) THEN
  ASM_MESON_TAC[REAL_LE_ANTISYM, REAL_LE_TOTAL, INF]);

val REAL_LE_INF_FINITE = store_thm ("REAL_LE_INF_FINITE",
 ``!s:real->bool a. FINITE s /\ ~(s = {}) ==> (a <= inf s <=> !x. x IN s ==> a <= x)``,
  METIS_TAC[INF_FINITE, REAL_LE_TRANS]);

val REAL_INF_LE_FINITE = store_thm ("REAL_INF_LE_FINITE",
 ``!s:real->bool a. FINITE s /\ ~(s = {}) ==> (inf s <= a <=> ?x. x IN s /\ x <= a)``,
  MESON_TAC[INF_FINITE, REAL_LE_TRANS]);

val REAL_LT_INF_FINITE = store_thm ("REAL_LT_INF_FINITE",
 ``!s:real->bool a. FINITE s /\ ~(s = {}) ==> (a < inf s <=> !x. x IN s ==> a < x)``,
  MESON_TAC[INF_FINITE, REAL_LTE_TRANS]);

val REAL_INF_LT_FINITE = store_thm ("REAL_INF_LT_FINITE",
 ``!s:real->bool a. FINITE s /\ ~(s = {}) ==> (inf s < a <=> ?x. x IN s /\ x < a)``,
  MESON_TAC[INF_FINITE, REAL_LET_TRANS]);

val SEQUENCE_INFINITE_LEMMA = store_thm ("SEQUENCE_INFINITE_LEMMA",
 ``!f l. (!n. ~(f(n) = l)) /\ (f --> l) sequentially
    ==> INFINITE {y:real | ?n. y = f n}``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPEC
    ``IMAGE (\y:real. dist(y,l)) {y | ?n:num. y = f n}`` INF_FINITE) THEN
  ASM_SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, IN_IMAGE, IMAGE_FINITE, GSPECIFICATION] THEN
  ASM_MESON_TAC[LIM_SEQUENTIALLY, LESS_EQ_REFL, REAL_NOT_LE, DIST_POS_LT]);

val LE_1 = store_thm ("LE_1",
 ``(!n:num. ~(n = 0) ==> 0 < n) /\
   (!n:num. ~(n = 0) ==> 1 <= n) /\
   (!n:num. 0 < n ==> ~(n = 0)) /\
   (!n:num. 0 < n ==> 1 <= n) /\
   (!n:num. 1 <= n ==> 0 < n) /\
   (!n:num. 1 <= n ==> ~(n = 0))``,
  REWRITE_TAC[LT_NZ, GSYM NOT_LESS, ONE, LT]);

val LIMPT_OF_SEQUENCE_SUBSEQUENCE = store_thm ("LIMPT_OF_SEQUENCE_SUBSEQUENCE",
  ``!f:num->real l.
     l limit_point_of (IMAGE f univ(:num))
     ==> ?r. (!m n. m < n ==> r(m) < r(n)) /\ ((f o r) --> l) sequentially``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [LIMPT_APPROACHABLE]) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC
   ``inf((inv(&n + &1:real)) INSERT IMAGE (\k. dist((f:num->real) k,l))
         {k | k IN (0:num)..n /\ ~(f k = l)})``) THEN
  SIMP_TAC std_ss [REAL_LT_INF_FINITE, FINITE_INSERT, NOT_INSERT_EMPTY,
   FINITE_RESTRICT, FINITE_NUMSEG, IMAGE_FINITE] THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, EXISTS_IN_IMAGE, FORALL_IN_IMAGE, IN_UNIV] THEN
  SIMP_TAC std_ss [REAL_LT_INV_EQ, METIS [REAL_LT, REAL_OF_NUM_ADD, GSYM ADD1, LESS_0]
                            ``&0 < &n + &1:real``] THEN
  SIMP_TAC std_ss [FORALL_AND_THM, FORALL_IN_GSPEC, GSYM DIST_NZ, SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``nn:num->num`` STRIP_ASSUME_TAC) THEN
  KNOW_TAC ``?r:num->num. (r 0 = nn 0) /\ (!n. r (SUC n) = nn(r n))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
  [ONCE_REWRITE_TAC [METIS []
    `` (r:num->num) m < r n <=> (\m n. r m < r n) m n``] THEN
  MATCH_MP_TAC TRANSITIVE_STEPWISE_LT THEN CONJ_TAC THENL
  [METIS_TAC [LESS_TRANS], ALL_TAC] THEN
   X_GEN_TAC ``n:num`` THEN ASM_REWRITE_TAC[] THEN
   FIRST_X_ASSUM(MP_TAC o SPECL
    [``(r:num->num) n``, ``(nn:num->num)(r(n:num))``]) THEN
   ASM_SIMP_TAC arith_ss [IN_NUMSEG, ZERO_LESS_EQ, REAL_LT_REFL],
   DISCH_THEN(ASSUME_TAC o MATCH_MP MONOTONE_BIGGER)] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_ARCH_INV] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!n:num. (N <= n ==> dist ((f o r) n,l) < e) <=>
                          (\n. N <= n ==> dist ((f o r) n,l) < e) n``] THEN
  MATCH_MP_TAC INDUCTION THEN ASM_SIMP_TAC std_ss [CONJUNCT1 LE] THEN
  X_GEN_TAC ``n:num`` THEN DISCH_THEN(K ALL_TAC) THEN DISCH_TAC THEN
  ASM_SIMP_TAC std_ss [o_THM] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``inv(&((r:num->num) n) + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``inv(&N:real)`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_INV2 THEN
  ASM_SIMP_TAC std_ss [REAL_OF_NUM_LE, REAL_LT, LE_1, REAL_OF_NUM_ADD] THEN
  MATCH_MP_TAC(ARITH_PROVE ``N <= SUC n /\ n <= r n ==> N <= r n + 1``) THEN
  ASM_REWRITE_TAC[]);

val SEQUENCE_UNIQUE_LIMPT = store_thm ("SEQUENCE_UNIQUE_LIMPT",
 ``!f l l':real.
   (f --> l) sequentially /\ l' limit_point_of {y | ?n. y = f n}
   ==> (l' = l)``,
  REWRITE_TAC[SET_RULE ``{y | ?n. y = f n} = IMAGE f univ(:num)``] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP LIMPT_OF_SEQUENCE_SUBSEQUENCE) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:num->num`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``(f:num->real) o (r:num->num)`` THEN
  ASM_SIMP_TAC std_ss [TRIVIAL_LIMIT_SEQUENTIALLY, LIM_SUBSEQUENCE]);

val BOLZANO_WEIERSTRASS_IMP_CLOSED = store_thm ("BOLZANO_WEIERSTRASS_IMP_CLOSED",
 ``!s:real->bool.
  (!t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t)
   ==> closed s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSED_SEQUENTIAL_LIMITS] THEN
  MAP_EVERY X_GEN_TAC [``f:num->real``, ``l:real``] THEN
  DISCH_TAC THEN
  MAP_EVERY (MP_TAC o ISPECL [``f:num->real``, ``l:real``])
   [SEQUENCE_UNIQUE_LIMPT, SEQUENCE_INFINITE_LEMMA] THEN
  MATCH_MP_TAC(TAUT
   `(~d ==> a /\ ~(b /\ c)) ==> (a ==> b) ==> c ==> d`) THEN
  DISCH_TAC THEN CONJ_TAC THENL [ASM_MESON_TAC[], STRIP_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{y:real | ?n:num. y = f n}``) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION],
   ABBREV_TAC ``t = {y:real | ?n:num. y = f n}``] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Hence express everything as an equivalence.                               *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EQ_HEINE_BOREL = store_thm ("COMPACT_EQ_HEINE_BOREL",
 ``!s:real->bool. compact s <=>
   !f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
   ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f')``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [COMPACT_IMP_HEINE_BOREL] THEN
  DISCH_THEN(MP_TAC o MATCH_MP HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS) THEN
  DISCH_TAC THEN MATCH_MP_TAC BOUNDED_CLOSED_IMP_COMPACT THEN
  ASM_MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED,
   BOLZANO_WEIERSTRASS_IMP_CLOSED]);

val COMPACT_EQ_BOLZANO_WEIERSTRASS = store_thm ("COMPACT_EQ_BOLZANO_WEIERSTRASS",
 ``!s:real->bool. compact s <=>
   !t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t``,
  GEN_TAC THEN EQ_TAC THENL
  [SIMP_TAC std_ss [COMPACT_EQ_HEINE_BOREL, HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS],
   MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED, BOLZANO_WEIERSTRASS_IMP_CLOSED,
    BOUNDED_CLOSED_IMP_COMPACT]]);

val COMPACT_EQ_BOUNDED_CLOSED = store_thm ("COMPACT_EQ_BOUNDED_CLOSED",
``!s:real->bool. compact s <=> bounded s /\ closed s``,
  GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_CLOSED_IMP_COMPACT] THEN
  MESON_TAC[COMPACT_EQ_BOLZANO_WEIERSTRASS, BOLZANO_WEIERSTRASS_IMP_BOUNDED,
  BOLZANO_WEIERSTRASS_IMP_CLOSED]);

val COMPACT_IMP_BOUNDED = store_thm ("COMPACT_IMP_BOUNDED",
 ``!s. compact s ==> bounded s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED]);

val COMPACT_IMP_CLOSED = store_thm ("COMPACT_IMP_CLOSED",
 ``!s. compact s ==> closed s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED]);

val COMPACT_SEQUENCE_WITH_LIMIT = store_thm ("COMPACT_SEQUENCE_WITH_LIMIT",
 ``!f l:real.
  (f --> l) sequentially ==> compact (l INSERT IMAGE f univ(:num))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
  REWRITE_TAC[BOUNDED_INSERT] THEN CONJ_TAC THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_BOUNDED],
   SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_INSERT, IN_INSERT] THEN
  SIMP_TAC std_ss [IMAGE_DEF, IN_UNIV, SET_RULE ``{f x | x IN s} =
    {y | ?x. x IN s /\ (y = f x)}``] THEN REPEAT STRIP_TAC THEN DISJ1_TAC THEN
  MATCH_MP_TAC SEQUENCE_UNIQUE_LIMPT THEN METIS_TAC[]]);

val CLOSED_IN_COMPACT = store_thm ("CLOSED_IN_COMPACT",
 ``!s t:real->bool.
  compact s /\ closed_in (subtopology euclidean s) t
   ==> compact t``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_EQ] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val CLOSED_IN_COMPACT_EQ = store_thm ("CLOSED_IN_COMPACT_EQ",
 ``!s t. compact s
  ==> (closed_in (subtopology euclidean s) t <=>
   compact t /\ t SUBSET s)``,
  MESON_TAC[CLOSED_IN_CLOSED_EQ, COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* A version of Heine-Borel for subtopology.                                 *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY = store_thm ("COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY",
 ``!s:real->bool. compact s <=>
   (!f. (!t. t IN f ==> open_in(subtopology euclidean s) t) /\
                        s SUBSET BIGUNION f
     ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET BIGUNION f')``,
  GEN_TAC THEN REWRITE_TAC[COMPACT_EQ_HEINE_BOREL] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``f:(real->bool)->bool`` THENL
  [REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM] THEN
   DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``m:(real->bool)->(real->bool)``) ASSUME_TAC) THEN
   FIRST_X_ASSUM(MP_TAC o SPEC
   ``IMAGE (m:(real->bool)->(real->bool)) f``) THEN
   ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
   KNOW_TAC ``(s :real -> bool) SUBSET
     BIGUNION
       (IMAGE (m :(real -> bool) -> real -> bool)
          (f :(real -> bool) -> bool))`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``f':(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (\t:real->bool. s INTER t) f'`` THEN
  ASM_SIMP_TAC std_ss [IMAGE_FINITE, BIGUNION_IMAGE, SUBSET_DEF, FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  UNDISCH_TAC ``f' SUBSET IMAGE (m :(real -> bool) -> real -> bool) f`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_IMAGE]) THEN
  STRIP_TAC THEN ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN ASM_MESON_TAC[SUBSET_DEF],
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{s INTER t:real->bool | t IN f}``) THEN
  SIMP_TAC std_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, OPEN_IN_OPEN, BIGUNION_IMAGE] THEN
  KNOW_TAC ``(!(t :real -> bool).
        t IN (f :(real -> bool) -> bool) ==>
        ?(t' :real -> bool).
          (open t' :bool) /\ ((s :real -> bool) INTER t = s INTER t')) /\
     s SUBSET {y | ?(t :real -> bool). t IN f /\ y IN s INTER t}`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, BIGUNION_IMAGE] THEN
  STRIP_TAC THEN EXISTS_TAC ``f' :(real -> bool) -> bool`` THEN
  ASM_SET_TAC []]);

(* ------------------------------------------------------------------------- *)
(* More easy lemmas.                                                         *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CLOSURE = store_thm ("COMPACT_CLOSURE",
 ``!s. compact(closure s) <=> bounded s``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE, BOUNDED_CLOSURE_EQ]);

val BOLZANO_WEIERSTRASS_CONTRAPOS = store_thm ("BOLZANO_WEIERSTRASS_CONTRAPOS",
 ``!s t:real->bool.
  compact s /\ t SUBSET s /\
  (!x. x IN s ==> ~(x limit_point_of t))
  ==> FINITE t``,
  REWRITE_TAC[COMPACT_EQ_BOLZANO_WEIERSTRASS] THEN MESON_TAC[]);

val DISCRETE_BOUNDED_IMP_FINITE = store_thm ("DISCRETE_BOUNDED_IMP_FINITE",
 ``!s:real->bool e. &0 < e /\
  (!x y. x IN s /\ y IN s /\ abs(y - x) < e ==> (y = x)) /\
   bounded s ==> FINITE s``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``compact(s:real->bool)`` MP_TAC THENL
  [ASM_REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
   ASM_MESON_TAC[DISCRETE_IMP_CLOSED],
  DISCH_THEN(MP_TAC o MATCH_MP COMPACT_IMP_HEINE_BOREL)] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\x:real. ball(x,e)) s``) THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, OPEN_BALL, BIGUNION_IMAGE, GSPECIFICATION] THEN
  KNOW_TAC ``(s :real -> bool) SUBSET
     {y | ?(x :real). x IN s /\ y IN ball (x,(e :real))}`` THENL
  [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN ASM_MESON_TAC[CENTRE_IN_BALL],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`]] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``s:real->bool = t`` (fn th => ASM_REWRITE_TAC[th]) THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``s SUBSET BIGUNION (IMAGE (\x. ball (x,e)) t)`` THEN
  GEN_REWR_TAC (LAND_CONV o RAND_CONV) [BIGUNION_IMAGE] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o REWRITE_RULE [SUBSET_DEF]) THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_BALL, dist] THEN ASM_MESON_TAC[SUBSET_DEF]);

val BOLZANO_WEIERSTRASS = store_thm ("BOLZANO_WEIERSTRASS",
 ``!s:real->bool. bounded s /\ INFINITE s ==> ?x. x limit_point_of s``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP NO_LIMIT_POINT_IMP_CLOSED) THEN
  STRIP_TAC THEN
  MP_TAC(ISPEC ``s:real->bool`` COMPACT_EQ_BOLZANO_WEIERSTRASS) THEN
  ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED] THEN
  EXISTS_TAC ``s:real->bool`` THEN
  ASM_REWRITE_TAC[SUBSET_REFL] THEN ASM_MESON_TAC[]);

val BOUNDED_EQ_BOLZANO_WEIERSTRASS = store_thm ("BOUNDED_EQ_BOLZANO_WEIERSTRASS",
 ``!s:real->bool.
  bounded s <=> !t. t SUBSET s /\ INFINITE t ==> ?x. x limit_point_of t``,
  MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED, BOLZANO_WEIERSTRASS,
   BOUNDED_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* In particular, some common special cases.                                 *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EMPTY = store_thm ("COMPACT_EMPTY",
 ``compact {}``,
  REWRITE_TAC[compact, NOT_IN_EMPTY]);

val COMPACT_UNION = store_thm ("COMPACT_UNION",
 ``!s t. compact s /\ compact t ==> compact (s UNION t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_UNION, CLOSED_UNION]);

val COMPACT_INTER = store_thm ("COMPACT_INTER",
 ``!s t. compact s /\ compact t ==> compact (s INTER t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTER, CLOSED_INTER]);

val COMPACT_INTER_CLOSED = store_thm ("COMPACT_INTER_CLOSED",
 ``!s t. compact s /\ closed t ==> compact (s INTER t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER] THEN
  MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET]);

val CLOSED_INTER_COMPACT = store_thm ("CLOSED_INTER_COMPACT",
 ``!s t. closed s /\ compact t ==> compact (s INTER t)``,
  MESON_TAC[COMPACT_INTER_CLOSED, INTER_COMM]);

val COMPACT_BIGINTER = store_thm ("COMPACT_BIGINTER",
 ``!f:(real->bool)->bool.
  (!s. s IN f ==> compact s) /\ ~(f = {})
  ==> compact(BIGINTER f)``,
  SIMP_TAC std_ss[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_BIGINTER] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC BOUNDED_BIGINTER THEN ASM_SET_TAC[]);

val FINITE_IMP_CLOSED = store_thm ("FINITE_IMP_CLOSED",
 ``!s. FINITE s ==> closed s``,
  MESON_TAC[BOLZANO_WEIERSTRASS_IMP_CLOSED, SUBSET_FINITE_I]);

val FINITE_IMP_CLOSED_IN = store_thm ("FINITE_IMP_CLOSED_IN",
 ``!s t. FINITE s /\ s SUBSET t ==> closed_in (subtopology euclidean t) s``,
  SIMP_TAC std_ss [CLOSED_SUBSET_EQ, FINITE_IMP_CLOSED]);

val FINITE_IMP_COMPACT = store_thm ("FINITE_IMP_COMPACT",
 ``!s. FINITE s ==> compact s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, FINITE_IMP_CLOSED, FINITE_IMP_BOUNDED]);

val COMPACT_SING = store_thm ("COMPACT_SING",
 ``!a. compact {a}``,
  SIMP_TAC std_ss [FINITE_IMP_COMPACT, FINITE_EMPTY, FINITE_INSERT]);

val COMPACT_INSERT = store_thm ("COMPACT_INSERT",
 ``!a s. compact s ==> compact(a INSERT s)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  SIMP_TAC std_ss [COMPACT_UNION, COMPACT_SING]);

val CLOSED_SING = store_thm ("CLOSED_SING",
 ``!a. closed {a}``,
 MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, COMPACT_SING]);

val CLOSED_IN_SING = store_thm ("CLOSED_IN_SING",
 ``!u x:real. closed_in (subtopology euclidean u) {x} <=> x IN u``,
  SIMP_TAC std_ss [CLOSED_SUBSET_EQ, CLOSED_SING] THEN SET_TAC[]);

val CLOSURE_SING = store_thm ("CLOSURE_SING",
 ``!x:real. closure {x} = {x}``,
   SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_SING]);

val CLOSED_INSERT = store_thm ("CLOSED_INSERT",
 ``!a s. closed s ==> closed(a INSERT s)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  SIMP_TAC std_ss [CLOSED_UNION, CLOSED_SING]);

val COMPACT_CBALL = store_thm ("COMPACT_CBALL",
 ``!x e. compact(cball(x,e))``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_CBALL, CLOSED_CBALL]);

val COMPACT_FRONTIER_BOUNDED = store_thm ("COMPACT_FRONTIER_BOUNDED",
 ``!s. bounded s ==> compact(frontier s)``,
  SIMP_TAC std_ss [frontier, COMPACT_EQ_BOUNDED_CLOSED,
   CLOSED_DIFF, OPEN_INTERIOR, CLOSED_CLOSURE] THEN
  MESON_TAC[DIFF_SUBSET, BOUNDED_SUBSET, BOUNDED_CLOSURE]);

val COMPACT_FRONTIER = store_thm ("COMPACT_FRONTIER",
 ``!s. compact s ==> compact (frontier s)``,
  MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, COMPACT_FRONTIER_BOUNDED]);

val BOUNDED_FRONTIER = store_thm ("BOUNDED_FRONTIER",
 ``!s:real->bool. bounded s ==> bounded(frontier s)``,
  MESON_TAC[COMPACT_FRONTIER_BOUNDED, COMPACT_IMP_BOUNDED]);

val FRONTIER_SUBSET_COMPACT = store_thm ("FRONTIER_SUBSET_COMPACT",
 ``!s. compact s ==> frontier s SUBSET s``,
  MESON_TAC[FRONTIER_SUBSET_CLOSED, COMPACT_EQ_BOUNDED_CLOSED]);

val OPEN_DELETE = store_thm ("OPEN_DELETE",
 ``!s x. open s ==> open(s DELETE x)``,
SIMP_TAC std_ss [SET_RULE ``s DELETE x = s DIFF {x}``,
                 OPEN_DIFF, CLOSED_SING]);

val OPEN_IN_DELETE = store_thm ("OPEN_IN_DELETE",
 ``!u s a:real.
  open_in (subtopology euclidean u) s
  ==> open_in (subtopology euclidean u) (s DELETE a)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``(a:real) IN s`` THENL
  [ONCE_REWRITE_TAC[SET_RULE ``s DELETE a = s DIFF {a}``] THEN
   MATCH_MP_TAC OPEN_IN_DIFF THEN ASM_REWRITE_TAC[CLOSED_IN_SING] THEN
   FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
   ASM_SIMP_TAC std_ss [SET_RULE ``~(a IN s) ==> (s DELETE a = s)``]]);

val CLOSED_BIGINTER_COMPACT = store_thm ("CLOSED_BIGINTER_COMPACT",
 ``!s:real->bool.
  closed s <=> !e. compact(cball(0,e) INTER s)``,
  GEN_TAC THEN EQ_TAC THENL
  [SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER, CLOSED_CBALL,
   BOUNDED_INTER, BOUNDED_CBALL], ALL_TAC] THEN
  STRIP_TAC THEN REWRITE_TAC[CLOSED_LIMPT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``abs(x:real) + &1:real``) THEN
  DISCH_THEN(MP_TAC o MATCH_MP COMPACT_IMP_CLOSED) THEN
  REWRITE_TAC[CLOSED_LIMPT] THEN DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  REWRITE_TAC[IN_INTER] THEN
  KNOW_TAC ``(x :real) limit_point_of
     cball ((0 :real),abs x + (1 :real)) INTER (s :real -> bool)`` THENL
  [ALL_TAC, MESON_TAC[]] THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min e (&1 / &2:real)``) THEN
  KNOW_TAC ``0 < min e (1 / 2:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [REAL_HALF_BETWEEN],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, IN_CBALL] THEN
  REWRITE_TAC [REAL_LT_MIN, DIST_0, dist] THEN STRIP_TAC THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

val COMPACT_BIGUNION = store_thm ("COMPACT_BIGUNION",
 ``!s. FINITE s /\ (!t. t IN s ==> compact t) ==> compact(BIGUNION s)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_BIGUNION, BOUNDED_BIGUNION]);

val COMPACT_DIFF = store_thm ("COMPACT_DIFF",
 ``!s t. compact s /\ open t ==> compact(s DIFF t)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  SIMP_TAC std_ss [COMPACT_INTER_CLOSED, GSYM OPEN_CLOSED]);

val COMPACT_SPHERE = store_thm ("COMPACT_SPHERE",
 ``!a:real r. compact(sphere(a,r))``,
  REPEAT GEN_TAC THEN
 REWRITE_TAC[GSYM FRONTIER_CBALL] THEN MATCH_MP_TAC COMPACT_FRONTIER THEN
  REWRITE_TAC[COMPACT_CBALL]);

val BOUNDED_SPHERE = store_thm ("BOUNDED_SPHERE",
 ``!a:real r. bounded(sphere(a,r))``,
  SIMP_TAC std_ss [COMPACT_SPHERE, COMPACT_IMP_BOUNDED]);

val CLOSED_SPHERE = store_thm ("CLOSED_SPHERE",
 ``!a r. closed(sphere(a,r))``,
  SIMP_TAC std_ss [COMPACT_SPHERE, COMPACT_IMP_CLOSED]);

val FRONTIER_SING = store_thm ("FRONTIER_SING",
 ``!a:real. frontier {a} = {a}``,
  REWRITE_TAC[frontier, CLOSURE_SING, INTERIOR_SING, DIFF_EMPTY]);

(* ------------------------------------------------------------------------- *)
(* Finite intersection property. I could make it an equivalence in fact.     *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
 ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``,
  SET_TAC[]);

val COMPACT_IMP_FIP = store_thm ("COMPACT_IMP_FIP",
 ``!s:real->bool f.
        compact s /\
        (!t. t IN f ==> closed t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\t:real->bool. UNIV DIFF t) f``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  DISCH_THEN(fn th => REPEAT STRIP_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, CLOSED_DIFF, OPEN_UNIV, CLOSED_UNIV, NOT_IMP] THEN
  CONJ_TAC THENL
   [UNDISCH_TAC ``(s:real->bool) INTER BIGINTER f = {}`` THEN
    ONCE_REWRITE_TAC[SUBSET_DEF, EXTENSION] THEN
    REWRITE_TAC [IN_BIGUNION] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
        REWRITE_TAC [EXISTS_IN_IMAGE] THEN BETA_TAC THEN SET_TAC[],
    X_GEN_TAC ``g:(real->bool)->bool`` THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (\t:real->bool. UNIV DIFF t) g``) THEN
    ASM_CASES_TAC ``FINITE(g:(real->bool)->bool)`` THEN
    ASM_SIMP_TAC std_ss [IMAGE_FINITE] THEN ONCE_REWRITE_TAC[SUBSET_DEF, EXTENSION] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_INTER, IN_BIGINTER, IN_IMAGE, IN_DIFF,
                IN_UNIV, NOT_IN_EMPTY, lemma, UNWIND_THM1, IN_BIGUNION] THEN
    SET_TAC[]]);

val CLOSED_IMP_FIP = store_thm ("CLOSED_IMP_FIP",
 ``!s:real->bool f.
        closed s /\
        (!t. t IN f ==> closed t) /\ (?t. t IN f /\ bounded t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC(SET_RULE
   ``~((s INTER t) INTER u = {}) ==> ~(s INTER u = {})``) THEN
  MATCH_MP_TAC COMPACT_IMP_FIP THEN ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
   [ASM_MESON_TAC[CLOSED_INTER_COMPACT, COMPACT_EQ_BOUNDED_CLOSED],
    REWRITE_TAC [METIS [INTER_ASSOC, GSYM BIGINTER_INSERT]
          ``!f.  s INTER t INTER BIGINTER f =  s INTER BIGINTER (t INSERT f)``] THEN
  GEN_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [FINITE_INSERT, INSERT_SUBSET]]);

val CLOSED_IMP_FIP_COMPACT = store_thm ("CLOSED_IMP_FIP_COMPACT",
 ``!s:real->bool f.
        closed s /\ (!t. t IN f ==> compact t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [SUBSET_EMPTY, BIGINTER_EMPTY, INTER_UNIV] THENL
   [MESON_TAC[FINITE_EMPTY], ALL_TAC] THEN
  STRIP_TAC THEN MATCH_MP_TAC CLOSED_IMP_FIP THEN
  ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, MEMBER_NOT_EMPTY]);

val CLOSED_FIP = store_thm ("CLOSED_FIP",
 ``!f. (!t:real->bool. t IN f ==> closed t) /\ (?t. t IN f /\ bounded t) /\
       (!f'. FINITE f' /\ f' SUBSET f ==> ~(BIGINTER f' = {}))
       ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = {}) <=> (UNIV INTER s = {})``] THEN
  MATCH_MP_TAC CLOSED_IMP_FIP THEN ASM_REWRITE_TAC[CLOSED_UNIV, INTER_UNIV]);

val COMPACT_FIP = store_thm ("COMPACT_FIP",
 ``!f. (!t:real->bool. t IN f ==> compact t) /\
       (!f'. FINITE f' /\ f' SUBSET f ==> ~(BIGINTER f' = {}))
       ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = {}) <=> (UNIV INTER s = {})``] THEN
  MATCH_MP_TAC CLOSED_IMP_FIP_COMPACT THEN
  ASM_REWRITE_TAC[CLOSED_UNIV, INTER_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Bounded closed nest property (proof does not use Heine-Borel).            *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_CLOSED_NEST = store_thm ("BOUNDED_CLOSED_NEST",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       bounded(s 0)
       ==> ?a:real. !n:num. a IN s(n)``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, SKOLEM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_TAC ``a:num->real``) STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``compact(s (0:num):real->bool)`` MP_TAC THENL
   [METIS_TAC[BOUNDED_CLOSED_IMP_COMPACT], ALL_TAC] THEN
  REWRITE_TAC[compact] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:num->real``) THEN
  KNOW_TAC ``(!n:num. a n IN s (0:num):real->bool)`` THENL
  [ASM_MESON_TAC[SUBSET_DEF, ZERO_LESS_EQ],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN
  EXISTS_TAC ``l:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:num->num`` STRIP_ASSUME_TAC) THEN
  GEN_REWR_TAC I [TAUT `p <=> ~(~p)`] THEN
  REWRITE_TAC [NOT_FORALL_THM] THEN X_GEN_TAC ``N:num`` THEN
  MP_TAC(ISPECL [``l:real``, ``(s:num->real->bool) N``]
                CLOSED_APPROACHABLE) THEN
  ASM_MESON_TAC[SUBSET_DEF, LESS_EQ_REFL, LESS_EQ_TRANS, LE_CASES, MONOTONE_BIGGER]);

(* ------------------------------------------------------------------------- *)
(* Decreasing case does not even need compactness, just completeness.        *)
(* ------------------------------------------------------------------------- *)

val DECREASING_CLOSED_NEST = store_thm ("DECREASING_CLOSED_NEST",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       (!e. &0 < e ==> ?n. !x y. x IN s(n) /\ y IN s(n) ==> dist(x,y) < e)
       ==> ?a:real. !n:num. a IN s(n)``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, SKOLEM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_TAC ``a:num->real``) STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``?l:real. (a --> l) sequentially`` MP_TAC THENL
   [ASM_MESON_TAC[cauchy, GE, SUBSET_DEF, LESS_EQ_TRANS, LESS_EQ_REFL,
                  complete, COMPLETE_UNIV, IN_UNIV],
    ASM_MESON_TAC[LIM_SEQUENTIALLY, CLOSED_APPROACHABLE,
                  SUBSET_DEF, LESS_EQ_REFL, LESS_EQ_TRANS, LE_CASES]]);

(* ------------------------------------------------------------------------- *)
(* Strengthen it to the intersection actually being a singleton.             *)
(* ------------------------------------------------------------------------- *)

val DECREASING_CLOSED_NEST_SING = store_thm ("DECREASING_CLOSED_NEST_SING",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       (!e. &0 < e ==> ?n. !x y. x IN s(n) /\ y IN s(n) ==> dist(x,y) < e)
       ==> ?a:real. BIGINTER {t | ?n:num. t = s n} = {a}``,
  GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DECREASING_CLOSED_NEST) THEN
  STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN
  SIMP_TAC std_ss [EXTENSION, IN_BIGINTER, IN_SING, GSPECIFICATION] THEN
  METIS_TAC[DIST_POS_LT, REAL_LT_REFL, SUBSET_DEF, LE_CASES]);

(* ------------------------------------------------------------------------- *)
(* A version for a more general chain, not indexed by N.                     *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_CLOSED_CHAIN = store_thm ("BOUNDED_CLOSED_CHAIN",
 ``!f b:real->bool.
        (!s. s IN f ==> closed s /\ ~(s = {})) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s) /\
         b IN f /\ bounded b
         ==> ~(BIGINTER f = {})``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN ``~(b INTER (BIGINTER f):real->bool = {})`` MP_TAC THENL
   [ALL_TAC, SET_TAC[]] THEN
  MATCH_MP_TAC COMPACT_IMP_FIP THEN
  ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED] THEN
  X_GEN_TAC ``u:(real->bool)->bool`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``?s:real->bool. s IN f /\ !t. t IN u ==> s SUBSET t``
   MP_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  UNDISCH_TAC ``(u:(real->bool)->bool) SUBSET f`` THEN
  UNDISCH_TAC ``FINITE(u:(real->bool)->bool)`` THEN
  SPEC_TAC(``u:(real->bool)->bool``,``u:(real->bool)->bool``) THEN
  ONCE_REWRITE_TAC [METIS [] ``!u. (u SUBSET f ==> ?s. s IN f /\ !t. t IN u ==> s SUBSET t) =
                          (\u. u SUBSET f ==> ?s. s IN f /\ !t. t IN u ==> s SUBSET t) u``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:(real->bool)->bool``, ``t:real->bool``] THEN
  REWRITE_TAC[INSERT_SUBSET] THEN
  ONCE_REWRITE_TAC [AND_IMP_INTRO] THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``s:real->bool``, ``t:real->bool``]) THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Analogous things directly for compactness.                                *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CHAIN = store_thm ("COMPACT_CHAIN",
 ``!f:(real->bool)->bool.
        (!s. s IN f ==> compact s /\ ~(s = {})) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
        ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THENL
   [ASM_REWRITE_TAC[BIGINTER_EMPTY] THEN SET_TAC[],
    MATCH_MP_TAC BOUNDED_CLOSED_CHAIN THEN ASM_SET_TAC[]]);

val COMPACT_NEST = store_thm ("COMPACT_NEST",
 ``!s. (!n. compact(s n) /\ ~(s n = {})) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> ~(BIGINTER {s n | n IN univ(:num)} = {})``,
  GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC COMPACT_CHAIN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``!n n'. (s n SUBSET s n' \/ s n' SUBSET s n) =
                          (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Cauchy-type criteria for *uniform* convergence.                           *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONVERGENT_EQ_CAUCHY = store_thm ("UNIFORMLY_CONVERGENT_EQ_CAUCHY",
 ``!P s:num->'a->real.
         (?l. !e. &0 < e
                  ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e) <=>
         (!e. &0 < e
              ==> ?N. !m n x. N <= m /\ N <= n /\ P x
                              ==> dist(s m x,s n x) < e)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_TAC ``l:'a->real``) THEN X_GEN_TAC ``e:real`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
    ASM_REWRITE_TAC[REAL_HALF] THEN MESON_TAC[DIST_TRIANGLE_HALF_L],
    ALL_TAC] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN ``!x:'a. P x ==> cauchy (\n. s n x :real)`` MP_TAC THENL
   [REWRITE_TAC[cauchy, GE] THEN ASM_MESON_TAC[], ALL_TAC] THEN
  REWRITE_TAC[GSYM CONVERGENT_EQ_CAUCHY, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN KNOW_TAC ``(!(x :'a). ?(l :real). (P :'a -> bool) x ==>
        (!(e :real). (0 :real) < e ==>
           (?(N :num). !(n :num). N <= n ==>
               (dist ((\(n :num). (s :num -> 'a -> real) n x) n,l) :real) < e)))`` THENL
  [METIS_TAC [], POP_ASSUM K_TAC] THEN SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:'a->real``) THEN
  EXISTS_TAC ``l:'a->real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``n:num``, ``x:'a``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:'a``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_TAC ``M:num``) THEN
  UNDISCH_TAC ``!m n x. N:num <= m /\ N <= n /\ P x
                 ==> dist (s m x,s n x) < e / 2:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`n:num`, `N + M:num`, `x:'a`]) THEN
  ASM_REWRITE_TAC[LE_ADD] THEN ONCE_REWRITE_TAC[ADD_SYM] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``M + N:num``) THEN REWRITE_TAC[LE_ADD] THEN
  ASM_MESON_TAC[DIST_TRIANGLE_HALF_L, DIST_SYM]);

Theorem UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT:
   !P s:num->'a->real.
      (?l. !e. &0 < e ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e) <=>
      (!e. &0 < e ==>
           ?N. !m n x. N <= m /\ N <= n /\ m < n /\ P x ==>
                       dist(s m x,s n x) < e)
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONVERGENT_EQ_CAUCHY] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  ASM_SIMP_TAC std_ss [] THEN
  HO_MATCH_MP_TAC WLOG_LT THEN
  ASM_SIMP_TAC std_ss [DIST_REFL] THEN MESON_TAC[DIST_SYM]
QED

val UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT = store_thm ("UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT",
 ``!P (s:num->'a->real) l.
    (!e. &0 < e
         ==> ?N. !m n x. N <= m /\ N <= n /\ P x ==> dist(s m x,s n x) < e) /\
    (!x. P x ==> !e. &0 < e ==> ?N. !n. N <= n ==> dist(s n x,l x) < e)
    ==> (!e. &0 < e ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM UNIFORMLY_CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``l':'a->real``) ASSUME_TAC) THEN
  SUBGOAL_THEN ``!x. P x ==> ((l:'a->real) x = l' x)`` MP_TAC THENL
   [ALL_TAC, METIS_TAC[]] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``\n. (s:num->'a->real) n x`` THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Define continuity over a net to take in restrictions of the set.          *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "continuous" (Infix(NONASSOC, 450));

val continuous = new_definition ("continuous",
 ``f continuous net <=> (f --> f(netlimit net)) net``);

val CONTINUOUS_TRIVIAL_LIMIT = store_thm ("CONTINUOUS_TRIVIAL_LIMIT",
 ``!f net. trivial_limit net ==> f continuous net``,
  SIMP_TAC std_ss [continuous, LIM]);

val CONTINUOUS_WITHIN = store_thm ("CONTINUOUS_WITHIN",
 ``!f x:real. f continuous (at x within s) <=> (f --> f(x)) (at x within s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous] THEN
  ASM_CASES_TAC ``trivial_limit(at (x:real) within s)`` THENL
  [ASM_REWRITE_TAC[LIM], ASM_SIMP_TAC std_ss [NETLIMIT_WITHIN]]);

val CONTINUOUS_AT = store_thm ("CONTINUOUS_AT",
 ``!f (x:real). f continuous (at x) <=> (f --> f(x)) (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN, IN_UNIV]);

val CONTINUOUS_AT_WITHIN = store_thm ("CONTINUOUS_AT_WITHIN",
 ``!f:real->real x s.
  f continuous (at x) ==> f continuous (at x within s)``,
  SIMP_TAC std_ss [LIM_AT_WITHIN, CONTINUOUS_AT, CONTINUOUS_WITHIN]);

val CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL = store_thm ("CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL",
 ``!a s. closed s /\ ~(a IN s) ==> f continuous (at a within s)``,
  ASM_SIMP_TAC std_ss [continuous, LIM, LIM_WITHIN_CLOSED_TRIVIAL]);

val CONTINUOUS_TRANSFORM_WITHIN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN",
 ``!f g:real->real s x d. &0 < d /\ x IN s /\
   (!x'. x' IN s /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
    f continuous (at x within s) ==> g continuous (at x within s)``,
  SIMP_TAC std_ss [CONTINUOUS_WITHIN] THEN
  METIS_TAC[LIM_TRANSFORM_WITHIN, DIST_REFL]);

val CONTINUOUS_TRANSFORM_AT = store_thm ("CONTINUOUS_TRANSFORM_AT",
 ``!f g:real->real x d.
   &0 < d /\ (!x'. dist(x',x) < d ==> (f(x') = g(x'))) /\
   f continuous (at x) ==> g continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT] THEN
  METIS_TAC[LIM_TRANSFORM_AT, DIST_REFL]);

val CONTINUOUS_TRANSFORM_WITHIN_OPEN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_OPEN",
 ``!f g:real->real s a. open s /\ a IN s /\
   (!x. x IN s ==> (f x = g x)) /\
    f continuous at a ==> g continuous at a``,
  METIS_TAC[CONTINUOUS_AT, LIM_TRANSFORM_WITHIN_OPEN]);

val CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN",
 ``!f g:real->real s t a.
   open_in (subtopology euclidean t) s /\ a IN s /\
   (!x. x IN s ==> (f x = g x)) /\
    f continuous (at a within t) ==> g continuous (at a within t)``,
  METIS_TAC[CONTINUOUS_WITHIN, LIM_TRANSFORM_WITHIN_OPEN_IN]);

val CONTINUOUS_TRANSFORM_WITHIN_SET_IMP = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_SET_IMP",
 ``!f a s t. eventually (\x. x IN t ==> x IN s) (at a) /\
   f continuous (at a within s) ==> f continuous (at a within t)``,
  REWRITE_TAC[CONTINUOUS_WITHIN, LIM_TRANSFORM_WITHIN_SET_IMP]);

(* ------------------------------------------------------------------------- *)
(* Derive the epsilon-delta forms, which we often use as "definitions" *)
(* ------------------------------------------------------------------------- *)

val continuous_within = store_thm ("continuous_within",
 ``f continuous (at x within s) <=> !e. &0 < e
   ==> ?d. &0 < d /\ !x'. x' IN s /\ dist(x',x) < d
     ==> dist(f(x'),f(x)) < e``,
  SIMP_TAC std_ss [CONTINUOUS_WITHIN, LIM_WITHIN] THEN
  SIMP_TAC std_ss [GSYM DIST_NZ] THEN MESON_TAC[DIST_REFL]);

val continuous_at = store_thm ("continuous_at",
 ``f continuous (at x) <=>
  !e. &0 < e ==> ?d. &0 < d /\
  !x'. dist(x',x) < d ==> dist(f(x'),f(x)) < e``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  SIMP_TAC std_ss [continuous_within, IN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Versions in terms of open balls.                                          *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_BALL = store_thm ("CONTINUOUS_WITHIN_BALL",
 ``!f s x. f continuous (at x within s) <=>
   !e. &0 < e ==> ?d. &0 < d /\
   IMAGE f (ball(x,d) INTER s) SUBSET ball(f x,e)``,
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_BALL, continuous_within, IN_INTER] THEN
  MESON_TAC[DIST_SYM]);

val CONTINUOUS_AT_BALL = store_thm ("CONTINUOUS_AT_BALL",
 ``!f x. f continuous (at x) <=>
   !e. &0 < e ==> ?d. &0 < d /\
   IMAGE f (ball(x,d)) SUBSET ball(f x,e)``,
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_BALL, continuous_at] THEN
  MESON_TAC[DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_COMPARISON = store_thm ("CONTINUOUS_WITHIN_COMPARISON",
 ``!f:real->real g:real->real s a.
        g continuous (at a within s) /\
        (!x. x IN s ==> dist(f a,f x) <= dist(g a,g x))
        ==> f continuous (at a within s)``,
  ONCE_REWRITE_TAC[DIST_SYM] THEN
  REWRITE_TAC[continuous_within] THEN MESON_TAC[REAL_LET_TRANS]);

(* ------------------------------------------------------------------------- *)
(* For setwise continuity, just start from the epsilon-delta definitions.    *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "continuous_on" (Infix(NONASSOC, 450));
val _ = set_fixity "uniformly_continuous_on" (Infix(NONASSOC, 450));

val continuous_on = new_definition ("continuous_on",
 ``f continuous_on s <=>
   !x. x IN s ==> !e. &0 < e
   ==> ?d. &0 < d /\ !x'. x' IN s /\ dist(x',x) < d
     ==> dist(f(x'),f(x)) < e``);

val uniformly_continuous_on = new_definition ("uniformly_continuous_on",
 ``f uniformly_continuous_on s <=>
   !e. &0 < e
   ==> ?d. &0 < d /\ !x x'. x IN s /\ x' IN s /\ dist(x',x) < d
     ==> dist(f(x'),f(x)) < e``);

(* ------------------------------------------------------------------------- *)
(* Some simple consequential lemmas.                                         *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS = store_thm ("UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS",
 ``!f s. f uniformly_continuous_on s ==> f continuous_on s``,
  REWRITE_TAC[uniformly_continuous_on, continuous_on] THEN MESON_TAC[]);

val CONTINUOUS_AT_IMP_CONTINUOUS_ON = store_thm ("CONTINUOUS_AT_IMP_CONTINUOUS_ON",
 ``!f s. (!x. x IN s ==> f continuous (at x)) ==> f continuous_on s``,
  REWRITE_TAC[continuous_at, continuous_on] THEN MESON_TAC[]);

val CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN = store_thm ("CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN",
 ``!f s. f continuous_on s <=> !x. x IN s ==> f continuous (at x within s)``,
 REWRITE_TAC[continuous_on, continuous_within]);

val CONTINUOUS_ON = store_thm ("CONTINUOUS_ON",
 ``!f (s:real->bool).
  f continuous_on s <=> !x. x IN s ==> (f --> f(x)) (at x within s)``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_WITHIN]);

val CONTINUOUS_ON_EQ_CONTINUOUS_AT = store_thm ("CONTINUOUS_ON_EQ_CONTINUOUS_AT",
 ``!f:real->real s.
  open s ==> (f continuous_on s <=> (!x. x IN s ==> f continuous (at x)))``,
  SIMP_TAC std_ss [CONTINUOUS_ON, CONTINUOUS_AT, LIM_WITHIN_OPEN]);

val CONTINUOUS_WITHIN_SUBSET = store_thm ("CONTINUOUS_WITHIN_SUBSET",
 ``!f s t x. f continuous (at x within s) /\ t SUBSET s
  ==> f continuous (at x within t)``,
 REWRITE_TAC[CONTINUOUS_WITHIN] THEN MESON_TAC[LIM_WITHIN_SUBSET]);

val CONTINUOUS_ON_SUBSET = store_thm ("CONTINUOUS_ON_SUBSET",
 ``!f s t. f continuous_on s /\ t SUBSET s ==> f continuous_on t``,
  REWRITE_TAC[CONTINUOUS_ON] THEN MESON_TAC[SUBSET_DEF, LIM_WITHIN_SUBSET]);

val UNIFORMLY_CONTINUOUS_ON_SUBSET = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUBSET",
 ``!f s t. f uniformly_continuous_on s /\ t SUBSET s
  ==> f uniformly_continuous_on t``,
  REWRITE_TAC[uniformly_continuous_on] THEN
  MESON_TAC[SUBSET_DEF, LIM_WITHIN_SUBSET]);

val CONTINUOUS_ON_INTERIOR = store_thm ("CONTINUOUS_ON_INTERIOR",
 ``!f:real->real s x.
  f continuous_on s /\ x IN interior(s) ==> f continuous at x``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_AT, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_ON_EQ = store_thm ("CONTINUOUS_ON_EQ",
 ``!f g s. (!x. x IN s ==> (f(x) = g(x))) /\ f continuous_on s
  ==> g continuous_on s``,
  SIMP_TAC std_ss [continuous_on, CONJ_EQ_IMP]);

val UNIFORMLY_CONTINUOUS_ON_EQ = store_thm ("UNIFORMLY_CONTINUOUS_ON_EQ",
 ``!f g s. (!x. x IN s ==> (f x = g x)) /\ f uniformly_continuous_on s
   ==> g uniformly_continuous_on s``,
  SIMP_TAC std_ss [uniformly_continuous_on, CONJ_EQ_IMP]);

val CONTINUOUS_ON_SING = store_thm ("CONTINUOUS_ON_SING",
 ``!f:real->real a. f continuous_on {a}``,
  SIMP_TAC std_ss [continuous_on, IN_SING, DIST_REFL] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_EMPTY = store_thm ("CONTINUOUS_ON_EMPTY",
 ``!f:real->real. f continuous_on {}``,
  MESON_TAC[CONTINUOUS_ON_SING, EMPTY_SUBSET, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_ON_NO_LIMPT = store_thm ("CONTINUOUS_ON_NO_LIMPT",
 ``!f:real->real s.
  ~(?x. x limit_point_of s) ==> f continuous_on s``,
  REWRITE_TAC[continuous_on, LIMPT_APPROACHABLE] THEN MESON_TAC[DIST_REFL]);

val CONTINUOUS_ON_FINITE = store_thm ("CONTINUOUS_ON_FINITE",
 ``!f:real->real s. FINITE s ==> f continuous_on s``,
  MESON_TAC[CONTINUOUS_ON_NO_LIMPT, LIMIT_POINT_FINITE]);

val CONTRACTION_IMP_CONTINUOUS_ON = store_thm ("CONTRACTION_IMP_CONTINUOUS_ON",
 ``!f:real->real.
   (!x y. x IN s /\ y IN s ==> dist(f x,f y) <= dist(x,y))
   ==> f continuous_on s``,
  SIMP_TAC std_ss [continuous_on] THEN MESON_TAC[REAL_LET_TRANS]);

val ISOMETRY_ON_IMP_CONTINUOUS_ON = store_thm ("ISOMETRY_ON_IMP_CONTINUOUS_ON",
 ``!f:real->real.
   (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
   ==> f continuous_on s``,
  SIMP_TAC std_ss [CONTRACTION_IMP_CONTINUOUS_ON, REAL_LE_REFL]);

(* ------------------------------------------------------------------------- *)
(* Characterization of various kinds of continuity in terms of sequences.    *)
(* ------------------------------------------------------------------------- *)

val FORALL_POS_MONO_1 = store_thm ("FORALL_POS_MONO_1",
 ``!P. (!d e. d < e /\ P d ==> P e) /\ (!n. P(inv(&n + &1)))
       ==> !e. (&0:real) < e ==> P e``,
  SIMP_TAC std_ss [REAL_OF_NUM_SUC] THEN SIMP_TAC std_ss [GSYM FORALL_SUC] THEN
  REWRITE_TAC [FORALL_POS_MONO]);

val CONTINUOUS_WITHIN_SEQUENTIALLY = store_thm ("CONTINUOUS_WITHIN_SEQUENTIALLY",
 ``!f s a:real.
    f continuous (at a within s) <=>
    !x. (!n. x(n) IN s) /\ (x --> a) sequentially
    ==> ((f o x) --> f(a)) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_within] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN MESON_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT, REAL_OF_NUM_LE, REAL_POS,
   REAL_ARITH ``&0 <= n ==> &0 < n + &1:real``, NOT_FORALL_THM, SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:num->real``) THEN EXISTS_TAC ``y:num->real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  STRIP_TAC THEN CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[LESS_EQ_REFL]] THEN
  KNOW_TAC ``!e. (?N:num. !n. N <= n ==> dist (y n,a) < e) =
             (\e. ?N:num. !n. N <= n ==> dist (y n,a) < e) e`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FORALL_POS_MONO_1 THEN BETA_TAC THEN
  CONJ_TAC THENL [ASM_MESON_TAC[REAL_LT_TRANS], ALL_TAC] THEN
  X_GEN_TAC ``n:num`` THEN EXISTS_TAC ``n:num`` THEN X_GEN_TAC ``m:num`` THEN
  DISCH_TAC THEN MATCH_MP_TAC REAL_LTE_TRANS THEN
  EXISTS_TAC ``&1 / (&m + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_INV2, real_div, REAL_ARITH ``&0 <= x ==> &0 < x + &1:real``,
   REAL_POS, REAL_MUL_LID, REAL_LE_RADD, REAL_OF_NUM_LE]);

val CONTINUOUS_AT_SEQUENTIALLY = store_thm ("CONTINUOUS_AT_SEQUENTIALLY",
 ``!f a:real. f continuous (at a) <=>
   !x. (x --> a) sequentially ==> ((f o x) --> f(a)) sequentially``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN_SEQUENTIALLY, IN_UNIV]);

val CONTINUOUS_ON_SEQUENTIALLY = store_thm ("CONTINUOUS_ON_SEQUENTIALLY",
 ``!f s:real->bool. f continuous_on s <=>
   !x a. a IN s /\ (!n. x(n) IN s) /\ (x --> a) sequentially
   ==> ((f o x) --> f(a)) sequentially``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
  CONTINUOUS_WITHIN_SEQUENTIALLY] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY = store_thm ("UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY",
 ``!f s:real->bool. f uniformly_continuous_on s <=>
   !x y. (!n. x(n) IN s) /\ (!n. y(n) IN s) /\
   ((\n. x(n) - y(n)) --> 0) sequentially
   ==> ((\n. f(x(n)) - f(y(n))) --> 0) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, dist, REAL_SUB_RZERO] THEN
  EQ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, REAL_OF_NUM_LE, REAL_POS,
   REAL_ARITH ``&0 <= n ==> &0 < n + &1:real``, NOT_FORALL_THM, SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:num->real``) THEN
  EXISTS_TAC ``x:num->real`` THEN EXISTS_TAC ``y:num->real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[ABS_SUB] THEN CONJ_TAC THENL
  [KNOW_TAC ``!e:real. (?N:num. !n. N <= n ==> abs (y n - x n) < e) =
                   (\e. ?N:num. !n. N <= n ==> abs (y n - x n) < e) e`` THENL
   [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
   MATCH_MP_TAC FORALL_POS_MONO_1 THEN BETA_TAC THEN
   CONJ_TAC THENL [ASM_MESON_TAC[REAL_LT_TRANS], ALL_TAC] THEN
   X_GEN_TAC ``n:num`` THEN EXISTS_TAC ``n:num`` THEN X_GEN_TAC ``m:num`` THEN
   DISCH_TAC THEN MATCH_MP_TAC REAL_LTE_TRANS THEN
   EXISTS_TAC ``&1 / (&m + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
   ASM_SIMP_TAC std_ss [REAL_LE_INV2, real_div, REAL_ARITH ``&0 <= x ==> &0 < x + &1:real``,
    REAL_POS, REAL_MUL_LID, REAL_LE_RADD, REAL_OF_NUM_LE],
  EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  EXISTS_TAC ``\x:num. x`` THEN ASM_SIMP_TAC std_ss [LESS_EQ_REFL]]);

val LIM_CONTINUOUS_FUNCTION = store_thm ("LIM_CONTINUOUS_FUNCTION",
 ``!f net g l.
  f continuous (at l) /\ (g --> l) net ==> ((\x. f(g x)) --> f l) net``,
  REWRITE_TAC[tendsto, continuous_at, eventually] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Combination results for pointwise continuity.                             *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_CONST = store_thm ("CONTINUOUS_CONST",
 ``!net c. (\x. c) continuous net``,
  REWRITE_TAC[continuous, LIM_CONST]);

val CONTINUOUS_CMUL = store_thm ("CONTINUOUS_CMUL",
 ``!f c net. f continuous net ==> (\x. c * f(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_CMUL]);

val CONTINUOUS_NEG = store_thm ("CONTINUOUS_NEG",
 ``!f net. f continuous net ==> (\x. -(f x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_NEG]);

val CONTINUOUS_ADD = store_thm ("CONTINUOUS_ADD",
 ``!f g net. f continuous net /\ g continuous net
  ==> (\x. f(x) + g(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_ADD]);

val CONTINUOUS_SUB = store_thm ("CONTINUOUS_SUB",
 ``!f g net. f continuous net /\ g continuous net
  ==> (\x. f(x) - g(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_SUB]);

val CONTINUOUS_ABS = store_thm ("CONTINUOUS_ABS",
 ``!(f:'a->real) net. f continuous net
  ==> (\x. abs(f(x)):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_ABS]);

val CONTINUOUS_MAX = store_thm ("CONTINUOUS_MAX",
 ``!(f:'a->real) (g:'a->real) net.
   f continuous net /\ g continuous net
   ==> (\x. (max (f(x)) (g(x))):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MAX]);

val CONTINUOUS_MIN = store_thm ("CONTINUOUS_MIN",
 ``!(f:'a->real) (g:'a->real) net.
   f continuous net /\ g continuous net
   ==> (\x. (min (f(x)) (g(x))):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MIN]);

val CONTINUOUS_SUM = store_thm ("CONTINUOUS_SUM",
 ``!net f s. FINITE s /\ (!a. a IN s ==> (f a) continuous net)
  ==> (\x. sum s (\a. f a x)) continuous net``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  KNOW_TAC ``!s. ((!a:'b. a IN s ==> f a continuous net) ==>
              (\x:'a. sum s (\a. f a x)) continuous net) =
             (\s. (!a. a IN s ==> f a continuous net) ==>
              (\x. sum s (\a. f a x)) continuous net) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   CONTINUOUS_CONST, CONTINUOUS_ADD, ETA_AX] THEN
  METIS_TAC [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   CONTINUOUS_CONST, CONTINUOUS_ADD, ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Same thing for setwise continuity.                                        *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CONST = store_thm ("CONTINUOUS_ON_CONST",
 ``!s c. (\x. c) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_CONST]);

val CONTINUOUS_ON_CMUL = store_thm ("CONTINUOUS_ON_CMUL",
 ``!f c s. f continuous_on s ==> (\x. c * f(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_CMUL]);

val CONTINUOUS_ON_NEG = store_thm ("CONTINUOUS_ON_NEG",
 ``!f s. f continuous_on s
  ==> (\x. -(f x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_NEG]);

val CONTINUOUS_ON_ADD = store_thm ("CONTINUOUS_ON_ADD",
 ``!f g s. f continuous_on s /\ g continuous_on s
  ==> (\x. f(x) + g(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ADD]);

val CONTINUOUS_ON_SUB = store_thm ("CONTINUOUS_ON_SUB",
 ``!f g s. f continuous_on s /\ g continuous_on s
  ==> (\x. f(x) - g(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_SUB]);

val CONTINUOUS_ON_ABS = store_thm ("CONTINUOUS_ON_ABS",
 ``!f:real->real s. f continuous_on s
  ==> (\x. (abs(f(x))):real) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ABS]);

val CONTINUOUS_ON_MAX = store_thm ("CONTINUOUS_ON_MAX",
 ``!f:real->real g:real->real s.
  f continuous_on s /\ g continuous_on s
  ==> (\x. (max (f(x)) (g(x))):real)
   continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_MAX]);

val CONTINUOUS_ON_MIN = store_thm ("CONTINUOUS_ON_MIN",
 ``!f:real->real g:real->real s.
  f continuous_on s /\ g continuous_on s
  ==> (\x. (min (f(x)) (g(x))):real)
   continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_MIN]);

val CONTINUOUS_ON_SUM = store_thm ("CONTINUOUS_ON_SUM",
 ``!t f s. FINITE s /\ (!a. a IN s ==> (f a) continuous_on t)
  ==> (\x. sum s (\a. f a x)) continuous_on t``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_SUM]);

(* ------------------------------------------------------------------------- *)
(* Same thing for uniform continuity, using sequential formulations.         *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_ON_CONST = store_thm ("UNIFORMLY_CONTINUOUS_ON_CONST",
 ``!s c. (\x. c) uniformly_continuous_on s``,
  SIMP_TAC std_ss [UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY, o_DEF,
   REAL_SUB_REFL, LIM_CONST]);

val LINEAR_UNIFORMLY_CONTINUOUS_ON = store_thm ("LINEAR_UNIFORMLY_CONTINUOUS_ON",
 ``!f:real->real s. linear f ==> f uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [uniformly_continuous_on, dist, GSYM LINEAR_SUB] THEN
  FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
   MATCH_MP LINEAR_BOUNDED_POS) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``e / B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``B * abs(y - x:real)`` THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[REAL_LT_RDIV_EQ, REAL_MUL_SYM]);

val lemma = prove (
 ``(!y. ((?x. (y = f x) /\ P x) /\ Q y ==> R y)) <=>
   (!x. P x /\ Q (f x) ==> R (f x))``,
  MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_COMPOSE = store_thm ("UNIFORMLY_CONTINUOUS_ON_COMPOSE",
 ``!f g s. f uniformly_continuous_on s /\
           g uniformly_continuous_on (IMAGE f s)
 ==> (g o f) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [uniformly_continuous_on, o_THM, IN_IMAGE] THEN
  KNOW_TAC ``((!e:real. 0 < e ==> ?d. 0 < d /\
     !x x'. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
    !x x'. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
             ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
    !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [SWAP_FORALL_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC `` ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
              ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ (?x. (x' = f x) /\ x IN s) /\ dist (x',f x) < d
                    ==> dist (g x',g (f x)) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`] THEN
  KNOW_TAC ``((!e. 0 < e ==> ?d. 0 < d /\
     !x' x. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x' x. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
              ((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [SWAP_FORALL_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
            ((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (f x',f x) < d ==>
       dist (g (f x'),g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e`` THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[]);

val BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE = store_thm ("BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE",
 ``!f:real->real g (h:real->real->real) s.
    f uniformly_continuous_on s /\ g uniformly_continuous_on s /\
    bilinear h /\ bounded(IMAGE f s) /\ bounded(IMAGE g s)
    ==> (\x. h (f x) (g x)) uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[uniformly_continuous_on, dist] THEN
  BETA_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``!a b c d. (h:real->real->real) a b - h c d =
     h (a - c) b + h c (b - d)`` (fn th => ONCE_REWRITE_TAC[th]) THENL
  [FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP BILINEAR_LSUB th]) THEN
   FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP BILINEAR_RSUB th]) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
   MATCH_MP BILINEAR_BOUNDED_POS) THEN
  UNDISCH_TAC ``bounded(IMAGE (g:real->real) s)`` THEN
  UNDISCH_TAC ``bounded(IMAGE (f:real->real) s)`` THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B1:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``B2:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``(g:real->real) uniformly_continuous_on s`` THEN
  UNDISCH_TAC ``(f:real->real) uniformly_continuous_on s`` THEN
  REWRITE_TAC[uniformly_continuous_on] THEN
  DISCH_THEN(MP_TAC o SPEC ``e:real / &2 / &2 / B / B2``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_HALF, dist] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``e:real / &2 / &2 / B / B1``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_HALF, dist] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x:real``, ``y:real``]) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x:real``, ``y:real``]) THEN
  ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC
   ``B * e / &2 / &2 / B / B2 * B2 + B * B1 * e / &2 / &2 / B / B1:real`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC(REAL_ARITH
   ``abs(x) <= a /\ abs(y) <= b ==> abs(x + y:real) <= a + b``) THEN
  CONJ_TAC THEN
  FIRST_X_ASSUM(fn th => W(MP_TAC o PART_MATCH lhand th o lhand o snd)) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LE_TRANS) THEN
  REWRITE_TAC [real_div] THEN REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC REAL_LE_LMUL1 THEN ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE] THENL
  [REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC],ALL_TAC] THEN
  MATCH_MP_TAC REAL_LE_MUL2 THEN REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, ABS_POS],
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [real_div, GSYM REAL_MUL_ASSOC] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [real_div] THEN
  REWRITE_TAC [REAL_ARITH `` B1 * e * inv 2 * inv 2 * inv B * inv B1 * B =
                             e * inv 2 * inv 2 * inv B * inv B1 * B1 * B:real``] THEN
  REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [REAL_HALF_DOUBLE] THEN ASM_SIMP_TAC std_ss [REAL_LT_HALF2]]);

val UNIFORMLY_CONTINUOUS_ON_MUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_MUL",
 ``!f g:real->real s.
    f uniformly_continuous_on s /\ g uniformly_continuous_on s /\
    bounded(IMAGE f s) /\ bounded(IMAGE g s)
    ==> (\x. f x * g x) uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``(f:real->real)``, ``g:real->real``,
   ``\c (v:real). c * v``, ``s:real->bool``]
  BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE) THEN
  ASM_SIMP_TAC std_ss [o_THM] THEN DISCH_THEN MATCH_MP_TAC THEN
  REWRITE_TAC[bilinear, linear] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_CMUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_CMUL",
 ``!f c s. f uniformly_continuous_on s
   ==> (\x. c * f(x)) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY] THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`x:num->real`, `y:num->real`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_CMUL) THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_MUL_RZERO]);

val UNIFORMLY_CONTINUOUS_ON_VMUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_VMUL",
 ``!s:real->bool c v:real.
    c uniformly_continuous_on s
    ==> (\x. c x * v) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o ISPEC ``\x. (x * v:real)`` o MATCH_MP
   (REWRITE_RULE[CONJ_EQ_IMP] UNIFORMLY_CONTINUOUS_ON_COMPOSE)) THEN
  SIMP_TAC std_ss [o_DEF] THEN DISCH_THEN MATCH_MP_TAC THEN
  MATCH_MP_TAC LINEAR_UNIFORMLY_CONTINUOUS_ON THEN
  REWRITE_TAC [linear] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_NEG = store_thm ("UNIFORMLY_CONTINUOUS_ON_NEG",
 ``!f s. f uniformly_continuous_on s
   ==> (\x. -(f x)) uniformly_continuous_on s``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_CMUL]);

val UNIFORMLY_CONTINUOUS_ON_ADD = store_thm ("UNIFORMLY_CONTINUOUS_ON_ADD",
 ``!f g s. f uniformly_continuous_on s /\ g uniformly_continuous_on s
  ==> (\x. f(x) + g(x)) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`x:num->real`, `y:num->real`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [o_DEF] THEN DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN BETA_TAC THEN
  REWRITE_TAC[REAL_ADD_LID] THEN AP_THM_TAC THEN BINOP_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_SUB = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUB",
 ``!f g s. f uniformly_continuous_on s /\ g uniformly_continuous_on s
   ==> (\x. f(x) - g(x)) uniformly_continuous_on s``,
  REWRITE_TAC[real_sub] THEN
  SIMP_TAC std_ss [UNIFORMLY_CONTINUOUS_ON_NEG, UNIFORMLY_CONTINUOUS_ON_ADD]);

val UNIFORMLY_CONTINUOUS_ON_SUM = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUM",
 ``!t f s. FINITE s /\ (!a. a IN s ==> (f a) uniformly_continuous_on t)
    ==> (\x. sum s (\a. f a x)) uniformly_continuous_on t``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  KNOW_TAC ``!s. ((!a. a IN s ==> f a uniformly_continuous_on t) ==>
              (\x. sum s (\a. f a x)) uniformly_continuous_on t) =
             (\s. (!a. a IN s ==> f a uniformly_continuous_on t) ==>
              (\x. sum s (\a. f a x)) uniformly_continuous_on t) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   UNIFORMLY_CONTINUOUS_ON_CONST, ETA_AX] THEN REPEAT STRIP_TAC THEN
  METIS_TAC [UNIFORMLY_CONTINUOUS_ON_ADD]);

(* ------------------------------------------------------------------------- *)
(* Identity function is continuous in every sense.                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_ID = store_thm ("CONTINUOUS_WITHIN_ID",
 ``!a s. (\x. x) continuous (at a within s)``,
  REWRITE_TAC[continuous_within] THEN MESON_TAC[]);

val CONTINUOUS_AT_ID = store_thm ("CONTINUOUS_AT_ID",
 ``!a. (\x. x) continuous (at a)``,
  REWRITE_TAC[continuous_at] THEN MESON_TAC[]);

val CONTINUOUS_ON_ID = store_thm ("CONTINUOUS_ON_ID",
 ``!s. (\x. x) continuous_on s``,
  REWRITE_TAC[continuous_on] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_ID = store_thm ("UNIFORMLY_CONTINUOUS_ON_ID",
 ``!s. (\x. x) uniformly_continuous_on s``,
  REWRITE_TAC[uniformly_continuous_on] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Continuity of all kinds is preserved under composition. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_COMPOSE = store_thm ("CONTINUOUS_WITHIN_COMPOSE",
 ``!f g x s. f continuous (at x within s) /\
      g continuous (at (f x) within IMAGE f s)
    ==> (g o f) continuous (at x within s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [continuous_within, o_THM, IN_IMAGE] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_MESON_TAC[]);

val CONTINUOUS_AT_COMPOSE = store_thm ("CONTINUOUS_AT_COMPOSE",
 ``!f g x. f continuous (at x) /\ g continuous (at (f x))
   ==> (g o f) continuous (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MESON_TAC[CONTINUOUS_WITHIN_COMPOSE, IN_IMAGE, CONTINUOUS_WITHIN_SUBSET,
   SUBSET_UNIV, IN_UNIV]);

val CONTINUOUS_ON_COMPOSE = store_thm ("CONTINUOUS_ON_COMPOSE",
 ``!f g s. f continuous_on s /\ g continuous_on (IMAGE f s)
  ==> (g o f) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  MESON_TAC[IN_IMAGE, CONTINUOUS_WITHIN_COMPOSE]);

(* ------------------------------------------------------------------------- *)
(* Continuity in terms of open preimages. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_OPEN = store_thm ("CONTINUOUS_WITHIN_OPEN",
 ``!f:real->real x u.
    f continuous (at x within u) <=>
   !t. open t /\ f(x) IN t
   ==> ?s. open s /\ x IN s /\
    !x'. x' IN s /\ x' IN u ==> f(x') IN t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_within] THEN EQ_TAC THENL
  [DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN
   DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
   GEN_REWR_TAC LAND_CONV [open_def] THEN
   DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
   ASM_MESON_TAC[IN_BALL, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL, DIST_SYM],
   DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``ball((f:real->real) x,e)``) THEN
   ASM_SIMP_TAC std_ss [OPEN_BALL, CENTRE_IN_BALL] THEN
   MESON_TAC[open_def, IN_BALL, REAL_LT_TRANS, DIST_SYM]]);

val CONTINUOUS_AT_OPEN = store_thm ("CONTINUOUS_AT_OPEN",
 ``!f:real->real x.
   f continuous (at x) <=>
   !t. open t /\ f(x) IN t
   ==> ?s. open s /\ x IN s /\
    !x'. x' IN s ==> f(x') IN t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_at] THEN EQ_TAC THENL
  [DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN
   DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
   GEN_REWR_TAC LAND_CONV [open_def] THEN
   DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
   ASM_MESON_TAC[IN_BALL, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL],
   DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``ball((f:real->real) x,e)``) THEN
   ASM_SIMP_TAC std_ss [OPEN_BALL, CENTRE_IN_BALL] THEN
   MESON_TAC[open_def, IN_BALL, REAL_LT_TRANS, DIST_SYM]]);

val CONTINUOUS_ON_OPEN_GEN = store_thm ("CONTINUOUS_ON_OPEN_GEN",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> (f continuous_on s <=>
    !u. open_in (subtopology euclidean t) u
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN u})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[continuous_on] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [open_in, SUBSET_DEF, GSPECIFICATION] THEN
   DISCH_TAC THEN X_GEN_TAC ``u:real->bool`` THEN STRIP_TAC THEN
   X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``(f:real->real) x``) THEN ASM_SET_TAC[],
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o
   SPEC ``ball((f:real->real) x,e) INTER t``) THEN
  KNOW_TAC ``open_in (subtopology euclidean t) (ball ((f:real->real) x,e) INTER t)`` THENL
  [ASM_MESON_TAC[OPEN_IN_OPEN, INTER_COMM, OPEN_BALL], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [open_in, SUBSET_DEF, IN_INTER, GSPECIFICATION, IN_BALL, IN_IMAGE] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF, FORALL_IN_IMAGE]) THEN
  FULL_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  ASM_MESON_TAC[DIST_REFL, DIST_SYM]]);

val CONTINUOUS_ON_OPEN = store_thm ("CONTINUOUS_ON_OPEN",
 ``!f:real->real s.
   f continuous_on s <=>
   !t. open_in (subtopology euclidean (IMAGE f s)) t
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_OPEN_GEN THEN
  REWRITE_TAC[SUBSET_REFL]);

val CONTINUOUS_OPEN_IN_PREIMAGE_GEN = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE_GEN",
 ``!f:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    open_in (subtopology euclidean t) u
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN u}``,
  METIS_TAC[CONTINUOUS_ON_OPEN_GEN]);

val CONTINUOUS_ON_IMP_OPEN_IN = store_thm ("CONTINUOUS_ON_IMP_OPEN_IN",
 ``!f:real->real s t. f continuous_on s /\
   open_in (subtopology euclidean (IMAGE f s)) t
   ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
 METIS_TAC[CONTINUOUS_ON_OPEN]);

(* ------------------------------------------------------------------------- *)
(* Similarly in terms of closed sets. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CLOSED_GEN = store_thm ("CONTINUOUS_ON_CLOSED_GEN",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> (f continuous_on s <=>
    !u. closed_in (subtopology euclidean t) u
    ==> closed_in (subtopology euclidean s)
    {x | x IN s /\ f x IN u})``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(fn th =>
  ONCE_REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``u:real->bool`` THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THENL
  [REWRITE_TAC[closed_in], REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ]] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_CLOSED = store_thm ("CONTINUOUS_ON_CLOSED",
 ``!f:real->real s.
    f continuous_on s <=>
   !t. closed_in (subtopology euclidean (IMAGE f s)) t
    ==> closed_in (subtopology euclidean s) {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_CLOSED_GEN THEN
  REWRITE_TAC[SUBSET_REFL]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_GEN = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_GEN",
 ``!f:real->real s t u.
   f continuous_on s /\ IMAGE f s SUBSET t /\
   closed_in (subtopology euclidean t) u
   ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN u}``,
  METIS_TAC[CONTINUOUS_ON_CLOSED_GEN]);

val CONTINUOUS_ON_IMP_CLOSED_IN = store_thm ("CONTINUOUS_ON_IMP_CLOSED_IN",
 ``!f:real->real s t. f continuous_on s /\
    closed_in (subtopology euclidean (IMAGE f s)) t
    ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  METIS_TAC[CONTINUOUS_ON_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* Half-global and completely global cases. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_OPEN_IN_PREIMAGE = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE",
 ``!f s t.
  f continuous_on s /\ open t
  ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[SET_RULE
  ``x IN s /\ f x IN t <=> x IN s /\ f x IN (t INTER IMAGE f s)``] THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CONTINUOUS_ON_OPEN]) THEN
  ONCE_REWRITE_TAC[INTER_COMM] THEN MATCH_MP_TAC OPEN_IN_OPEN_INTER THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_CLOSED_IN_PREIMAGE = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE",
 ``!f s t.
   f continuous_on s /\ closed t
   ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[SET_RULE
   ``x IN s /\ f x IN t <=> x IN s /\ f x IN (t INTER IMAGE f s)``] THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CONTINUOUS_ON_CLOSED]) THEN
  ONCE_REWRITE_TAC[INTER_COMM] THEN MATCH_MP_TAC CLOSED_IN_CLOSED_INTER THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_OPEN_PREIMAGE = store_thm ("CONTINUOUS_OPEN_PREIMAGE",
 ``!f:real->real s t.
   f continuous_on s /\ open s /\ open t
   ==> open {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  REWRITE_TAC [OPEN_IN_OPEN] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (f:real->real) s INTER t``) THEN
  KNOW_TAC ``(?t'. open t' /\ (IMAGE (f:real->real) s INTER t = IMAGE f s INTER t'))`` THENL
  [EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC [],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN t} =
                                            s INTER t'`` SUBST1_TAC THENL
  [ASM_SET_TAC [], ASM_MESON_TAC [OPEN_INTER]]]);

val CONTINUOUS_CLOSED_PREIMAGE = store_thm ("CONTINUOUS_CLOSED_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ closed s /\ closed t
    ==> closed {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN UNDISCH_TAC ``f continuous_on s`` THEN
  GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_CLOSED] THEN
  REWRITE_TAC [CLOSED_IN_CLOSED] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (f:real->real) s INTER t``) THEN
  KNOW_TAC ``(?t'. closed t' /\ (IMAGE (f:real->real) s INTER t = IMAGE f s INTER t'))`` THENL
  [EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC [],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN t} =
                                            s INTER t'`` SUBST1_TAC THENL
  [ASM_SET_TAC [], ASM_MESON_TAC [CLOSED_INTER]]]);

val CONTINUOUS_OPEN_PREIMAGE_UNIV = store_thm ("CONTINUOUS_OPEN_PREIMAGE_UNIV",
 ``!f:real->real s.
  (!x. f continuous (at x)) /\ open s ==> open {x | f(x) IN s}``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``f:real->real``, ``univ(:real)``, ``s:real->bool``]
   CONTINUOUS_OPEN_PREIMAGE) THEN
  ASM_SIMP_TAC std_ss [OPEN_UNIV, IN_UNIV, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val CONTINUOUS_CLOSED_PREIMAGE_UNIV = store_thm ("CONTINUOUS_CLOSED_PREIMAGE_UNIV",
 ``!f:real->real s.
  (!x. f continuous (at x)) /\ closed s ==> closed {x | f(x) IN s}``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``f:real->real``, ``univ(:real)``, ``s:real->bool``]
   CONTINUOUS_CLOSED_PREIMAGE) THEN
  ASM_SIMP_TAC std_ss [CLOSED_UNIV, IN_UNIV, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val CONTINUOUS_OPEN_IN_PREIMAGE_EQ = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE_EQ",
 ``!f:real->real s. f continuous_on s <=>
   !t. open t ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONTINUOUS_OPEN_IN_PREIMAGE] THEN
  REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN DISCH_TAC THEN
  X_GEN_TAC ``t:real->bool`` THEN GEN_REWR_TAC LAND_CONV [OPEN_IN_OPEN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SET_TAC[]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_EQ = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_EQ",
 ``!f:real->real s. f continuous_on s <=> !t. closed t
     ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONTINUOUS_CLOSED_IN_PREIMAGE] THEN
  REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN DISCH_TAC THEN
  X_GEN_TAC ``t:real->bool`` THEN
  GEN_REWR_TAC LAND_CONV [CLOSED_IN_CLOSED] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Linear functions are (uniformly) continuous on any set. *)
(* ------------------------------------------------------------------------- *)

val LINEAR_LIM_0 = store_thm ("LINEAR_LIM_0",
 ``!f. linear f ==> (f --> 0) (at (0))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIM_AT] THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP LINEAR_BOUNDED_POS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``e / B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV] THEN REWRITE_TAC[dist, REAL_SUB_RZERO] THEN
  ASM_MESON_TAC[REAL_MUL_SYM, REAL_LET_TRANS, REAL_LT_RDIV_EQ]);

val LINEAR_CONTINUOUS_AT = store_thm ("LINEAR_CONTINUOUS_AT",
 ``!f:real->real a. linear f ==> f continuous (at a)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``\x. (f:real->real) (a + x) - f(a)`` LINEAR_LIM_0) THEN
  KNOW_TAC ``linear (\x. f (a + x) - f a)`` THENL
  [POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [linear] THEN
   REPEAT STRIP_TAC THEN REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [GSYM LIM_NULL, CONTINUOUS_AT] THEN
  GEN_REWR_TAC RAND_CONV [LIM_AT_ZERO] THEN SIMP_TAC std_ss []);

val LINEAR_CONTINUOUS_WITHIN = store_thm ("LINEAR_CONTINUOUS_WITHIN",
 ``!f:real->real s x. linear f ==> f continuous (at x within s)``,
  SIMP_TAC std_ss [CONTINUOUS_AT_WITHIN, LINEAR_CONTINUOUS_AT]);

val LINEAR_CONTINUOUS_ON = store_thm ("LINEAR_CONTINUOUS_ON",
 ``!f:real->real s. linear f ==> f continuous_on s``,
  MESON_TAC[LINEAR_CONTINUOUS_AT, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val LINEAR_CONTINUOUS_COMPOSE = store_thm ("LINEAR_CONTINUOUS_COMPOSE",
 ``!net f:'a->real g:real->real.
   f continuous net /\ linear g ==> (\x. g(f x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_LINEAR]);

val LINEAR_CONTINUOUS_ON_COMPOSE = store_thm ("LINEAR_CONTINUOUS_ON_COMPOSE",
 ``!f:real->real g:real->real s.
    f continuous_on s /\ linear g ==> (\x. g(f x)) continuous_on s``,
  SIMP_TAC std_ss[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
   LINEAR_CONTINUOUS_COMPOSE]);

val CONTINUOUS_COMPONENT_COMPOSE = store_thm ("CONTINUOUS_COMPONENT_COMPOSE",
 ``!net f:'a->real i. f continuous net ==> (\x. f x) continuous net``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``linear(\x:real. x)`` MP_TAC THENL
  [REWRITE_TAC[LINEAR_ID], REWRITE_TAC[GSYM IMP_CONJ_ALT]] THEN
  METIS_TAC [LINEAR_CONTINUOUS_COMPOSE]);

val CONTINUOUS_ON_COMPONENT_COMPOSE = store_thm ("CONTINUOUS_ON_COMPONENT_COMPOSE",
 ``!f:real->real s. f continuous_on s
    ==> (\x. f x) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
                   CONTINUOUS_COMPONENT_COMPOSE]);

(* ------------------------------------------------------------------------- *)
(* Also bilinear functions, in composition form. *)
(* ------------------------------------------------------------------------- *)

val BILINEAR_CONTINUOUS_COMPOSE = store_thm ("BILINEAR_CONTINUOUS_COMPOSE",
 ``!net f:'a->real g:'a->real h:real->real->real.
   f continuous net /\ g continuous net /\ bilinear h
   ==> (\x. h (f x) (g x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_BILINEAR]);

val BILINEAR_CONTINUOUS_ON_COMPOSE = store_thm ("BILINEAR_CONTINUOUS_ON_COMPOSE",
 ``!f g h s. f continuous_on s /\ g continuous_on s /\ bilinear h
   ==> (\x. h (f x) (g x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
                   BILINEAR_CONTINUOUS_COMPOSE]);

val BILINEAR_DOT = store_thm ("BILINEAR_DOT",
 ``bilinear (\x y:real. (x * y))``,
SIMP_TAC std_ss [bilinear, linear] THEN REAL_ARITH_TAC);

val CONTINUOUS_DOT2 = store_thm ("CONTINUOUS_DOT2",
 ``!net f g:'a->real.
   f continuous net /\ g continuous net
   ==> (\x. f x * g x) continuous net``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP (MATCH_MP (REWRITE_RULE
   [TAUT `p /\ q /\ r ==> s <=> r ==> p /\ q ==> s`]
  BILINEAR_CONTINUOUS_COMPOSE) BILINEAR_DOT)) THEN BETA_TAC THEN REWRITE_TAC[]);

val CONTINUOUS_ON_DOT2 = store_thm ("CONTINUOUS_ON_DOT2",
 ``!f:real->real g s.
    f continuous_on s /\ g continuous_on s
    ==> (\x. f x * g x) continuous_on s``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP (MATCH_MP (REWRITE_RULE
  [TAUT `p /\ q /\ r ==> s <=> r ==> p /\ q ==> s`]
  BILINEAR_CONTINUOUS_ON_COMPOSE) BILINEAR_DOT)) THEN BETA_TAC THEN REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Preservation of compactness and connectedness under continuous function. *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CONTINUOUS_IMAGE = store_thm ("COMPACT_CONTINUOUS_IMAGE",
 ``!f:real->real s.
    f continuous_on s /\ compact s ==> compact(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on, compact] THEN
  STRIP_TAC THEN X_GEN_TAC ``y:num->real`` THEN
  SIMP_TAC std_ss [IN_IMAGE, SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN ASM_REWRITE_TAC[] THEN
  KNOW_TAC ``((?(l :real) (r :num -> num).
              l IN s /\ (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((x :num -> real) o r --> l) sequentially) ==>
               ?(l :real) (r :num -> num).
              (?(x :real). (l = f x) /\ x IN s) /\
                        (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((y :num -> real) o r --> l) sequentially) =
             ((?(r :num -> num) (l :real).
              l IN s /\ (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((x :num -> real) o r --> l) sequentially) ==>
               ?(r :num -> num) (l :real).
              (?(x :real). (l = f x) /\ x IN s) /\
                        (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((y :num -> real) o r --> l) sequentially)`` THENL
  [METIS_TAC [SWAP_EXISTS_THM], DISC_RW_KILL] THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THEN
  EXISTS_TAC ``(f:real->real) l`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``l:real``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `` ((x :num -> real) o (r :num -> num) --> l) sequentially`` THEN
  GEN_REWR_TAC LAND_CONV [LIM_SEQUENTIALLY] THEN
  DISCH_THEN(MP_TAC o SPEC ``d:real``) THEN ASM_SIMP_TAC std_ss [o_THM] THEN
  ASM_MESON_TAC[]);

val COMPACT_TRANSLATION = store_thm ("COMPACT_TRANSLATION",
 ``!s a:real. compact s ==> compact (IMAGE (\x. a + x) s)``,
  SIMP_TAC std_ss [COMPACT_CONTINUOUS_IMAGE, CONTINUOUS_ON_ADD,
   CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]);

val COMPACT_TRANSLATION_EQ = store_thm ("COMPACT_TRANSLATION_EQ",
 ``!a s. compact (IMAGE (\x:real. a + x) s) <=> compact s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[COMPACT_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o ISPEC ``-a:real`` o MATCH_MP COMPACT_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val COMPACT_LINEAR_IMAGE = store_thm ("COMPACT_LINEAR_IMAGE",
 ``!f:real->real s. compact s /\ linear f ==> compact(IMAGE f s)``,
  SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, COMPACT_CONTINUOUS_IMAGE]);

val CONNECTED_CONTINUOUS_IMAGE = store_thm ("CONNECTED_CONTINUOUS_IMAGE",
 ``!f:real->real s.
   f continuous_on s /\ connected s ==> connected(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [CONNECTED_CLOPEN, NOT_FORALL_THM, NOT_IMP, DE_MORGAN_THM] THEN
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``t:real->bool`` th) THEN
   MP_TAC(SPEC ``IMAGE (f:real->real) s DIFF t`` th)) THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN IMAGE f s DIFF t} =
   s DIFF {x | x IN s /\ f x IN t}`` SUBST1_TAC THENL
  [UNDISCH_TAC ``t SUBSET IMAGE (f:real->real) s`` THEN
   SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_DIFF, GSPECIFICATION, SUBSET_DEF] THEN
   MESON_TAC[],
   REPEAT STRIP_TAC THEN
   EXISTS_TAC ``{x | x IN s /\ (f:real->real) x IN t}`` THEN
   ASM_REWRITE_TAC[] THEN POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
   SIMP_TAC std_ss [IN_IMAGE, SUBSET_DEF, GSPECIFICATION, NOT_IN_EMPTY, EXTENSION] THEN
   MESON_TAC[]]);

val CONNECTED_TRANSLATION = store_thm ("CONNECTED_TRANSLATION",
 ``!a s. connected s ==> connected (IMAGE (\x:real. a + x) s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_ID, CONTINUOUS_ON_CONST]);

val CONNECTED_TRANSLATION_EQ = store_thm ("CONNECTED_TRANSLATION_EQ",
 ``!a s. connected (IMAGE (\x:real. a + x) s) <=> connected s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[CONNECTED_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o ISPEC ``-a:real`` o MATCH_MP CONNECTED_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val CONNECTED_LINEAR_IMAGE = store_thm ("CONNECTED_LINEAR_IMAGE",
 ``!f:real->real s. connected s /\ linear f ==> connected(IMAGE f s)``,
  SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, CONNECTED_CONTINUOUS_IMAGE]);

(* ------------------------------------------------------------------------- *)
(* Quotient maps are occasionally useful.                                    *)
(* ------------------------------------------------------------------------- *)

val QUASICOMPACT_OPEN_CLOSED = store_thm ("QUASICOMPACT_OPEN_CLOSED",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> ((!u. u SUBSET t
    ==> (open_in (subtopology euclidean s)
        {x | x IN s /\ f x IN u}
      ==> open_in (subtopology euclidean t) u)) <=>
          (!u. u SUBSET t
        ==> (closed_in (subtopology euclidean s)
            {x | x IN s /\ f x IN u}
           ==> closed_in (subtopology euclidean t) u)))``,
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``u:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``u SUBSET t ==> (t DIFF (t DIFF u) = u)``] THEN
  REWRITE_TAC [DIFF_SUBSET] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (MESON[]
   ``open_in top x ==> (x = y) ==> open_in top y``)) THEN
  ASM_SET_TAC[]);

val QUOTIENT_MAP_IMP_CONTINUOUS_OPEN = store_thm ("QUOTIENT_MAP_IMP_CONTINUOUS_OPEN",
 ``!f:real->real s t.
    IMAGE f s SUBSET t /\
    (!u. u SUBSET t
    ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
     open_in (subtopology euclidean t) u))
     ==> f continuous_on s``,
  METIS_TAC[OPEN_IN_IMP_SUBSET, CONTINUOUS_ON_OPEN_GEN]);

val QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED = store_thm ("QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED",
 ``!f:real->real s t.
   IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (closed_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
     closed_in (subtopology euclidean t) u))
     ==> f continuous_on s``,
  METIS_TAC[CLOSED_IN_IMP_SUBSET, CONTINUOUS_ON_CLOSED_GEN]);

val OPEN_MAP_IMP_QUOTIENT_MAP = store_thm ("OPEN_MAP_IMP_QUOTIENT_MAP",
 ``!f:real->real s. f continuous_on s /\
  (!t. open_in (subtopology euclidean s) t
  ==> open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t))
    ==> !t. t SUBSET IMAGE f s
      ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN t} <=>
           open_in (subtopology euclidean (IMAGE f s)) t)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
  [SUBGOAL_THEN
   ``(t = IMAGE f {x | x IN s /\ (f:real->real) x IN t})``
    SUBST1_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC std_ss []],
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  ASM_SIMP_TAC std_ss []]);

val CLOSED_MAP_IMP_QUOTIENT_MAP = store_thm ("CLOSED_MAP_IMP_QUOTIENT_MAP",
 ``!f:real->real s. f continuous_on s /\
  (!t. closed_in (subtopology euclidean s) t
  ==> closed_in (subtopology euclidean (IMAGE f s)) (IMAGE f t))
   ==> !t. t SUBSET IMAGE f s
     ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN t} <=>
          open_in (subtopology euclidean (IMAGE f s)) t)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC
    ``s DIFF {x | x IN s /\ (f:real->real) x IN t}``) THEN
   KNOW_TAC ``closed_in (subtopology euclidean (s :real -> bool))
   (s DIFF {x | x IN s /\ (f :real -> real) x IN (t :real -> bool)})`` THENL
  [MATCH_MP_TAC CLOSED_IN_DIFF THEN
   ASM_SIMP_TAC std_ss [CLOSED_IN_SUBTOPOLOGY_REFL,
    TOPSPACE_EUCLIDEAN, SUBSET_UNIV],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
   DISCH_THEN(MP_TAC o CONJUNCT2) THEN MATCH_MP_TAC EQ_IMPLIES THEN
   AP_TERM_TAC THEN ASM_SET_TAC[]],
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  ASM_SIMP_TAC std_ss []]);

val CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP",
 ``!f:real->real g s t.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET s /\
  (!y. y IN t ==> (f(g y) = y))
   ==> (!u. u SUBSET t
    ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
         open_in (subtopology euclidean t) u))``,
  REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN REPEAT STRIP_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``(IMAGE (g:real->real) t) INTER
                              {x | x IN s /\ (f:real->real) x IN u}``) THEN
   SUBGOAL_THEN ``open_in (subtopology euclidean (IMAGE (g:real->real) t))
               (IMAGE g t INTER {x | x IN s /\ (f:real->real) x IN u})``
               (fn th => REWRITE_TAC[th]) THENL
   [POP_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN] THEN ASM_SET_TAC[],
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]],
   DISCH_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
   SUBGOAL_THEN ``IMAGE (f:real->real) s = t``
    (fn th => ASM_REWRITE_TAC[th]) THEN
   ASM_SET_TAC[]]);

val CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP",
 ``!f:real->real g s.
    f continuous_on s /\ g continuous_on (IMAGE f s) /\
    (!x. x IN s ==> (g(f x) = x))
    ==> (!u. u SUBSET (IMAGE f s)
      ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
           open_in (subtopology euclidean (IMAGE f s)) u))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP THEN
  EXISTS_TAC ``g:real->real`` THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_OPEN_CLOSED = store_thm ("QUOTIENT_MAP_OPEN_CLOSED",
 ``!f:real->real s t.
    IMAGE f s SUBSET t
    ==> ((!u. u SUBSET t
      ==> (open_in (subtopology euclidean s)
          {x | x IN s /\ f x IN u} <=>
          open_in (subtopology euclidean t) u)) <=>
          (!u. u SUBSET t
          ==> (closed_in (subtopology euclidean s)
              {x | x IN s /\ f x IN u} <=>
              closed_in (subtopology euclidean t) u)))``,
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``u:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``u SUBSET t ==> (t DIFF (t DIFF u) = u)``] THEN
  REWRITE_TAC [DIFF_SUBSET] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT] THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_COMPOSE_QUOTIENT = store_thm ("CONTINUOUS_ON_COMPOSE_QUOTIENT",
 ``!f:real->real g:real->real s t u.
   IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
   (!v. v SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
        open_in (subtopology euclidean t) v)) /\
       (g o f) continuous_on s
         ==> g continuous_on t``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THEN
  SUBGOAL_THEN
   ``IMAGE ((g:real->real) o (f:real->real)) s SUBSET u``
   (fn th => REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THENL
  [REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[], DISCH_TAC] THEN
  X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``v:real->bool``) THEN
  ASM_REWRITE_TAC[o_THM] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{x | x IN t /\ (g:real->real) x IN v}``) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (MESON[]
   ``open_in top s ==> (s = t) ==> open_in top t``)) THEN
  ASM_SET_TAC[]);

val FUNCTION_FACTORS_LEFT_GEN = store_thm ("FUNCTION_FACTORS_LEFT_GEN",
 ``!P f g. (!x y. P x /\ P y /\ (g x = g y) ==> (f x = f y)) <=>
           (?h. !x. P x ==> (f(x) = h(g x)))``,
  ONCE_REWRITE_TAC[MESON[]
   ``(!x. P x ==> (f(x) = g(k x))) <=> (!y x. P x /\ (y = k x) ==> (f x = g y))``] THEN
  SIMP_TAC std_ss [GSYM SKOLEM_THM] THEN MESON_TAC[]);

val LIFT_TO_QUOTIENT_SPACE = store_thm ("LIFT_TO_QUOTIENT_SPACE",
 ``!f:real->real h:real->real s t u.
  (IMAGE f s = t) /\ (!v. v SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
       open_in (subtopology euclidean t) v)) /\
       h continuous_on s /\ (IMAGE h s = u) /\
      (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (h x = h y))
     ==> ?g. g continuous_on t /\ (IMAGE g t = u) /\
         !x. x IN s ==> (h(x) = g(f x))``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SIMP_TAC std_ss [FUNCTION_FACTORS_LEFT_GEN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN
  EXISTS_TAC ``g:real->real`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CONTINUOUS_ON_COMPOSE_QUOTIENT THEN MAP_EVERY EXISTS_TAC
   [``f:real->real``, ``s:real->bool``, ``u:real->bool``] THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
   CONTINUOUS_ON_EQ)) THEN ASM_SIMP_TAC std_ss [o_THM]);

val QUOTIENT_MAP_COMPOSE = store_thm ("QUOTIENT_MAP_COMPOSE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\
  (!v. v SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
      open_in (subtopology euclidean t) v)) /\
      (!v. v SUBSET u
      ==> (open_in (subtopology euclidean t) {x | x IN t /\ g x IN v} <=>
           open_in (subtopology euclidean u) v))
          ==> !v. v SUBSET u
            ==> (open_in (subtopology euclidean s)
                {x | x IN s /\ (g o f) x IN v} <=>
                 open_in (subtopology euclidean u) v)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [o_THM] THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (g:real->real) ((f:real->real) x) IN v} =
     {x | x IN s /\ f x IN {x | x IN t /\ g x IN v}}``
   SUBST1_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [SUBSET_RESTRICT]]);

val QUOTIENT_MAP_FROM_COMPOSITION = store_thm ("QUOTIENT_MAP_FROM_COMPOSITION",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
    (!v. v SUBSET u
    ==> (open_in (subtopology euclidean s)
         {x | x IN s /\ (g o f) x IN v} <=>
         open_in (subtopology euclidean u) v))
         ==> !v. v SUBSET u
           ==> (open_in (subtopology euclidean t)
                {x | x IN t /\ g x IN v} <=>
                open_in (subtopology euclidean u) v)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC ``v:real->bool``) THEN
   ASM_SIMP_TAC std_ss [o_THM] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
   SUBGOAL_THEN
    ``{x | x IN s /\ (g:real->real) ((f:real->real) x) IN v} =
      {x | x IN s /\ f x IN {x | x IN t /\ g x IN v}}``
     SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
   MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
   EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[],
   MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
   EXISTS_TAC ``u:real->bool`` THEN ASM_REWRITE_TAC[]]);

val QUOTIENT_MAP_FROM_SUBSET = store_thm ("QUOTIENT_MAP_FROM_SUBSET",
 ``!f:real->real s t u.
    f continuous_on t /\ IMAGE f t SUBSET u /\
    s SUBSET t /\ (IMAGE f s = u) /\
    (!v. v SUBSET u
    ==> (open_in (subtopology euclidean s)
         {x | x IN s /\ f x IN v} <=>
         open_in (subtopology euclidean u) v))
         ==> !v. v SUBSET u
           ==> (open_in (subtopology euclidean t)
               {x | x IN t /\ f x IN v} <=>
                open_in (subtopology euclidean u) v)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC QUOTIENT_MAP_FROM_COMPOSITION THEN
  MAP_EVERY EXISTS_TAC [``\x:real. x``, ``s:real->bool``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, IMAGE_ID, o_THM]);

val QUOTIENT_MAP_RESTRICT = store_thm ("QUOTIENT_MAP_RESTRICT",
 ``!f:real->real s t c.
    IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (open_in (subtopology euclidean t) c \/
      closed_in (subtopology euclidean t) c)
      ==> !u. u SUBSET c
        ==> (open_in (subtopology euclidean {x | x IN s /\ f x IN c})
             {x | x IN {x | x IN s /\ f x IN c} /\ f x IN u} <=>
             open_in (subtopology euclidean c) u)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(fn th => MP_TAC th THEN MP_TAC (MATCH_MP
   (REWRITE_RULE[IMP_CONJ_ALT] QUOTIENT_MAP_IMP_CONTINUOUS_OPEN) th)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) {x | x IN s /\ f x IN c} SUBSET c``
   ASSUME_TAC THENL [SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THENL
  [FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET),
   ASM_SIMP_TAC std_ss [QUOTIENT_MAP_OPEN_CLOSED] THEN
   FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET)] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `u:real->bool`) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  (KNOW_TAC ``(u:real->bool) SUBSET t`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []]) THEN
  (MATCH_MP_TAC EQ_IMPLIES THEN BINOP_TAC THENL
  [MATCH_MP_TAC(MESON[] ``(t = s) /\ (P s <=> Q s) ==> (P s <=> Q t)``) THEN
   CONJ_TAC THENL [ASM_SET_TAC[], SIMP_TAC std_ss [GSPECIFICATION]], ALL_TAC]) THEN
  (EQ_TAC THENL
  [MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_SUBSET_TRANS) ORELSE
   MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_SUBSET_TRANS),
   MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_TRANS) ORELSE
   MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_TRANS)]) THEN
  (MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN ORELSE
   MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN ORELSE ASM_SIMP_TAC std_ss []) THEN
  ASM_SET_TAC[]);

val CONNECTED_MONOTONE_QUOTIENT_PREIMAGE = store_thm ("CONNECTED_MONOTONE_QUOTIENT_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (!y. y IN t ==> connected {x | x IN s /\ (f x = y)}) /\
        connected t ==> connected s``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN UNDISCH_TAC ``connected(t:real->bool)`` THEN
  SIMP_TAC std_ss [CONNECTED_OPEN_IN] THEN
  MAP_EVERY EXISTS_TAC
  [``IMAGE (f:real->real) (s INTER u)``,
   ``IMAGE (f:real->real) (s INTER v)``] THEN
  ASM_REWRITE_TAC[IMAGE_EQ_EMPTY] THEN
  SUBGOAL_THEN
   ``IMAGE (f:real->real) (s INTER u) INTER IMAGE f (s INTER v) = {}``
   ASSUME_TAC THENL
  [REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
   X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
   KNOW_TAC ``y IN t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN REWRITE_TAC[connected]] THEN
  MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
  ASM_SET_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[CONJ_ASSOC] THEN
  CONJ_TAC THENL [CONJ_TAC, ASM_SET_TAC[]] THEN
  FIRST_X_ASSUM(fn th =>
   W(MP_TAC o PART_MATCH (rand o rand) th o snd)) THENL
  [KNOW_TAC ``IMAGE (f:real->real) (s INTER u) SUBSET t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN(SUBST1_TAC o SYM)],
   KNOW_TAC ``IMAGE (f:real->real) (s INTER v) SUBSET t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN(SUBST1_TAC o SYM)]] THEN
  MATCH_MP_TAC(MESON[]
   ``({x | x IN s /\ f x IN IMAGE f u} = u) /\ open_in top u
       ==> open_in top {x | x IN s /\ f x IN IMAGE f u}``) THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER] THEN ASM_SET_TAC[]);

val CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN = store_thm ("CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN",
 ``!f:real->real s t c.
   (IMAGE f s = t) /\ (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (!y. y IN t ==> connected {x | x IN s /\ (f x = y)}) /\
       (open_in (subtopology euclidean t) c \/
      closed_in (subtopology euclidean t) c) /\
      connected c ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MATCH_MP_TAC(ONCE_REWRITE_RULE[CONJ_EQ_IMP]
   (REWRITE_RULE[CONJ_ASSOC] CONNECTED_MONOTONE_QUOTIENT_PREIMAGE)) THEN
  SUBGOAL_THEN ``(c:real->bool) SUBSET t`` ASSUME_TAC THENL
  [ASM_MESON_TAC[OPEN_IN_IMP_SUBSET, CLOSED_IN_IMP_SUBSET], ALL_TAC] THEN
  EXISTS_TAC ``f:real->real`` THEN REPEAT CONJ_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
    QUOTIENT_MAP_IMP_CONTINUOUS_OPEN)) THEN
   ASM_REWRITE_TAC[SUBSET_REFL] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT],
  ASM_SET_TAC[],
  MATCH_MP_TAC QUOTIENT_MAP_RESTRICT THEN
  METIS_TAC[SUBSET_REFL],
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
  KNOW_TAC ``y IN t:real->bool`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN MATCH_MP_TAC EQ_IMPLIES] THEN
  AP_TERM_TAC THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* More properties of open and closed maps.                                  *)
(* ------------------------------------------------------------------------- *)

val CLOSED_MAP_CLOSURES = store_thm ("CLOSED_MAP_CLOSURES",
 ``!f:real->real.
  (!s. closed s ==> closed(IMAGE f s)) <=>
  (!s. closure(IMAGE f s) SUBSET IMAGE f (closure s))``,
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN
   ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, CLOSURE_SUBSET, IMAGE_SUBSET],
   REWRITE_TAC[GSYM CLOSURE_SUBSET_EQ] THEN ASM_MESON_TAC[CLOSURE_CLOSED]]);

val OPEN_MAP_INTERIORS = store_thm ("OPEN_MAP_INTERIORS",
 ``!f:real->real.
  (!s. open s ==> open(IMAGE f s)) <=>
  (!s. IMAGE f (interior s) SUBSET interior(IMAGE f s))``,
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [MATCH_MP_TAC INTERIOR_MAXIMAL THEN
  ASM_SIMP_TAC std_ss [OPEN_INTERIOR, INTERIOR_SUBSET, IMAGE_SUBSET],
  REWRITE_TAC[GSYM SUBSET_INTERIOR_EQ] THEN ASM_MESON_TAC[INTERIOR_OPEN]]);

val OPEN_MAP_RESTRICT = store_thm ("OPEN_MAP_RESTRICT",
 ``!f:real->real s t t'.
  (!u. open_in (subtopology euclidean s) u
  ==> open_in (subtopology euclidean t) (IMAGE f u)) /\
      t' SUBSET t
     ==> !u. open_in (subtopology euclidean {x | x IN s /\ f x IN t'}) u
         ==> open_in (subtopology euclidean t') (IMAGE f u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN
  REPEAT DISCH_TAC THEN X_GEN_TAC ``c:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val CLOSED_MAP_RESTRICT = store_thm ("CLOSED_MAP_RESTRICT",
 ``!f:real->real s t t'.
  (!u. closed_in (subtopology euclidean s) u
  ==> closed_in (subtopology euclidean t) (IMAGE f u)) /\
      t' SUBSET t
     ==> !u. closed_in (subtopology euclidean {x | x IN s /\ f x IN t'}) u
     ==> closed_in (subtopology euclidean t') (IMAGE f u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN
  REPEAT DISCH_TAC THEN X_GEN_TAC ``c:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_OPEN_MAP_EQ = store_thm ("QUOTIENT_MAP_OPEN_MAP_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t /\
  (!u. u SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
       open_in (subtopology euclidean t) u))
      ==> ((!k. open_in (subtopology euclidean s) k
            ==> open_in (subtopology euclidean t) (IMAGE f k)) <=>
               (!k. open_in (subtopology euclidean s) k
                ==> open_in (subtopology euclidean s)
                    {x | x IN s /\ f x IN IMAGE f k}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  UNDISCH_TAC ``!u. u SUBSET t ==>
        (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
         open_in (subtopology euclidean t) u)`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (f:real->real) k``) THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_CLOSED_MAP_EQ = store_thm ("QUOTIENT_MAP_CLOSED_MAP_EQ",
 ``!f:real->real s t.
   IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u))
       ==> ((!k. closed_in (subtopology euclidean s) k
         ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
            (!k. closed_in (subtopology euclidean s) k
           ==> closed_in (subtopology euclidean s)
               {x | x IN s /\ f x IN IMAGE f k}))``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_SIMP_TAC std_ss [QUOTIENT_MAP_OPEN_CLOSED] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  UNDISCH_TAC ``!u. u SUBSET t ==>
        (closed_in (subtopology euclidean s)
           {x | x IN s /\ f x IN u} <=>
         closed_in (subtopology euclidean t) u)`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (f:real->real) k``) THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val CLOSED_MAP_IMP_OPEN_MAP = store_thm ("CLOSED_MAP_IMP_OPEN_MAP",
 ``!f:real->real s t.
  (IMAGE f s = t) /\
  (!u. closed_in (subtopology euclidean s) u
  ==> closed_in (subtopology euclidean t) (IMAGE f u)) /\
      (!u. open_in (subtopology euclidean s) u
      ==> open_in (subtopology euclidean s)
          {x | x IN s /\ f x IN IMAGE f u})
          ==> (!u. open_in (subtopology euclidean s) u
            ==> open_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``IMAGE (f:real->real) u =
   t DIFF IMAGE f (s DIFF {x | x IN s /\ f x IN IMAGE f u})``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_REFL]]);

val OPEN_MAP_IMP_CLOSED_MAP = store_thm ("OPEN_MAP_IMP_CLOSED_MAP",
 ``!f:real->real s t.
   (IMAGE f s = t) /\
   (!u. open_in (subtopology euclidean s) u
   ==> open_in (subtopology euclidean t) (IMAGE f u)) /\
      (!u. closed_in (subtopology euclidean s) u
      ==> closed_in (subtopology euclidean s)
          {x | x IN s /\ f x IN IMAGE f u})
          ==> (!u. closed_in (subtopology euclidean s) u
            ==> closed_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
  ``IMAGE (f:real->real) u =
    t DIFF IMAGE f (s DIFF {x | x IN s /\ f x IN IMAGE f u})``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_REFL]]);

val OPEN_MAP_FROM_COMPOSITION_SURJECTIVE = store_thm ("OPEN_MAP_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
   f continuous_on s /\ (IMAGE f s = t) /\ IMAGE g t SUBSET u /\
  (!k. open_in (subtopology euclidean s) k
  ==> open_in (subtopology euclidean u) (IMAGE (g o f) k))
    ==> (!k. open_in (subtopology euclidean t) k
      ==> open_in (subtopology euclidean u) (IMAGE g k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE g k = IMAGE ((g:real->real) o (f:real->real))
     {x | x IN s /\ f(x) IN k}`` SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
   REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[SUBSET_REFL]]);

val CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE = store_thm ("CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ (IMAGE f s = t) /\ IMAGE g t SUBSET u /\
  (!k. closed_in (subtopology euclidean s) k
   ==> closed_in (subtopology euclidean u) (IMAGE (g o f) k))
     ==> (!k. closed_in (subtopology euclidean t) k
       ==> closed_in (subtopology euclidean u) (IMAGE g k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE g k = IMAGE ((g:real->real) o (f:real->real))
    {x | x IN s /\ f(x) IN k}`` SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[SUBSET_REFL]]);

val OPEN_MAP_FROM_COMPOSITION_INJECTIVE = store_thm ("OPEN_MAP_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
  g continuous_on t /\ (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
  (!k. open_in (subtopology euclidean s) k
   ==> open_in (subtopology euclidean u) (IMAGE (g o f) k))
     ==> (!k. open_in (subtopology euclidean s) k
       ==> open_in (subtopology euclidean t) (IMAGE f k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
  ``IMAGE f k = {x | x IN t /\
     g(x) IN IMAGE ((g:real->real) o (f:real->real)) k}``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``u:real->bool`` THEN ASM_SIMP_TAC std_ss []]);

val CLOSED_MAP_FROM_COMPOSITION_INJECTIVE = store_thm ("CLOSED_MAP_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
  g continuous_on t /\ (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
  (!k. closed_in (subtopology euclidean s) k
  ==> closed_in (subtopology euclidean u) (IMAGE (g o f) k))
    ==> (!k. closed_in (subtopology euclidean s) k
      ==> closed_in (subtopology euclidean t) (IMAGE f k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE f k = {x | x IN t /\
     g(x) IN IMAGE ((g:real->real) o (f:real->real)) k}``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``u:real->bool`` THEN ASM_SIMP_TAC std_ss []]);

val OPEN_MAP_CLOSED_SUPERSET_PREIMAGE = store_thm ("OPEN_MAP_CLOSED_SUPERSET_PREIMAGE",
 ``!f:real->real s t u w.
  (!k. open_in (subtopology euclidean s) k
   ==> open_in (subtopology euclidean t) (IMAGE f k)) /\
     closed_in (subtopology euclidean s) u /\
     w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
     ==> ?v. closed_in (subtopology euclidean t) v /\
          w SUBSET v /\
         {x | x IN s /\ f(x) IN v} SUBSET u``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``t DIFF IMAGE (f:real->real) (s DIFF u)`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL]);

val OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ = store_thm ("OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
    ==> ((!k. open_in (subtopology euclidean s) k
      ==> open_in (subtopology euclidean t) (IMAGE f k)) <=>
        (!u w. closed_in (subtopology euclidean s) u /\
        w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
        ==> ?v. closed_in (subtopology euclidean t) v /\
            w SUBSET v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN
  ASM_SIMP_TAC std_ss [OPEN_MAP_CLOSED_SUPERSET_PREIMAGE] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
  [``s DIFF k:real->bool``, ``t DIFF IMAGE (f:real->real) k``]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
  KNOW_TAC ``t DIFF IMAGE (f:real->real) k SUBSET t /\
     {x | x IN s /\ f x IN t DIFF IMAGE (f:real->real) k} SUBSET s DIFF k`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) k = t DIFF v`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL]]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE",
 ``!f:real->real s t u w.
  (!k. closed_in (subtopology euclidean s) k
   ==> closed_in (subtopology euclidean t) (IMAGE f k)) /\
         open_in (subtopology euclidean s) u /\
        w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
       ==> ?v. open_in (subtopology euclidean t) v /\
          w SUBSET v /\
         {x | x IN s /\ f(x) IN v} SUBSET u``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``t DIFF IMAGE (f:real->real) (s DIFF u)`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. closed_in (subtopology euclidean s) k
    ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
       (!u w. open_in (subtopology euclidean s) u /\
       w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
       ==> ?v. open_in (subtopology euclidean t) v /\
           w SUBSET v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN
  ASM_SIMP_TAC std_ss [CLOSED_MAP_OPEN_SUPERSET_PREIMAGE] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
  [``s DIFF k:real->bool``, ``t DIFF IMAGE (f:real->real) k``]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
  KNOW_TAC ``t DIFF IMAGE (f:real->real) k SUBSET t /\
     {x | x IN s /\ f x IN t DIFF IMAGE (f:real->real) k} SUBSET s DIFF k`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) k = t DIFF v`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL]]);

val BIGUNION_GSPEC = store_thm ("BIGUNION_GSPEC",
 ``(!P f. BIGUNION {f x | P x} = {a | ?x. P x /\ a IN (f x)}) /\
   (!P f. BIGUNION {f x y | P x y} = {a | ?x y. P x y /\ a IN (f x y)}) /\
   (!P f. BIGUNION {f x y z | P x y z} =
            {a | ?x y z. P x y z /\ a IN (f x y z)})``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  SIMP_TAC std_ss [IN_BIGUNION, GSPECIFICATION, EXISTS_PROD] THEN MESON_TAC[]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. closed_in (subtopology euclidean s) k
    ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
   (!u y. open_in (subtopology euclidean s) u /\
     y IN t /\ {x | x IN s /\ (f(x) = y)} SUBSET u
  ==> ?v. open_in (subtopology euclidean t) v /\
     y IN v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ] THEN
  EQ_TAC THEN DISCH_TAC THENL
  [MAP_EVERY X_GEN_TAC [``u:real->bool``, ``y:real``] THEN
  STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``u:real->bool``, ``{y:real}``]) THEN
  ASM_REWRITE_TAC[SING_SUBSET, IN_SING],
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``w:real->bool``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  KNOW_TAC ``(!y. ?v. open_in (subtopology euclidean s) u /\
          y IN t /\ {x | x IN s /\ (f x = y)} SUBSET u
          ==> open_in (subtopology euclidean t) v /\
              y IN v /\ {x | x IN s /\ f x IN v} SUBSET u)
     ==> (?v. open_in (subtopology euclidean t) v /\
          w SUBSET v /\ {x | x IN s /\ f x IN v} SUBSET u)`` THENL
  [ALL_TAC, METIS_TAC [GSYM RIGHT_EXISTS_IMP_THM]] THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``vv:real->real->bool`` THEN DISCH_TAC THEN
  EXISTS_TAC ``BIGUNION {(vv:real->real->bool) y | y IN w}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC OPEN_IN_BIGUNION THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [BIGUNION_GSPEC] THEN
   CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, GSYM RIGHT_EXISTS_AND_THM,
    LEFT_IMP_EXISTS_THM] THEN
   MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_SET_TAC[]]]);

val CONNECTED_OPEN_MONOTONE_PREIMAGE = store_thm ("CONNECTED_OPEN_MONOTONE_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
  (!c. open_in (subtopology euclidean s) c
   ==> open_in (subtopology euclidean t) (IMAGE f c)) /\
      (!y. y IN t ==> connected {x | x IN s /\ (f x = y)})
       ==> !c. connected c /\ c SUBSET t
         ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``c:real->bool`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] OPEN_MAP_RESTRICT)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN MP_TAC(ISPECL
   [``f:real->real``, ``{x | x IN s /\ (f:real->real) x IN c}``]
   OPEN_MAP_IMP_QUOTIENT_MAP) THEN
  SUBGOAL_THEN ``IMAGE f {x | x IN s /\ (f:real->real) x IN c} = c``
   ASSUME_TAC THENL [ASM_SET_TAC[], ASM_REWRITE_TAC[]] THEN
  KNOW_TAC ``(f:real->real) continuous_on {x | x IN s /\ f x IN c}`` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
   CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  MATCH_MP_TAC CONNECTED_MONOTONE_QUOTIENT_PREIMAGE THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``c:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [SET_RULE
   ``y IN c ==> ({x | x IN {x | x IN s /\ f x IN c} /\ (f x = y)} =
                 {x | x IN s /\ (f x = y)})``] THEN
  ASM_SET_TAC[]);

val CONNECTED_CLOSED_MONOTONE_PREIMAGE = store_thm ("CONNECTED_CLOSED_MONOTONE_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
   (!c. closed_in (subtopology euclidean s) c
   ==> closed_in (subtopology euclidean t) (IMAGE f c)) /\
      (!y. y IN t ==> connected {x | x IN s /\ (f x = y)})
      ==> !c. connected c /\ c SUBSET t
        ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``c:real->bool`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] CLOSED_MAP_RESTRICT)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN MP_TAC(ISPECL
   [``f:real->real``, ``{x | x IN s /\ (f:real->real) x IN c}``]
    CLOSED_MAP_IMP_QUOTIENT_MAP) THEN
  SUBGOAL_THEN ``IMAGE f {x | x IN s /\ (f:real->real) x IN c} = c``
   ASSUME_TAC THENL [ASM_SET_TAC[], ASM_REWRITE_TAC[]] THEN
  KNOW_TAC ``(f:real->real) continuous_on {x | x IN s /\ f x IN c}`` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
   CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  MATCH_MP_TAC CONNECTED_MONOTONE_QUOTIENT_PREIMAGE THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``c:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [SET_RULE
   ``y IN c ==> ({x | x IN {x | x IN s /\ f x IN c} /\ (f x = y)} =
                 {x | x IN s /\ (f x = y)})``] THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Proper maps, including projections out of compact sets.                   *)
(* ------------------------------------------------------------------------- *)

val PROPER_MAP = store_thm ("PROPER_MAP",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}) <=>
       (!k. closed_in (subtopology euclidean s) k
        ==> closed_in (subtopology euclidean t) (IMAGE f k)) /\
            (!a. a IN t ==> compact {x | x IN s /\ (f x = a)}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [REPEAT STRIP_TAC THENL
   [ALL_TAC,
    ONCE_REWRITE_TAC[SET_RULE ``(x = a) <=> x IN {a}``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    ASM_REWRITE_TAC[SING_SUBSET, COMPACT_SING]] THEN
   FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
   REWRITE_TAC[CLOSED_IN_LIMPT] THEN
   CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``y:real``] THEN
   REWRITE_TAC[LIMPT_SEQUENTIAL_INJ, IN_DELETE] THEN
   SIMP_TAC std_ss [IN_IMAGE, GSYM LEFT_EXISTS_AND_THM, SKOLEM_THM] THEN
   KNOW_TAC ``(?(x :num -> real) (f' :num -> real).
   ((!(n :num).
       ((f' n = (f :real -> real) (x n)) /\
        x n IN (k :real -> bool)) /\ f' n <> (y :real)) /\
    (!(m :num) (n :num). (f' m = f' n) <=> (m = n)) /\
    ((f' --> y) sequentially :bool)) /\ y IN (t :real -> bool)) ==>
     ?(x :real). (y = f x) /\ x IN k`` THENL
   [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
   SIMP_TAC std_ss [GSYM CONJ_ASSOC, FORALL_AND_THM] THEN
   SIMP_TAC std_ss [GSYM FUN_EQ_THM] THEN
   SIMP_TAC std_ss [UNWIND_THM2, FUN_EQ_THM] THEN
   DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
   SUBGOAL_THEN
   ``~(BIGINTER {{a | a IN k /\ (f:real->real) a IN
      (y INSERT IMAGE (\i. f(x(n + i))) univ(:num))} | n IN univ(:num)} = {})``
   MP_TAC THENL
   [MATCH_MP_TAC COMPACT_FIP THEN CONJ_TAC THENL
    [SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV] THEN X_GEN_TAC ``n:num`` THEN
     UNDISCH_TAC ``closed_in (subtopology euclidean s) k`` THEN DISCH_TAC THEN
     FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CLOSED_IN_CLOSED]) THEN
     DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
     ONCE_REWRITE_TAC [METIS [] ``f a IN s <=> (\a. f a IN s) a``] THEN
     ASM_REWRITE_TAC[SET_RULE
     ``{x | x IN s INTER k /\ P x} = k INTER {x | x IN s /\ P x}``] THEN
     MATCH_MP_TAC CLOSED_INTER_COMPACT THEN ASM_REWRITE_TAC[] THEN
     BETA_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
     CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
     MATCH_MP_TAC COMPACT_SEQUENCE_WITH_LIMIT THEN
     UNDISCH_TAC ``((\n. f ((x:num->real) n)) --> y) sequentially`` THEN DISCH_TAC THEN
     FIRST_ASSUM(MP_TAC o SPEC ``n:num`` o MATCH_MP SEQ_OFFSET) THEN
     BETA_TAC THEN GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [ADD_SYM] THEN
     SIMP_TAC std_ss [],
     SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_FINITE_SUBSET_IMAGE] THEN
     X_GEN_TAC ``i:num->bool`` THEN STRIP_TAC THEN
     UNDISCH_TAC ``FINITE (i:num->bool)`` THEN DISCH_TAC THEN
     FIRST_ASSUM(MP_TAC o ISPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
     SIMP_TAC std_ss [] THEN DISCH_THEN(X_CHOOSE_TAC ``m:num``) THEN
     SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, BIGINTER_IMAGE, GSPECIFICATION] THEN
     EXISTS_TAC ``(x:num->real) m`` THEN
     X_GEN_TAC ``p:num`` THEN DISCH_TAC THEN
     CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
     REWRITE_TAC[IN_INSERT, IN_IMAGE, IN_UNIV] THEN DISJ2_TAC THEN
     EXISTS_TAC ``m - p:num`` THEN BETA_TAC THEN
     UNDISCH_TAC ``!x:num. x IN i ==> x <= m`` THEN DISCH_THEN (MP_TAC o SPEC ``p:num``) THEN
     ASM_REWRITE_TAC [] THEN ARITH_TAC],
     REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
     DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
     POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION, IN_UNIV] THEN
     DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``0:num``) THEN
     SIMP_TAC std_ss [ADD_CLAUSES, IN_INSERT, IN_IMAGE, IN_UNIV] THEN
     DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (DISJ_CASES_THEN MP_TAC)) THEN
     ASM_SIMP_TAC std_ss [] THEN DISCH_THEN(X_CHOOSE_TAC ``i:num``) THEN
     FIRST_X_ASSUM (MP_TAC o SPEC ``i + 1:num``) THEN
     ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
     ASM_SIMP_TAC std_ss [IN_INSERT, IN_IMAGE, IN_UNIV] THEN ARITH_TAC],
   STRIP_TAC THEN X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
   REWRITE_TAC[COMPACT_EQ_HEINE_BOREL] THEN
   X_GEN_TAC ``c:(real->bool)->bool`` THEN STRIP_TAC THEN
   SUBGOAL_THEN
   ``!a. a IN k
   ==> ?g. g SUBSET c /\ FINITE g /\
    {x | x IN s /\ ((f:real->real) x = a)} SUBSET BIGUNION g``
   MP_TAC THENL
   [X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN UNDISCH_THEN
    ``!a. a IN t ==> compact {x | x IN s /\ ((f:real->real) x = a)}``
    (MP_TAC o SPEC ``a:real``) THEN
    KNOW_TAC ``(a :real) IN (t :real -> bool)`` THENL
    [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN REWRITE_TAC[COMPACT_EQ_HEINE_BOREL]] THEN
     DISCH_THEN MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
   DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
   X_GEN_TAC ``uu:real->(real->bool)->bool`` THEN DISCH_TAC] THEN
  SUBGOAL_THEN
  ``!a. a IN k ==> ?v. open v /\ a IN v /\
   {x | x IN s /\ (f:real->real) x IN v} SUBSET BIGUNION(uu a)``
   MP_TAC THENL
  [REPEAT STRIP_TAC THEN
   UNDISCH_THEN
   ``!k. closed_in (subtopology euclidean s) k
     ==> closed_in (subtopology euclidean t) (IMAGE (f:real->real) k)``
    (MP_TAC o SPEC ``(s:real->bool) DIFF BIGUNION(uu(a:real))``) THEN
   SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
   KNOW_TAC ``(s :real -> bool) DIFF
    BIGUNION ((uu :real -> (real -> bool) -> bool) (a :real)) SUBSET s /\
     open_in (subtopology euclidean s) (s DIFF (s DIFF BIGUNION (uu a)))`` THENL
   [CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[SET_RULE ``s DIFF (s DIFF t) = s INTER t``] THEN
    MATCH_MP_TAC OPEN_IN_OPEN_INTER THEN
    MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``v:real->bool``) THEN
    EXISTS_TAC ``v:real->bool`` THEN POP_ASSUM MP_TAC THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``)) THEN
    ASM_REWRITE_TAC[] THEN
    KNOW_TAC ``a IN t:real->bool`` THENL [ASM_SET_TAC[],
     DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    STRIP_TAC THEN ASM_SET_TAC[]],
   DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
   X_GEN_TAC ``vv:real->(real->bool)`` THEN DISCH_TAC] THEN
  UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (vv:real->(real->bool)) k``) THEN
  KNOW_TAC ``(!(t :real -> bool).
    t IN IMAGE (vv :real -> real -> bool) (k :real -> bool) ==>
    (open t :bool)) /\ k SUBSET BIGUNION (IMAGE vv k)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r ==> s <=> q /\ p ==> r ==> s`] THEN
  SIMP_TAC real_ss [FORALL_FINITE_SUBSET_IMAGE] THEN
  X_GEN_TAC ``j:real->bool`` THEN REPEAT STRIP_TAC THEN
  EXISTS_TAC ``BIGUNION (IMAGE (uu:real->(real->bool)->bool) j)`` THEN
  REPEAT CONJ_TAC THENL
  [ASM_SET_TAC[],
   ASM_SIMP_TAC std_ss [FINITE_BIGUNION_EQ, FORALL_IN_IMAGE, IMAGE_FINITE] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [BIGUNION_IMAGE, SUBSET_DEF, IN_BIGUNION, GSPECIFICATION] THEN
   ASM_SET_TAC[]]]);

val COMPACT_CONTINUOUS_IMAGE_EQ = store_thm ("COMPACT_CONTINUOUS_IMAGE_EQ",
 ``!f:real->real s.
   (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
   ==> (f continuous_on s <=>
   !t. compact t /\ t SUBSET s ==> compact(IMAGE f t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [MESON_TAC[COMPACT_CONTINUOUS_IMAGE, CONTINUOUS_ON_SUBSET], DISCH_TAC] THEN
   FIRST_X_ASSUM(X_CHOOSE_TAC ``g:real->real`` o
   SIMP_RULE std_ss [INJECTIVE_ON_LEFT_INVERSE]) THEN
   REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN
   X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
   MP_TAC(ISPECL [``g:real->real``, ``IMAGE (f:real->real) s``,
    ``s:real->bool``] PROPER_MAP) THEN
  KNOW_TAC ``IMAGE (g :real -> real)
   (IMAGE (f :real -> real) (s :real -> bool)) SUBSET s`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC] THEN
  MATCH_MP_TAC(TAUT `(q ==> s) /\ p ==> (p <=> q /\ r) ==> s`) THEN
  REPEAT STRIP_TAC THENL
  [SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN u} = IMAGE g u``
   (fn th => ASM_MESON_TAC[th]),
   SUBGOAL_THEN
   ``{x | x IN IMAGE f s /\ (g:real->real) x IN k} = IMAGE f k``
   (fn th => ASM_SIMP_TAC std_ss [th])] THEN
  UNDISCH_TAC `` closed_in
        (subtopology euclidean
           (IMAGE (f :real -> real) (s :real -> bool)))
        (u :real -> bool)`` THEN DISCH_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN ASM_SET_TAC[]);

val PROPER_MAP_FROM_COMPACT = store_thm ("PROPER_MAP_FROM_COMPACT",
 ``!f:real->real s k.
   f continuous_on s /\ IMAGE f s SUBSET t /\ compact s /\
   closed_in (subtopology euclidean t) k
   ==> compact {x | x IN s /\ f x IN k}``,
   REPEAT STRIP_TAC THEN
   MATCH_MP_TAC CLOSED_IN_COMPACT THEN EXISTS_TAC ``s:real->bool`` THEN
   METIS_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_GEN]);

val PROPER_MAP_COMPOSE = store_thm ("PROPER_MAP_COMPOSE",
 ``!f:real->real g:real->real s t u.
   IMAGE f s SUBSET t /\
   (!k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}) /\
   (!k. k SUBSET u /\ compact k ==> compact {x | x IN t /\ g x IN k})
   ==> !k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k}``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[o_THM] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{x | x IN t /\ (g:real->real) x IN k}``) THEN
  KNOW_TAC ``{x | x IN (t :real -> bool) /\
   (g :real -> real) x IN (k :real -> bool)} SUBSET t /\
    compact {x | x IN t /\ g x IN k}`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC THEN MATCH_MP_TAC EQ_IMPLIES] THEN
  AP_TERM_TAC THEN ASM_SET_TAC[]);

val PROPER_MAP_FROM_COMPOSITION_LEFT = store_thm ("PROPER_MAP_FROM_COMPOSITION_LEFT",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ (IMAGE f s = t) /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
    (!k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k})
   ==> !k. k SUBSET u /\ compact k ==> compact {x | x IN t /\ g x IN k}``,
  REWRITE_TAC[o_THM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o ISPEC ``f:real->real`` o MATCH_MP
  (REWRITE_RULE[IMP_CONJ_ALT] COMPACT_CONTINUOUS_IMAGE)) THEN
  KNOW_TAC ``(f :real -> real) continuous_on
   {x | x IN (s :real -> bool) /\
   (g :real -> real) (f x) IN (k :real -> bool)} `` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
  CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val lemma = prove (
 ``!s t. closed_in (subtopology euclidean s) t ==> compact s ==> compact t``,
  MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_SUBSET, CLOSED_IN_CLOSED_EQ]);

val PROPER_MAP_FROM_COMPOSITION_RIGHT = store_thm ("PROPER_MAP_FROM_COMPOSITION_RIGHT",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
   (!k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k})
   ==> !k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}``,
  REWRITE_TAC[o_THM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (g:real->real) k``) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (k :real -> bool) SUBSET (u :real -> bool) /\
   compact (IMAGE g k)`` THENL
  [CONJ_TAC THENL [ASM_SET_TAC[], MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE] THEN
   ASM_MESON_TAC[CONTINUOUS_ON_SUBSET],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   MATCH_MP_TAC lemma THEN
   MATCH_MP_TAC CLOSED_IN_SUBSET_TRANS THEN
   EXISTS_TAC ``s:real->bool`` THEN
   CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CLOSED_SUBSET THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED]]);

(* ------------------------------------------------------------------------- *)
(* Pasting functions together on open sets.                                  *)
(* ------------------------------------------------------------------------- *)

val PASTING_LEMMA = store_thm ("PASTING_LEMMA",
 ``!f:'a->real->real g t s k.
        (!i. i IN k
             ==> open_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x)) /\
        (!x. x IN s ==> ?j. j IN k /\ x IN t j /\ (g x = f j x))
        ==> g continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_OPEN_IN_PREIMAGE_EQ] THEN
  STRIP_TAC THEN X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ g x IN u} =
     BIGUNION {{x | x IN (t i) /\ ((f:'a->real->real) i x) IN u} |
            i IN k}``
  SUBST1_TAC THENL
   [SUBGOAL_THEN ``!i. i IN k ==> ((t:'a->real->bool) i) SUBSET s``
    ASSUME_TAC THENL
     [ASM_MESON_TAC[OPEN_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
      SIMP_TAC std_ss [BIGUNION_GSPEC] THEN ASM_SET_TAC[]],
    MATCH_MP_TAC OPEN_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
    METIS_TAC[OPEN_IN_TRANS]]);

val PASTING_LEMMA_EXISTS = store_thm ("PASTING_LEMMA_EXISTS",
 ``!f:'a->real->real t s k.
        s SUBSET BIGUNION {t i | i IN k} /\
        (!i. i IN k
             ==> open_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x))
        ==> ?g. g continuous_on s /\
                (!x i. i IN k /\ x IN s INTER t i ==> (g x = f i x))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\x. (f:'a->real->real)(@i. i IN k /\ x IN t i) x`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN MATCH_MP_TAC PASTING_LEMMA THEN
  MAP_EVERY EXISTS_TAC
   [``f:'a->real->real``, ``t:'a->real->bool``, ``k:'a->bool``] THEN
  ASM_SET_TAC[]);

val CONTINUOUS_ON_UNION_LOCAL_OPEN = store_thm ("CONTINUOUS_ON_UNION_LOCAL_OPEN",
 ``!f:real->real s.
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ f continuous_on t
        ==> f continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``(\i:(real->bool). (f:real->real))``, ``f:real->real``,
    ``(\i:(real->bool). i)``, ``s UNION (t:real->bool)``, ``{s:real->bool;t}``]
   PASTING_LEMMA) THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_INSERT, EXISTS_IN_INSERT, NOT_IN_EMPTY] THEN
  REWRITE_TAC[IN_UNION]);

val CONTINUOUS_ON_UNION_OPEN = store_thm ("CONTINUOUS_ON_UNION_OPEN",
 ``!f s t. open s /\ open t /\ f continuous_on s /\ f continuous_on t
           ==> f continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL_OPEN THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION] THEN SET_TAC[]);

val CONTINUOUS_ON_CASES_LOCAL_OPEN = store_thm ("CONTINUOUS_ON_CASES_LOCAL_OPEN",
 ``!P f g:real->real s t.
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL_OPEN THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  ASM_SIMP_TAC std_ss [] THEN METIS_TAC[]);

val CONTINUOUS_ON_CASES_OPEN = store_thm ("CONTINUOUS_ON_CASES_OPEN",
 ``!P f g s t.
           open s /\
           open t /\
           f continuous_on s /\
           g continuous_on t /\
           (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
           ==> (\x. if P x then f x else g x) continuous_on s UNION t``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL_OPEN THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Likewise on closed sets, with a finiteness assumption.                    *)
(* ------------------------------------------------------------------------- *)

val PASTING_LEMMA_CLOSED = store_thm ("PASTING_LEMMA_CLOSED",
 ``!f:'a->real->real g t s k.
        FINITE k /\
        (!i. i IN k
             ==> closed_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x)) /\
        (!x. x IN s ==> ?j. j IN k /\ x IN t j /\ (g x = f j x))
        ==> g continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
  STRIP_TAC THEN X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ g x IN u} =
     BIGUNION {{x | x IN (t i) /\ ((f:'a->real->real) i x) IN u} |
            i IN k}``
  SUBST1_TAC THENL
   [SUBGOAL_THEN ``!i. i IN k ==> ((t:'a->real->bool) i) SUBSET s``
    ASSUME_TAC THENL
     [ASM_MESON_TAC[CLOSED_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
      SIMP_TAC std_ss [BIGUNION_GSPEC] THEN ASM_SET_TAC[]],
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN
    ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, IMAGE_FINITE, FORALL_IN_IMAGE] THEN
    METIS_TAC[CLOSED_IN_TRANS]]);

val PASTING_LEMMA_EXISTS_CLOSED = store_thm ("PASTING_LEMMA_EXISTS_CLOSED",
 ``!f:'a->real->real t s k.
        FINITE k /\
        s SUBSET BIGUNION {t i | i IN k} /\
        (!i. i IN k
             ==> closed_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x))
        ==> ?g. g continuous_on s /\
                (!x i. i IN k /\ x IN s INTER t i ==> (g x = f i x))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\x. (f:'a->real->real)(@i. i IN k /\ x IN t i) x`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC PASTING_LEMMA_CLOSED THEN
  MAP_EVERY EXISTS_TAC
   [``f:'a->real->real``, ``t:'a->real->bool``, ``k:'a->bool``] THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Closure of halflines, halfspaces and hyperplanes.                         *)
(* ------------------------------------------------------------------------- *)

val LIM_LIFT_DOT = store_thm ("LIM_LIFT_DOT",
 ``!f:real->real a.
        (f --> l) net ==> ((\y. a * f(y)) --> (a * l)) net``,
  METIS_TAC [LIM_CMUL]);

val CONTINUOUS_AT_LIFT_DOT = store_thm ("CONTINUOUS_AT_LIFT_DOT",
 ``!a:real x. (\y. a * y) continuous at x``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [CONTINUOUS_AT, o_THM] THEN
  KNOW_TAC ``((\y. a * (\y. y) y:real) --> (a * x)) (at x)`` THENL
  [ALL_TAC, SIMP_TAC std_ss []] THEN
  MATCH_MP_TAC LIM_LIFT_DOT THEN REWRITE_TAC[LIM_AT] THEN METIS_TAC[]);

val CONTINUOUS_ON_LIFT_DOT = store_thm ("CONTINUOUS_ON_LIFT_DOT",
 ``!s. (\y. a * y) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_AT_IMP_CONTINUOUS_ON, CONTINUOUS_AT_LIFT_DOT]);

val CLOSED_INTERVAL_LEFT = store_thm ("CLOSED_INTERVAL_LEFT",
 ``!b:real.
     closed {x:real | x <= b}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(x:real) - (b:real)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val CLOSED_INTERVAL_RIGHT = store_thm ("CLOSED_INTERVAL_RIGHT",
 ``!a:real.
     closed {x:real | a <= x}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) - (x:real)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val CLOSED_HALFSPACE_LE = store_thm ("CLOSED_HALFSPACE_LE",
 ``!a:real b. closed {x | a * x <= b}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPEC ``univ(:real)`` CONTINUOUS_ON_LIFT_DOT) THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_CLOSED, GSYM CLOSED_IN, SUBTOPOLOGY_UNIV] THEN
  DISCH_THEN(MP_TAC o SPEC
   ``IMAGE (\x. x) {r | ?x:real. (a * x = r) /\ r <= b}``) THEN
   KNOW_TAC ``closed_in (subtopology euclidean (IMAGE (\y. a * y) univ(:real)))
             (IMAGE (\x. x) {r | ?x. (a * x = r) /\ r <= b})`` THENL
   [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
    SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE, IN_UNIV] THEN
    METIS_TAC []] THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``{x | (x:real) <= (b)}`` THEN
  SIMP_TAC std_ss [CLOSED_INTERVAL_LEFT] THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_UNIV, GSPECIFICATION, IN_INTER] THEN
  METIS_TAC []);

val CLOSED_HALFSPACE_GE = store_thm ("CLOSED_HALFSPACE_GE",
 ``!a:real b. closed {x | a * x >= b}``,
  REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``] THEN
  REWRITE_TAC[GSYM REAL_MUL_LNEG, CLOSED_HALFSPACE_LE]);

val CLOSED_HYPERPLANE = store_thm ("CLOSED_HYPERPLANE",
 ``!a b. closed {x | a * x = b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
  REWRITE_TAC[REAL_ARITH ``b <= a * x <=> a * x >= b:real``] THEN
  REWRITE_TAC[SET_RULE `` {x | a * x <= b /\ a * x >= b} =
                          {x | a * x <= b} INTER  {x | a * x >= b}``] THEN
  SIMP_TAC std_ss [CLOSED_INTER, CLOSED_HALFSPACE_LE, CLOSED_HALFSPACE_GE]);

val CLOSURE_HYPERPLANE = store_thm ("CLOSURE_HYPERPLANE",
 ``!a b. closure {x | a * x = b} = {x | a * x = b}``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_HYPERPLANE]);

val CLOSED_STANDARD_HYPERPLANE = store_thm ("CLOSED_STANDARD_HYPERPLANE",
 ``!a. closed {x:real | x = a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HYPERPLANE) THEN
  REAL_ARITH_TAC);

val CLOSED_HALFSPACE_COMPONENT_LE = store_thm ("CLOSED_HALFSPACE_COMPONENT_LE",
 ``!a. closed {x:real | x <= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HALFSPACE_LE) THEN
  REAL_ARITH_TAC);

val CLOSED_HALFSPACE_COMPONENT_GE = store_thm ("CLOSED_HALFSPACE_COMPONENT_GE",
 ``!a. closed {x:real | x >= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HALFSPACE_GE) THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Openness of halfspaces.                                                   *)
(* ------------------------------------------------------------------------- *)

val OPEN_HALFSPACE_LT = store_thm ("OPEN_HALFSPACE_LT",
 ``!a b. open {x | a * x < b}``,
  REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | ~p x} = UNIV DIFF {x | p x}``] THEN
  REWRITE_TAC[GSYM closed_def, GSYM real_ge, CLOSED_HALFSPACE_GE]);

val OPEN_HALFSPACE_COMPONENT_LT = store_thm ("OPEN_HALFSPACE_COMPONENT_LT",
 ``!a. open {x:real | x < a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] OPEN_HALFSPACE_LT) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

val OPEN_HALFSPACE_GT = store_thm ("OPEN_HALFSPACE_GT",
 ``!a b. open {x | a * x > b}``,
  REWRITE_TAC[REAL_ARITH ``x > y <=> ~(x <= y:real)``] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | ~p x} = UNIV DIFF {x | p x}``] THEN
  REWRITE_TAC[GSYM closed_def, CLOSED_HALFSPACE_LE]);

val OPEN_HALFSPACE_COMPONENT_GT = store_thm ("OPEN_HALFSPACE_COMPONENT_GT",
 ``!a. open {x:real | x > a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] OPEN_HALFSPACE_GT) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

val OPEN_POSITIVE_MULTIPLES = store_thm ("OPEN_POSITIVE_MULTIPLES",
 ``!s:real->bool. open s ==> open {c * x | &0 < c /\ x IN s}``,
  SIMP_TAC std_ss [open_def, FORALL_IN_GSPEC] THEN GEN_TAC THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``c:real``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``c * e:real`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``inv(c) * y:real``) THEN
  KNOW_TAC ``(dist (inv (c :real) * (y :real),(x :real)) :real) < (e :real)`` THENL
   [SUBGOAL_THEN ``x:real = inv c * c * x`` SUBST1_TAC THENL
     [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID,
                   REAL_LT_IMP_NE],
          ONCE_REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
      ASM_SIMP_TAC std_ss [DIST_MUL, abs, REAL_LT_INV_EQ, REAL_LT_IMP_LE] THEN
      ONCE_REWRITE_TAC[METIS [REAL_MUL_SYM, GSYM real_div] ``inv c * x:real = x / c:real``] THEN
      METIS_TAC[REAL_LT_LDIV_EQ, REAL_MUL_SYM]],
        DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN SRW_TAC [][] THEN
    EXISTS_TAC ``c:real`` THEN EXISTS_TAC ``inv(c) * y:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_LT_IMP_NE] THEN
    REAL_ARITH_TAC]);

val OPEN_INTERVAL_LEFT = store_thm ("OPEN_INTERVAL_LEFT",
 ``!b:real. open {x:real | x < b}``,
    REWRITE_TAC[OPEN_HALFSPACE_COMPONENT_LT]);

val OPEN_INTERVAL_RIGHT = store_thm ("OPEN_INTERVAL_RIGHT",
 ``!a:real. open {x:real | a < x}``,
    REWRITE_TAC[GSYM real_gt, OPEN_HALFSPACE_COMPONENT_GT]);

val OPEN_POSITIVE_ORTHANT = store_thm ("OPEN_POSITIVE_ORTHANT",
 ``open {x:real | &0 < x}``,
  MP_TAC(ISPEC ``0:real`` OPEN_INTERVAL_RIGHT) THEN
  REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Closures and interiors of halfspaces.                                     *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_HALFSPACE_LE = store_thm ("INTERIOR_HALFSPACE_LE",
 ``!a:real b.
        ~(a = 0) ==> (interior {x | a * x <= b} = {x | a * x < b})``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  SIMP_TAC std_ss [OPEN_HALFSPACE_LT, SUBSET_DEF, GSPECIFICATION, REAL_LT_IMP_LE] THEN
  X_GEN_TAC ``s:real->bool`` THEN STRIP_TAC THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_LE] THEN
  DISCH_TAC THEN UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[SUBSET_DEF, IN_CBALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``x + e / abs(a) * a:real``) THEN
  REWRITE_TAC[METIS [dist, REAL_ADD_SUB2, ABS_NEG] ``dist(x:real,x + y) = abs y``] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, REAL_DIV_RMUL,
               ABS_ZERO, REAL_ARITH ``&0 < x ==> abs x <= x:real``] THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x + e / abs(a) * a:real``) THEN
  ASM_REWRITE_TAC [REAL_LDISTRIB] THEN
  REWRITE_TAC [REAL_ARITH ``a * (b * a) = b * (a * a:real)``] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < e ==> ~(b + e <= b:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_MUL, REAL_LT_DIV, GSYM ABS_NZ, REAL_POASQ]);

val INTERIOR_HALFSPACE_GE = store_thm ("INTERIOR_HALFSPACE_GE",
 ``!a:real b.
        ~(a = 0) ==> (interior {x | a * x >= b} = {x | a * x > b})``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``,
                   REAL_ARITH ``a > b <=> -a < -b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL, INTERIOR_HALFSPACE_LE, REAL_NEG_EQ0]);

val INTERIOR_HALFSPACE_COMPONENT_LE = store_thm ("INTERIOR_HALFSPACE_COMPONENT_LE",
 ``!a. interior {x:real | x <= a} = {x | x < a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HALFSPACE_LE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val INTERIOR_HALFSPACE_COMPONENT_GE = store_thm ("INTERIOR_HALFSPACE_COMPONENT_GE",
 ``!a. interior {x:real | x >= a} = {x | x > a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HALFSPACE_GE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val CLOSURE_HALFSPACE_LT = store_thm ("CLOSURE_HALFSPACE_LT",
 ``!a:real b.
        ~(a = 0) ==> (closure {x | a * x < b} = {x | a * x <= b})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSURE_INTERIOR] THEN
  SIMP_TAC std_ss [SET_RULE ``UNIV DIFF {x | P x} = {x | ~P x}``] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``~(x < b) <=> x >= b:real``, INTERIOR_HALFSPACE_GE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_UNIV, GSPECIFICATION] THEN REAL_ARITH_TAC);

val CLOSURE_HALFSPACE_GT = store_thm ("CLOSURE_HALFSPACE_GT",
 ``!a:real b.
        ~(a = 0) ==> (closure {x | a * x > b} = {x | a * x >= b})``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``,
                   REAL_ARITH ``a > b <=> -a < -b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL, CLOSURE_HALFSPACE_LT, REAL_NEG_EQ0]);

val CLOSURE_HALFSPACE_COMPONENT_LT = store_thm ("CLOSURE_HALFSPACE_COMPONENT_LT",
 ``!a. closure {x:real | x < a} = {x | x <= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSURE_HALFSPACE_LT) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val CLOSURE_HALFSPACE_COMPONENT_GT = store_thm ("CLOSURE_HALFSPACE_COMPONENT_GT",
 ``!a. closure {x:real | x > a} = {x | x >= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSURE_HALFSPACE_GT) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val INTERIOR_HYPERPLANE = store_thm ("INTERIOR_HYPERPLANE",
 ``!a b. ~(a = 0) ==> (interior {x | a * x = b} = {})``,
  REWRITE_TAC[REAL_ARITH ``(x = y) <=> x <= y /\ x >= y:real``] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | p x /\ q x} = {x | p x} INTER {x | q x}``] THEN
  REWRITE_TAC[INTERIOR_INTER] THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM, REAL_ARITH ``x <= y /\ x >= y:real <=> (x = y)``] THEN
  ASM_SIMP_TAC std_ss [INTERIOR_HALFSPACE_LE, INTERIOR_HALFSPACE_GE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTER, GSPECIFICATION, NOT_IN_EMPTY] THEN
  REAL_ARITH_TAC);

val FRONTIER_HALFSPACE_LE = store_thm ("FRONTIER_HALFSPACE_LE",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x <= b} = {x | a * x = b})``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = 0`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LZERO] THENL
   [ASM_CASES_TAC ``&0 <= b:real`` THEN
    ASM_SIMP_TAC std_ss [GSPEC_T, FRONTIER_UNIV, GSPEC_F, FRONTIER_EMPTY],
    ASM_SIMP_TAC std_ss [frontier, INTERIOR_HALFSPACE_LE, CLOSURE_CLOSED,
                 CLOSED_HALFSPACE_LE] THEN
    SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION] THEN REAL_ARITH_TAC]);

val FRONTIER_HALFSPACE_GE = store_thm ("FRONTIER_HALFSPACE_GE",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x >= b} = {x | a * x = b})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``-a:real``, ``-b:real``] FRONTIER_HALFSPACE_LE) THEN
  ASM_REWRITE_TAC [REAL_NEG_EQ0, REAL_NEG_LMUL] THEN
  REWRITE_TAC [GSYM REAL_NEG_LMUL] THEN REWRITE_TAC [REAL_EQ_NEG] THEN
  SIMP_TAC std_ss [REAL_LE_NEG2, real_ge]);

val FRONTIER_HALFSPACE_LT = store_thm ("FRONTIER_HALFSPACE_LT",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x < b} = {x | a * x = b})``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = 0`` THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL] THENL
   [ASM_CASES_TAC ``&0 < b:real`` THEN REWRITE_TAC [REAL_MUL_LZERO] THEN
    ASM_SIMP_TAC std_ss [GSPEC_T, FRONTIER_UNIV, GSPEC_F, FRONTIER_EMPTY],
    ASM_SIMP_TAC std_ss [frontier, CLOSURE_HALFSPACE_LT, INTERIOR_OPEN,
                 OPEN_HALFSPACE_LT] THEN
    SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION] THEN REAL_ARITH_TAC]);

val FRONTIER_HALFSPACE_GT = store_thm ("FRONTIER_HALFSPACE_GT",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x > b} = {x | a * x = b})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``-a:real``, ``-b:real``] FRONTIER_HALFSPACE_LT) THEN
  ASM_REWRITE_TAC[REAL_NEG_EQ0, REAL_MUL_LNEG] THEN
  SIMP_TAC std_ss [REAL_LT_NEG, REAL_EQ_NEG, real_gt]);

val INTERIOR_STANDARD_HYPERPLANE = store_thm ("INTERIOR_STANDARD_HYPERPLANE",
 ``!a. interior {x:real | x = a} = {}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HYPERPLANE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

(* ------------------------------------------------------------------------- *)
(* Unboundedness of halfspaces.                                              *)
(* ------------------------------------------------------------------------- *)

val UNBOUNDED_HALFSPACE_COMPONENT_LE = store_thm
  ("UNBOUNDED_HALFSPACE_COMPONENT_LE",
  ``!a. ~bounded {x:real | x <= a}``,
    REPEAT GEN_TAC
 >> ASM_SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC]
 >> X_GEN_TAC ``B:real``
 >> EXISTS_TAC ``-((&1:real) + max (abs B) (abs a))``
 >> REWRITE_TAC [ABS_NEG, REAL_NOT_LE, REAL_NEG_ADD]
 >> RW_TAC bool_ss [abs, max_def]
 >> FULL_SIMP_TAC real_ss [REAL_NOT_LE]
 >| (* 12 goals *)
  [ ASM_REAL_ARITH_TAC, (* 1 *)
    ASM_REAL_ARITH_TAC, (* 2 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [] >> ASM_REAL_ARITH_TAC, (* 3 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [GSYM REAL_NOT_LE] >> ASM_REAL_ARITH_TAC, (* 4 *)
    Cases_on `0 <= B` >> FULL_SIMP_TAC real_ss [] >> ASM_REAL_ARITH_TAC, (* 5 *)
    Cases_on `0 <= B` >> FULL_SIMP_TAC real_ss [GSYM REAL_NOT_LE] >> ASM_REAL_ARITH_TAC, (* 6 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [] >> ASM_REAL_ARITH_TAC, (* 7 *)
    ASM_REAL_ARITH_TAC, (* 8 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [] >> ASM_REAL_ARITH_TAC, (* 9 *)
    Cases_on `0 <= B` >> FULL_SIMP_TAC real_ss [GSYM REAL_NOT_LE] >> ASM_REAL_ARITH_TAC, (* 10 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [GSYM REAL_NOT_LE] >> ASM_REAL_ARITH_TAC, (* 11 *)
    Cases_on `0 <= a` >> FULL_SIMP_TAC real_ss [GSYM REAL_NOT_LE] >> ASM_REAL_ARITH_TAC ]);

val UNBOUNDED_HALFSPACE_COMPONENT_GE = store_thm
  ("UNBOUNDED_HALFSPACE_COMPONENT_GE",
 ``!a. ~bounded {x:real | x >= a}``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_NEGATIONS) THEN
  MP_TAC(SPECL [``-a:real``] UNBOUNDED_HALFSPACE_COMPONENT_LE) THEN
  REWRITE_TAC[GSYM MONO_NOT_EQ] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_TERM_TAC THEN MATCH_MP_TAC SURJECTIVE_IMAGE_EQ THEN CONJ_TAC THENL
   [MESON_TAC[REAL_NEG_NEG],
    SIMP_TAC std_ss [GSPECIFICATION] THEN REAL_ARITH_TAC]);

val UNBOUNDED_HALFSPACE_COMPONENT_LT = store_thm ("UNBOUNDED_HALFSPACE_COMPONENT_LT",
 ``!a. ~bounded {x:real | x < a}``,
  ONCE_REWRITE_TAC[GSYM BOUNDED_CLOSURE_EQ] THEN
  REWRITE_TAC[CLOSURE_HALFSPACE_COMPONENT_LT,
              UNBOUNDED_HALFSPACE_COMPONENT_LE]);

val UNBOUNDED_HALFSPACE_COMPONENT_GT = store_thm ("UNBOUNDED_HALFSPACE_COMPONENT_GT",
 ``!a. ~bounded {x:real | x > a}``,
  ONCE_REWRITE_TAC[GSYM BOUNDED_CLOSURE_EQ] THEN
  REWRITE_TAC[CLOSURE_HALFSPACE_COMPONENT_GT,
              UNBOUNDED_HALFSPACE_COMPONENT_GE]);

(* ------------------------------------------------------------------------- *)
(* Equality of continuous functions on closure and related results.          *)
(* ------------------------------------------------------------------------- *)

val FORALL_IN_CLOSURE = store_thm ("FORALL_IN_CLOSURE",
 ``!f:real->real s t.
        closed t /\ f continuous_on (closure s) /\
        (!x. x IN s ==> f x IN t)
        ==> (!x. x IN closure s ==> f x IN t)``,
  REWRITE_TAC[SET_RULE ``(!x. x IN s ==> f x IN t) <=>
                        s SUBSET {x | x IN s /\ f x IN t}``] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSURE_MINIMAL THEN
  ASM_REWRITE_TAC[CLOSED_CLOSURE] THEN CONJ_TAC THENL
   [MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
    ASM_REWRITE_TAC[CLOSED_CLOSURE]]);

val FORALL_IN_CLOSURE_EQ = store_thm ("FORALL_IN_CLOSURE_EQ",
 ``!f s t.
         closed t /\ f continuous_on closure s
         ==> ((!x. x IN closure s ==> f x IN t) <=>
              (!x. x IN s ==> f x IN t))``,
  METIS_TAC[FORALL_IN_CLOSURE, CLOSURE_SUBSET, SUBSET_DEF]);

val CONTINUOUS_LE_ON_CLOSURE = store_thm ("CONTINUOUS_LE_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> f(x) <= a)
        ==> !x. x IN closure(s) ==> f(x) <= a``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  KNOW_TAC `` !(x :real). x IN closure (s :real -> bool)
           ==> (f :real -> real) x IN {y | y <= (a :real)}`` THENL
  [ALL_TAC, SET_TAC []] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_SIMP_TAC std_ss [ETA_AX, CLOSED_HALFSPACE_COMPONENT_LE] THEN ASM_SET_TAC []);

val CONTINUOUS_GE_ON_CLOSURE = store_thm ("CONTINUOUS_GE_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> a <= f(x))
        ==> !x. x IN closure(s) ==> a <= f(x)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  KNOW_TAC `` !(x :real). x IN closure (s :real -> bool)
           ==> (f :real -> real) x IN {y | y >= (a :real)}`` THENL
  [ALL_TAC, SET_TAC [real_ge]] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_SIMP_TAC std_ss [ETA_AX, CLOSED_HALFSPACE_COMPONENT_GE] THEN ASM_SET_TAC [real_ge]);

val CONTINUOUS_CONSTANT_ON_CLOSURE = store_thm ("CONTINUOUS_CONSTANT_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> (f(x) = a))
        ==> !x. x IN closure(s) ==> (f(x) = a)``,
  REWRITE_TAC[SET_RULE
   ``x IN s ==> (f x = a) <=> x IN s ==> f x IN {a}``] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_REWRITE_TAC[CLOSED_SING]);

val CONTINUOUS_AGREE_ON_CLOSURE = store_thm ("CONTINUOUS_AGREE_ON_CLOSURE",
 ``!g h:real->real.
        g continuous_on closure s /\ h continuous_on closure s /\
        (!x. x IN s ==> (g x = h x))
        ==> !x. x IN closure s ==> (g x = h x)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(g x - h x = 0) =  ((\x. g x - h x) x = 0:real)``] THEN
  MATCH_MP_TAC CONTINUOUS_CONSTANT_ON_CLOSURE THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_SUB]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT",
 ``!f:real->real s a.
        f continuous_on s
        ==> closed_in (subtopology euclidean s) {x | x IN s /\ (f x = a)}``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE
   ``{x | x IN s /\ (f(x) = a)} = {x | x IN s /\ f(x) IN {a}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
  ASM_REWRITE_TAC[CLOSED_SING]);

val CONTINUOUS_CLOSED_PREIMAGE_CONSTANT = store_thm ("CONTINUOUS_CLOSED_PREIMAGE_CONSTANT",
 ``!f:real->real s.
      f continuous_on s /\ closed s ==> closed {x | x IN s /\ (f(x) = a)}``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``{x | x IN s /\ ((f:real->real)(x) = a)} = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN ONCE_REWRITE_TAC[SET_RULE
   ``{x | x IN s /\ (f(x) = a)} = {x | x IN s /\ f(x) IN {a}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
  ASM_REWRITE_TAC[CLOSED_SING] THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Theorems relating continuity and uniform continuity to closures.          *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CLOSURE = store_thm ("CONTINUOUS_ON_CLOSURE",
 ``!f:real->real s.
        f continuous_on closure s <=>
        !x e. x IN closure s /\ &0 < e
              ==> ?d. &0 < d /\
                      !y. y IN s /\ dist(y,x) < d ==> dist(f y,f x) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on] THEN
  EQ_TAC THENL [METIS_TAC[REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET], ALL_TAC] THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPECL [``x:real``, ``e / &2:real``]) THEN
  KNOW_TAC ``x IN closure s:real->bool /\ 0 < e / 2:real`` THENL
  [ASM_REWRITE_TAC[REAL_HALF], DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [])] THEN
  DISCH_TAC THEN FIRST_ASSUM (fn th => REWRITE_TAC [th]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``d / &2:real`` THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``y:real``, ``e / &2:real``]) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``y:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min k (d / &2:real)``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_LT_MIN] THEN
  KNOW_TAC ``!a b c e. abs(a - b) < e / &2 /\ abs(b - c) < e / &2:real ==>
                                    abs(a - c) < e / 2 + e / 2:real`` THENL
  [REAL_ARITH_TAC, DISCH_TAC] THEN STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN REWRITE_TAC [dist] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``(f:real->real) y'`` THEN CONJ_TAC THENL
  [REWRITE_TAC [GSYM dist] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
   FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [],
   REWRITE_TAC [GSYM dist] THEN FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC DIST_TRIANGLE_LT THEN EXISTS_TAC ``y:real`` THEN
   GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
   METIS_TAC [DIST_SYM]]);

val CONTINUOUS_ON_CLOSURE_SEQUENTIALLY = store_thm ("CONTINUOUS_ON_CLOSURE_SEQUENTIALLY",
 ``!f:real->real s.
        f continuous_on closure s <=>
        !x a. a IN closure s /\ (!n. x n IN s) /\ (x --> a) sequentially
              ==> ((f o x) --> f a) sequentially``,
  REWRITE_TAC[CONTINUOUS_ON_CLOSURE] THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM continuous_within] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN_SEQUENTIALLY] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_CLOSURE = store_thm ("UNIFORMLY_CONTINUOUS_ON_CLOSURE",
 ``!f:real->real s.
        f uniformly_continuous_on s /\ f continuous_on closure s
        ==> f uniformly_continuous_on closure s``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[uniformly_continuous_on] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &3:real``) THEN
  KNOW_TAC ``0 < e / 3:real`` THENL
  [FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   ASM_REAL_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``d / &3:real`` THEN CONJ_TAC THENL
  [FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  UNDISCH_TAC ``f continuous_on closure s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [continuous_on]) THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``y:real`` th) THEN MP_TAC(SPEC ``x:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MP_TAC(ISPECL [``x:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d1 (d / &3:real)``) THEN
  KNOW_TAC ``0 < min d1 (d / 3:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x':real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``x':real``) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN DISCH_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MP_TAC(ISPECL [``y:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d2 (d / &3:real)``) THEN
  KNOW_TAC ``0 < min d2 (d / 3:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y':real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``y':real``) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x':real``, ``y':real``]) THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
  METIS_TAC[dist, ABS_SUB, REAL_ARITH
   ``abs(y - x) * 3 < d /\ abs(x' - x) * 3 < d /\ abs(y' - y) * 3 < d
    ==> abs(y' - x') < d:real``]);

(* ------------------------------------------------------------------------- *)
(* Cauchy continuity, and the extension of functions to closures.            *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS = store_thm
  ("UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS",
 ``!f:real->real s.
        f uniformly_continuous_on s
        ==> (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on, cauchy, o_DEF] THEN
  MESON_TAC[]);

val CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS = store_thm
  ("CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS",
 ``!f:real->real s.
        f continuous_on s /\ closed s
        ==> (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))``,
  REWRITE_TAC[GSYM COMPLETE_EQ_CLOSED, CONTINUOUS_ON_SEQUENTIALLY] THEN
  REWRITE_TAC[complete] THEN MESON_TAC[CONVERGENT_IMP_CAUCHY]);

val CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA = store_thm
  ("CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> !a x. (!n. (x n) IN s) /\ (x --> a) sequentially
                  ==> ?l. ((f o x) --> l) sequentially /\
                          !y. (!n. (y n) IN s) /\ (y --> a) sequentially
                              ==> ((f o y) --> l) sequentially``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN
  KNOW_TAC ``cauchy x /\ (!n. x n IN s)`` THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_CAUCHY],
    DISCH_THEN (fn th => REWRITE_TAC [th])] THEN
  REWRITE_TAC [GSYM CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN EXISTS_TAC ``l:real`` THEN
  ASM_REWRITE_TAC [] THEN
  X_GEN_TAC ``y:num->real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``y:num->real``) THEN
  KNOW_TAC ``cauchy y /\ (!n. y n IN s)`` THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_CAUCHY],
    DISCH_THEN (fn th => REWRITE_TAC [th])] THEN
  REWRITE_TAC[GSYM CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``l':real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``l:real = l'`` (fn th => ASM_REWRITE_TAC[th]) THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``\n:num. (f:real->real)(x n) - f(y n)`` THEN
  RULE_ASSUM_TAC(REWRITE_RULE[o_DEF]) THEN
  ASM_SIMP_TAC std_ss [LIM_SUB, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``\n. if EVEN n then x(n DIV 2):real else y(n DIV 2)``) THEN
  REWRITE_TAC[cauchy, o_THM, LIM_SEQUENTIALLY] THEN
  KNOW_TAC ``(!(e :real).
    (0 :real) < e ==>
    ?(N :num).
      !(m :num) (n :num).
        m >= N /\ n >= N ==>
        (dist
           ((\(n :num).
               if EVEN n then (x :num -> real) (n DIV (2 :num))
               else (y :num -> real) (n DIV (2 :num))) m,
            (\(n :num).
               if EVEN n then x (n DIV (2 :num))
               else y (n DIV (2 :num))) n) :real) < e) /\
      (!(n :num). (\(n :num).
       if EVEN n then x (n DIV (2 :num)) else y (n DIV (2 :num))) n IN
    (s :real -> bool))`` THENL
  [ (* goal 1 (of 2) *)
    CONJ_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
    X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN MAP_EVERY UNDISCH_TAC
     [``((y:num->real) --> a) sequentially``,
      ``((x:num->real) --> a) sequentially``] THEN
    REWRITE_TAC[LIM_SEQUENTIALLY] THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N1:num``) THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
    EXISTS_TAC ``2 * (N1 + N2:num)`` THEN
    MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN STRIP_TAC THEN
    UNDISCH_TAC ``!n. (y:num->real) n IN s`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``!n. (x:num->real) n IN s`` THEN DISCH_TAC THEN
    POP_ASSUM K_TAC THEN POP_ASSUM K_TAC THEN
    REPEAT(FIRST_X_ASSUM(fn th =>
      MP_TAC(SPEC ``m DIV 2`` th) THEN MP_TAC(SPEC ``n DIV 2`` th))) THEN
    KNOW_TAC ``N1 <= n DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N1 <= m DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N2 <= n DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N2 <= m DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    REPEAT(COND_CASES_TAC THEN ASM_REWRITE_TAC[]) THEN
    FULL_SIMP_TAC std_ss [dist, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
    Cases_on `EVEN m` >> Cases_on `EVEN n` >> fs [] >| (* 4 subgoals *)
    [ MP_TAC (Q.SPECL [`x (m DIV 2) - a`, `x (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`x (m DIV 2) - a`, `y (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`y (m DIV 2) - a`, `x (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`y (m DIV 2) - a`, `y (n DIV 2) - a`] ABS_TRIANGLE_NEG) ]
    >> ASM_REAL_ARITH_TAC,
    (* goal 2 (of 2) *)
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
    ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``2 * n:num``, ``2 * n + 1:num``]) THEN
    KNOW_TAC ``2 * n >= N /\ 2 * n + 1 >= N:num`` THENL
    [ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    SIMP_TAC arith_ss [EVEN_ADD, EVEN_MULT] THEN
    KNOW_TAC ``((2 * n) DIV 2 = n) /\ ((2 * n + 1) DIV 2 = n)`` THENL
    [SIMP_TAC arith_ss [DIV_EQ_X, ARITH_PROVE ``0 < 2:num``], ALL_TAC] THEN
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    REWRITE_TAC[dist, REAL_SUB_RZERO] ]);

val CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE = store_thm ("CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> ?g. g continuous_on closure s /\ (!x. x IN s ==> (g x = f x))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``!a:real. ?x.
       a IN closure s ==> (!n. x n IN s) /\ (x --> a) sequentially``
  MP_TAC THENL [MESON_TAC[CLOSURE_SEQUENTIAL], ALL_TAC] THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``X:real->num->real`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA) THEN
  DISCH_THEN(MP_TAC o GEN ``a:real`` o
   SPECL [``a:real``, ``(X:real->num->real) a``]) THEN
  KNOW_TAC ``(!(a :real). a IN closure (s :real -> bool) ==>
   ?(l :real).
     (((f :real -> real) o X a --> l) sequentially :bool) /\
     !(y :num -> real).
       (!(n :num). y n IN s) /\ ((y --> a) sequentially :bool) ==>
       ((f o y --> l) sequentially :bool)) ==>
  ?(g :real -> real).
  g continuous_on closure s /\ !(x :real). x IN s ==> (g x = f x)`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `b /\ (b ==> a) ==> a /\ b`) THEN CONJ_TAC THENL
   [X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``) THEN
    ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN
    DISCH_THEN(MP_TAC o SPEC ``(\n. a):num->real`` o CONJUNCT2) THEN
    ASM_SIMP_TAC std_ss [LIM_CONST_EQ, o_DEF, TRIVIAL_LIMIT_SEQUENTIALLY],
    STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CLOSURE_SEQUENTIALLY] THEN
  MAP_EVERY X_GEN_TAC [``x:num->real``, ``a:real``] THEN STRIP_TAC THEN
  MATCH_MP_TAC LIM_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC ``(f:real->real) o (x:num->real)`` THEN ASM_SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC ALWAYS_EVENTUALLY THEN ASM_SIMP_TAC std_ss [o_THM]);

val UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE = store_thm ("UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE",
 ``!f:real->real s.
   f uniformly_continuous_on s
   ==> ?g. g uniformly_continuous_on closure s /\ (!x. x IN s ==> (g x = f x)) /\
           !h. h continuous_on closure s /\ (!x. x IN s ==> (h x = f x))
               ==> !x. x IN closure s ==> (h x = g x)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE o
   MATCH_MP UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS) THEN
  STRIP_TAC THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [METIS_TAC[UNIFORMLY_CONTINUOUS_ON_CLOSURE, UNIFORMLY_CONTINUOUS_ON_EQ],
    METIS_TAC[CONTINUOUS_AGREE_ON_CLOSURE]]);

val CAUCHY_CONTINUOUS_IMP_CONTINUOUS = store_thm ("CAUCHY_CONTINUOUS_IMP_CONTINUOUS",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> f continuous_on s``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(CHOOSE_TAC o MATCH_MP CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE) THEN
  ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, CLOSURE_SUBSET, CONTINUOUS_ON_EQ]);

val BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE = store_thm ("BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE",
 ``!f:real->real s.
        f uniformly_continuous_on s /\ bounded s ==> bounded(IMAGE f s)``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC o MATCH_MP UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC BOUNDED_SUBSET THEN
  EXISTS_TAC ``IMAGE (g:real->real) (closure s)`` THEN CONJ_TAC THENL
   [ASM_MESON_TAC[COMPACT_CLOSURE, UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS,
                  COMPACT_IMP_BOUNDED, COMPACT_CONTINUOUS_IMAGE],
    MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Occasionally useful invariance properties.                                *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_AT_COMPOSE_EQ = store_thm ("CONTINUOUS_AT_COMPOSE_EQ",
 ``!f:real->real g:real->real h:real->real.
        g continuous at x /\ h continuous at (g x) /\
        (!y. g(h y) = y) /\ (h(g x) = x)
        ==> ((f continuous at (g x) <=> (\x. f(g x)) continuous at x))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[o_DEF] CONTINUOUS_AT_COMPOSE] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN
   ``((f:real->real) o (g:real->real) o (h:real->real))
     continuous at (g(x:real))``
  MP_TAC THENL
   [REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC CONTINUOUS_AT_COMPOSE THEN
    ASM_REWRITE_TAC[o_DEF],
    ASM_SIMP_TAC std_ss [o_DEF, ETA_AX]]);

val CONTINUOUS_AT_TRANSLATION = store_thm ("CONTINUOUS_AT_TRANSLATION",
 ``!a z f:real->real.
      f continuous at (a + z) <=> (\x. f(a + x)) continuous at z``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``a + z = (\z. a + z) z:real``] THEN
  MATCH_MP_TAC CONTINUOUS_AT_COMPOSE_EQ THEN
  EXISTS_TAC ``\x:real. x - a`` THEN
  SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_SUB,
           CONTINUOUS_AT_ID, CONTINUOUS_CONST] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Interior of an injective image.                                           *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_IMAGE_SUBSET = store_thm ("INTERIOR_IMAGE_SUBSET",
 ``!f:real->real s.
       (!x. f continuous at x) /\ (!x y. (f x = f y) ==> (x = y))
       ==> interior(IMAGE f s) SUBSET IMAGE f (interior s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[SUBSET_DEF] THEN
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  X_GEN_TAC ``y:real`` THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  SIMP_TAC std_ss [IN_IMAGE, GSPECIFICATION] THEN
  SUBGOAL_THEN ``y IN IMAGE (f:real->real) s`` MP_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[IN_IMAGE] THEN
  STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN FIRST_X_ASSUM SUBST_ALL_TAC THEN
  EXISTS_TAC ``{x | (f:real->real)(x) IN t}`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE_UNIV THEN ASM_MESON_TAC[],
    ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Making a continuous function avoid some value in a neighbourhood.         *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_AVOID = store_thm ("CONTINUOUS_WITHIN_AVOID",
 ``!f:real->real x s a.
        f continuous (at x within s) /\ x IN s /\  ~(f x = a)
        ==> ?e. &0 < e /\ !y. y IN s /\ dist(x,y) < e ==> ~(f y = a)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``f continuous (at x within s)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [continuous_within]) THEN
  DISCH_THEN(MP_TAC o SPEC ``abs((f:real->real) x - a)``) THEN
  ASM_REWRITE_TAC[GSYM ABS_NZ, REAL_SUB_0] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN MATCH_MP_TAC MONO_AND THEN
  REWRITE_TAC[] THEN DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN
  POP_ASSUM (MP_TAC o SPEC ``y:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_AT_AVOID = store_thm ("CONTINUOUS_AT_AVOID",
 ``!f:real->real x a.
        f continuous (at x) /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. dist(x,y) < e ==> ~(f y = a)``,
  MP_TAC CONTINUOUS_WITHIN_AVOID THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o SPECL [``f:real->real``,``x:real``]) THEN
  DISCH_THEN(MP_TAC o SPEC ``univ(:real)``) THEN
  DISCH_TAC THEN X_GEN_TAC ``a:real`` THEN POP_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  REWRITE_TAC[WITHIN_UNIV, IN_UNIV]);

val CONTINUOUS_ON_AVOID = store_thm ("CONTINUOUS_ON_AVOID",
 ``!f:real->real x s a.
        f continuous_on s /\ x IN s /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. y IN s /\ dist(x,y) < e ==> ~(f y = a)``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_WITHIN_AVOID THEN
  ASM_SIMP_TAC std_ss []);

val CONTINUOUS_ON_OPEN_AVOID = store_thm ("CONTINUOUS_ON_OPEN_AVOID",
 ``!f:real->real x s a.
        f continuous_on s /\ open s /\ x IN s /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. dist(x,y) < e ==> ~(f y = a)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``open(s:real->bool)`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_AT] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_AT_AVOID THEN
  ASM_SIMP_TAC std_ss []);

(* ------------------------------------------------------------------------- *)
(* Proving a function is constant by proving open-ness of level set.         *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_LEVELSET_OPEN_IN_CASES = store_thm ("CONTINUOUS_LEVELSET_OPEN_IN_CASES",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open_in (subtopology euclidean s) {x | x IN s /\ (f x = a)}
        ==> (!x. x IN s ==> ~(f x = a)) \/ (!x. x IN s ==> (f x = a))``,
  REWRITE_TAC[SET_RULE ``(!x. x IN s ==> ~(f x = a)) <=>
                        ({x | x IN s /\ (f x = a)} = {})``,
              SET_RULE ``(!x. x IN s ==> (f x = a)) <=>
                        ({x | x IN s /\ (f x = a)} = s)``] THEN
  REWRITE_TAC[CONNECTED_CLOPEN] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT]);

val CONTINUOUS_LEVELSET_OPEN_IN = store_thm ("CONTINUOUS_LEVELSET_OPEN_IN",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open_in (subtopology euclidean s) {x | x IN s /\ (f x = a)} /\
        (?x. x IN s /\ (f x = a))
        ==> (!x. x IN s ==> (f x = a))``,
  METIS_TAC[CONTINUOUS_LEVELSET_OPEN_IN_CASES]);

val CONTINUOUS_LEVELSET_OPEN = store_thm ("CONTINUOUS_LEVELSET_OPEN",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open {x | x IN s /\ (f x = a)} /\
        (?x. x IN s /\ (f x = a))
        ==> (!x. x IN s ==> (f x = a))``,
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC CONTINUOUS_LEVELSET_OPEN_IN THEN
  ASM_REWRITE_TAC[OPEN_IN_OPEN] THEN
  EXISTS_TAC ``{x | x IN s /\ ((f:real->real) x = a)}`` THEN
  ASM_REWRITE_TAC[] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some arithmetical combinations (more to prove).                           *)
(* ------------------------------------------------------------------------- *)

val OPEN_SCALING = store_thm ("OPEN_SCALING",
 ``!s:real->bool c. ~(c = &0) /\ open s ==> open(IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [open_def, FORALL_IN_IMAGE] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e * abs(c:real)`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL, GSYM ABS_NZ] THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_IMAGE] THEN
  EXISTS_TAC ``inv(c) * y:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  SUBGOAL_THEN ``x = inv(c) * c * x:real`` SUBST1_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID],
    REWRITE_TAC[dist, GSYM REAL_MUL_ASSOC, GSYM REAL_SUB_LDISTRIB, ABS_MUL] THEN
    ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_SIMP_TAC std_ss [ABS_INV] THEN
    ASM_SIMP_TAC std_ss [GSYM real_div, REAL_LT_LDIV_EQ, GSYM ABS_NZ] THEN
    ASM_REWRITE_TAC[GSYM dist]]);

val OPEN_NEGATIONS = store_thm ("OPEN_NEGATIONS",
 ``!s:real->bool. open s ==> open (IMAGE (\x. -x) s)``,
  SUBGOAL_THEN ``(\x. -x) = \x:real. -(&1) * x``
   (fn th => SIMP_TAC std_ss [th, OPEN_SCALING, REAL_ARITH ``~(-(&1) = &0:real)``]) THEN
  REWRITE_TAC[FUN_EQ_THM] THEN REAL_ARITH_TAC);

val OPEN_TRANSLATION = store_thm ("OPEN_TRANSLATION",
 ``!s a:real. open s ==> open(IMAGE (\x. a + x) s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``\x:real. x - a``, ``s:real->bool``]
         CONTINUOUS_OPEN_PREIMAGE_UNIV) THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_SUB, CONTINUOUS_AT_ID, CONTINUOUS_CONST] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE, IN_UNIV] THEN
  ASM_MESON_TAC[REAL_ARITH ``(a + x) - a = x:real``,
                REAL_ARITH ``a + (x - a) = x:real``]);

val OPEN_TRANSLATION_EQ = store_thm ("OPEN_TRANSLATION_EQ",
 ``!a s. open (IMAGE (\x:real. a + x) s) <=> open s``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
  [ALL_TAC, REWRITE_TAC [OPEN_TRANSLATION]] THEN
  REWRITE_TAC [open_def] THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN
  KNOW_TAC ``a + x IN IMAGE (\x:real. a + x) s`` THENL
  [SIMP_TAC std_ss [IN_IMAGE, REAL_EQ_LADD] THEN METIS_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC [] THEN
  GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [dist, IN_IMAGE] THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``a + x':real``) THEN
  ASM_SIMP_TAC real_ss [REAL_ARITH ``a + b - (a + c) = b - c:real``] THEN
  REWRITE_TAC [REAL_EQ_LADD] THEN METIS_TAC []);

val OPEN_AFFINITY = store_thm ("OPEN_AFFINITY",
 ``!s a:real c.
        open s /\ ~(c = &0) ==> open (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IMAGE_COMPOSE, OPEN_TRANSLATION, OPEN_SCALING]);

val INTERIOR_TRANSLATION = store_thm ("INTERIOR_TRANSLATION",
 ``!a:real s.
    interior (IMAGE (\x. a + x) s) = IMAGE (\x. a + x) (interior s)``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``(!t. ?s. IMAGE ((\x. a + x):real->real) s = t)`` THENL
  [REWRITE_TAC [SURJECTIVE_IMAGE] THEN GEN_TAC THEN EXISTS_TAC ``-a + y:real`` THEN
   SIMP_TAC std_ss [] THEN REAL_ARITH_TAC, DISCH_TAC] THEN
  REWRITE_TAC [interior] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [FIRST_ASSUM (MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
   DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [IN_IMAGE] THEN
   SIMP_TAC std_ss [] THEN STRIP_TAC THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [] THEN
   FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN STRIP_TAC THEN
   EXISTS_TAC ``s':real->bool`` THEN REPEAT CONJ_TAC THENL
   [METIS_TAC [OPEN_TRANSLATION_EQ],
    UNDISCH_TAC ``IMAGE ((\x. a + x):real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_SIMP_TAC std_ss [IN_IMAGE] THEN
    REWRITE_TAC [REAL_EQ_LADD] THEN METIS_TAC [],
    REWRITE_TAC [SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``IMAGE ((\x. a + x):real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``a + y:real``) THEN SIMP_TAC std_ss [IN_IMAGE] THEN
    KNOW_TAC ``(?x:real. (a + y = a + x) /\ x IN s')`` THENL
    [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN UNDISCH_TAC ``t SUBSET IMAGE ((\x. a + x):real->real) s`` THEN
    REWRITE_TAC [SUBSET_DEF] THEN DISCH_THEN (MP_TAC o SPEC ``a + y:real``) THEN
    ASM_REWRITE_TAC [] THEN SIMP_TAC std_ss [IN_IMAGE, REAL_EQ_LADD]], ALL_TAC] THEN
  FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
  STRIP_TAC THEN EXISTS_TAC ``IMAGE (\x:real. a + x) t`` THEN
  REPEAT CONJ_TAC THENL
  [METIS_TAC [OPEN_TRANSLATION_EQ],
   SIMP_TAC std_ss [IN_IMAGE] THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [],
   MATCH_MP_TAC IMAGE_SUBSET THEN ASM_REWRITE_TAC []]);

val OPEN_SUMS = store_thm ("OPEN_SUMS",
 ``!s t:real->bool.
        open s \/ open t ==> open {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_def] THEN STRIP_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``),
    FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``)] THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC[REAL_ADD_SYM, REAL_ARITH ``(z - y) + y:real = z``, dist,
                REAL_ARITH ``abs(z:real - (x + y)) < e ==> abs(z - y - x) < e``]);

(* ------------------------------------------------------------------------- *)
(* Upper and lower hemicontinuous functions, relation in the case of         *)
(* preimage map to open and closed maps, and fact that upper and lower       *)
(* hemicontinuity together imply continuity in the sense of the Hausdorff    *)
(* metric (at points where the function gives a bounded and nonempty set).   *)
(* ------------------------------------------------------------------------- *)

val UPPER_HEMICONTINUOUS = store_thm ("UPPER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
        (!x. x IN s ==> f(x) SUBSET t)
        ==> ((!u. open_in (subtopology euclidean t) u
                  ==> open_in (subtopology euclidean s)
                              {x | x IN s /\ f(x) SUBSET u}) <=>
             (!u. closed_in (subtopology euclidean t) u
                  ==> closed_in (subtopology euclidean s)
                                {x | x IN s /\ ~(f(x) INTER u = {})}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  MATCH_MP_TAC MONO_IMP THEN
  SIMP_TAC std_ss [OPEN_IN_DIFF, CLOSED_IN_DIFF, OPEN_IN_REFL, CLOSED_IN_REFL] THENL
   [REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ], REWRITE_TAC[closed_in]] THEN
  SIMP_TAC std_ss [TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val LOWER_HEMICONTINUOUS = store_thm ("LOWER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
        (!x. x IN s ==> f(x) SUBSET t)
        ==> ((!u. closed_in (subtopology euclidean t) u
                  ==> closed_in (subtopology euclidean s)
                                {x | x IN s /\ f(x) SUBSET u}) <=>
             (!u. open_in (subtopology euclidean t) u
                  ==> open_in (subtopology euclidean s)
                              {x | x IN s /\ ~(f(x) INTER u = {})}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  MATCH_MP_TAC MONO_IMP THEN
  SIMP_TAC std_ss [OPEN_IN_DIFF, CLOSED_IN_DIFF, OPEN_IN_REFL, CLOSED_IN_REFL] THENL
   [REWRITE_TAC[closed_in], REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ]] THEN
  SIMP_TAC std_ss [TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE = store_thm ("OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE",
 ``!f:real->real s t.
        IMAGE f s SUBSET t
        ==> ((!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. closed_in (subtopology euclidean s) u
                      ==> closed_in (subtopology euclidean t)
                                    {y | y IN t /\
                                         {x | x IN s /\ (f x = y)} SUBSET u}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
    SIMP_TAC std_ss [OPEN_IN_CLOSED_IN_EQ, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[],
    X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
    REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(fn th => CONJ_TAC THENL [ASM_SET_TAC[], MP_TAC th]) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE = store_thm ("CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE",
 ``!f:real->real s t.
        IMAGE f s SUBSET t
        ==> ((!u. closed_in (subtopology euclidean s) u
                  ==> closed_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t)
                              {y | y IN t /\
                                   {x | x IN s /\ (f x = y)} SUBSET u}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
    SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[],
    X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
    REWRITE_TAC[closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(fn th => CONJ_TAC THENL [ASM_SET_TAC[], MP_TAC th]) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val UPPER_LOWER_HEMICONTINUOUS_EXPLICIT = store_thm ("UPPER_LOWER_HEMICONTINUOUS_EXPLICIT",
 ``!f:real->real->bool t s.
      (!x. x IN s ==> f(x) SUBSET t) /\
      (!u. open_in (subtopology euclidean t) u
           ==> open_in (subtopology euclidean s)
                       {x | x IN s /\ f(x) SUBSET u}) /\
      (!u. closed_in (subtopology euclidean t) u
           ==> closed_in (subtopology euclidean s)
                         {x | x IN s /\ f(x) SUBSET u})
      ==> !x e. x IN s /\ &0 < e /\ bounded(f x) /\ ~(f x = {})
                ==> ?d. &0 < d /\
                        !x'. x' IN s /\ dist(x,x') < d
                             ==> (!y. y IN f x
                                      ==> ?y'. y' IN f x' /\ dist(y,y') < e) /\
                                 (!y'. y' IN f x'
                                       ==> ?y. y IN f x /\ dist(y',y) < e)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC
   ``!u. open_in (subtopology euclidean t) u
        ==> open_in (subtopology euclidean s)
                    {x | x IN s /\ (f:real->real->bool)(x) SUBSET u}`` THEN
  DISCH_THEN(MP_TAC o SPEC
   ``t INTER
    {a + b | a IN (f:real->real->bool) x /\ b IN ball(0,e)}``) THEN
  SIMP_TAC std_ss [OPEN_SUMS, OPEN_BALL, OPEN_IN_OPEN_INTER] THEN
  SIMP_TAC std_ss [open_in, SUBSET_RESTRICT] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION, SUBSET_INTER] THEN
  KNOW_TAC ``(f :real -> real -> bool) (x :real) SUBSET
    {a + b | a IN f x /\ b IN ball ((0 :real),(e :real))}`` THENL
   [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
    METIS_TAC[CENTRE_IN_BALL, REAL_ADD_RID],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``d1:real``
     (CONJUNCTS_THEN2 ASSUME_TAC ASSUME_TAC))] THEN
  UNDISCH_TAC
   ``!u. closed_in (subtopology euclidean t) u
        ==> closed_in (subtopology euclidean s)
                    {x | x IN s /\ (f:real->real->bool)(x) SUBSET u}`` THEN
  ASM_SIMP_TAC std_ss [LOWER_HEMICONTINUOUS] THEN DISCH_THEN(MP_TAC o
    GEN ``a:real`` o SPEC ``t INTER ball(a:real,e / &2)``) THEN
  SIMP_TAC std_ss [OPEN_BALL, OPEN_IN_OPEN_INTER] THEN
  MP_TAC(SPEC ``closure((f:real->real->bool) x)``
    COMPACT_EQ_HEINE_BOREL) THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE] THEN DISCH_THEN(MP_TAC o SPEC
   ``{ball(a:real,e / &2) | a IN (f:real->real->bool) x}``) THEN
  SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, OPEN_BALL] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE] THEN
  KNOW_TAC ``closure ((f :real -> real -> bool) (x :real)) SUBSET
   BIGUNION (IMAGE (\(a :real). ball (a,(e :real) / (2 :real))) (f x))`` THENL
   [SIMP_TAC std_ss [CLOSURE_APPROACHABLE, SUBSET_DEF, BIGUNION_IMAGE, GSPECIFICATION] THEN
    REWRITE_TAC[IN_BALL] THEN ASM_SIMP_TAC std_ss [REAL_HALF],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
  DISCH_TAC THEN FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP
   (METIS[CLOSURE_SUBSET, SUBSET_TRANS]
        ``closure s SUBSET t ==> s SUBSET t``)) THEN
  SUBGOAL_THEN
   ``open_in (subtopology euclidean s)
      (BIGINTER {{x | x IN s /\
          ~((f:real->real->bool) x INTER t INTER ball(a,e / &2) = {})} |
     a IN c})``
  MP_TAC THENL
   [MATCH_MP_TAC OPEN_IN_BIGINTER THEN
    ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IMAGE_FINITE,
     GSYM INTER_ASSOC] THEN ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY] THEN
    ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[open_in] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN
  KNOW_TAC ``(x :real) IN
   BIGINTER {{x |
     x IN (s :real -> bool) /\
     (f :real -> real -> bool) x INTER (t :real -> bool) INTER
     ball (a,(e :real) / (2 :real)) <> ({} :real -> bool)} |
    a IN (c :real -> bool)}`` THENL
   [SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION] THEN
    X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
    EXISTS_TAC ``a:real`` THEN
    ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_HALF] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``d2:real``
     (CONJUNCTS_THEN2 ASSUME_TAC ASSUME_TAC))] THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  X_GEN_TAC ``x':real`` THEN STRIP_TAC THEN CONJ_TAC THENL
   [ALL_TAC,
    UNDISCH_TAC ``!x'':real.
        x'' IN s /\ dist (x'',x) < d1 ==>
        f x'' SUBSET {a + b | a IN f x /\ b IN ball (0,e)}`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``x':real``) THEN
    ASM_REWRITE_TAC[] THEN
    KNOW_TAC ``dist (x',x) < d1:real`` THENL
    [ASM_MESON_TAC[DIST_SYM], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD, IN_BALL] THEN
    SIMP_TAC std_ss [REAL_ARITH ``(x:real = a + b) <=> (x - a = b)``,
                DIST_0, ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
    REWRITE_TAC[dist]] THEN
  UNDISCH_TAC ``!x':real.
         x' IN s /\ dist (x',x) < d2 ==>
         x' IN
         BIGINTER
           {{x | x IN s /\ f x INTER t INTER ball (a,e / 2) <> {}} |
            a IN c}`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``x':real``) THEN
  ASM_SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION] THEN
  KNOW_TAC ``dist (x',x) < d2:real`` THENL
  [ASM_MESON_TAC[DIST_SYM], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_TAC THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``(f:real->real->bool) x SUBSET
               BIGUNION (IMAGE (\a. ball (a,e / &2)) c)`` THEN
  REWRITE_TAC[SUBSET_DEF] THEN DISCH_THEN(MP_TAC o SPEC ``y:real``) THEN
  ASM_SIMP_TAC std_ss [BIGUNION_IMAGE, GSPECIFICATION, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!(a' :real).
         a' IN (c :real -> bool) ==>
         (f :real -> real -> bool) (x' :real) INTER
         (t :real -> bool) INTER ball (a',(e :real) / (2 :real)) <>
         ({} :real -> bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER, IN_BALL] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  METIS_TAC[DIST_TRIANGLE_HALF_L, DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Connected components, considered as a "connectedness" relation or a set.  *)
(* ------------------------------------------------------------------------- *)

val connected_component = new_definition ("connected_component",
 ``connected_component s x y <=>
        ?t. connected t /\ t SUBSET s /\ x IN t /\ y IN t``);

val CONNECTED_COMPONENT_IN = store_thm ("CONNECTED_COMPONENT_IN",
 ``!s x y. connected_component s x y ==> x IN s /\ y IN s``,
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_REFL = store_thm ("CONNECTED_COMPONENT_REFL",
 ``!s x:real. x IN s ==> connected_component s x x``,
  REWRITE_TAC[connected_component] THEN REPEAT STRIP_TAC THEN
  EXISTS_TAC ``{x:real}`` THEN REWRITE_TAC[CONNECTED_SING] THEN
  ASM_SET_TAC[]);

val CONNECTED_COMPONENT_REFL_EQ = store_thm ("CONNECTED_COMPONENT_REFL_EQ",
 ``!s x:real. connected_component s x x <=> x IN s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[CONNECTED_COMPONENT_REFL] THEN
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SYM = store_thm ("CONNECTED_COMPONENT_SYM",
 ``!s x y:real. connected_component s x y ==> connected_component s y x``,
  REWRITE_TAC[connected_component] THEN MESON_TAC[]);

val CONNECTED_COMPONENT_TRANS = store_thm ("CONNECTED_COMPONENT_TRANS",
 ``!s x y:real.
    connected_component s x y /\ connected_component s y z
    ==> connected_component s x z``,
  REPEAT GEN_TAC THEN REWRITE_TAC[connected_component] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``t:real->bool``)
                             (X_CHOOSE_TAC ``u:real->bool``)) THEN
  EXISTS_TAC ``t UNION u:real->bool`` THEN
  ASM_REWRITE_TAC[IN_UNION, UNION_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_UNION THEN ASM_SET_TAC[]);

val CONNECTED_COMPONENT_OF_SUBSET = store_thm ("CONNECTED_COMPONENT_OF_SUBSET",
 ``!s t x. s SUBSET t /\ connected_component s x y
           ==> connected_component t x y``,
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SET = store_thm ("CONNECTED_COMPONENT_SET",
 ``!s x. connected_component s x =
            { y | ?t. connected t /\ t SUBSET s /\ x IN t /\ y IN t}``,
  SIMP_TAC std_ss [GSPECIFICATION, EXTENSION] THEN
  SIMP_TAC std_ss [IN_DEF, connected_component]);

val CONNECTED_COMPONENT_BIGUNION = store_thm ("CONNECTED_COMPONENT_BIGUNION",
 ``!s x. connected_component s x =
                BIGUNION {t | connected t /\ x IN t /\ t SUBSET s}``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SUBSET = store_thm ("CONNECTED_COMPONENT_SUBSET",
 ``!s x. (connected_component s x) SUBSET s``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_CONNECTED_COMPONENT_SET = store_thm ("CONNECTED_CONNECTED_COMPONENT_SET",
 ``!s. connected s <=> !x:real. x IN s ==> (connected_component s x = s)``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_COMPONENT_BIGUNION] THEN EQ_TAC THENL
   [SET_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[CONNECTED_EMPTY] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(SUBST1_TAC o SYM) THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN
  ASM_SET_TAC[]);

val CONNECTED_COMPONENT_UNIV = store_thm ("CONNECTED_COMPONENT_UNIV",
 ``!x. connected_component univ(:real) x = univ(:real)``,
  MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET, CONNECTED_UNIV, IN_UNIV]);

val CONNECTED_COMPONENT_EQ_UNIV = store_thm ("CONNECTED_COMPONENT_EQ_UNIV",
 ``!s x. (connected_component s x = univ(:real)) <=> (s = univ(:real))``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONNECTED_COMPONENT_UNIV] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (s = UNIV) ==> (t = UNIV)``) THEN
  REWRITE_TAC[CONNECTED_COMPONENT_SUBSET]);

val CONNECTED_COMPONENT_EQ_SELF = store_thm ("CONNECTED_COMPONENT_EQ_SELF",
 ``!s x. connected s /\ x IN s ==> (connected_component s x = s)``,
  MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET]);

val CONNECTED_IFF_CONNECTED_COMPONENT = store_thm ("CONNECTED_IFF_CONNECTED_COMPONENT",
 ``!s. connected s <=>
          !x y. x IN s /\ y IN s ==> connected_component s x y``,
  REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT_SET] THEN
  REWRITE_TAC[EXTENSION] THEN MESON_TAC[IN_DEF, CONNECTED_COMPONENT_IN]);

val CONNECTED_COMPONENT_MAXIMAL = store_thm ("CONNECTED_COMPONENT_MAXIMAL",
 ``!s t x:real.
        x IN t /\ connected t /\ t SUBSET s
        ==> t SUBSET (connected_component s x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_COMPONENT_MONO = store_thm ("CONNECTED_COMPONENT_MONO",
 ``!s t x. s SUBSET t
           ==> (connected_component s x) SUBSET (connected_component t x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_CONNECTED_COMPONENT = store_thm ("CONNECTED_CONNECTED_COMPONENT",
 ``!s x. connected(connected_component s x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_BIGUNION] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN SET_TAC[]);

val CONNECTED_COMPONENT_EQ_EMPTY = store_thm ("CONNECTED_COMPONENT_EQ_EMPTY",
 ``!s x:real. (connected_component s x = {}) <=> ~(x IN s)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
    SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]]);

val CONNECTED_COMPONENT_EMPTY = store_thm ("CONNECTED_COMPONENT_EMPTY",
 ``!x. connected_component {} x = {}``,
  REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY, NOT_IN_EMPTY]);

val CONNECTED_COMPONENT_EQ = store_thm ("CONNECTED_COMPONENT_EQ",
 ``!s x y. y IN connected_component s x
           ==> ((connected_component s y = connected_component s x))``,
  REWRITE_TAC[EXTENSION, IN_DEF] THEN
  MESON_TAC[CONNECTED_COMPONENT_SYM, CONNECTED_COMPONENT_TRANS]);

val CLOSED_CONNECTED_COMPONENT = store_thm ("CLOSED_CONNECTED_COMPONENT",
 ``!s x:real. closed s ==> closed(connected_component s x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``(x:real) IN s`` THENL
   [ALL_TAC, ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY, CLOSED_EMPTY]] THEN
  REWRITE_TAC[GSYM CLOSURE_EQ] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[CLOSURE_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
  SIMP_TAC std_ss [CONNECTED_CLOSURE, CONNECTED_CONNECTED_COMPONENT] THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC(REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET) THEN
    ASM_SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    MATCH_MP_TAC CLOSURE_MINIMAL THEN
    ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET]]);

val CONNECTED_COMPONENT_DISJOINT = store_thm ("CONNECTED_COMPONENT_DISJOINT",
 ``!s a b. DISJOINT (connected_component s a) (connected_component s b) <=>
             ~(a IN connected_component s b)``,
  REWRITE_TAC[DISJOINT_DEF, EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
  REWRITE_TAC[IN_DEF] THEN
  MESON_TAC[CONNECTED_COMPONENT_SYM, CONNECTED_COMPONENT_TRANS]);

val CONNECTED_COMPONENT_NONOVERLAP = store_thm ("CONNECTED_COMPONENT_NONOVERLAP",
 ``!s a b:real.
        ((connected_component s a) INTER (connected_component s b) = {}) <=>
        ~(a IN s) \/ ~(b IN s) \/
        ~(connected_component s a = connected_component s b)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``(a:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(SIMP_RULE std_ss [GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  ASM_SIMP_TAC std_ss [INTER_EMPTY] THEN
  ASM_CASES_TAC ``(b:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  ASM_REWRITE_TAC[INTER_EMPTY] THEN ASM_CASES_TAC
   ``connected_component s (a:real) = connected_component s b`` THEN
  ASM_REWRITE_TAC[INTER_IDEMPOT, CONNECTED_COMPONENT_EQ_EMPTY] THEN
  POP_ASSUM MP_TAC THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
  REWRITE_TAC[] THEN MATCH_MP_TAC CONNECTED_COMPONENT_EQ THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM DISJOINT_DEF]) THEN
  REWRITE_TAC[CONNECTED_COMPONENT_DISJOINT]);

val CONNECTED_COMPONENT_OVERLAP = store_thm ("CONNECTED_COMPONENT_OVERLAP",
 ``!s a b:real.
        ~((connected_component s a) INTER (connected_component s b) = {}) <=>
        a IN s /\ b IN s /\
        (connected_component s a = connected_component s b)``,
  REWRITE_TAC[CONNECTED_COMPONENT_NONOVERLAP, DE_MORGAN_THM]);

val CONNECTED_COMPONENT_SYM_EQ = store_thm ("CONNECTED_COMPONENT_SYM_EQ",
 ``!s x y. connected_component s x y <=> connected_component s y x``,
  MESON_TAC[CONNECTED_COMPONENT_SYM]);

val CONNECTED_COMPONENT_EQ_EQ = store_thm ("CONNECTED_COMPONENT_EQ_EQ",
 ``!s x y:real.
        (connected_component s x = connected_component s y) <=>
           ~(x IN s) /\ ~(y IN s) \/
           x IN s /\ y IN s /\ connected_component s x y``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(y:real) IN s`` THENL
   [ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THENL
     [REWRITE_TAC[FUN_EQ_THM] THEN
      ASM_MESON_TAC[CONNECTED_COMPONENT_TRANS, CONNECTED_COMPONENT_REFL,
                    CONNECTED_COMPONENT_SYM],
      ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY]],
    RULE_ASSUM_TAC(REWRITE_RULE[GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
    ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY] THEN
    ONCE_REWRITE_TAC[CONNECTED_COMPONENT_SYM_EQ] THEN
    ASM_REWRITE_TAC[EMPTY_DEF] THEN ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY]]);

val CONNECTED_EQ_CONNECTED_COMPONENT_EQ = store_thm ("CONNECTED_EQ_CONNECTED_COMPONENT_EQ",
 ``!s. connected s <=>
       !x y. x IN s /\ y IN s
             ==> (connected_component s x = connected_component s y)``,
  SIMP_TAC std_ss [CONNECTED_COMPONENT_EQ_EQ] THEN
  REWRITE_TAC[CONNECTED_IFF_CONNECTED_COMPONENT]);

val CONNECTED_COMPONENT_IDEMP = store_thm ("CONNECTED_COMPONENT_IDEMP",
 ``!s x:real. connected_component (connected_component s x) x =
                connected_component s x``,
  REWRITE_TAC[FUN_EQ_THM, connected_component] THEN
  REPEAT GEN_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN EQ_TAC THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[CONNECTED_COMPONENT_MAXIMAL, SUBSET_TRANS,
                CONNECTED_COMPONENT_SUBSET]);

val CONNECTED_COMPONENT_UNIQUE = store_thm ("CONNECTED_COMPONENT_UNIQUE",
 ``!s c x:real.
        x IN c /\ c SUBSET s /\ connected c /\
        (!c'. x IN c' /\ c' SUBSET s /\ connected c'
              ==> c' SUBSET c)
        ==> (connected_component s x = c)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [FIRST_X_ASSUM MATCH_MP_TAC THEN
    REWRITE_TAC[CONNECTED_COMPONENT_SUBSET, CONNECTED_CONNECTED_COMPONENT] THEN
    REWRITE_TAC[IN_DEF] THEN ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_SET_TAC[],
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN ASM_REWRITE_TAC[]]);

val JOINABLE_CONNECTED_COMPONENT_EQ = store_thm ("JOINABLE_CONNECTED_COMPONENT_EQ",
 ``!s t x y:real.
        connected t /\ t SUBSET s /\
        ~(connected_component s x INTER t = {}) /\
        ~(connected_component s y INTER t = {})
        ==> (connected_component s x = connected_component s y)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``w:real`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC)) THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_EQ THEN
  SIMP_TAC std_ss [IN_DEF] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_TRANS THEN
  EXISTS_TAC ``z:real`` THEN CONJ_TAC THENL [ASM_MESON_TAC[IN_DEF], ALL_TAC] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_TRANS THEN
  EXISTS_TAC ``w:real`` THEN CONJ_TAC THENL
   [REWRITE_TAC[connected_component] THEN
    EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[],
    ASM_MESON_TAC[IN_DEF, CONNECTED_COMPONENT_SYM]]);

val BIGUNION_CONNECTED_COMPONENT = store_thm ("BIGUNION_CONNECTED_COMPONENT",
 ``!s:real->bool. BIGUNION {connected_component s x |x| x IN s} = s``,
  GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC, CONNECTED_COMPONENT_SUBSET] THEN
  SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN EXISTS_TAC ``x:real`` THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[IN_DEF] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ]);

val COMPLEMENT_CONNECTED_COMPONENT_BIGUNION = store_thm ("COMPLEMENT_CONNECTED_COMPONENT_BIGUNION",
 ``!s x:real.
     s DIFF connected_component s x =
     BIGUNION({connected_component s y | y | y IN s} DELETE
            (connected_component s x))``,
  REPEAT GEN_TAC THEN
  GEN_REWR_TAC (LAND_CONV o LAND_CONV)
    [GSYM BIGUNION_CONNECTED_COMPONENT] THEN
  MATCH_MP_TAC(SET_RULE
   ``(!x. x IN s DELETE a ==> DISJOINT a x)
     ==> (BIGUNION s DIFF a = BIGUNION (s DELETE a))``) THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, FORALL_IN_GSPEC, IN_DELETE] THEN
  SIMP_TAC std_ss [CONNECTED_COMPONENT_DISJOINT, CONNECTED_COMPONENT_EQ_EQ] THEN
  MESON_TAC[IN_DEF, SUBSET_DEF, CONNECTED_COMPONENT_SUBSET]);

val CLOSED_IN_CONNECTED_COMPONENT = store_thm ("CLOSED_IN_CONNECTED_COMPONENT",
 ``!s x:real. closed_in (subtopology euclidean s) (connected_component s x)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``connected_component s (x:real) = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_IN_EMPTY] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``closure(connected_component s x):real->bool`` THEN
  REWRITE_TAC[CLOSED_CLOSURE] THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[SUBSET_INTER, CONNECTED_COMPONENT_SUBSET, CLOSURE_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN REWRITE_TAC[INTER_SUBSET] THEN
  CONJ_TAC THENL
   [ASM_REWRITE_TAC[IN_INTER] THEN
    MATCH_MP_TAC(REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET) THEN
    ASM_SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    MATCH_MP_TAC CONNECTED_INTERMEDIATE_CLOSURE THEN
    EXISTS_TAC ``connected_component s (x:real)`` THEN
    SIMP_TAC std_ss [INTER_SUBSET, CONNECTED_CONNECTED_COMPONENT,
                SUBSET_INTER, CONNECTED_COMPONENT_SUBSET, CLOSURE_SUBSET]]);

val BIGUNION_DIFF = store_thm ("BIGUNION_DIFF",
 ``!s t. BIGUNION s DIFF t = BIGUNION {x DIFF t | x IN s}``,
  SIMP_TAC std_ss [BIGUNION_GSPEC] THEN SET_TAC[]);

val OPEN_IN_CONNECTED_COMPONENT = store_thm ("OPEN_IN_CONNECTED_COMPONENT",
 ``!s x:real.
        FINITE {connected_component s x |x| x IN s}
        ==> open_in (subtopology euclidean s) (connected_component s x)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``connected_component s (x:real) =
        s DIFF (BIGUNION {connected_component s y |y| y IN s} DIFF
                connected_component s x)``
  SUBST1_TAC THENL
   [REWRITE_TAC[BIGUNION_CONNECTED_COMPONENT] THEN
    MATCH_MP_TAC(SET_RULE ``t SUBSET s ==> (t = s DIFF (s DIFF t))``) THEN
    SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET],
    MATCH_MP_TAC OPEN_IN_DIFF THEN
    SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV] THEN
    SIMP_TAC std_ss [BIGUNION_DIFF] THEN
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
        CONJ_TAC THENL [METIS_TAC [GSYM IMAGE_DEF, IMAGE_FINITE], ALL_TAC] THEN
    X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    SUBGOAL_THEN
    ``(connected_component s y DIFF connected_component s x =
       connected_component s y) \/
      (connected_component s (y:real) DIFF connected_component s x = {})``
     (DISJ_CASES_THEN SUBST1_TAC)
    THENL
     [MATCH_MP_TAC(SET_RULE
       ``(~(s INTER t = {}) ==> (s = t)) ==> (s DIFF t = s) \/ (s DIFF t = {})``) THEN
      SIMP_TAC std_ss [CONNECTED_COMPONENT_OVERLAP],
      REWRITE_TAC[CLOSED_IN_CONNECTED_COMPONENT],
      REWRITE_TAC[CLOSED_IN_EMPTY]]]);

val CONNECTED_COMPONENT_EQUIVALENCE_RELATION = store_thm ("CONNECTED_COMPONENT_EQUIVALENCE_RELATION",
 ``!R s:real->bool.
        (!x y. R x y ==> R y x) /\
        (!x y z. R x y /\ R y z ==> R x z) /\
        (!a. a IN s
             ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
                     !x. x IN t ==> R a x)
        ==> !a b. connected_component s a b ==> R a b``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``R:real->real->bool``, ``connected_component s (a:real)``]
    CONNECTED_EQUIVALENCE_RELATION) THEN
  ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
  KNOW_TAC ``(!(a' :real).
        a' IN connected_component (s :real -> bool) (a :real) ==>
        ?(t :real -> bool).
          open_in (subtopology euclidean (connected_component s a)) t /\
          a' IN t /\
          !(x :real). x IN t ==> (R :real -> real -> bool) a' x)`` THENL
   [X_GEN_TAC ``c:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``c:real``) THEN
    KNOW_TAC ``(c :real) IN (s :real -> bool)`` THENL
     [ASM_MESON_TAC[CONNECTED_COMPONENT_SUBSET, SUBSET_DEF],
          DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``t INTER connected_component s (a:real)`` THEN
    ASM_SIMP_TAC std_ss [IN_INTER, OPEN_IN_OPEN] THEN
        UNDISCH_TAC ``open_in (subtopology euclidean s) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    SIMP_TAC std_ss [] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``a:real``]
        CONNECTED_COMPONENT_SUBSET) THEN
    SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN MATCH_MP_TAC THEN ASM_SIMP_TAC std_ss [IN_DEF] THEN
    REWRITE_TAC[CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_MESON_TAC[CONNECTED_COMPONENT_IN]]);

val CONNECTED_COMPONENT_INTERMEDIATE_SUBSET = store_thm ("CONNECTED_COMPONENT_INTERMEDIATE_SUBSET",
 ``!t u a:real.
        connected_component u a SUBSET t /\ t SUBSET u
        ==> (connected_component t a = connected_component u a)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(a:real) IN u`` THENL
   [REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_UNIQUE THEN
    ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
    CONJ_TAC THENL [ASM_MESON_TAC[CONNECTED_COMPONENT_REFL, IN_DEF], ALL_TAC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_SET_TAC[],
    ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY, SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* The set of connected components of a set.                                 *)
(* ------------------------------------------------------------------------- *)

val components = new_definition ("components",
  ``components s = {connected_component s x | x | x:real IN s}``);

val IN_COMPONENTS = store_thm ("IN_COMPONENTS",
 ``!u:real->bool s. s IN components u
    <=> ?x. x IN u /\ (s = connected_component u x)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[components] THEN EQ_TAC
  THENL [SET_TAC[], STRIP_TAC THEN ASM_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``x:real IN u`` THEN SET_TAC[]]);

val BIGUNION_COMPONENTS = store_thm
  ("BIGUNION_COMPONENTS",
  ``!u:real->bool. u = BIGUNION (components u)``,
    REWRITE_TAC [EXTENSION]
 >> REPEAT GEN_TAC >> EQ_TAC
 >| [ (* goal 1 (of 2) *)
      DISCH_TAC >> REWRITE_TAC [IN_BIGUNION] \\
      EXISTS_TAC ``connected_component (u:real->bool) x`` \\
      CONJ_TAC >|
      [ REWRITE_TAC [CONNECTED_COMPONENT_SET] \\
        SUBGOAL_THEN ``?s:real->bool. connected s /\ s SUBSET u /\ x IN s`` MP_TAC >|
        [ EXISTS_TAC ``{x:real}`` \\
          ASM_REWRITE_TAC [CONNECTED_SING] \\
          POP_ASSUM MP_TAC >> SET_TAC [],
          SET_TAC [] ],
        REWRITE_TAC [components] >> ASM_SET_TAC [] ],
      (* goal 2 of 2 *)
      REWRITE_TAC [IN_BIGUNION] \\
      STRIP_TAC \\
      MATCH_MP_TAC (SET_RULE ``!x:real s u. x IN s /\ s SUBSET u ==> x IN u``) \\
      EXISTS_TAC ``s :real -> bool`` >> ASM_REWRITE_TAC [] \\
      `?(y :real). ((s :real -> bool) = connected_component u y)`
                by METIS_TAC [IN_COMPONENTS] \\
      ASM_REWRITE_TAC [CONNECTED_COMPONENT_SUBSET] ]);

val PAIRWISE_DISJOINT_COMPONENTS = store_thm ("PAIRWISE_DISJOINT_COMPONENTS",
 ``!u:real->bool. pairwise DISJOINT (components u)``,
  GEN_TAC THEN REWRITE_TAC[pairwise, DISJOINT_DEF] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``t:real->bool``] THEN STRIP_TAC THEN
  ASSERT_TAC ``(?a. s:real->bool = connected_component u a) /\
                ?b. t:real->bool = connected_component u b``
  THENL [ASM_MESON_TAC[IN_COMPONENTS],
  ASM_MESON_TAC[CONNECTED_COMPONENT_NONOVERLAP]]);

val IN_COMPONENTS_NONEMPTY = store_thm ("IN_COMPONENTS_NONEMPTY",
 ``!s c. c IN components s ==> ~(c = {})``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY]);

val IN_COMPONENTS_SUBSET = store_thm ("IN_COMPONENTS_SUBSET",
 ``!s c. c IN components s ==> c SUBSET s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_COMPONENT_SUBSET]);

val IN_COMPONENTS_CONNECTED = store_thm ("IN_COMPONENTS_CONNECTED",
 ``!s c. c IN components s ==> connected c``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT]);

val IN_COMPONENTS_MAXIMAL = store_thm ("IN_COMPONENTS_MAXIMAL",
 ``!s c:real->bool.
        c IN components s <=>
        ~(c = {}) /\ c SUBSET s /\ connected c /\
        !c'. ~(c' = {}) /\ c SUBSET c' /\ c' SUBSET s /\ connected c'
             ==> (c' = c)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``x:real`` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY, CONNECTED_COMPONENT_SUBSET,
                    CONNECTED_CONNECTED_COMPONENT] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_MESON_TAC[CONNECTED_COMPONENT_REFL, IN_DEF, SUBSET_DEF],
    STRIP_TAC THEN
        UNDISCH_TAC ``(c:real->bool) <> {}`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
        STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN CONJ_TAC THENL
        [ALL_TAC, ASM_SET_TAC[]] THEN
    MATCH_MP_TAC(GSYM CONNECTED_COMPONENT_UNIQUE) THEN
    ASM_REWRITE_TAC[] THEN X_GEN_TAC ``c':real->bool`` THEN STRIP_TAC THEN
    REWRITE_TAC[SET_RULE ``c' SUBSET c <=> (c' UNION c = c)``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC CONNECTED_UNION THEN ASM_SET_TAC[]]);

val JOINABLE_COMPONENTS_EQ = store_thm ("JOINABLE_COMPONENTS_EQ",
 ``!s t c1 c2.
        connected t /\ t SUBSET s /\
        c1 IN components s /\ c2 IN components s /\
        ~(c1 INTER t = {}) /\ ~(c2 INTER t = {})
        ==> (c1 = c2)``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, components, FORALL_IN_GSPEC] THEN
  MESON_TAC[JOINABLE_CONNECTED_COMPONENT_EQ]);

val CLOSED_IN_COMPONENT = store_thm ("CLOSED_IN_COMPONENT",
 ``!s c:real->bool.
        c IN components s ==> closed_in (subtopology euclidean s) c``,
  SIMP_TAC std_ss [components, FORALL_IN_GSPEC, CLOSED_IN_CONNECTED_COMPONENT]);

val CLOSED_COMPONENTS = store_thm ("CLOSED_COMPONENTS",
 ``!s c. closed s /\ c IN components s ==> closed c``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, components, FORALL_IN_GSPEC] THEN
  SIMP_TAC std_ss [CLOSED_CONNECTED_COMPONENT]);

val COMPACT_COMPONENTS = store_thm ("COMPACT_COMPONENTS",
 ``!s c:real->bool. compact s /\ c IN components s ==> compact c``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
  MESON_TAC[CLOSED_COMPONENTS, IN_COMPONENTS_SUBSET, BOUNDED_SUBSET]);

val CONTINUOUS_ON_COMPONENTS_GEN = store_thm ("CONTINUOUS_ON_COMPONENTS_GEN",
 ``!f:real->real s.
        (!c. c IN components s
             ==> open_in (subtopology euclidean s) c /\ f continuous_on c)
        ==> f continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_OPEN_IN_PREIMAGE_EQ] THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN t} =
     BIGUNION {{x | x IN c /\ f x IN t} | c IN components s}``
  SUBST1_TAC THENL
   [GEN_REWR_TAC LAND_CONV [METIS [BIGUNION_COMPONENTS] ``{x | x IN s /\ f x IN t} =
          {x | x IN BIGUNION (components s) /\ f x IN t}``] THEN
    SIMP_TAC std_ss [BIGUNION_GSPEC, IN_BIGUNION] THEN SET_TAC[],
    MATCH_MP_TAC OPEN_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
    METIS_TAC[OPEN_IN_TRANS]]);

val CONTINUOUS_ON_COMPONENTS_FINITE = store_thm ("CONTINUOUS_ON_COMPONENTS_FINITE",
 ``!f:real->real s.
        FINITE(components s) /\
        (!c. c IN components s ==> f continuous_on c)
        ==> f continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN t} =
    BIGUNION {{x | x IN c /\ f x IN t} | c IN components s}``
  SUBST1_TAC THENL
   [GEN_REWR_TAC LAND_CONV [METIS [BIGUNION_COMPONENTS] ``{x | x IN s /\ f x IN t} =
          {x | x IN BIGUNION (components s) /\ f x IN t}``] THEN
    SIMP_TAC std_ss [BIGUNION_GSPEC, IN_BIGUNION] THEN SET_TAC[],
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN
    ASM_SIMP_TAC std_ss [GSYM IMAGE_DEF, IMAGE_FINITE, FORALL_IN_IMAGE] THEN
    METIS_TAC[CLOSED_IN_TRANS, CLOSED_IN_COMPONENT]]);

val COMPONENTS_NONOVERLAP = store_thm ("COMPONENTS_NONOVERLAP",
 ``!s c c'. c IN components s /\ c' IN components s
            ==> ((c INTER c' = {}) <=> ~(c = c'))``,
  SIMP_TAC std_ss [components, GSPECIFICATION] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_NONOVERLAP]);

val COMPONENTS_EQ = store_thm ("COMPONENTS_EQ",
 ``!s c c'. c IN components s /\ c' IN components s
            ==> ((c = c') <=> ~(c INTER c' = {}))``,
  MESON_TAC[COMPONENTS_NONOVERLAP]);

val COMPONENTS_EQ_EMPTY = store_thm ("COMPONENTS_EQ_EMPTY",
 ``!s. (components s = {}) <=> (s = {})``,
  GEN_TAC THEN REWRITE_TAC[EXTENSION] THEN
  SIMP_TAC std_ss [components, connected_component, GSPECIFICATION] THEN
  SET_TAC[]);

val COMPONENTS_EMPTY = store_thm ("COMPONENTS_EMPTY",
 ``components {} = {}``,
  REWRITE_TAC[COMPONENTS_EQ_EMPTY]);

val CONNECTED_EQ_CONNECTED_COMPONENTS_EQ = store_thm ("CONNECTED_EQ_CONNECTED_COMPONENTS_EQ",
 ``!s. connected s <=>
       !c c'. c IN components s /\ c' IN components s ==> (c = c')``,
  SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  MESON_TAC[CONNECTED_EQ_CONNECTED_COMPONENT_EQ]);

val COMPONENTS_EQ_SING_N_EXISTS = store_thm ("COMPONENTS_EQ_SING_N_EXISTS",
 ``(!s:real->bool. (components s = {s}) <=> connected s /\ ~(s = {})) /\
   (!s:real->bool. (?a. (components s = {a})) <=> connected s /\ ~(s = {}))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN X_GEN_TAC ``s:real->bool`` THEN
  MATCH_MP_TAC(TAUT `(p ==> q) /\ (q ==> r) /\ (r ==> p)
                     ==> (p <=> r) /\ (q <=> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[],
    STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_EQ_CONNECTED_COMPONENTS_EQ] THEN
    ASM_MESON_TAC[IN_SING, COMPONENTS_EQ_EMPTY, NOT_INSERT_EMPTY],
    STRIP_TAC THEN ONCE_REWRITE_TAC[EXTENSION] THEN
    REWRITE_TAC[IN_SING] THEN
    SIMP_TAC std_ss [components, GSPECIFICATION] THEN
    ASM_MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET, MEMBER_NOT_EMPTY]]);

val COMPONENTS_EQ_SING = store_thm ("COMPONENTS_EQ_SING",
 ``(!s:real->bool. (components s = {s}) <=> connected s /\ ~(s = {}))``,
   REWRITE_TAC [COMPONENTS_EQ_SING_N_EXISTS]);

val COMPONENTS_EQ_SING_EXISTS = store_thm ("COMPONENTS_EQ_SING_EXISTS",
 `` (!s:real->bool. (?a. (components s = {a})) <=> connected s /\ ~(s = {}))``,
   REWRITE_TAC [COMPONENTS_EQ_SING_N_EXISTS]);

val COMPONENTS_UNIV = store_thm ("COMPONENTS_UNIV",
 ``components univ(:real) = {univ(:real)}``,
  REWRITE_TAC[COMPONENTS_EQ_SING, CONNECTED_UNIV, UNIV_NOT_EMPTY]);

val CONNECTED_EQ_COMPONENTS_SUBSET_SING = store_thm ("CONNECTED_EQ_COMPONENTS_SUBSET_SING",
 ``!s:real->bool. connected s <=> components s SUBSET {s}``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[COMPONENTS_EMPTY, CONNECTED_EMPTY, EMPTY_SUBSET] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET {a} <=> (s = {}) \/ (s = {a})``] THEN
  ASM_REWRITE_TAC[COMPONENTS_EQ_EMPTY, COMPONENTS_EQ_SING]);

val CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS = store_thm ("CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS",
 ``!s:real->bool. connected s <=> ?a. components s SUBSET {a}``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[COMPONENTS_EMPTY, CONNECTED_EMPTY, EMPTY_SUBSET] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET {a} <=> (s = {}) \/ (s = {a})``] THEN
  ASM_REWRITE_TAC[COMPONENTS_EQ_EMPTY, COMPONENTS_EQ_SING_EXISTS]);

val IN_COMPONENTS_SELF = store_thm ("IN_COMPONENTS_SELF",
 ``!s:real->bool. s IN components s <=> connected s /\ ~(s = {})``,
  GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[IN_COMPONENTS_NONEMPTY, IN_COMPONENTS_CONNECTED],
    SIMP_TAC std_ss [GSYM COMPONENTS_EQ_SING, IN_SING]]);

val     COMPONENTS_MAXIMAL = store_thm ("COMPONENTS_MAXIMAL",
 ``!s t c:real->bool.
     c IN components s /\ connected t /\ t SUBSET s /\ ~(c INTER t = {})
     ==> t SUBSET c``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, components, FORALL_IN_GSPEC] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  SIMP_TAC std_ss [IN_INTER, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(SUBST1_TAC o SYM o MATCH_MP CONNECTED_COMPONENT_EQ) THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN ASM_REWRITE_TAC[]);

val COMPONENTS_UNIQUE = store_thm ("COMPONENTS_UNIQUE",
 ``!s:real->bool k.
        (BIGUNION k = s) /\
        (!c. c IN k
             ==> connected c /\ ~(c = {}) /\
                 !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c))
        ==> (components s = k)``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  X_GEN_TAC ``c:real->bool`` THEN REWRITE_TAC[IN_COMPONENTS] THEN
  EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``x:real``
     (CONJUNCTS_THEN2 ASSUME_TAC SUBST1_TAC)) THEN
        UNDISCH_TAC `` !c. c IN k ==>
            connected c /\ c <> {} /\
            !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c)`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o SPEC ``x:real`` o REWRITE_RULE [EXTENSION]) THEN
    REWRITE_TAC[IN_BIGUNION] THEN ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC ``c:real->bool`` THEN STRIP_TAC THEN
    SUBGOAL_THEN ``connected_component s (x:real) = c``
     (fn th => ASM_REWRITE_TAC[th]) THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_UNIQUE THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    X_GEN_TAC ``c':real->bool`` THEN STRIP_TAC THEN
    REWRITE_TAC[SET_RULE ``c' SUBSET c <=> (c' UNION c = c)``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN CONJ_TAC THENL
     [MATCH_MP_TAC CONNECTED_UNION, ASM_SET_TAC[]] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
        UNDISCH_TAC ``c <> {}:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
        STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN
    CONJ_TAC THENL [ASM_SET_TAC[], CONV_TAC SYM_CONV] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT, CONNECTED_COMPONENT_SUBSET] THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]]);

val COMPONENTS_UNIQUE_EQ = store_thm ("COMPONENTS_UNIQUE_EQ",
 ``!s:real->bool k.
        (components s = k) <=>
        (BIGUNION k = s) /\
        (!c. c IN k
             ==> connected c /\ ~(c = {}) /\
                 !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c))``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(SUBST1_TAC o SYM), REWRITE_TAC[COMPONENTS_UNIQUE]] THEN
  REWRITE_TAC[GSYM BIGUNION_COMPONENTS] THEN
  X_GEN_TAC ``c:real->bool`` THEN DISCH_TAC THEN REPEAT CONJ_TAC THENL
   [ASM_MESON_TAC[IN_COMPONENTS_CONNECTED],
    ASM_MESON_TAC[IN_COMPONENTS_NONEMPTY],
    RULE_ASSUM_TAC(REWRITE_RULE[IN_COMPONENTS_MAXIMAL]) THEN
    ASM_MESON_TAC[SUBSET_EMPTY]]);

val EXISTS_COMPONENT_SUPERSET = store_thm ("EXISTS_COMPONENT_SUPERSET",
 ``!s t:real->bool.
        t SUBSET s /\ ~(s = {}) /\ connected t
        ==> ?c. c IN components s /\ t SUBSET c``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [ASM_REWRITE_TAC[EMPTY_SUBSET] THEN
    ASM_MESON_TAC[COMPONENTS_EQ_EMPTY, MEMBER_NOT_EMPTY],
    FIRST_X_ASSUM(X_CHOOSE_TAC ``a:real`` o
      REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    EXISTS_TAC ``connected_component s (a:real)`` THEN
    REWRITE_TAC[IN_COMPONENTS] THEN CONJ_TAC THENL
     [ASM_SET_TAC[], ASM_MESON_TAC[CONNECTED_COMPONENT_MAXIMAL]]]);

val COMPONENTS_INTERMEDIATE_SUBSET = store_thm ("COMPONENTS_INTERMEDIATE_SUBSET",
 ``!s t u:real->bool.
        s IN components u /\ s SUBSET t /\ t SUBSET u
        ==> s IN components t``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [IN_COMPONENTS, GSYM LEFT_EXISTS_AND_THM] THEN
  MESON_TAC[CONNECTED_COMPONENT_INTERMEDIATE_SUBSET, SUBSET_DEF,
            CONNECTED_COMPONENT_REFL, IN_DEF, CONNECTED_COMPONENT_SUBSET]);

val IN_COMPONENTS_BIGUNION_COMPLEMENT = store_thm ("IN_COMPONENTS_BIGUNION_COMPLEMENT",
 ``!s c:real->bool.
        c IN components s
        ==> (s DIFF c = BIGUNION(components s DELETE c))``,
  SIMP_TAC std_ss [components, FORALL_IN_GSPEC,
              COMPLEMENT_CONNECTED_COMPONENT_BIGUNION]);

val CONNECTED_SUBSET_CLOPEN = store_thm ("CONNECTED_SUBSET_CLOPEN",
 ``!u s c:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s /\
        connected c /\ c SUBSET u /\ ~(c INTER s = {})
        ==> c SUBSET s``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected c`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CONNECTED_CLOSED_IN]) THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN DISCH_THEN(MP_TAC o
    SPECL [``c INTER s:real->bool``, ``c DIFF s:real->bool``]) THEN
  KNOW_TAC ``~((((closed_in (subtopology euclidean (c :real -> bool))
               (c INTER (s :real -> bool)) /\
               closed_in (subtopology euclidean c) (c DIFF s)) /\
               (c SUBSET c INTER s UNION (c DIFF s))) /\
               (c INTER s INTER (c DIFF s) = ({} :real -> bool))) /\
     ~(c SUBSET s)) ==> c SUBSET s`` THENL
         [ALL_TAC, METIS_TAC [CONJ_ASSOC, SET_RULE ``(c DIFF s = {}) <=> c SUBSET s``]] THEN
  MATCH_MP_TAC(TAUT `p ==> ~(p /\ ~q) ==> q`) THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  CONJ_TAC THENL
   [UNDISCH_TAC ``closed_in (subtopology euclidean u) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CLOSED_IN_CLOSED]),
        UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN])] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[OPEN_IN_OPEN, CLOSED_IN_CLOSED] THENL
   [EXISTS_TAC ``t:real->bool``, EXISTS_TAC ``univ(:real) DIFF t``] THEN
  ASM_REWRITE_TAC[GSYM OPEN_CLOSED] THEN ASM_SET_TAC[]);

val CLOPEN_BIGUNION_COMPONENTS = store_thm ("CLOPEN_BIGUNION_COMPONENTS",
 ``!u s:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s
        ==> ?k. k SUBSET components u /\ (s = BIGUNION k)``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``{c:real->bool | c IN components u /\ ~(c INTER s = {})}`` THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT] THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  CONJ_TAC THENL
   [MP_TAC(ISPEC ``u:real->bool`` BIGUNION_COMPONENTS) THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN SET_TAC[],
    SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_SUBSET_CLOPEN THEN
    EXISTS_TAC ``u:real->bool`` THEN
    ASM_MESON_TAC[IN_COMPONENTS_CONNECTED, IN_COMPONENTS_SUBSET]]);

val CLOPEN_IN_COMPONENTS = store_thm ("CLOPEN_IN_COMPONENTS",
 ``!u s:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s /\
        connected s /\ ~(s = {})
        ==> s IN components u``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[CONJ_ASSOC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CLOPEN_BIGUNION_COMPONENTS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``k:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGUNION_EMPTY] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``c:real->bool``) THEN
  ASM_CASES_TAC ``k = {c:real->bool}`` THENL
   [METIS_TAC[BIGUNION_SING, GSYM SING_SUBSET], ALL_TAC] THEN
  MATCH_MP_TAC(TAUT `~p ==> p /\ q ==> r`) THEN
  SUBGOAL_THEN ``?c':real->bool. c' IN k /\ ~(c = c')`` STRIP_ASSUME_TAC THENL
   [ASM_MESON_TAC[SET_RULE
     ``a IN s /\ ~(s = {a}) ==> ?b. b IN s /\ ~(b = a)``],
    REWRITE_TAC[CONNECTED_EQ_CONNECTED_COMPONENTS_EQ] THEN
    DISCH_THEN(MP_TAC o SPECL [``c:real->bool``, ``c':real->bool``]) THEN
    ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THEN
    MATCH_MP_TAC COMPONENTS_INTERMEDIATE_SUBSET THEN
    EXISTS_TAC ``u:real->bool`` THEN
    MP_TAC(ISPEC ``u:real->bool`` BIGUNION_COMPONENTS) THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Continuity implies uniform continuity on a compact domain.                *)
(* ------------------------------------------------------------------------- *)

val COMPACT_UNIFORMLY_EQUICONTINUOUS = store_thm ("COMPACT_UNIFORMLY_EQUICONTINUOUS",
 ``!(fs:(real->real)->bool) s.
     (!x e. x IN s /\ &0 < e
            ==> ?d. &0 < d /\
                    (!f x'. f IN fs /\ x' IN s /\ dist (x',x) < d
                            ==> dist (f x',f x) < e)) /\
     compact s
     ==> !e. &0 < e
             ==> ?d. &0 < d /\
                     !f x x'. f IN fs /\ x IN s /\ x' IN s /\ dist (x',x) < d
                              ==> dist(f x',f x) < e``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``d:real->real->real`` THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o MATCH_MP HEINE_BOREL_LEMMA) THEN
  DISCH_THEN(MP_TAC o SPEC
    ``{ ball(x:real,d x (e / &2:real)) | x IN s}``) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, OPEN_BALL, BIGUNION_GSPEC, SUBSET_DEF, GSPECIFICATION] THEN
  KNOW_TAC ``(!(x :real).
        x IN (s :real -> bool) ==>
        ?(x' :real).
          x' IN s /\
          x IN
          ball
            (x',
             (d :real -> real -> real) x'
               ((e :real) / (2 :real))))`` THENL
  [ASM_MESON_TAC[CENTRE_IN_BALL, REAL_HALF], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``k:real``) THEN EXISTS_TAC ``k:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  MAP_EVERY X_GEN_TAC [``f:real->real``, ``u:real``, ``v:real``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``v:real`` th) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(CHOOSE_THEN MP_TAC)) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``u:real`` th) THEN MP_TAC(SPEC ``v:real`` th)) THEN
  ASM_SIMP_TAC std_ss [DIST_REFL] THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN (X_CHOOSE_TAC ``w:real``) THEN ASM_REWRITE_TAC [] THEN
  ASM_REWRITE_TAC[CENTRE_IN_BALL] THEN ASM_REWRITE_TAC[IN_BALL] THEN
  ONCE_REWRITE_TAC[DIST_SYM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real``, ``e / &2:real``]) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(MP_TAC o SPEC ``f:real->real`` o CONJUNCT2) THEN
  DISCH_THEN(fn th => MP_TAC(SPEC ``u:real`` th) THEN
                        MP_TAC(SPEC ``v:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN GEN_REWR_TAC (LAND_CONV o LAND_CONV) [DIST_SYM] THEN
  REWRITE_TAC [dist] THEN GEN_REWR_TAC (RAND_CONV o RAND_CONV o RAND_CONV) [GSYM REAL_HALF] THEN
  REAL_ARITH_TAC);

val COMPACT_UNIFORMLY_CONTINUOUS = store_thm ("COMPACT_UNIFORMLY_CONTINUOUS",
 ``!f:real->real s.
        f continuous_on s /\ compact s ==> f uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on, uniformly_continuous_on] THEN
  STRIP_TAC THEN
  MP_TAC(ISPECL [``{f:real->real}``, ``s:real->bool``]
        COMPACT_UNIFORMLY_EQUICONTINUOUS) THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP, IN_SING, UNWIND_FORALL_THM2] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* A uniformly convergent limit of continuous functions is continuous.       *)
(* ------------------------------------------------------------------------- *)

val ABS_TRIANGLE_LE = store_thm ("ABS_TRIANGLE_LE",
 ``!x y. abs(x) + abs(y) <= e ==> abs(x + y) <= e:real``,
  METIS_TAC[REAL_LE_TRANS, ABS_TRIANGLE]);

val CONTINUOUS_UNIFORM_LIMIT = store_thm ("CONTINUOUS_UNIFORM_LIMIT",
 ``!net f:'a->real->real g s.
        ~(trivial_limit net) /\
        eventually (\n. (f n) continuous_on s) net /\
        (!e. &0 < e
             ==> eventually (\n. !x. x IN s ==> abs(f n x - g x) < e) net)
        ==> g continuous_on s``,
  REWRITE_TAC[continuous_on] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &3:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  UNDISCH_TAC ``eventually
        (\n. !x. x IN s ==>
             !e. 0 < e ==>
               ?d. 0 < d /\
                 !x'. x' IN s /\ dist (x',x) < d ==>
                   dist (f n x',f n x) < e) net`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th => MP_TAC th THEN REWRITE_TAC[AND_IMP_INTRO] THEN
        GEN_REWR_TAC LAND_CONV [GSYM EVENTUALLY_AND]) THEN
  DISCH_THEN(MP_TAC o MATCH_MP EVENTUALLY_HAPPENS) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``a:'a`` THEN
  DISCH_THEN(CONJUNCTS_THEN2 (MP_TAC o SPEC ``x:real``) ASSUME_TAC) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN POP_ASSUM (MP_TAC o Q.SPEC `y:real`) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(fn th =>
   MP_TAC(SPEC ``x:real`` th) THEN MP_TAC(SPEC ``y:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
  MATCH_MP_TAC(REAL_ARITH ``w <= x + y + z
    ==> x * &3 < e ==> y * &3 < e ==> z * &3 < e ==> w < e:real``) THEN
  REWRITE_TAC[dist] THEN
  SUBST1_TAC(REAL_ARITH
   ``(g:real->real) y - g x =
    -(f (a:'a) y - g y) + (f a x - g x) + (f a y - f a x)``) THEN
  MATCH_MP_TAC ABS_TRIANGLE_LE THEN SIMP_TAC std_ss [ABS_NEG, REAL_LE_LADD] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN SIMP_TAC std_ss [REAL_LE_REFL] THEN
  MATCH_MP_TAC ABS_TRIANGLE_LE THEN REWRITE_TAC[ABS_NEG, REAL_LE_REFL]);

(* ------------------------------------------------------------------------- *)
(* Topological stuff lifted from and dropped to R                            *)
(* ------------------------------------------------------------------------- *)

val OPEN = store_thm ("OPEN",
 ``!s. open s <=>
        !x. x IN s ==> ?e. &0 < e /\ !x'. abs(x' - x) < e ==> x' IN s``,
  REWRITE_TAC[open_def, dist]);

val CLOSED = store_thm ("CLOSED",
 ``!s. closed s <=>
        !x. (!e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ abs(x' - x) < e)
            ==> x IN s``,
   SIMP_TAC std_ss [open_def, closed_def, dist, IN_DIFF, IN_UNIV] THEN
   SET_TAC []);

val CONTINUOUS_AT_RANGE = store_thm ("CONTINUOUS_AT_RANGE",
 ``!f x. f continuous (at x) <=>
                !e. &0 < e
                    ==> ?d. &0 < d /\
                            (!x'. abs(x' - x) < d
                                  ==> abs(f x' - f x) < e)``,
  REWRITE_TAC[continuous_at, o_THM, dist] THEN REWRITE_TAC[dist]);

val CONTINUOUS_ON_RANGE = store_thm ("CONTINUOUS_ON_RANGE",
 ``!f s. f continuous_on s <=>
         !x. x IN s
             ==> !e. &0 < e
                     ==> ?d. &0 < d /\
                             (!x'. x' IN s /\ abs(x' - x) < d
                                   ==> abs(f x' - f x) < e)``,
  REWRITE_TAC[continuous_on, o_THM, dist] THEN REWRITE_TAC[dist]);

val CONTINUOUS_ABS_COMPOSE = store_thm ("CONTINUOUS_ABS_COMPOSE",
 ``!net f:'a->real.
        f continuous net
        ==> (\x. abs(f x)) continuous net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous, tendsto] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] EVENTUALLY_MONO) THEN
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_ON_ABS_COMPOSE = store_thm ("CONTINUOUS_ON_ABS_COMPOSE",
 ``!f:real->real s.
        f continuous_on s
        ==> (\x. abs(f x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ABS_COMPOSE]);

val CONTINUOUS_AT_ABS = store_thm ("CONTINUOUS_AT_ABS",
 ``!x. abs continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT_RANGE] THEN
  METIS_TAC [ABS_SUB_ABS, REAL_LET_TRANS]);

val CONTINUOUS_AT_DIST = store_thm ("CONTINUOUS_AT_DIST",
 ``!a:real x. (\x. dist(a,x)) continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT_RANGE, dist] THEN
  METIS_TAC[REAL_ARITH ``abs(abs(a:real - x) - abs(a - y)) <= abs(x - y)``,
            REAL_LET_TRANS]);

val CONTINUOUS_ON_DIST = store_thm ("CONTINUOUS_ON_DIST",
 ``!a s. (\x. dist(a,x)) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_RANGE, dist] THEN
  METIS_TAC [REAL_ARITH ``abs(abs(a:real - x) - abs(a - y)) <= abs(x - y)``,
            REAL_LET_TRANS]);

(* ------------------------------------------------------------------------- *)
(* Hence some handy theorems on distance, diameter etc. of/from a set.       *)
(* ------------------------------------------------------------------------- *)

val COMPACT_ATTAINS_SUP = store_thm ("COMPACT_ATTAINS_SUP",
 ``!s. compact s /\ ~(s = {})
       ==> ?x. x IN s /\ !y. y IN s ==> y <= x``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``s:real->bool`` BOUNDED_HAS_SUP) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``sup (s:real->bool)`` THEN ASM_SIMP_TAC std_ss [] THEN
  METIS_TAC [CLOSED, REAL_ARITH ``s <= s - e <=> ~(&0 < e:real)``,
             REAL_ARITH ``x <= s /\ ~(x <= s - e) ==> abs(x - s) < e:real``]);

val COMPACT_ATTAINS_INF = store_thm ("COMPACT_ATTAINS_INF",
 ``!s. compact s /\ ~(s = {})
       ==> ?x. x IN s /\ !y. y IN s ==> x <= y``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``s:real->bool`` BOUNDED_HAS_INF) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``inf (s:real->bool)`` THEN ASM_REWRITE_TAC[] THEN
  METIS_TAC[ CLOSED, REAL_ARITH ``s + e <= s <=> ~(&0 < e:real)``,
                REAL_ARITH ``s <= x /\ ~(s + e <= x) ==> abs(x - s) < e:real``]);

val CONTINUOUS_ATTAINS_SUP = store_thm ("CONTINUOUS_ATTAINS_SUP",
 ``!f:real->real s.
        compact s /\ ~(s = {}) /\ (f) continuous_on s
        ==> ?x. x IN s /\ !y. y IN s ==> f(y) <= f(x)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``IMAGE (f:real->real) s`` COMPACT_ATTAINS_SUP) THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, COMPACT_CONTINUOUS_IMAGE, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[IN_IMAGE]);

val CONTINUOUS_ATTAINS_INF = store_thm ("CONTINUOUS_ATTAINS_INF",
 ``!f:real->real s.
        compact s /\ ~(s = {}) /\ (f) continuous_on s
        ==> ?x. x IN s /\ !y. y IN s ==> f(x) <= f(y)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``IMAGE (f:real->real) s`` COMPACT_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, COMPACT_CONTINUOUS_IMAGE, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[IN_IMAGE]);

val DISTANCE_ATTAINS_SUP = store_thm ("DISTANCE_ATTAINS_SUP",
 ``!s a. compact s /\ ~(s = {})
         ==> ?x. x IN s /\ !y. y IN s ==> dist(a,y) <= dist(a,x)``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (a,x) = (\x. dist (a,x)) x:real``] THEN
  MATCH_MP_TAC CONTINUOUS_ATTAINS_SUP THEN
  ASM_REWRITE_TAC[CONTINUOUS_ON_RANGE] THEN REWRITE_TAC[dist] THEN
  ASM_MESON_TAC[REAL_LET_TRANS, ABS_SUB_ABS, ABS_NEG,
                REAL_ARITH ``(a - x) - (a - y) = -(x - y):real``]);

(* ------------------------------------------------------------------------- *)
(* For *minimal* distance, we only need closure, not compactness.            *)
(* ------------------------------------------------------------------------- *)

val DISTANCE_ATTAINS_INF = store_thm ("DISTANCE_ATTAINS_INF",
 ``!s a:real.
        closed s /\ ~(s = {})
        ==> ?x. x IN s /\ !y. y IN s ==> dist(a,x) <= dist(a,y)``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  DISCH_THEN(X_CHOOSE_TAC ``b:real``) THEN
  MP_TAC(ISPECL [``\x:real. dist(a,x)``, ``cball(a:real,dist(b,a)) INTER s``]
                CONTINUOUS_ATTAINS_INF) THEN
  KNOW_TAC ``compact
   (cball ((a :real),(dist ((b :real),a) :real)) INTER
    (s :real -> bool)) /\
    cball (a,(dist (b,a) :real)) INTER s <> ({} :real -> bool) /\
    (\(x :real). (dist (a,x) :real)) continuous_on
    cball (a,(dist (b,a) :real)) INTER s`` THENL
   [ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER, BOUNDED_INTER,
                 BOUNDED_CBALL, CLOSED_CBALL, GSYM MEMBER_NOT_EMPTY] THEN
    SIMP_TAC std_ss [dist, CONTINUOUS_ON_RANGE, IN_INTER, IN_CBALL] THEN
    METIS_TAC[REAL_LET_TRANS, ABS_SUB_ABS, ABS_NEG, REAL_LE_REFL,
            ABS_SUB, REAL_ARITH ``(a - x) - (a - y) = -(x - y:real):real``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
    POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, IN_CBALL] THEN
    METIS_TAC[DIST_SYM, REAL_LE_TOTAL, REAL_LE_TRANS]]);

(* ------------------------------------------------------------------------- *)
(* We can now extend limit compositions to consider the scalar multiplier.   *)
(* ------------------------------------------------------------------------- *)

val LIM_MUL = store_thm ("LIM_MUL",
 ``!net:('a)net f l:real c d.
        (c --> d) net /\ (f --> l) net
        ==> ((\x. c(x) * f(x)) --> (d * l)) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``net:('a)net``, ``\x y:real. x * y``, ``c:'a->real``,
  ``f:'a->real``, ``d:real``, ``l:real``] LIM_BILINEAR) THEN
  BETA_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN MATCH_MP_TAC THEN
  REWRITE_TAC[bilinear, linear] THEN BETA_TAC THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LIM_VMUL = store_thm ("LIM_VMUL",
 ``!net:('a)net c d v:real.
  (c --> d) net ==> ((\x. c(x) * v) --> (d * v)) net``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``(((\(x :'a). (c :'a -> real) x * (v :real)) -->
                             ((d :real) * v)) (net :'a net)) =
             (((\(x :'a). (c :'a -> real) x * (\x. v :real) x) -->
                             ((d :real) * v)) (net :'a net))`` THENL
 [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
 MATCH_MP_TAC LIM_MUL THEN ASM_REWRITE_TAC[LIM_CONST]);

val CONTINUOUS_VMUL = store_thm ("CONTINUOUS_VMUL",
 ``!net c v. c continuous net ==> (\x. c(x) * v) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_VMUL, o_THM]);

val CONTINUOUS_MUL = store_thm ("CONTINUOUS_MUL",
 ``!net f c. c continuous net /\ f continuous net
             ==> (\x. c(x) * f(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MUL, o_THM]);

val CONTINUOUS_ON_VMUL = store_thm ("CONTINUOUS_ON_VMUL",
 ``!s c v. c continuous_on s ==> (\x. c(x) * v) continuous_on s``,
  REWRITE_TAC [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  SIMP_TAC std_ss [CONTINUOUS_VMUL]);

val CONTINUOUS_ON_MUL = store_thm ("CONTINUOUS_ON_MUL",
 ``!s c f. c continuous_on s /\ f continuous_on s
           ==> (\x. c(x) * f(x)) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  SIMP_TAC std_ss [CONTINUOUS_MUL]);

val CONTINUOUS_POW = store_thm ("CONTINUOUS_POW",
 ``!net f:'a->real n.
        (\x. f x) continuous net
        ==> (\x. f x pow n) continuous net``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  INDUCT_TAC THEN ASM_SIMP_TAC std_ss [pow, CONTINUOUS_CONST] THEN
  KNOW_TAC ``((\x:'a. f x * f x pow n) continuous net) =
             ((\x:'a. f x * (\x. f x pow n) x)  continuous net)`` THENL
  [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC CONTINUOUS_MUL THEN METIS_TAC [o_DEF, ETA_AX]);

val CONTINUOUS_ON_POW = store_thm ("CONTINUOUS_ON_POW",
 ``!f:real->real s n.
        (\x. f x) continuous_on s
        ==> (\x. f x pow n) continuous_on s``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN INDUCT_TAC THEN
  ASM_SIMP_TAC std_ss[pow, CONTINUOUS_ON_CONST] THEN
  KNOW_TAC ``((\x. (f:real->real) x * f x pow n) continuous_on s:real->bool) =
             ((\x. f x * (\x. f x pow n) x)  continuous_on s)`` THENL
  [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN METIS_TAC [o_DEF, ETA_AX]);

val CONTINUOUS_PRODUCT = store_thm ("CONTINUOUS_PRODUCT",
 ``!net:('a)net f (t:'b->bool).
        FINITE t /\
        (!i. i IN t ==> (\x. (f x i)) continuous net)
        ==> (\x. (product t (f x))) continuous net``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  ONCE_REWRITE_TAC [METIS []
    ``!t. ((!i. i IN t ==> (\x. f x i) continuous net) ==>
  (\x. product t (f x)) continuous net) =
     (\t. (!i. i IN t ==> (\x. f x i) continuous net) ==>
  (\x. product t (f x)) continuous net) t``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN SIMP_TAC std_ss [PRODUCT_CLAUSES] THEN
  SIMP_TAC std_ss [CONTINUOUS_CONST, FORALL_IN_INSERT] THEN
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. f x e * product s (f x)) =
                  (\x. (\x. f x e) x * (\x. product s (f x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_MUL THEN ASM_SIMP_TAC std_ss [o_DEF]);

val CONTINUOUS_ON_PRODUCT = store_thm ("CONTINUOUS_ON_PRODUCT",
 ``!f:real->'a->real s t.
        FINITE t /\
        (!i. i IN t ==> (\x. (f x i)) continuous_on s)
        ==> (\x. (product t (f x))) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_PRODUCT]);

(* ------------------------------------------------------------------------- *)
(* And so we have continuity of inverse.                                     *)
(* ------------------------------------------------------------------------- *)

val LIM_INV = store_thm ("LIM_INV",
 ``!net:('a)net f l.
        (f --> l) net /\ ~(l = &0)
        ==> ((inv o f) --> (inv l)) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit(net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[o_THM, dist] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min (abs(l) / &2) ((l pow 2 * e) / &2:real)``) THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  KNOW_TAC ``0 < abs l / 2 /\ 0 < l pow 2 * e / 2:real`` THENL
   [ASM_SIMP_TAC arith_ss [GSYM ABS_NZ, REAL_LT_DIV, REAL_LT] THEN
    MATCH_MP_TAC REAL_LT_DIV THEN SIMP_TAC arith_ss [REAL_LT] THEN
    ONCE_REWRITE_TAC[GSYM REAL_POW2_ABS] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MUL, GSYM ABS_NZ, REAL_POW_LT],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:'a``) THEN EXISTS_TAC ``a:'a`` THEN
  POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  DISCH_TAC THEN X_GEN_TAC ``b:'a`` THEN POP_ASSUM (MP_TAC o Q.SPEC `b:'a`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  SIMP_TAC arith_ss [REAL_LT_RDIV_EQ, REAL_LT] THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP (REAL_ARITH
   ``abs(x - l) * &2 < abs l ==> ~(x = &0:real)``)) THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_INV2, ABS_DIV, REAL_LT_LDIV_EQ,
               GSYM ABS_NZ, REAL_ENTIRE] THEN
  FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``abs(x - y) * &2 < b * c ==> c * b <= d * &2 ==> abs(y - x) < d:real``)) THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_MUL_ASSOC, REAL_LE_LMUL] THEN
  ONCE_REWRITE_TAC[GSYM REAL_POW2_ABS] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, POW_2, REAL_MUL_ASSOC, GSYM ABS_NZ,
               REAL_LE_RMUL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``abs(x - y) * &2 < abs y ==> abs y <= &2 * abs x:real``]);

val CONTINUOUS_INV = store_thm ("CONTINUOUS_INV",
 ``!net f. f continuous net /\ ~(f(netlimit net) = &0)
           ==> (inv o f) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_INV, o_THM]);

val CONTINUOUS_AT_WITHIN_INV = store_thm ("CONTINUOUS_AT_WITHIN_INV",
 ``!f s a:real.
        f continuous (at a within s) /\ ~(f a = &0)
        ==> (inv o f) continuous (at a within s)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``trivial_limit (at (a:real) within s)`` THENL
   [ASM_REWRITE_TAC[continuous, LIM],
    ASM_SIMP_TAC std_ss [NETLIMIT_WITHIN, CONTINUOUS_INV]]);

val CONTINUOUS_AT_INV = store_thm ("CONTINUOUS_AT_INV",
 ``!f a. f continuous at a /\ ~(f a = &0)
         ==> (inv o f) continuous at a``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_AT_WITHIN_INV]);

val CONTINUOUS_ON_INV = store_thm ("CONTINUOUS_ON_INV",
 ``!f s. f continuous_on s /\ (!x. x IN s ==> ~(f x = &0))
         ==> (inv o f) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_AT_WITHIN_INV]);

(* ------------------------------------------------------------------------- *)
(* Hence some useful properties follow quite easily.                         *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_SCALING = store_thm ("CONNECTED_SCALING",
 ``!s:real->bool c. connected s ==> connected (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val CONNECTED_NEGATIONS = store_thm ("CONNECTED_NEGATIONS",
 ``!s:real->bool. connected s ==> connected (IMAGE (\x. -x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_SCALING = store_thm ("COMPACT_SCALING",
 ``!s:real->bool c. compact s ==> compact (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_NEGATIONS = store_thm ("COMPACT_NEGATIONS",
 ``!s:real->bool. compact s ==> compact (IMAGE (\x. -x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_AFFINITY = store_thm ("COMPACT_AFFINITY",
 ``!s a:real c.
        compact s ==> compact (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IMAGE_COMPOSE, COMPACT_TRANSLATION, COMPACT_SCALING]);

(* ------------------------------------------------------------------------- *)
(* We can state this in terms of diameter of a set.                          *)
(* ------------------------------------------------------------------------- *)

val diameter = new_definition ("diameter",
  ``diameter s =
        if s = {} then (&0:real)
        else sup {abs(x - y) | x IN s /\ y IN s}``);

val DIAMETER_BOUNDED = store_thm ("DIAMETER_BOUNDED",
 ``!s. bounded s
       ==> (!x:real y. x IN s /\ y IN s ==> abs(x - y) <= diameter s) /\
           (!d. &0 <= d /\ d < diameter s
                ==> ?x y. x IN s /\ y IN s /\ abs(x - y) > d)``,
  GEN_TAC THEN DISCH_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[diameter, NOT_IN_EMPTY, REAL_LET_ANTISYM] THENL
  [SIMP_TAC std_ss [REAL_NOT_LE, REAL_NOT_LT, REAL_LTE_TOTAL], ALL_TAC] THEN
  MP_TAC(SPEC ``{abs(x - y:real) | x IN s /\ y IN s}`` SUP) THEN
  ABBREV_TAC ``b = sup {abs(x - y:real) | x IN s /\ y IN s}`` THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[NOT_IN_EMPTY, real_gt] THEN
  KNOW_TAC ``(?(x :real) (p_1 :real) (p_2 :real).
    (x = abs (p_1 - p_2)) /\ p_1 IN (s :real -> bool) /\ p_2 IN s) /\
 (?(b :real).
    !(x :real).
      (?(p_1 :real) (p_2 :real).
         (x = abs (p_1 - p_2)) /\ p_1 IN s /\ p_2 IN s) ==>
      x <= b)`` THENL
   [CONJ_TAC THENL [METIS_TAC[MEMBER_NOT_EMPTY], ALL_TAC],
    METIS_TAC[REAL_NOT_LE]] THEN
  SIMP_TAC std_ss [REAL_SUB, LEFT_IMP_EXISTS_THM] THEN
  UNDISCH_TAC ``bounded s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [bounded_def]) THEN
  REWRITE_TAC [real_sub] THEN
  METIS_TAC [REAL_ARITH ``x <= y + z /\ y <= b /\ z <= b ==> x <= b + b:real``,
            ABS_TRIANGLE, ABS_NEG]);

val DIAMETER_BOUNDED_BOUND = store_thm ("DIAMETER_BOUNDED_BOUND",
 ``!s x y. bounded s /\ x IN s /\ y IN s ==> abs(x - y) <= diameter s``,
  MESON_TAC[DIAMETER_BOUNDED]);

val DIAMETER_LINEAR_IMAGE = store_thm ("DIAMETER_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x. abs(f x) = abs x)
        ==> (diameter(IMAGE f s) = diameter s)``,
  REWRITE_TAC[diameter] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[diameter, IMAGE_EQ_EMPTY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC [CONJ_SYM] THEN
  SIMP_TAC std_ss [GSYM CONJ_ASSOC, RIGHT_EXISTS_AND_THM, EXISTS_IN_IMAGE] THEN
  METIS_TAC[LINEAR_SUB]);

val DIAMETER_EMPTY = store_thm ("DIAMETER_EMPTY",
 ``diameter {} = &0``,
  REWRITE_TAC[diameter]);

val DIAMETER_SING = store_thm ("DIAMETER_SING",
 ``!a. diameter {a} = &0``,
  REWRITE_TAC[diameter, NOT_INSERT_EMPTY, IN_SING] THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y:real) = (\x y. abs (x - y:real)) x y``] THEN
  KNOW_TAC ``!a:real f x:real y:real. {f x y | (x = a) /\ (y = a)} = {(f a a):real }`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_SING],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  SIMP_TAC std_ss [REAL_SUB_REFL, ABS_0] THEN
  MATCH_MP_TAC REAL_SUP_UNIQUE THEN
  REWRITE_TAC [METIS [SPECIFICATION] ``{0:real} x <=> x IN {0}``] THEN
  SET_TAC [REAL_LE_LT]);

val DIAMETER_POS_LE = store_thm ("DIAMETER_POS_LE",
 ``!s:real->bool. bounded s ==> &0 <= diameter s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_LE_REFL] THEN
  MP_TAC(SPEC ``{abs(x - y:real) | x IN s /\ y IN s}`` SUP) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{abs (x - y) | x IN (s :real -> bool) /\ y IN s} <>
      ({} :real -> bool) /\ (?(b :real).
    !(x :real) (y :real). x IN s /\ y IN s ==> abs (x - y) <= b)`` THENL
   [CONJ_TAC THENL [FULL_SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
     EXISTS_PROD, NOT_IN_EMPTY] THEN METIS_TAC [MEMBER_NOT_EMPTY], ALL_TAC] THEN
    UNDISCH_TAC ``bounded s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC ``B:real`` o REWRITE_RULE [BOUNDED_POS]) THEN
    EXISTS_TAC ``&2 * B:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
      ``abs x <= B /\ abs y <= B ==> abs(x - y) <= &2 * B:real``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN
    DISCH_THEN(MP_TAC o SPECL [``a:real``, ``a:real``] o CONJUNCT1) THEN
    ASM_REWRITE_TAC[REAL_SUB_REFL, ABS_0]]);

val DIAMETER_SUBSET = store_thm ("DIAMETER_SUBSET",
 ``!s t:real->bool. s SUBSET t /\ bounded t ==> diameter s <= diameter t``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [DIAMETER_EMPTY, DIAMETER_POS_LE] THEN
  ASM_REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC REAL_SUP_LE_SUBSET THEN
  REPEAT(CONJ_TAC THENL
  [FULL_SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, SUBSET_DEF,
     EXISTS_PROD, NOT_IN_EMPTY] THEN METIS_TAC [MEMBER_NOT_EMPTY], ALL_TAC]) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  UNDISCH_TAC ``bounded t`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_TAC ``B:real`` o REWRITE_RULE [BOUNDED_POS]) THEN
  EXISTS_TAC ``&2 * B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH
    ``abs x <= B /\ abs y <= B ==> abs(x - y) <= &2 * B:real``]);

val DIAMETER_CLOSURE = store_thm ("DIAMETER_CLOSURE",
 ``!s:real->bool. bounded s ==> (diameter(closure s) = diameter s)``,
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [DIAMETER_SUBSET, BOUNDED_CLOSURE, CLOSURE_SUBSET] THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN
  DISCH_TAC THEN MP_TAC(ISPEC ``closure s:real->bool`` DIAMETER_BOUNDED) THEN
  ABBREV_TAC ``d = diameter(closure s) - diameter(s:real->bool)`` THEN
  ASM_SIMP_TAC std_ss [BOUNDED_CLOSURE] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM (MP_TAC o
    SPEC ``diameter(closure(s:real->bool)) - d / &2:real``) THEN
  SIMP_TAC std_ss [NOT_IMP, GSYM CONJ_ASSOC, NOT_EXISTS_THM] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(x:real) NOTIN y <=> ~(x IN y)``, GSYM DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(x:real) NOTIN y <=> ~(x IN y)``, GSYM DE_MORGAN_THM] THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP DIAMETER_POS_LE) THEN
  CONJ_TAC THENL
  [SIMP_TAC std_ss [REAL_SUB_LE, REAL_LE_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   EXPAND_TAC "d" THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
   SIMP_TAC std_ss [GSYM REAL_DOUBLE, real_sub] THEN
   MATCH_MP_TAC REAL_LE_ADD2 THEN SIMP_TAC std_ss [REAL_LE_REFL] THEN
   FULL_SIMP_TAC std_ss [REAL_ARITH ``(a - b = c) <=> (a = c + b:real)``] THEN
   ONCE_REWRITE_TAC [GSYM REAL_SUB_LE] THEN
   REWRITE_TAC [REAL_ARITH ``0 < a + b - -c <=> 0 + 0 < a + (b + c):real``, REAL_LE_LT] THEN
   DISJ1_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN ASM_REWRITE_TAC [] THEN
   ONCE_REWRITE_TAC [REAL_ARITH ``0 = 0 + 0:real``] THEN
   MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  CONJ_TAC THENL
  [ONCE_REWRITE_TAC [REAL_ARITH ``a - b < c <=> a - c < b:real``] THEN
   SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   ASM_REWRITE_TAC [REAL_SUB_REFL, REAL_MUL_LZERO], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, CONJ_ASSOC, GSYM FORALL_AND_THM] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``!e. ~(0 < e) \/ ?y'. y' IN s /\ dist (y',y) < e:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `d / 4:real`) THEN
  UNDISCH_TAC ``!e. ~(0 < e) \/ ?y. y IN s /\ dist (y,x) < e:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `d / 4:real`) THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  ASM_REWRITE_TAC[METIS [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 4:real``, REAL_MUL_LZERO]
                         ``&0 < d / &4 <=> &0 < d:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``u:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC))
   (X_CHOOSE_THEN ``v:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC))) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DIAMETER_BOUNDED) THEN
  DISCH_THEN(MP_TAC o SPECL [``u:real``, ``v:real``] o CONJUNCT1) THEN
  ASM_REWRITE_TAC[dist] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [real_gt]) THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``a - b < c <=> a - c < b:real``]) THEN
  RULE_ASSUM_TAC (SIMP_RULE std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``]) THEN
  UNDISCH_TAC `` (diameter (closure s) - abs (x - y)) * 2 < d:real`` THEN
  EXPAND_TAC "d" THEN SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 4:real``] THEN
  REAL_ARITH_TAC);

val DIAMETER_SUBSET_CBALL_NONEMPTY = store_thm ("DIAMETER_SUBSET_CBALL_NONEMPTY",
 ``!s:real->bool.
       bounded s /\ ~(s = {}) ==> ?z. z IN s /\ s SUBSET cball(z,diameter s)``,
   REPEAT STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
   DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
   ASM_REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``b:real`` THEN
   DISCH_TAC THEN REWRITE_TAC[IN_CBALL, dist] THEN
   ASM_MESON_TAC[DIAMETER_BOUNDED]);

val DIAMETER_SUBSET_CBALL = store_thm ("DIAMETER_SUBSET_CBALL",
 ``!s:real->bool. bounded s ==> ?z. s SUBSET cball(z,diameter s)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_MESON_TAC[DIAMETER_SUBSET_CBALL_NONEMPTY, EMPTY_SUBSET]);

val DIAMETER_EQ_0 = store_thm ("DIAMETER_EQ_0",
 ``!s:real->bool.
        bounded s ==> ((diameter s = &0) <=> (s = {}) \/ ?a. (s = {a}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[DIAMETER_EMPTY, DIAMETER_SING] THEN
  REWRITE_TAC[SET_RULE
   ``(s = {}) \/ (?a. s = {a}) <=> !a b. a IN s /\ b IN s ==> (a = b)``] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``a:real``, ``b:real``]
        DIAMETER_BOUNDED_BOUND) THEN
  ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);

val DIAMETER_LE = store_thm ("DIAMETER_LE",
 ``!s:real->bool d.
        (~(s = {}) \/ &0 <= d) /\
        (!x y. x IN s /\ y IN s ==> abs(x - y) <= d) ==> diameter s <= d``,
  NTAC 2 GEN_TAC THEN REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_SUP_LE' THEN
  CONJ_TAC THENL [
   SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[],
   SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC []]);

val DIAMETER_CBALL = store_thm ("DIAMETER_CBALL",
 ``!a:real r. diameter(cball(a,r)) = if r < &0 then &0 else &2 * r``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THENL
   [ASM_MESON_TAC[CBALL_EQ_EMPTY, DIAMETER_EMPTY], ALL_TAC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[REAL_NOT_LT]) THEN
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [MATCH_MP_TAC DIAMETER_LE THEN
    ASM_SIMP_TAC std_ss [CBALL_EQ_EMPTY, REAL_LE_MUL, REAL_POS, REAL_NOT_LT] THEN
    REWRITE_TAC[IN_CBALL, dist] THEN REAL_ARITH_TAC,
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``abs((a + r) - (a - r):real)`` THEN
    CONJ_TAC THENL
     [REWRITE_TAC[REAL_ARITH ``(a + r) - (a - r) = (&2 * r:real)``] THEN
      ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC DIAMETER_BOUNDED_BOUND THEN
      REWRITE_TAC[BOUNDED_CBALL, IN_CBALL, dist] THEN
      REWRITE_TAC[REAL_ARITH
       ``(abs(a - (a + b)) = abs b) /\ (abs(a - (a - b)) = abs b:real)``] THEN
      ASM_REAL_ARITH_TAC]]);

val DIAMETER_BALL = store_thm ("DIAMETER_BALL",
 ``!a:real r. diameter(ball(a,r)) = if r < &0 then &0 else &2 * r``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THENL
   [ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LT_IMP_LE, DIAMETER_EMPTY], ALL_TAC] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN
  ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LE_REFL, DIAMETER_EMPTY, REAL_MUL_RZERO] THEN
  MATCH_MP_TAC EQ_TRANS THEN
  EXISTS_TAC ``diameter(cball(a:real,r))`` THEN CONJ_TAC THENL
   [SUBGOAL_THEN ``&0 < r:real`` ASSUME_TAC THENL [ASM_REAL_ARITH_TAC, ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [GSYM CLOSURE_BALL, DIAMETER_CLOSURE, BOUNDED_BALL],
    ASM_SIMP_TAC std_ss [DIAMETER_CBALL]]);

val DIAMETER_SUMS = store_thm ("DIAMETER_SUMS",
 ``!s t:real->bool.
        bounded s /\ bounded t
        ==> diameter {x + y | x IN s /\ y IN t} <= diameter s + diameter t``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``!x y:real. {x + y| F} = {}:real->bool`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [], DISCH_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, DIAMETER_EMPTY, REAL_ADD_LID, DIAMETER_POS_LE] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, DIAMETER_EMPTY, REAL_ADD_RID, DIAMETER_POS_LE] THEN
  MATCH_MP_TAC DIAMETER_LE THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, NOT_IN_EMPTY] THEN
   ASM_SET_TAC [], ALL_TAC] THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP, FORALL_IN_GSPEC] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC(REAL_ARITH
   ``abs(x - x') <= s /\ abs(y - y') <= t
    ==> abs((x + y) - (x' + y'):real) <= s + t``) THEN
  ASM_SIMP_TAC std_ss [DIAMETER_BOUNDED_BOUND]);

val LEBESGUE_COVERING_LEMMA = store_thm ("LEBESGUE_COVERING_LEMMA",
 ``!s:real->bool c.
        compact s /\ ~(c = {}) /\ s SUBSET BIGUNION c /\ (!b. b IN c ==> open b)
        ==> ?d. &0 < d /\
                !t. t SUBSET s /\ diameter t <= d
                    ==> ?b. b IN c /\ t SUBSET b``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP HEINE_BOREL_LEMMA) THEN
  DISCH_THEN(MP_TAC o SPEC ``c:(real->bool)->bool``) THEN ASM_SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``e:real`` THEN
  STRIP_TAC THEN EXISTS_TAC ``e / &2:real`` THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPEC ``t:real->bool`` DIAMETER_SUBSET_CBALL_NONEMPTY) THEN
  KNOW_TAC ``(bounded (t :real -> bool) :bool) /\ t <> ({} :real -> bool)`` THENL
   [ASM_MESON_TAC[BOUNDED_SUBSET, COMPACT_IMP_BOUNDED],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
  KNOW_TAC ``(x :real) IN (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``b:real->bool``) THEN EXISTS_TAC ``b:real->bool`` THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``cball(x:real,diameter(t:real->bool))`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``ball(x:real,e)`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_BALL] THEN
  MAP_EVERY UNDISCH_TAC [``&0 < e:real``, ``diameter(t:real->bool) <= e / &2:real``] THEN
  SIMP_TAC std_ss [dist, REAL_LE_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Related results with closure as the conclusion.                           *)
(* ------------------------------------------------------------------------- *)

val CLOSED_SCALING = store_thm ("CLOSED_SCALING",
 ``!s:real->bool c. closed s ==> closed (IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``s :real->bool = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY, IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_CASES_TAC ``c = &0:real`` THENL
   [SUBGOAL_THEN ``IMAGE (\x:real. c * x) s = {(0)}``
     (fn th => REWRITE_TAC[th, CLOSED_SING]) THEN
    ASM_REWRITE_TAC[EXTENSION, IN_IMAGE, IN_SING, REAL_MUL_LZERO] THEN
    ASM_MESON_TAC[MEMBER_NOT_EMPTY],
    ALL_TAC] THEN
  SIMP_TAC std_ss [CLOSED_SEQUENTIAL_LIMITS, IN_IMAGE, SKOLEM_THM] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:num->real`` THEN X_GEN_TAC ``l:real`` THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:num->real`` MP_TAC) THEN
  SIMP_TAC std_ss [FORALL_AND_THM] THEN STRIP_TAC THEN
  EXISTS_TAC ``inv(c) * l :real`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``\n:num. inv(c) * x n:real`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID],
    ONCE_REWRITE_TAC [METIS [] ``(\n:num. inv c * (c * (y:num->real) n)) =
                                 (\n. inv c:real * (\n. (c * y n)) n)``] THEN
    MATCH_MP_TAC LIM_CMUL THEN
    FIRST_ASSUM(fn th => REWRITE_TAC[SYM(SPEC_ALL th)]) THEN
    ASM_SIMP_TAC std_ss [ETA_AX]]);

val CLOSED_NEGATIONS = store_thm ("CLOSED_NEGATIONS",
 ``!s:real->bool. closed s ==> closed (IMAGE (\x. -x) s)``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``IMAGE (\x. -x) s = IMAGE (\x:real. -(&1) * x) s``
  SUBST1_TAC THEN SIMP_TAC std_ss [CLOSED_SCALING] THEN
  REWRITE_TAC[REAL_ARITH ``-(&1) * x = -x:real``] THEN SIMP_TAC std_ss [ETA_AX]);

val COMPACT_CLOSED_SUMS = store_thm ("COMPACT_CLOSED_SUMS",
 ``!s:real->bool t.
        compact s /\ closed t ==> closed {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [compact, GSPECIFICATION, CLOSED_SEQUENTIAL_LIMITS, EXISTS_PROD] THEN
  STRIP_TAC THEN X_GEN_TAC ``f:num->real`` THEN X_GEN_TAC ``l:real`` THEN
  SIMP_TAC std_ss [SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:num->real`` MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:num->real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `` !f:num->real.
        (!n. f n IN s) ==>
        ?l r.
          l IN s /\ (!m n. m < n ==> r m < r n) /\
          (f o r --> l) sequentially`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``a:num->real``) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``la:real`` (X_CHOOSE_THEN ``sub:num->num``
        STRIP_ASSUME_TAC)) THEN
  MAP_EVERY EXISTS_TAC [``la:real``, ``l - la:real``] THEN
  ASM_REWRITE_TAC[REAL_ARITH ``a + (b - a) = b:real``] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  EXISTS_TAC ``\n. (f o (sub:num->num)) n - (a o sub) n:real`` THEN
  CONJ_TAC THENL [ASM_SIMP_TAC std_ss [REAL_ADD_SUB, o_THM], ALL_TAC] THEN
  MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [LIM_SUBSEQUENCE, ETA_AX]);

val CLOSED_COMPACT_SUMS = store_thm ("CLOSED_COMPACT_SUMS",
 ``!s:real->bool t.
        closed s /\ compact t ==> closed {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``{x + y:real | x IN s /\ y IN t} = {y + x | y IN t /\ x IN s}``
  SUBST1_TAC THEN  SIMP_TAC std_ss [COMPACT_CLOSED_SUMS] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN METIS_TAC [REAL_ADD_SYM]);

val CLOSURE_SUMS = store_thm ("CLOSURE_SUMS",
 ``!s t:real->bool.
        bounded s \/ bounded t
        ==> (closure {x + y | x IN s /\ y IN t} =
             {x + y | x IN closure s /\ y IN closure t})``,
  REWRITE_TAC[TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC std_ss [FORALL_AND_THM] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SUMS_SYM] THEN
  MATCH_MP_TAC(TAUT `(p ==> q) /\ p ==> p /\ q`) THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [EXTENSION, CLOSURE_SEQUENTIAL] THEN
  X_GEN_TAC ``z:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN EQ_TAC THENL
   [GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [CONJ_SYM] THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_DELETE, SKOLEM_THM, GSYM LEFT_EXISTS_AND_THM] THEN
    SIMP_TAC std_ss [FORALL_AND_THM] THEN
    ONCE_REWRITE_TAC[TAUT `(p /\ q) /\ r <=> q /\ p /\ r`] THEN
    KNOW_TAC ``(?(x' :num -> real) (f :num -> real) (f' :num -> real).
   (\x' f f'. ((!(n :num). f n IN (s :real -> bool)) /\
    !(n :num). f' n IN (t :real -> bool)) /\
   (!(n :num). x' n = f n + f' n) /\
   ((x' --> (z :real)) sequentially :bool)) x' f f') ==>
?(p_1 :real) (p_2 :real) (x' :num -> real).
  (\p_1 p_2 x'. (?(x :num -> real).
     (!(n :num). x n IN t) /\ ((x --> p_2) sequentially :bool)) /\
  ((!(n :num). x' n IN s) /\ ((x' --> p_1) sequentially :bool)) /\
  (z = p_1 + p_2)) p_1 p_2 x'`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    ONCE_REWRITE_TAC[MESON[] ``(?f x y. P f x y) <=> (?x y f. P f x y)``] THEN
    SIMP_TAC std_ss [GSYM FUN_EQ_THM] THEN
    SIMP_TAC std_ss [ETA_AX, UNWIND_THM2] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:num->real``, ``b:num->real``] THEN
    STRIP_TAC THEN
    MP_TAC(ISPEC ``closure s:real->bool`` compact) THEN
    ASM_SIMP_TAC std_ss [COMPACT_CLOSURE] THEN
    DISCH_THEN(MP_TAC o SPEC ``a:num->real``) THEN
    ASM_SIMP_TAC std_ss [SIMP_RULE std_ss [SUBSET_DEF] CLOSURE_SUBSET, LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real``, ``r:num->num``] THEN STRIP_TAC THEN
    EXISTS_TAC ``z - u:real`` THEN
    EXISTS_TAC ``(a:num->real) o (r:num->num)`` THEN EXISTS_TAC ``u:real`` THEN
    ASM_SIMP_TAC std_ss [o_THM] THEN
    CONJ_TAC THENL [ALL_TAC, REAL_ARITH_TAC] THEN
    EXISTS_TAC ``(\n. ((\n. a n + b n) o (r:num->num)) n - (a o r) n)
                :num->real`` THEN
    CONJ_TAC THENL
     [ASM_SIMP_TAC real_ss [o_DEF, REAL_ARITH ``(a + b) - a:real = b``],
      MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [ETA_AX] THEN
      MATCH_MP_TAC LIM_SUBSEQUENCE THEN ASM_REWRITE_TAC[]],
    SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, GSYM LEFT_EXISTS_AND_THM,
                GSYM RIGHT_EXISTS_AND_THM] THEN
    MAP_EVERY X_GEN_TAC
     [``x:real``, ``y:real``, ``a:num->real``, ``b:num->real``] THEN
    STRIP_TAC THEN EXISTS_TAC ``(\n. a n + b n):num->real`` THEN
    ASM_SIMP_TAC std_ss [LIM_ADD] THEN ASM_MESON_TAC[]]);

val COMPACT_CLOSED_DIFFERENCES = store_thm ("COMPACT_CLOSED_DIFFERENCES",
 ``!s:real->bool t.
        compact s /\ closed t ==> closed {x - y | x IN s /\ y IN t}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x - y | x:real IN s /\ y IN t} =
                 {x + y | x IN s /\ y IN (IMAGE (\x. -x) t)}``
    (fn th => ASM_SIMP_TAC std_ss [th, COMPACT_CLOSED_SUMS, CLOSED_NEGATIONS]) THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = -y) <=> (y = -x:real)``] THEN
  SIMP_TAC std_ss [real_sub, GSYM CONJ_ASSOC, UNWIND_THM2] THEN
  METIS_TAC[REAL_NEG_NEG]);

val CLOSED_COMPACT_DIFFERENCES = store_thm ("CLOSED_COMPACT_DIFFERENCES",
 ``!s:real->bool t.
        closed s /\ compact t ==> closed {x - y | x IN s /\ y IN t}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x - y | x:real IN s /\ y IN t} =
                 {x + y | x IN s /\ y IN (IMAGE (\x. -x) t)}``
    (fn th => ASM_SIMP_TAC std_ss [th, CLOSED_COMPACT_SUMS, COMPACT_NEGATIONS]) THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = -y) <=> (y = -x)``] THEN
  SIMP_TAC std_ss [real_sub, GSYM CONJ_ASSOC, UNWIND_THM2] THEN
  METIS_TAC[REAL_NEG_NEG]);

val TRANSLATION_DIFF = store_thm ("TRANSLATION_DIFF",
 ``!s t:real->bool.
        IMAGE (\x. a + x) (s DIFF t) =
        (IMAGE (\x. a + x) s) DIFF (IMAGE (\x. a + x) t)``,
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = a + y) <=> (y = x - a)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2]);

(* ------------------------------------------------------------------------- *)
(* Separation between points and sets.                                       *)
(* ------------------------------------------------------------------------- *)

val SEPARATE_POINT_CLOSED = store_thm ("SEPARATE_POINT_CLOSED",
 ``!s a:real.
        closed s /\ ~(a IN s)
        ==> ?d. &0 < d /\ !x. x IN s ==> d <= dist(a,x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [EXISTS_TAC ``&1:real`` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY, REAL_LT_01],
    ALL_TAC] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``a:real``] DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``b:real`` THEN
  STRIP_TAC THEN EXISTS_TAC ``dist(a:real,b)`` THEN
  METIS_TAC[DIST_POS_LT]);

val SEPARATE_COMPACT_CLOSED = store_thm ("SEPARATE_COMPACT_CLOSED",
 ``!s t:real->bool.
        compact s /\ closed t /\ (s INTER t = {})
        ==> ?d. &0 < d /\ !x y. x IN s /\ y IN t ==> d <= dist(x,y)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
                SEPARATE_POINT_CLOSED) THEN
  ASM_SIMP_TAC std_ss [COMPACT_CLOSED_DIFFERENCES, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[REAL_ARITH ``(0 = x - y) <=> (x = y:real)``] THEN
  KNOW_TAC ``(!(p_1 :real) (p_2 :real).
    p_1 <> p_2 \/ p_1 NOTIN (s :real -> bool) \/
    p_2 NOTIN (t :real -> bool))`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  REWRITE_TAC [dist] THEN
  METIS_TAC[REAL_ARITH ``abs(0 - (x - y)) = abs(x - y:real)``]);

val SEPARATE_CLOSED_COMPACT = store_thm ("SEPARATE_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t /\ (s INTER t = {})
        ==> ?d. &0 < d /\ !x y. x IN s /\ y IN t ==> d <= dist(x,y)``,
  ONCE_REWRITE_TAC[DIST_SYM, INTER_COMM] THEN
  MESON_TAC[SEPARATE_COMPACT_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* Representing sets as the union of a chain of compact sets.                *)
(* ------------------------------------------------------------------------- *)

val CLOSED_UNION_COMPACT_SUBSETS = store_thm ("CLOSED_UNION_COMPACT_SUBSETS",
 ``!s. closed s
       ==> ?f:num->real->bool.
                (!n. compact(f n)) /\
                (!n. (f n) SUBSET s) /\
                (!n. (f n) SUBSET f(n + 1)) /\
                (BIGUNION {f n | n IN univ(:num)} = s) /\
                (!k. compact k /\ k SUBSET s
                     ==> ?N. !n. n >= N ==> k SUBSET (f n))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\n. s INTER cball(0:real,&n)`` THEN
  ASM_SIMP_TAC std_ss [INTER_SUBSET, COMPACT_CBALL, CLOSED_INTER_COMPACT] THEN
  REPEAT CONJ_TAC THENL
   [GEN_TAC THEN MATCH_MP_TAC(SET_RULE
     ``t SUBSET u ==> s INTER t SUBSET s INTER u``) THEN
    REWRITE_TAC[SUBSET_BALLS, DIST_REFL, GSYM REAL_OF_NUM_ADD] THEN
    REAL_ARITH_TAC,
    SIMP_TAC std_ss [EXTENSION, BIGUNION_GSPEC, GSPECIFICATION, IN_UNIV, IN_INTER] THEN
    X_GEN_TAC ``x:real`` THEN REWRITE_TAC[IN_CBALL_0] THEN
    MESON_TAC[SIMP_REAL_ARCH],
    X_GEN_TAC ``k:real->bool`` THEN SIMP_TAC std_ss [SUBSET_INTER] THEN
    REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP COMPACT_IMP_BOUNDED) THEN DISCH_THEN
     (MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_CBALL) THEN
    DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPEC ``r:real`` SIMP_REAL_ARCH) THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_GE] THEN
    REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
    REWRITE_TAC[SUBSET_BALLS, DIST_REFL] THEN ASM_REAL_ARITH_TAC]);

val OPEN_UNION_COMPACT_SUBSETS = store_thm ("OPEN_UNION_COMPACT_SUBSETS",
 ``!s. open s
       ==> ?f:num->real->bool.
                (!n. compact(f n)) /\
                (!n. (f n) SUBSET s) /\
                (!n. (f n) SUBSET interior(f(n + 1))) /\
                (BIGUNION {f n | n IN univ(:num)} = s) /\
                (!k. compact k /\ k SUBSET s
                     ==> ?N. !n. n >= N ==> k SUBSET (f n))``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [DISCH_TAC THEN EXISTS_TAC ``(\n. {}):num->real->bool`` THEN
    ASM_SIMP_TAC std_ss [EMPTY_SUBSET, SUBSET_EMPTY, COMPACT_EMPTY] THEN
    SIMP_TAC std_ss [EXTENSION, BIGUNION_GSPEC, GSPECIFICATION, NOT_IN_EMPTY],
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN STRIP_TAC] THEN
  KNOW_TAC ``?(f :num -> real -> bool).
           (\f. !(n :num). compact (f n)) f /\
           (\f. !(n :num). f n SUBSET (s :real -> bool)) f /\
           (\f. !(n :num). f n SUBSET interior (f (n + (1 :num)))) f /\
           (\f. BIGUNION {f n | n IN univ((:num) :num itself)} = s) f /\
  (\f. !(k :real -> bool).
    compact k /\ k SUBSET s ==>
    ?(N :num). !(n :num). n >= N ==> k SUBSET f n) f`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS[]
  ``(!f. p1 f /\ p3 f /\ p4 f ==> p5 f) /\
    (?f. p1 f /\ p2 f /\ p3 f /\ (p2 f ==> p4 f))
    ==> ?f. p1 f /\ p2 f /\ p3 f /\ p4 f /\ p5 f``) THEN
  CONJ_TAC THENL
   [BETA_TAC THEN X_GEN_TAC ``f:num->real->bool`` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
    UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
    DISCH_THEN(MP_TAC o SPEC ``{interior(f n):real->bool | n IN univ(:num)}``) THEN
    SIMP_TAC std_ss [FORALL_IN_GSPEC, OPEN_INTERIOR] THEN
    KNOW_TAC ``(k :real -> bool) SUBSET
        BIGUNION {interior ((f :num -> real -> bool) n) |
                               n IN univ((:num) :num itself)}`` THENL
     [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
      SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, GSPECIFICATION] THEN ASM_SET_TAC[],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
      ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
      ONCE_REWRITE_TAC [METIS [] ``interior (f n) = (\n. interior (f n)) (n:num)``] THEN
      SIMP_TAC std_ss [GSYM IMAGE_DEF, EXISTS_FINITE_SUBSET_IMAGE] THEN
      REWRITE_TAC[SUBSET_UNIV] THEN
      DISCH_THEN(X_CHOOSE_THEN ``i:num->bool`` STRIP_ASSUME_TAC) THEN
      FIRST_ASSUM(MP_TAC o SPEC ``\n:num. n`` o
        MATCH_MP UPPER_BOUND_FINITE_SET) THEN
      DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
      POP_ASSUM MP_TAC THEN
      REWRITE_TAC[GE] THEN DISCH_TAC THEN X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
      SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_IMAGE] THEN
      X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN MATCH_MP_TAC SUBSET_TRANS THEN
      EXISTS_TAC ``(f:num->real->bool) m`` THEN
      REWRITE_TAC[INTERIOR_SUBSET] THEN
      SUBGOAL_THEN ``!m n. m <= n ==> (f:num->real->bool) m SUBSET f n``
       (fn th => METIS_TAC[th, LESS_EQ_TRANS]) THEN
      ONCE_REWRITE_TAC [METIS [] ``f m SUBSET f n <=> (\m n. f m SUBSET f n) m n``] THEN
      MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
      METIS_TAC[SUBSET_DEF, ADD1, INTERIOR_SUBSET]],
    BETA_TAC THEN EXISTS_TAC ``\n. cball(a,&n) DIFF
         {x + e | x IN univ(:real) DIFF s /\ e IN ball(0,inv(&n + &1))}`` THEN
    SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL
     [X_GEN_TAC ``n:num`` THEN MATCH_MP_TAC COMPACT_DIFF THEN
      SIMP_TAC std_ss [COMPACT_CBALL, OPEN_SUMS, OPEN_BALL],
      GEN_TAC THEN MATCH_MP_TAC(SET_RULE
       ``(UNIV DIFF s) SUBSET t ==> c DIFF t SUBSET s``) THEN
      SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      MAP_EVERY EXISTS_TAC [``x:real``, ``0:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_ADD_RID, CENTRE_IN_BALL, REAL_LT_INV_EQ] THEN
      SIMP_TAC std_ss [REAL_LT, REAL_OF_NUM_ADD] THEN ARITH_TAC,
      GEN_TAC THEN REWRITE_TAC[INTERIOR_DIFF] THEN MATCH_MP_TAC(SET_RULE
       ``s SUBSET s' /\ t' SUBSET t ==> (s DIFF t) SUBSET (s' DIFF t')``) THEN
      CONJ_TAC THENL
       [REWRITE_TAC[INTERIOR_CBALL, SUBSET_DEF, IN_BALL, IN_CBALL] THEN
        SIMP_TAC std_ss [GSYM REAL_OF_NUM_ADD] THEN REAL_ARITH_TAC,
        MATCH_MP_TAC SUBSET_TRANS THEN
        EXISTS_TAC ``{x + e | x IN univ(:real) DIFF s /\
                             e IN cball(0,inv(&n + &2))}`` THEN
        CONJ_TAC THENL
         [MATCH_MP_TAC CLOSURE_MINIMAL THEN
          ASM_SIMP_TAC std_ss [CLOSED_COMPACT_SUMS, COMPACT_CBALL,
                       GSYM OPEN_CLOSED] THEN
          KNOW_TAC ``ball (0,inv (&n + 1)) SUBSET ball (0,inv (&n + 1))`` THENL
          [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
           SIMP_TAC std_ss [ball, cball, dist, GSYM REAL_OF_NUM_ADD,
                            REAL_ARITH ``n + 1 + 1:real = n + 2``,
                            GSPECIFICATION] THEN
           METIS_TAC [REAL_LE_LT], ALL_TAC] THEN
          SIMP_TAC std_ss [SUBSET_DEF, IN_BALL, IN_CBALL, GSYM REAL_OF_NUM_ADD] THEN
          SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD, dist,
                           REAL_ARITH ``n + 1 + 1:real = n + 2``] THEN
          METIS_TAC [REAL_LE_LT],
          KNOW_TAC ``cball (0,inv (&n + &2)) SUBSET ball (0,inv (&n + &1))`` THENL
          [ALL_TAC,
           SIMP_TAC std_ss [cball, ball, dist, SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
           METIS_TAC [REAL_LE_LT]] THEN
          REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL, GSYM REAL_OF_NUM_ADD] THEN
          GEN_TAC THEN MATCH_MP_TAC(REAL_ARITH
           ``a < b ==> x <= a ==> x < b:real``) THEN
          MATCH_MP_TAC REAL_LT_INV2 THEN
          SIMP_TAC arith_ss [REAL_LT, REAL_OF_NUM_ADD]]],
      DISCH_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
      ASM_SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC] THEN
      SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, IN_UNIV, GSPECIFICATION] THEN
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_DIFF] THEN
      SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, IN_BALL_0, EXISTS_PROD] THEN
      REWRITE_TAC[REAL_ARITH ``(x:real = y + e) <=> (e = x - y)``] THEN
      SIMP_TAC std_ss [TAUT `(p /\ q) /\ r <=> r /\ p /\ q`, UNWIND_THM2] THEN
      ONCE_REWRITE_TAC [METIS [DE_MORGAN_THM]
           ``(!p_1:real. p_1 IN s \/ ~(abs (x - p_1) < inv (&n + 1))) <=>
             ~(?p_1:real. (~(\p_1. (p_1 IN s)) p_1 /\
                            (\p_1. abs (x - p_1) < inv (&n + 1)) p_1))``] THEN
      REWRITE_TAC[METIS [] ``~(?x. ~P x /\ Q x) <=> !x. Q x ==> P x``] THEN
      UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN BETA_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_BALL]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
      ASM_REWRITE_TAC[SUBSET_DEF, IN_BALL, dist] THEN
      DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
      UNDISCH_TAC ``0 < e:real`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC o ONCE_REWRITE_RULE [REAL_ARCH_INV]) THEN
      DISCH_THEN(X_CHOOSE_THEN ``N1:num`` STRIP_ASSUME_TAC) THEN
      MP_TAC(ISPEC ``abs(x - a:real)`` SIMP_REAL_ARCH) THEN
      DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN EXISTS_TAC ``N1 + N2:num`` THEN
      CONJ_TAC THENL
       [REWRITE_TAC[IN_CBALL] THEN ONCE_REWRITE_TAC[DIST_SYM, dist] THEN
        UNDISCH_TAC ``abs(x - a:real) <= &N2`` THEN
        REWRITE_TAC[dist, GSYM REAL_OF_NUM_ADD] THEN
        FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ] THEN
        DISCH_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC ``&N2:real`` THEN ASM_REWRITE_TAC [] THEN
        SIMP_TAC arith_ss [REAL_OF_NUM_LE, REAL_OF_NUM_ADD],
        REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
        SUBGOAL_THEN ``inv(&(N1 + N2) + &1) <= inv(&N1:real)`` MP_TAC THENL
         [MATCH_MP_TAC REAL_LE_INV2 THEN
          ASM_SIMP_TAC arith_ss [REAL_LT, LE_1] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
          SIMP_TAC arith_ss [REAL_OF_NUM_LE, REAL_OF_NUM_ADD],
          METIS_TAC [REAL_LTE_TRANS, REAL_LET_TRANS, REAL_LE_TRANS, REAL_LT_TRANS]]]]]);

(* ------------------------------------------------------------------------- *)
(* A cute way of denoting open and closed intervals using overloading.       *)
(* ------------------------------------------------------------------------- *)

Definition OPEN_interval :
    OPEN_interval ((a:real),(b:real)) = {x:real | a < x /\ x < b}
End

Definition CLOSED_interval :
    CLOSED_interval (l :(real # real) list) =
      {x:real | FST (HD l) <= x /\ x <= SND (HD l)}
End

val _ = overload_on ("interval", ``OPEN_interval``);
val _ = overload_on ("interval", ``CLOSED_interval``);

val interval = store_thm ("interval",
 ``(interval (a,b) = {x:real | a < x /\ x < b}) /\
   (interval [a,b] = {x:real | a <= x /\ x <= b})``,
  REWRITE_TAC [OPEN_interval, CLOSED_interval, HD]);

val IN_INTERVAL = store_thm ("IN_INTERVAL",
 ``(x IN interval (a,b) <=> a < x /\ x < b) /\
   (x IN interval [a,b] <=> a <= x /\ x <= b)``,
  SIMP_TAC std_ss [interval, GSPECIFICATION]);

val IN_INTERVAL_REFLECT = store_thm ("IN_INTERVAL_REFLECT",
 ``(!a b x. (-x) IN interval[-b,-a] <=> x IN interval[a,b]) /\
   (!a b x. (-x) IN interval(-b,-a) <=> x IN interval(a,b))``,
  SIMP_TAC std_ss [IN_INTERVAL, REAL_LT_NEG, REAL_LE_NEG] THEN
  METIS_TAC[]);

val REFLECT_INTERVAL = store_thm ("REFLECT_INTERVAL",
 ``(!a b:real. IMAGE (\x. -x) (interval[a,b]) = interval[-b,-a]) /\
   (!a b:real. IMAGE (\x. -x) (interval(a,b)) = interval(-b,-a))``,
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_INTERVAL,
   IN_IMAGE] THEN REPEAT STRIP_TAC THEN EQ_TAC THEN
  METIS_TAC [REAL_LE_NEG, REAL_LT_NEG, REAL_NEG_NEG]);

val INTERVAL_EQ_EMPTY = store_thm ("INTERVAL_EQ_EMPTY",
 ``!a b. (b < a <=> (interval [a,b] = {})) /\
         (b <= a <=> (interval (a,b) = {}))``,
  REPEAT GEN_TAC THEN CONJ_TAC THENL
  [EQ_TAC THENL [RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [NOT_IN_EMPTY] THEN CCONTR_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_NEG_NEG] THEN UNDISCH_TAC (Term `b < a:real`) THEN
   FULL_SIMP_TAC std_ss [REAL_NOT_LT] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
   EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC [], SIMP_TAC std_ss [NOT_IN_EMPTY]],
   RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN
   CCONTR_TAC THEN UNDISCH_TAC (Term `!x:real. a <= x /\ x <= b <=> x IN {}`) THEN
   FULL_SIMP_TAC std_ss [NOT_IN_EMPTY, REAL_NOT_LT] THEN EXISTS_TAC ``a:real``
   THEN FULL_SIMP_TAC std_ss [REAL_LE_LT]],
   EQ_TAC THENL [RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN EQ_TAC THENL
    [SIMP_TAC std_ss [NOT_IN_EMPTY] THEN CCONTR_TAC THEN
     FULL_SIMP_TAC std_ss [REAL_NEG_NEG] THEN UNDISCH_TAC (Term `b <= a:real`) THEN
     FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
     EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC [], SIMP_TAC std_ss [NOT_IN_EMPTY]],
     RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN
     CCONTR_TAC THEN UNDISCH_TAC (Term `!x:real. a < x /\ x < b <=> x IN {}`) THEN
     FULL_SIMP_TAC std_ss [NOT_IN_EMPTY, REAL_NOT_LE, REAL_MEAN]]]);

val INTERVAL_NE_EMPTY = store_thm ("INTERVAL_NE_EMPTY",
 ``(~(interval [a:real,b] = {}) <=> a <= b) /\
   (~(interval (a:real,b) = {}) <=> a < b)``,
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, NOT_IN_EMPTY, IN_INTERVAL] THEN
  CONJ_TAC THEN EQ_TAC THENL [SIMP_TAC std_ss [REAL_LE_TRANS],
  DISCH_TAC THEN EXISTS_TAC ``a:real`` THEN ASM_SIMP_TAC std_ss [REAL_LE_LT],
  SIMP_TAC std_ss [REAL_LT_TRANS], FULL_SIMP_TAC std_ss [REAL_MEAN]]);

val SUBSET_INTERVAL_IMP = store_thm ("SUBSET_INTERVAL_IMP",
 ``((a <= c /\ d <= b) ==> interval[c,d] SUBSET interval[a:real,b]) /\
   ((a < c  /\ d < b)  ==> interval[c,d] SUBSET interval(a:real,b)) /\
   ((a <= c /\ d <= b) ==> interval(c,d) SUBSET interval[a:real,b]) /\
   ((a <= c /\ d <= b) ==> interval(c,d) SUBSET interval(a:real,b))``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN REPEAT CONJ_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM MP_TAC THEN REPEAT STRIP_TAC THEN
  METIS_TAC [REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS, REAL_LT_IMP_LE]);

val INTERVAL_SING = store_thm ("INTERVAL_SING",
 ``(interval[a,a] = {a}) /\ (interval(a,a) = {})``,
  REWRITE_TAC[EXTENSION, IN_SING, NOT_IN_EMPTY, IN_INTERVAL] THEN
  REWRITE_TAC[REAL_LE_ANTISYM, REAL_LT_ANTISYM] THEN
  MESON_TAC[EQ_SYM_EQ]);

val SUBSET_INTERVAL = store_thm ("SUBSET_INTERVAL",
 ``(interval[c,d] SUBSET interval[a:real,b] <=>
        (c <= d) ==> (a <= c /\ d <= b)) /\
   (interval[c,d] SUBSET interval(a:real,b) <=>
        (c <= d) ==> (a < c /\ d < b)) /\
   (interval(c,d) SUBSET interval[a:real,b] <=>
        (c < d) ==> (a <= c /\ d <= b)) /\
   (interval(c,d) SUBSET interval(a:real,b) <=>
        (c < d) ==> (a <= c /\ d <= b))``,
  REPEAT STRIP_TAC THEN
  (MATCH_MP_TAC(TAUT
    `(~q ==> p) /\ (q ==> (p <=> r)) ==> (p <=> q ==> r)`) THEN
   CONJ_TAC THENL
    [DISCH_TAC THEN MATCH_MP_TAC(SET_RULE ``(s = {}) ==> s SUBSET t``) THEN
     ASM_MESON_TAC[INTERVAL_EQ_EMPTY, REAL_NOT_LE], ALL_TAC] THEN
   DISCH_TAC THEN EQ_TAC THEN REWRITE_TAC[SUBSET_INTERVAL_IMP] THEN
   REWRITE_TAC[SUBSET_DEF, IN_INTERVAL]) THENL
   [KNOW_TAC ``((?y. c <= y /\ y <= d)
           ==> (!y. c <= y /\ y <= d
                ==> a <= y /\ y <= b))
          ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c <= y /\ y <= d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL],
    KNOW_TAC ``((?y. c <= y /\ y <= d)
           ==> (!y. c <= y /\ y <= d
                 ==> a < y /\ y < b))
           ==> (a < c:real /\ d < b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c <= y /\ y <= d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL],
    KNOW_TAC ``((?y. c < y /\ y < d)
           ==> (!y. c < y /\ y < d
               ==> a <= y /\ y <= b))
         ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c < y /\ y < d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    REPEAT STRIP_TAC THENL
    [CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a <= y /\ y <= b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``((c:real) + min ((a:real)) ((d:real))) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE],
    CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a <= y /\ y <= b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``(max ((b:real)) ((c:real)) + (d:real)) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE]],
    KNOW_TAC ``((?y. c < y /\ y < d)
           ==> (!y. c < y /\ y < d
                ==> a < y /\ y < b))
         ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c < y /\ y < d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    REPEAT STRIP_TAC THENL
    [CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a < y /\ y < b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``((c:real) + min ((a:real)) ((d:real))) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE, REAL_NOT_LT, REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
               REAL_LE_LADD, REAL_LE_ADD2, REAL_LE_RADD, REAL_LE_LT],
    CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a < y /\ y < b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``(max ((b:real)) ((c:real)) + (d:real)) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE, REAL_NOT_LT, REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
               REAL_LE_LADD, REAL_LE_ADD2, REAL_LE_RADD, REAL_LE_LT]]]);

val DISJOINT_INTERVAL = store_thm ("DISJOINT_INTERVAL",
  ``!a b c d:real.
        ((interval[a,b] INTER interval[c,d] = {}) <=>
          b < a \/ d < c \/
          b < c \/ d < a) /\
        ((interval[a,b] INTER interval(c,d) = {}) <=>
          b < a \/ d <= c \/
          b <= c \/ d <= a) /\
        ((interval(a,b) INTER interval[c,d] = {}) <=>
          b <= a \/ d < c \/
          b <= c \/ d <= a) /\
        ((interval(a,b) INTER interval(c,d) = {}) <=>
          b <= a \/ d <= c \/
          b <= c \/ d <= a)``,
  REWRITE_TAC [EXTENSION, IN_INTER, IN_INTERVAL, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, NOT_FORALL_THM] THEN
  REWRITE_TAC [TAUT `~((p ==> q) /\ (p ==> r)) <=> p /\ (~q \/ ~r)`] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  REPEAT STRIP_TAC THEN (* 4 subgoals *)
  (EQ_TAC THENL
    [DISCH_THEN (MP_TAC o SPEC ``(@f. f = (max ((a:real)) ((c:real)) +
                                           min ((b:real)) ((d:real))) / &2):real``) THEN
     DISCH_TAC THEN
     FULL_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ,
                           REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
                           REAL_ARITH ``0 < 2:real``] THEN (* 4 subgoals *)
     FULL_SIMP_TAC bool_ss [REAL_NOT_LE, min_def, max_def] THEN
     POP_ASSUM MP_TAC THEN
     REPEAT COND_CASES_TAC THEN ASM_REAL_ARITH_TAC,

     DISCH_THEN (fn th => GEN_TAC THEN MP_TAC th) THEN
     SIMP_TAC std_ss [] THEN REAL_ARITH_TAC ]));

val ENDS_IN_INTERVAL = store_thm ("ENDS_IN_INTERVAL",
 ``(!a b. a IN interval[a,b] <=> ~(interval[a,b] = {})) /\
   (!a b. b IN interval[a,b] <=> ~(interval[a,b] = {})) /\
   (!a b. ~(a IN interval(a,b))) /\
   (!a b. ~(b IN interval(a,b)))``,
  REWRITE_TAC[IN_INTERVAL, INTERVAL_NE_EMPTY] THEN
  REWRITE_TAC[REAL_LE_REFL, REAL_LT_REFL] THEN
  MESON_TAC[REAL_LE_REFL]);

val ENDS_IN_UNIT_INTERVAL = store_thm ("ENDS_IN_UNIT_INTERVAL",
 ``0 IN interval[0,1] /\ 1 IN interval[0,1] /\
   ~(0 IN interval(0,1)) /\ ~(1 IN interval(0,1))``,
  REWRITE_TAC[ENDS_IN_INTERVAL, INTERVAL_NE_EMPTY] THEN
  REWRITE_TAC[REAL_POS]);

val INTER_INTERVAL = store_thm ("INTER_INTERVAL",
 ``interval[a,b] INTER interval[c,d] =
        interval[(max (a) (c)),(min (b) (d))]``,
  REWRITE_TAC[EXTENSION, IN_INTER, IN_INTERVAL] THEN
  SIMP_TAC std_ss [REAL_MAX_LE, REAL_LE_MIN] THEN MESON_TAC[]);

val INTERVAL_OPEN_SUBSET_CLOSED = store_thm ("INTERVAL_OPEN_SUBSET_CLOSED",
 ``!a b. interval(a,b) SUBSET interval[a,b]``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN MESON_TAC[REAL_LT_IMP_LE]);

val REAL_LT_MIN = store_thm ("REAL_LT_MIN",
 ``!x y z:real. z < min x y <=> z < x /\ z < y``,
  METIS_TAC [min_def, REAL_LTE_TRANS, REAL_LT_TRANS, REAL_NOT_LE]);

val OPEN_INTERVAL_LEMMA = store_thm ("OPEN_INTERVAL_LEMMA",
 ``!a b x. a < x /\ x < b
           ==> ?d. (0:real) < d /\ !x'. abs(x' - x) < d ==> a < x' /\ x' < b``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``min (x - a) (b - x:real)`` THEN REWRITE_TAC[REAL_LT_MIN] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

val OPEN_INTERVAL = store_thm ("OPEN_INTERVAL",
 ``!a:real b. open(interval (a,b))``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [open_def, interval, GSPECIFICATION, dist, OPEN_INTERVAL_LEMMA]);

val CLOSED_INTERVAL = store_thm ("CLOSED_INTERVAL",
 ``!a:real b. closed(interval [a,b])``,
  REWRITE_TAC[CLOSED_LIMPT, LIMPT_APPROACHABLE, IN_INTERVAL] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) - (x:real)``),
    FIRST_X_ASSUM(MP_TAC o SPEC ``(x:real) - (b:real)``)] THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist, REAL_NOT_LT] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``abs((z - x :real))`` THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``x < a /\ a <= z ==> a - x:real <= abs(z - x)``,
                       REAL_ARITH ``z <= b /\ b < x ==> x - b:real <= abs(z - x)``,
                       REAL_LE_REFL]);

val INTERIOR_CLOSED_INTERVAL = store_thm ("INTERIOR_CLOSED_INTERVAL",
 ``!a:real b. interior(interval [a,b]) = interval (a,b)``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [ALL_TAC,
    MATCH_MP_TAC INTERIOR_MAXIMAL THEN
    REWRITE_TAC[INTERVAL_OPEN_SUBSET_CLOSED, OPEN_INTERVAL]] THEN
  SIMP_TAC std_ss [interior, SUBSET_DEF, IN_INTERVAL, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LE] THEN REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``open s`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THENL
  [DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x - (e / 2:real)`),
   DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x + (e / 2:real)`)] THEN
   ASM_SIMP_TAC std_ss [dist, REAL_ADD_SUB, REAL_ARITH ``x - y - x = -y:real``,
                                   REAL_ARITH ``x + y - x =  y:real``] THEN
   ASM_SIMP_TAC std_ss [ABS_MUL, ABS_NEG, REAL_MUL_RID] THENL [CONJ_TAC THENL
   [METIS_TAC [ABS_REFL, REAL_LT_HALF1, REAL_LT_HALF2, REAL_LE_LT], ALL_TAC],
    CONJ_TAC THENL [METIS_TAC [ABS_REFL, REAL_LT_HALF1, REAL_LT_HALF2, REAL_LE_LT],
   ALL_TAC]] THEN CCONTR_TAC THEN
   UNDISCH_TAC ``!x. x IN s ==> a <= x /\ x <= b:real`` THEN DISCH_TAC THENL
   [POP_ASSUM (MP_TAC o Q.SPEC `x - e / 2:real`),
    POP_ASSUM (MP_TAC o Q.SPEC `x + e / 2:real`)] THEN FULL_SIMP_TAC std_ss [] THENL
   [DISJ1_TAC THEN REWRITE_TAC[REAL_ARITH ``a <= a - b <=> ~(&0 < b:real)``],
    DISJ2_TAC THEN REWRITE_TAC[REAL_ARITH ``a + b <= a <=> ~(&0 < b:real)``]] THEN
   FULL_SIMP_TAC std_ss [REAL_LT_HALF1]);

val INTERIOR_INTERVAL = store_thm ("INTERIOR_INTERVAL",
 ``(!a b. interior(interval[a,b]) = interval(a,b)) /\
   (!a b. interior(interval(a,b)) = interval(a,b))``,
  SIMP_TAC std_ss [INTERIOR_CLOSED_INTERVAL, INTERIOR_OPEN, OPEN_INTERVAL]);

val BOUNDED_CLOSED_INTERVAL = store_thm ("BOUNDED_CLOSED_INTERVAL",
 ``!a b:real. bounded (interval [a,b])``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[bounded_def, interval] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN
  EXISTS_TAC ``abs(a) + abs(b:real)`` THEN REAL_ARITH_TAC);

val BOUNDED_INTERVAL = store_thm ("BOUNDED_INTERVAL",
 ``(!a b. bounded (interval [a,b])) /\ (!a b. bounded (interval (a,b)))``,
  MESON_TAC[BOUNDED_CLOSED_INTERVAL, BOUNDED_SUBSET,
            INTERVAL_OPEN_SUBSET_CLOSED]);

val NOT_INTERVAL_UNIV = store_thm ("NOT_INTERVAL_UNIV",
 ``(!a b. ~(interval[a,b] = UNIV)) /\
   (!a b. ~(interval(a,b) = UNIV))``,
  MESON_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val COMPACT_INTERVAL = store_thm ("COMPACT_INTERVAL",
 ``!a b. compact (interval [a,b])``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTERVAL, CLOSED_INTERVAL]);

val OPEN_INTERVAL_MIDPOINT = store_thm ("OPEN_INTERVAL_MIDPOINT",
 ``!a b:real.
        ~(interval(a,b) = {}) ==> (inv(&2) * (a + b)) IN interval(a,b)``,
  REWRITE_TAC[INTERVAL_NE_EMPTY, IN_INTERVAL] THEN
  ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  KNOW_TAC ``0 < 2:real`` THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ] THEN
  REWRITE_TAC [REAL_MUL_COMM, GSYM REAL_DOUBLE] THEN
  FULL_SIMP_TAC std_ss [REAL_LT_LADD, REAL_LT_RADD]);

val OPEN_CLOSED_INTERVAL_CONVEX = store_thm ("OPEN_CLOSED_INTERVAL_CONVEX",
 ``!a b x y:real e.
        x IN interval(a,b) /\ y IN interval[a,b] /\ &0 < e /\ e <= &1
        ==> (e * x + (&1 - e) * y) IN interval(a,b)``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(c /\ d ==> a /\ b ==> e) ==> a /\ b /\ c /\ d ==> e`) THEN
  STRIP_TAC THEN REWRITE_TAC[IN_INTERVAL] THEN STRIP_TAC THEN
  SUBST1_TAC(REAL_ARITH ``(a:real) = e * a + (&1 - e) * a``) THEN
  SUBST1_TAC(REAL_ARITH ``(b:real) = e * b + (&1 - e) * b``) THEN
  KNOW_TAC ``0:real <= 1 - e`` THENL
 [FULL_SIMP_TAC std_ss [REAL_SUB_LE], ALL_TAC] THEN
  REWRITE_TAC [REAL_LE_LT] THEN STRIP_TAC THENL
  [CONJ_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LMUL, REAL_LE_LMUL, REAL_SUB_LE],
  POP_ASSUM MP_TAC THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
  DISCH_TAC THEN CONJ_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LMUL, REAL_LE_LMUL, REAL_SUB_LE, REAL_MUL_LZERO, REAL_LE_REFL]]);

val REAL_LE_INV2 = store_thm ("REAL_LE_INV2",
 ``!x:real y. &0 < x /\ x <= y ==> inv(y) <= inv(x)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_LT] THEN
  ASM_CASES_TAC ``x:real = y`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN DISJ1_TAC THEN MATCH_MP_TAC REAL_LT_INV THEN
  ASM_REWRITE_TAC[]);

val REAL_INV_LE_1 = store_thm ("REAL_INV_LE_1",
 ``!x:real. &1 <= x ==> inv(x) <= &1``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_INV1] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN ASM_REWRITE_TAC[REAL_LT_01]);

val CLOSURE_OPEN_INTERVAL = store_thm ("CLOSURE_OPEN_INTERVAL",
 ``!a b:real.
     ~(interval(a,b) = {}) ==> (closure(interval(a,b)) = interval[a,b])``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [MATCH_MP_TAC CLOSURE_MINIMAL THEN
    REWRITE_TAC[INTERVAL_OPEN_SUBSET_CLOSED, CLOSED_INTERVAL],
    ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, closure, IN_UNION] THEN X_GEN_TAC ``x:real`` THEN
  DISCH_TAC THEN MATCH_MP_TAC(TAUT `(~b ==> c) ==> b \/ c`) THEN DISCH_TAC THEN
  SIMP_TAC std_ss [GSPECIFICATION, LIMPT_SEQUENTIAL] THEN
  ABBREV_TAC ``(c:real) = inv(&2:real) * (a + b)`` THEN
  EXISTS_TAC ``\n. (x:real) + inv(&n + &1:real) * (c - x)`` THEN CONJ_TAC THENL
   [X_GEN_TAC ``n:num`` THEN REWRITE_TAC[IN_DELETE] THEN BETA_TAC THEN
    REWRITE_TAC[REAL_ARITH ``(x + a = x) <=> (a = 0:real)``] THEN
    REWRITE_TAC[REAL_ENTIRE, REAL_INV_EQ_0] THEN
    SIMP_TAC std_ss [REAL_SUB_0, REAL_OF_NUM_SUC, SUC_NOT, REAL_OF_NUM_EQ, EQ_SYM_EQ] THEN
    CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[OPEN_INTERVAL_MIDPOINT]] THEN
    REWRITE_TAC[REAL_ARITH ``x + a * (y - x) = a * y + (&1 - a) * x:real``] THEN
    MATCH_MP_TAC OPEN_CLOSED_INTERVAL_CONVEX THEN
    CONJ_TAC THENL [ASM_MESON_TAC[OPEN_INTERVAL_MIDPOINT], ALL_TAC] THEN
    KNOW_TAC ``&0:real < &n + &1`` THENL [SIMP_TAC std_ss [REAL_OF_NUM_SUC] THEN
    ASM_REWRITE_TAC[REAL_LT_INV_EQ, REAL_OF_NUM_SUC, REAL_LT, LESS_0], ALL_TAC] THEN
    DISCH_TAC THEN ASM_REWRITE_TAC[REAL_LT_INV_EQ, REAL_OF_NUM_SUC, REAL_LT, LESS_0] THEN
    MATCH_MP_TAC REAL_INV_LE_1 THEN REWRITE_TAC [REAL_LE, ONE, LESS_EQ_MONO,
    ZERO_LESS_EQ], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [REAL_ARITH ``x:real = x + &0 * (c - x)``] THEN
  KNOW_TAC ``!n:num x:real. (\n. x + inv (&n + 1) * (c - x)) =
                     (\n. (\n. x) n + (\n. inv (&n + 1) * (c - x)) n)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LIM_ADD THEN REWRITE_TAC[LIM_CONST] THEN
  KNOW_TAC ``!n:num. (\n. inv (&n + 1) * (c - x:real)) =
                     (\n. (\n. inv (&n + 1)) n * (\n. (c - x)) n)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LIM_MUL THEN REWRITE_TAC[LIM_CONST] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, o_THM, REAL_SUB_RZERO] THEN BETA_TAC THEN
  X_GEN_TAC ``e:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_ARCH_INV] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  KNOW_TAC ``&n + 1 <> 0:real`` THENL
  [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   SIMP_TAC arith_ss [REAL_OF_NUM_SUC, REAL_LT, ADD1], ALL_TAC] THEN DISCH_TAC THEN
  ASM_SIMP_TAC std_ss [DIST_0, ABS_INV] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``inv(&N:real)`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``N:num <= n`` THEN UNDISCH_TAC ``N <> 0:num`` THEN
  REWRITE_TAC[NOT_ZERO_LT_ZERO, GSYM REAL_OF_NUM_LE, GSYM REAL_LT] THEN
  REAL_ARITH_TAC);

val CLOSURE_INTERVAL = store_thm ("CLOSURE_INTERVAL",
 ``(!a b. closure(interval[a,b]) = interval[a,b]) /\
   (!a b. closure(interval(a,b)) =
          if interval(a,b) = {} then {} else interval[a,b])``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_INTERVAL] THEN REPEAT GEN_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [CLOSURE_OPEN_INTERVAL, CLOSURE_EMPTY]);

val BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC = store_thm ("BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC",
 ``!s:real->bool. bounded s ==> ?a. s SUBSET interval(-a,a)``,
  SIMP_TAC std_ss [BOUNDED_POS, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``B:real``] THEN STRIP_TAC THEN
  EXISTS_TAC ``(B + &1):real`` THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [IN_INTERVAL, REAL_BOUNDS_LT] THEN
  METIS_TAC[REAL_LE_REFL, REAL_ARITH ``x <= y ==> a <= x ==> a < y + &1:real``]);

val BOUNDED_SUBSET_OPEN_INTERVAL = store_thm ("BOUNDED_SUBSET_OPEN_INTERVAL",
 ``!s:real->bool. bounded s ==> ?a b. s SUBSET interval(a,b)``,
  MESON_TAC[BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC]);

val BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC = store_thm ("BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC",
 ``!s:real->bool. bounded s ==> ?a. s SUBSET interval[-a,a]``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC) THEN
  STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [IN_BALL, IN_INTERVAL, SUBSET_DEF, REAL_LT_IMP_LE]);

val BOUNDED_SUBSET_CLOSED_INTERVAL = store_thm ("BOUNDED_SUBSET_CLOSED_INTERVAL",
 ``!s:real->bool. bounded s ==> ?a b. s SUBSET interval[a,b]``,
  MESON_TAC[BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC]);

val FRONTIER_CLOSED_INTERVAL = store_thm ("FRONTIER_CLOSED_INTERVAL",
 ``!a b. frontier(interval[a,b]) = interval[a,b] DIFF interval(a,b)``,
  SIMP_TAC std_ss [frontier, INTERIOR_CLOSED_INTERVAL, CLOSURE_CLOSED,
           CLOSED_INTERVAL]);

val FRONTIER_OPEN_INTERVAL = store_thm ("FRONTIER_OPEN_INTERVAL",
 ``!a b. frontier(interval(a,b)) =
                if interval(a,b) = {} then {}
                else interval[a,b] DIFF interval(a,b)``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[FRONTIER_EMPTY] THEN
  ASM_SIMP_TAC std_ss [frontier, CLOSURE_OPEN_INTERVAL, INTERIOR_OPEN,
               OPEN_INTERVAL]);

val INTER_INTERVAL_MIXED_EQ_EMPTY = store_thm ("INTER_INTERVAL_MIXED_EQ_EMPTY",
 ``!a b c d:real.
        ~(interval(c,d) = {})
        ==> ((interval(a,b) INTER interval[c,d] = {}) <=>
             (interval(a,b) INTER interval(c,d) = {}))``,
  SIMP_TAC std_ss [GSYM CLOSURE_OPEN_INTERVAL, OPEN_INTER_CLOSURE_EQ_EMPTY,
           OPEN_INTERVAL]);

val INTERVAL_TRANSLATION = store_thm ("INTERVAL_TRANSLATION",
 ``(!c a b. interval[c + a,c + b] = IMAGE (\x. c + x) (interval[a,b])) /\
   (!c a b. interval(c + a,c + b) = IMAGE (\x. c + x) (interval(a,b)))``,
  REWRITE_TAC[interval] THEN CONJ_TAC THEN
  (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
   REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
   TRY (EXISTS_TAC ``-c + x:real``) THEN ASM_REAL_ARITH_TAC));

val EMPTY_AS_INTERVAL = store_thm ("EMPTY_AS_INTERVAL",
 ``{} = interval[1,0]``,
  SIMP_TAC std_ss [EXTENSION, NOT_IN_EMPTY, IN_INTERVAL] THEN
  REAL_ARITH_TAC);

val UNIT_INTERVAL_NONEMPTY = store_thm ("UNIT_INTERVAL_NONEMPTY",
 ``~(interval[0:real,1] = {}) /\
   ~(interval(0:real,1) = {})``,
  SIMP_TAC std_ss [INTERVAL_NE_EMPTY, REAL_LT_01, REAL_POS]);

val IMAGE_STRETCH_INTERVAL = store_thm
  ("IMAGE_STRETCH_INTERVAL",
 ``!a b:real m.
    IMAGE (\x. @f. f = m(1:num) * x) (interval[a,b]) =
        if interval[a,b] = {} then {}
        else interval[(@f. f = min (m(1:num) * a) (m(1:num) * b)):real,
                      (@f. f = max (m(1:num) * a) (m(1:num) * b))]``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_INTERVAL, GSYM FORALL_AND_THM,
               TAUT `(a ==> b) /\ (a ==> c) <=> a ==> b /\ c`] THEN
  X_GEN_TAC ``x:real`` THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INTERVAL_NE_EMPTY]) THEN
  ASM_CASES_TAC ``(m:num->real) (1:num) = &0`` THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_LZERO, REAL_MAX_ACI, REAL_MIN_ACI] THEN
    METIS_TAC[REAL_LE_ANTISYM, REAL_LE_REFL],
    ALL_TAC] THEN
  KNOW_TAC ``!m x y:real. ~(m = 0:real) ==> ((x = m * y) <=> (y = x / m))`` THENL
  [REPEAT GEN_TAC THEN DISCH_TAC THEN ASSUME_TAC REAL_LE_TOTAL THEN
   GEN_REWR_TAC RAND_CONV [EQ_SYM_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
   POP_ASSUM (MP_TAC o Q.SPECL [`m':real`,`0:real`]) THEN
   ASM_SIMP_TAC std_ss [REAL_LE_LT] THEN STRIP_TAC THENL
   [ALL_TAC, METIS_TAC [REAL_EQ_LDIV_EQ]] THEN
   ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN REWRITE_TAC [real_div] THEN
   REWRITE_TAC [REAL_ARITH ``-(a * b) = a * -b:real``] THEN
   ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN POP_ASSUM MP_TAC THEN
   GEN_REWR_TAC LAND_CONV [GSYM REAL_LT_NEG] THEN REWRITE_TAC [REAL_NEG_0] THEN
   DISCH_TAC THEN REWRITE_TAC [REAL_ARITH ``(-x = y * -m) <=> (x = -y * -m:real)``] THEN
   METIS_TAC [REAL_EQ_LDIV_EQ], DISCH_TAC THEN ASM_SIMP_TAC std_ss []] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP
   (REAL_ARITH ``~(z = &0) ==> &0 < z \/ &0 < -z:real``))
  >- ( ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ] \\
       DISCH_TAC \\
       `(m 1) * a <= (m 1) * b` by PROVE_TAC [REAL_LE_LMUL] \\
       ASM_SIMP_TAC std_ss [min_def, max_def] \\
       METIS_TAC [REAL_MUL_SYM] )
  >> ONCE_REWRITE_TAC[GSYM REAL_LE_NEG2]
  >> ONCE_REWRITE_TAC[REAL_MUL_SYM]
  >> KNOW_TAC ``!a b. -(max a b) = min (-a) (-b:real)``
  >- PROVE_TAC [REAL_MAX_MIN, REAL_NEG_NEG] >> DISCH_TAC
  >> KNOW_TAC ``!a b. -(min a b) = max (-a) (-b:real)``
  >- PROVE_TAC [REAL_MIN_MAX, REAL_NEG_NEG] >> DISCH_TAC
  >> ASM_SIMP_TAC std_ss [real_div, GSYM REAL_MUL_RNEG, REAL_NEG_INV]
  >> REWRITE_TAC [GSYM real_div]
  >> ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ]
  >> ONCE_REWRITE_TAC [REAL_LE_NEG2]
  >> DISCH_TAC
  >> `a * -(m 1) <= b * -(m 1)` by PROVE_TAC [REAL_LE_RMUL]
  >> ASM_SIMP_TAC std_ss [min_def, max_def]
  >> REAL_ARITH_TAC);

val INTERVAL_IMAGE_STRETCH_INTERVAL = store_thm ("INTERVAL_IMAGE_STRETCH_INTERVAL",
 ``!a b:real m. ?u v:real.
     IMAGE (\x. @f. f = m (1:num) * x) (interval[a,b]) = interval[u,v]``,
  SIMP_TAC std_ss [IMAGE_STRETCH_INTERVAL] THEN METIS_TAC[EMPTY_AS_INTERVAL]);

val CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL = store_thm ("CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL",
 ``!a b:real.
        ~(interval[a,b] = {})
        ==> (interval[a,b] = IMAGE (\x:real. a + x)
                                  (IMAGE (\x. (@f. f = (b - a) * x))
                                         (interval[0:real,1])))``,
  REWRITE_TAC[INTERVAL_NE_EMPTY] THEN REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. @f. f = (b - a) * x) =
                               (\x. @f. f = (\x. (b - a)) (1:num) * x:real)``] THEN
  REWRITE_TAC[IMAGE_STRETCH_INTERVAL] THEN
  SIMP_TAC std_ss [REAL_MUL_RZERO, REAL_MUL_RID, UNIT_INTERVAL_NONEMPTY] THEN
  REWRITE_TAC[EXTENSION, IN_INTERVAL] THEN
  GEN_TAC THEN SIMP_TAC std_ss [IN_IMAGE, IN_INTERVAL, min_def, max_def] THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LE] THEN EQ_TAC THENL
  [DISCH_TAC THEN EXISTS_TAC ``x - a:real`` THEN ASM_REAL_ARITH_TAC, ASM_REAL_ARITH_TAC]);

val SUMS_INTERVALS = store_thm ("SUMS_INTERVALS",
 ``(!a b c d:real.
        ~(interval[a,b] = {}) /\ ~(interval[c,d] = {})
        ==> ({x + y | x IN interval[a,b] /\ y IN interval[c,d]} =
             interval[a+c,b+d])) /\
   (!a b c d:real.
        ~(interval(a,b) = {}) /\ ~(interval(c,d) = {})
        ==> ({x + y | x IN interval(a,b) /\ y IN interval(c,d)} =
             interval(a+c,b+d)))``,
  CONJ_TAC THEN REPEAT GEN_TAC THEN REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
  STRIP_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_INTERVAL, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC[TAUT `(a /\ b) /\ c <=> c /\ a /\ b`] THEN
  REWRITE_TAC[REAL_ARITH ``(x:real = y + z) <=> (z = x - y)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN (* 2 subgoals *)
  ( X_GEN_TAC ``x:real`` THEN EQ_TAC
 >- ( DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) >> ASM_REAL_ARITH_TAC )
 >> STRIP_TAC
 >> ONCE_REWRITE_TAC [CONJ_SYM]
 >> KNOW_TAC
    ``(!y. (a <= y /\ y <= b) /\ c <= x - y /\ x - y <= d <=>
       ((if a <= x - d then x - d else a) <= y /\
    y <= if b <= x - c then b else x - c:real)) /\
      (!y. (a < y /\ y < b) /\ c < x - y /\ x - y < d <=>
       ((if a <= x - d then x - d else a) < y /\
    y < if b <= x - c then b else x - c:real))``
 >- ( CONJ_TAC >> GEN_TAC >> rpt COND_CASES_TAC >> ASM_REAL_ARITH_TAC )
 >> STRIP_TAC >> ASM_REWRITE_TAC []
 >> REWRITE_TAC [GSYM min_def, GSYM max_def, GSYM REAL_LE_BETWEEN, GSYM REAL_LT_BETWEEN]
 >> ASM_REWRITE_TAC [min_def, max_def]
 >> rpt COND_CASES_TAC (* 4 subgoals *)
 >> METIS_TAC [REAL_LE_SUB_LADD, REAL_LE_SUB_RADD, REAL_LE_LADD, REAL_LE_NEG, real_sub,
               REAL_LT_SUB_LADD, REAL_LT_SUB_RADD, REAL_LT_LADD, REAL_LT_NEG] ));

val OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL = store_thm ("OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval[a,b] SUBSET s) /\
   (!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval(a,b) SUBSET s)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN GEN_TAC THEN
  MATCH_MP_TAC(TAUT
   `(q ==> r) /\ (r ==> p) /\ (p ==> q) ==> (p <=> q) /\ (p <=> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[SUBSET_TRANS, INTERVAL_OPEN_SUBSET_CLOSED],
    DISCH_TAC THEN REWRITE_TAC[OPEN_CONTAINS_BALL] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN STRIP_TAC THEN
    MP_TAC(ISPEC ``interval(a:real,b)`` OPEN_CONTAINS_BALL) THEN
    REWRITE_TAC[OPEN_INTERVAL] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
        REPEAT STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
    ASM_MESON_TAC[SUBSET_TRANS, INTERVAL_OPEN_SUBSET_CLOSED],
    DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o SPEC ``x:real`` o
      REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``x - e:real`` THEN
    EXISTS_TAC ``x + e:real`` THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
     ``b SUBSET s ==> x IN i /\ j SUBSET b ==> x IN i /\ j SUBSET s``)) THEN
    SIMP_TAC std_ss [IN_INTERVAL, IN_CBALL, SUBSET_DEF, REAL_MUL_RID] THEN
    REWRITE_TAC[REAL_ARITH ``x - e < x /\ x < x + e <=> &0 < e:real``,
                REAL_ARITH ``x - e <= y /\ y <= x + e <=> abs(x - y) <= e:real``] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, LE_1] THEN
    X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN ASM_REWRITE_TAC[dist]]);

val OPEN_CONTAINS_INTERVAL = store_thm ("OPEN_CONTAINS_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval[a,b] SUBSET s)``,
   REWRITE_TAC [OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL]);

val OPEN_CONTAINS_OPEN_INTERVAL = store_thm ("OPEN_CONTAINS_OPEN_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval(a,b) SUBSET s)``,
   METIS_TAC [OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL]);

val DIAMETER_INTERVAL = store_thm ("DIAMETER_INTERVAL",
 ``(!a b:real.
        diameter(interval[a,b]) =
        if interval[a,b] = {} then &0 else abs(b - a)) /\
   (!a b:real.
        diameter(interval(a,b)) =
        if interval(a,b) = {} then &0 else abs(b - a))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``interval[a:real,b] = {}`` THENL
   [METIS_TAC[INTERVAL_OPEN_SUBSET_CLOSED, SUBSET_EMPTY, DIAMETER_EMPTY],
    ASM_REWRITE_TAC[]] THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
   [REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
    ASM_SIMP_TAC std_ss [DIAMETER_BOUNDED_BOUND,
                 ENDS_IN_INTERVAL, BOUNDED_INTERVAL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
     ``diameter(cball(inv(&2) * (a + b):real,abs(b - a) / &2))`` THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC DIAMETER_SUBSET THEN REWRITE_TAC[BOUNDED_CBALL] THEN
      REWRITE_TAC[SUBSET_DEF, IN_INTERVAL, IN_CBALL] THEN
      GEN_TAC THEN DISCH_TAC THEN REWRITE_TAC[dist] THEN
      KNOW_TAC ``x = x * (2 / 2:real)`` THENL
      [METIS_TAC [REAL_DIV_REFL, REAL_MUL_RID, REAL_ARITH ``2 <> 0:real``],
       DISCH_TAC THEN ONCE_ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
       REWRITE_TAC [real_div]] THEN
      REWRITE_TAC [REAL_ARITH ``a * (b * inv b) = inv b * (a * b:real)``] THEN
      REWRITE_TAC [GSYM REAL_SUB_LDISTRIB, ABS_MUL] THEN
      SIMP_TAC std_ss [ABS_INV, REAL_ARITH ``2 <> 0:real``, ABS_N] THEN
      GEN_REWR_TAC RAND_CONV [REAL_MUL_SYM] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
      SIMP_TAC std_ss [ABS_POS, REAL_LE_REFL, REAL_INV_1OVER, REAL_HALF_BETWEEN] THEN
      ASM_REAL_ARITH_TAC,
      REWRITE_TAC[DIAMETER_CBALL] THEN COND_CASES_TAC THEN
      REWRITE_TAC [ABS_POS, real_div] THEN
      ONCE_REWRITE_TAC [REAL_ARITH ``a * (b * c) = (a * c) * b:real``] THEN
      SIMP_TAC std_ss [REAL_MUL_RINV, REAL_ARITH ``2 <> 0:real``] THEN
      REAL_ARITH_TAC],
    DISCH_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[DIAMETER_EMPTY] THEN
    SUBGOAL_THEN ``interval[a:real,b] = closure(interval(a,b))``
    SUBST_ALL_TAC THEN ASM_REWRITE_TAC[CLOSURE_INTERVAL] THEN
    ASM_MESON_TAC[DIAMETER_CLOSURE, BOUNDED_INTERVAL]]);

val IMAGE_TWIZZLE_INTERVAL = store_thm ("IMAGE_TWIZZLE_INTERVAL",
 ``!p a b. IMAGE ((\x. x):real->real) (interval[a,b]) =
               interval[a,b]``,
  SET_TAC [interval]);

val EQ_INTERVAL = store_thm ("EQ_INTERVAL",
 ``(!a b c d:real.
        (interval[a,b] = interval[c,d]) <=>
        ((interval[a,b] = {}) /\ (interval[c,d] = {})) \/ ((a = c) /\ (b = d))) /\
   (!a b c d:real.
        (interval[a,b] = interval(c,d)) <=>
        (interval[a,b] = {}) /\ (interval(c,d) = {})) /\
   (!a b c d:real.
        (interval(a,b) = interval[c,d]) <=>
        (interval(a,b) = {}) /\ (interval[c,d] = {})) /\
   (!a b c d:real.
        (interval(a,b) = interval(c,d)) <=>
        ((interval(a,b) = {}) /\ (interval(c,d) = {})) \/ ((a = c) /\ (b = d)))``,
  REPEAT CONJ_TAC THEN REPEAT GEN_TAC THEN
  (EQ_TAC THENL [ALL_TAC, STRIP_TAC THEN ASM_REWRITE_TAC[]]) THEN
  MATCH_MP_TAC(MESON[]
   ``((p = {}) /\ (q = {}) ==> r) /\ (~(p = {}) /\ ~(q = {}) ==> (p = q) ==> r)
    ==> (p = q) ==> r``) THEN
  SIMP_TAC std_ss [] THENL
   [REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
    REWRITE_TAC[GSYM SUBSET_ANTISYM] THEN
    METIS_TAC [SUBSET_INTERVAL, GSYM REAL_LE_ANTISYM],
    STRIP_TAC THEN MATCH_MP_TAC(MESON[CLOPEN]
     ``closed s /\ open t /\ ~(s = {}) /\ ~(s = UNIV) ==> ~(s = t)``) THEN
    ASM_REWRITE_TAC[CLOSED_INTERVAL, OPEN_INTERVAL, NOT_INTERVAL_UNIV],
    STRIP_TAC THEN MATCH_MP_TAC(MESON[CLOPEN]
     ``closed s /\ open t /\ ~(s = {}) /\ ~(s = UNIV) ==> ~(t = s)``) THEN
    ASM_REWRITE_TAC[CLOSED_INTERVAL, OPEN_INTERVAL, NOT_INTERVAL_UNIV],
    REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
    REWRITE_TAC[GSYM SUBSET_ANTISYM] THEN
    METIS_TAC [SUBSET_INTERVAL, GSYM REAL_LE_ANTISYM]]);

val CLOSED_INTERVAL_EQ = store_thm ("CLOSED_INTERVAL_EQ",
 ``(!a b:real. closed(interval[a,b])) /\
   (!a b:real. closed(interval(a,b)) <=> (interval(a,b) = {}))``,
  REWRITE_TAC[CLOSED_INTERVAL] THEN
  REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN
  MP_TAC(ISPEC ``interval(a:real,b)`` CLOPEN) THEN
  ASM_REWRITE_TAC[OPEN_INTERVAL] THEN
  METIS_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val OPEN_INTERVAL_EQ = store_thm ("OPEN_INTERVAL_EQ",
 ``(!a b:real. open(interval[a,b]) <=> (interval[a,b] = {})) /\
   (!a b:real. open(interval(a,b)))``,
  REWRITE_TAC[OPEN_INTERVAL] THEN
  REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN
  MP_TAC(ISPEC ``interval[a:real,b]`` CLOPEN) THEN
  ASM_REWRITE_TAC[CLOSED_INTERVAL] THEN
  METIS_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val COMPACT_INTERVAL_EQ = store_thm ("COMPACT_INTERVAL_EQ",
 ``(!a b:real. compact(interval[a,b])) /\
   (!a b:real. compact(interval(a,b)) <=> (interval(a,b) = {}))``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTERVAL] THEN
  REWRITE_TAC[CLOSED_INTERVAL_EQ]);

val EQ_BALLS = store_thm ("EQ_BALLS",
 ``(!a a':real r r'.
      (ball(a,r) = ball(a',r')) <=> (a = a') /\ (r = r') \/ r <= &0 /\ r' <= &0) /\
   (!a a':real r r'.
      (ball(a,r) = cball(a',r')) <=> r <= &0 /\ r' < &0) /\
   (!a a':real r r'.
      (cball(a,r) = ball(a',r')) <=> r < &0 /\ r' <= &0) /\
   (!a a':real r r'.
      (cball(a,r) = cball(a',r')) <=> (a = a') /\ (r = r') \/ r < &0 /\ r' < &0)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT STRIP_TAC THEN
  (EQ_TAC THENL
    [ALL_TAC, REWRITE_TAC[EXTENSION, IN_BALL, IN_CBALL, dist] THEN REAL_ARITH_TAC])
  THENL
   [SIMP_TAC std_ss [SET_EQ_SUBSET, SUBSET_BALLS, dist] THEN REAL_ARITH_TAC,
    ONCE_REWRITE_TAC[EQ_SYM_EQ],
    ALL_TAC,
    REWRITE_TAC[SET_EQ_SUBSET, SUBSET_BALLS, dist] THEN REAL_ARITH_TAC] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (METIS [CLOPEN, BOUNDED_BALL, NOT_BOUNDED_UNIV]
    ``(s = t) ==> closed s /\ open t /\ bounded t ==> (s = {}) /\ (t = {})``)) THEN
  REWRITE_TAC[OPEN_BALL, CLOSED_CBALL, BOUNDED_BALL,
              BALL_EQ_EMPTY, CBALL_EQ_EMPTY] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Some special cases for intervals in R^1.                                  *)
(* ------------------------------------------------------------------------- *)

val INTERVAL_CASES = store_thm ("INTERVAL_CASES",
 ``!x:real. x IN interval[a,b] ==> x IN interval(a,b) \/ (x = a) \/ (x = b)``,
  REWRITE_TAC[IN_INTERVAL] THEN REAL_ARITH_TAC);

val OPEN_CLOSED_INTERVAL = store_thm ("OPEN_CLOSED_INTERVAL",
 ``!a b:real. interval(a,b) = interval[a,b] DIFF {a;b}``,
  REWRITE_TAC[EXTENSION, IN_INTERVAL, IN_DIFF, IN_INSERT, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val CLOSED_OPEN_INTERVAL = store_thm ("CLOSED_OPEN_INTERVAL",
 ``!a b:real. a <= b ==> (interval[a,b] = interval(a,b) UNION {a;b})``,
  REWRITE_TAC[EXTENSION, IN_INTERVAL, IN_UNION, IN_INSERT, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val BALL = store_thm ("BALL",
 ``!x:real r. (cball(x,r) = interval[x - r,x + r]) /\
               (ball(x,r) = interval(x - r,x + r))``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_CBALL, IN_INTERVAL] THEN
  REWRITE_TAC[dist] THEN REAL_ARITH_TAC);

val SPHERE = store_thm ("SPHERE",
 ``!a:real r. sphere(a,r) = if r < (&0:real) then {} else {a - r;a + r}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sphere] THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_INSERT, NOT_IN_EMPTY, GSPECIFICATION, dist] THEN
  ASM_REAL_ARITH_TAC);

val FINITE_SPHERE = store_thm ("FINITE_SPHERE",
 ``!a:real r. FINITE(sphere(a,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SPHERE] THEN
  METIS_TAC[FINITE_INSERT, FINITE_EMPTY]);

val FINITE_INTERVAL = store_thm ("FINITE_INTERVAL",
 ``(!a b. FINITE(interval[a,b]) <=> b <= a) /\
   (!a b. FINITE(interval(a,b)) <=> b <= a)``,
  REWRITE_TAC[OPEN_CLOSED_INTERVAL] THEN
  REWRITE_TAC[SET_RULE ``s DIFF {a;b} = s DELETE a DELETE b``] THEN
  REWRITE_TAC[FINITE_DELETE] THEN REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [interval, FINITE_IMAGE_INJ_EQ, FINITE_REAL_INTERVAL]);

val BALL_INTERVAL = store_thm ("BALL_INTERVAL",
 ``!x:real e. ball(x,e) = interval(x - e,x + e)``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_INTERVAL, dist] THEN
  REAL_ARITH_TAC);

val CBALL_INTERVAL = store_thm ("CBALL_INTERVAL",
 ``!x:real e. cball(x,e) = interval[x - e,x + e]``,
  REWRITE_TAC[EXTENSION, IN_CBALL, IN_INTERVAL, dist] THEN
  REAL_ARITH_TAC);

val BALL_INTERVAL_0 = store_thm ("BALL_INTERVAL_0",
 ``!e. ball(0:real,e) = interval(-e,e)``,
  GEN_TAC THEN REWRITE_TAC[BALL_INTERVAL] THEN AP_TERM_TAC THEN
  BINOP_TAC THEN REAL_ARITH_TAC);

val CBALL_INTERVAL_0 = store_thm ("CBALL_INTERVAL_0",
 ``!e. cball(0:real,e) = interval[-e,e]``,
  GEN_TAC THEN REWRITE_TAC[CBALL_INTERVAL] THEN AP_TERM_TAC THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN BINOP_TAC THEN REAL_ARITH_TAC);

val CLOSED_DIFF_OPEN_INTERVAL = store_thm ("CLOSED_DIFF_OPEN_INTERVAL",
 ``!a b:real.
        interval[a,b] DIFF interval(a,b) =
        if interval[a,b] = {} then {} else {a;b}``,
  REWRITE_TAC[EXTENSION, IN_DIFF, GSYM INTERVAL_EQ_EMPTY, IN_INTERVAL] THEN
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[NOT_IN_EMPTY, IN_INSERT, NOT_IN_EMPTY] THEN
  FULL_SIMP_TAC std_ss [NOT_IN_EMPTY] THEN
  ASM_REAL_ARITH_TAC);

val INTERVAL = store_thm ("INTERVAL",
 ``(!a b:real. interval[a,b] =
                 if a <= b then cball(midpoint(a,b),dist(a,b) / &2)
                 else {}) /\
   (!a b:real. interval(a,b) =
                 if a < b then ball(midpoint(a,b),dist(a,b) / &2)
                 else {})``,
  REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[REAL_NOT_LE, REAL_NOT_LT]) THEN
  ASM_REWRITE_TAC[INTERVAL_EQ_EMPTY] THEN
  REWRITE_TAC[BALL, dist] THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LE, REAL_LT_IMP_LE,
                       REAL_ARITH ``a <= b ==> (abs(a - b) = b - a:real)``] THEN
  REWRITE_TAC[METIS [real_div, REAL_MUL_SYM] ``x / &2 = inv(&2:real) * x``] THEN
  REWRITE_TAC[midpoint] THEN
  TRY AP_TERM_TAC THEN ASM_SIMP_TAC std_ss [PAIR_EQ, CONS_11, GSYM INTERVAL_EQ_EMPTY] THEN
  REWRITE_TAC [GSYM REAL_SUB_LDISTRIB, GSYM REAL_ADD_LDISTRIB] THEN
  REWRITE_TAC [REAL_ARITH ``a + b - (b - a) = 2 * a:real``] THEN
  REWRITE_TAC [REAL_ARITH ``a + b + (b - a) = 2 * b:real``] THEN
  SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_ARITH ``2 <> 0:real``, REAL_MUL_LINV] THEN REAL_ARITH_TAC);

val SEGMENT = store_thm ("SEGMENT",
 ``(!a b. segment[a,b] =
          if a <= b then interval[a,b] else interval[b,a]) /\
   (!a b. segment(a,b) =
          if a <= b then interval(a,b) else interval(b,a))``,
  CONJ_TAC THEN REPEAT GEN_TAC THEN REWRITE_TAC[open_segment] THEN
  COND_CASES_TAC THEN
  REWRITE_TAC[IN_DIFF, IN_INSERT, NOT_IN_EMPTY,
              EXTENSION, GSYM BETWEEN_IN_SEGMENT, between, IN_INTERVAL] THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val OPEN_SEGMENT = store_thm ("OPEN_SEGMENT",
 ``!a b:real. open(segment(a,b))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SEGMENT] THEN
  COND_CASES_TAC THEN REWRITE_TAC[OPEN_INTERVAL]);

val SEGMENT_SCALAR_MULTIPLE = store_thm ("SEGMENT_SCALAR_MULTIPLE",
 ``(!a b v:real. segment[a * v,b * v] =
            {x * v:real | a <= x /\ x <= b \/ b <= x /\ x <= a}) /\
   (!a b v:real. ~(v = 0)
            ==> (segment(a * v,b * v) =
                 {x * v:real | a < x /\ x < b \/ b < x /\ x < a}))``,
  MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN REPEAT STRIP_TAC THENL
   [REPEAT GEN_TAC THEN
    MP_TAC(SPECL [``a * 1:real``, ``b * 1:real``]
     (CONJUNCT1 SEGMENT)) THEN
    REWRITE_TAC[segment, REAL_MUL_ASSOC, GSYM REAL_ADD_RDISTRIB] THEN
        ONCE_REWRITE_TAC [METIS [] ``((1 - u) * a + u * b:real) =
                                (\u. ((1 - u) * a + u * b)) u``] THEN
        ONCE_REWRITE_TAC [METIS [] ``(0 <= u /\ u <= 1:real) =
                                (\u.  0 <= u /\ u <= 1) u``] THEN
        ONCE_REWRITE_TAC [METIS []
        ``{x:real * v | a <= x /\ x <= b \/ b <= x /\ x <= a} =
          {(\x. x) x * v | (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x}``] THEN
    REWRITE_TAC [SET_RULE ``{f x * b:real | p (x:real)} =
                                IMAGE (\a. a * b) {f x | p x}``] THEN
    BETA_TAC THEN DISCH_TAC THEN AP_TERM_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [REAL_MUL_RID, IMAGE_ID]) THEN
    DISCH_THEN SUBST1_TAC THEN COND_CASES_TAC THEN
        SIMP_TAC std_ss [EXTENSION, IN_INTERVAL, GSPECIFICATION] THEN ASM_REAL_ARITH_TAC,
    ASM_REWRITE_TAC[open_segment] THEN
        ONCE_REWRITE_TAC [METIS [] ``{x * v | a <= x /\ x <= b \/ b <= x /\ x <= a:real} =
                        {(\x. x) x * v | (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x}``] THEN
    ASM_SIMP_TAC std_ss [REAL_EQ_RMUL, SET_RULE
     ``(!x y:real. (x * v = y * v) <=> (x = y))
      ==> ({x * v | P x} DIFF {a * v;b * v} =
           {x * v | P x /\ ~(x = a) /\ ~(x = b)})``] THEN
        ONCE_REWRITE_TAC [SET_RULE
        ``{x * v | (a <= x /\ x <= b \/ b <= x /\ x <= a) /\ x <> a /\ x <> b:real} =
     {(\x. x * v) x | x IN (\x. (a <= x /\ x <= b \/ b <= x /\ x <= a) /\ x <> a /\ x <> b)}``] THEN
        ONCE_REWRITE_TAC [SET_RULE
              ``{x * v | a < x /\ x < b \/ b < x /\ x < a:real} =
       {(\x. x * v) x | x IN (\x. (a < x /\ x < b \/ b < x /\ x < a))}``] THEN
    ONCE_REWRITE_TAC[GSYM IMAGE_DEF] THEN AP_TERM_TAC THEN
    ABS_TAC THEN REAL_ARITH_TAC]);

(* ------------------------------------------------------------------------- *)
(* Intervals in general, including infinite and mixtures of open and closed. *)
(* ------------------------------------------------------------------------- *)

val is_interval = new_definition ("is_interval",
  ``is_interval(s:real->bool) <=>
        !a b x. a IN s /\ b IN s
                     ==> (a <= x /\ x <= b) \/
                         (b <= x /\ x <= a)
                ==> x IN s``);

val IS_INTERVAL_INTERVAL = store_thm ("IS_INTERVAL_INTERVAL",
 ``!a:real b. is_interval(interval (a,b)) /\ is_interval(interval [a,b])``,
  REWRITE_TAC[is_interval, IN_INTERVAL] THEN
  METIS_TAC[REAL_LT_TRANS, REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]);

val IS_INTERVAL_EMPTY = store_thm ("IS_INTERVAL_EMPTY",
 ``is_interval {}``,
  REWRITE_TAC[is_interval, NOT_IN_EMPTY]);

val IS_INTERVAL_UNIV = store_thm ("IS_INTERVAL_UNIV",
 ``is_interval(UNIV:real->bool)``,
  REWRITE_TAC[is_interval, IN_UNIV]);

val IS_INTERVAL_POINTWISE = store_thm ("IS_INTERVAL_POINTWISE",
 ``!s:real->bool x.
        is_interval s ==> (?a. a IN s /\ (a = x))
        ==> x IN s``,
  METIS_TAC [is_interval]);

Theorem IS_INTERVAL_COMPACT :
    !s:real->bool. is_interval s /\ compact s <=> ?a b. s = interval[a,b]
Proof
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [IS_INTERVAL_INTERVAL, COMPACT_INTERVAL] THEN
  ASM_CASES_TAC ``s:real->bool = {}``
  >- ASM_MESON_TAC[EMPTY_AS_INTERVAL] THEN (* one goal left *)
  EXISTS_TAC ``(@f. f = inf { (x:real) | x IN s}):real`` THEN
  EXISTS_TAC ``(@f. f = sup { (x:real) | x IN s}):real`` THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTERVAL] THEN X_GEN_TAC ``x:real`` THEN
  EQ_TAC THENL (* 2 subgoals *)
  [ (* goal 1 (of 2) *)
    DISCH_TAC THEN
    MP_TAC(ISPEC ``{ (x:real) | x IN s}`` INF) THEN
    MP_TAC(ISPEC ``{ (x:real) | x IN s}`` SUP) THEN
    SIMP_TAC std_ss [METIS [] ``x = (\x. x) x``, GSYM IMAGE_DEF] THEN
    ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP COMPACT_IMP_BOUNDED) THEN
    REWRITE_TAC[bounded_def] THEN
    ASM_MESON_TAC[REAL_LE_TRANS, MEMBER_NOT_EMPTY,
                  REAL_ARITH ``abs(x) <= B ==> -B <= x /\ x <= B:real``],
    (* goal 2 (of 2) *)
    DISCH_TAC THEN
    SUFF_TAC ``?a:real. a IN s /\ (a = x)``
    >- (MATCH_MP_TAC IS_INTERVAL_POINTWISE >> ASM_REWRITE_TAC []) THEN
    SUBGOAL_THEN
     ``?a b:real. a IN s /\ b IN s /\ a <= (x:real) /\ x <= b``
    STRIP_ASSUME_TAC THENL (* 2 subgoals *)
    [ (* goal 2.1 (of 2) *)
      MP_TAC (ISPECL [``\x:real. x``, ``s:real->bool``]
                     CONTINUOUS_ATTAINS_INF) THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, o_DEF] THEN
      DISCH_THEN (X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC ``a:real`` THEN
      MP_TAC (ISPECL [``\x:real. x``, ``s:real->bool``]
                     CONTINUOUS_ATTAINS_SUP) THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, o_DEF] THEN
      DISCH_THEN (X_CHOOSE_THEN ``b:real`` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC ``b:real`` THEN ASM_REWRITE_TAC [] THEN
      CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL (* 2 subgoals *)
      [ (* goal 2.1.1 (of 2) *)
        EXISTS_TAC ``inf {(x:real) | x IN s}`` THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC REAL_LE_INF THEN
        ONCE_REWRITE_TAC [METIS [SPECIFICATION] ``{x | x IN s} x <=> x IN {x | x IN s}``] THEN
        ASM_SET_TAC [],
        (* goal 2.1.2 (of 2) *)
        EXISTS_TAC ``sup {(x:real) | x IN s}`` THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC REAL_SUP_LE' THEN
        ONCE_REWRITE_TAC [METIS [SPECIFICATION] ``{x | x IN s} x <=> x IN {x | x IN s}``] THEN
        ASM_SET_TAC [] ],
      (* goal 2.2 (of 2) *)
      EXISTS_TAC ``x:real`` THEN ASM_SIMP_TAC std_ss [] THEN
      UNDISCH_TAC ``is_interval s`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[is_interval, AND_IMP_INTRO]) THEN
      MAP_EVERY EXISTS_TAC [``a:real``, ``b:real``] THEN
      ASM_SIMP_TAC std_ss [] ] ]
QED

val IS_INTERVAL = store_thm ("IS_INTERVAL",
 ``!s:real->bool.
        is_interval s <=>
          !a b x. a IN s /\ b IN s /\ a <= x /\ x <= b
                  ==> x IN s``,
  REWRITE_TAC[is_interval] THEN MESON_TAC[]);

val IS_INTERVAL_CASES = store_thm ("IS_INTERVAL_CASES",
 ``!s:real->bool.
        is_interval s <=>
        (s = {}) \/
        (s = univ(:real)) \/
        (?a. s = {x | a < x}) \/
        (?a. s = {x | a <= x}) \/
        (?b. s = {x | x <= b}) \/
        (?b. s = {x | x < b}) \/
        (?a b. s = {x | a < x /\ x < b}) \/
        (?a b. s = {x | a < x /\ x <= b}) \/
        (?a b. s = {x | a <= x /\ x < b}) \/
        (?a b. s = {x | a <= x /\ x <= b})``,
  GEN_TAC THEN REWRITE_TAC[IS_INTERVAL] THEN EQ_TAC THENL
   [DISCH_TAC,
    STRIP_TAC THEN ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, NOT_IN_EMPTY] THEN
    REAL_ARITH_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPEC ``s:real->bool`` SUP) THEN
  MP_TAC(ISPEC ``s:real->bool`` INF) THEN
  ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
  ASM_CASES_TAC ``?a. !x:real. x IN s ==> a <= x`` THEN
  ASM_CASES_TAC ``?b. !x:real. x IN s ==> x <= b`` THEN
  ASM_REWRITE_TAC[] THENL
   [STRIP_TAC THEN STRIP_TAC THEN
    MAP_EVERY ASM_CASES_TAC
     [``inf(s) IN s:real->bool``, ``sup(s) IN s:real->bool``]
    THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
      DISJ2_TAC THEN DISJ1_TAC] THEN
    MAP_EVERY EXISTS_TAC [``inf(s:real->bool)``, ``sup(s:real->bool)``],
    STRIP_TAC THEN ASM_CASES_TAC ``inf(s:real->bool) IN s`` THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ1_TAC] THEN
    EXISTS_TAC ``inf(s:real->bool)``,
    STRIP_TAC THEN ASM_CASES_TAC ``sup(s:real->bool) IN s`` THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ1_TAC] THEN
    EXISTS_TAC ``sup(s:real->bool)``,
    DISJ1_TAC] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_UNIV] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[IN_IMAGE]) THEN
  REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  ASM_MESON_TAC [REAL_LE_TRANS, REAL_LE_TOTAL, REAL_LE_ANTISYM]);

val IS_INTERVAL_INTER = store_thm ("IS_INTERVAL_INTER",
 ``!s t:real->bool.
        is_interval s /\ is_interval t ==> is_interval(s INTER t)``,
  REWRITE_TAC[is_interval, IN_INTER] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``x:real``] THEN
  REPEAT STRIP_TAC THENL
  [UNDISCH_TAC ``!a b x.
            a IN s /\ b IN s ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN s:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN t /\ b IN t ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN t:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN s /\ b IN s ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN s:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN t /\ b IN t ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN t:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO])] THEN
  MAP_EVERY EXISTS_TAC [``a:real``, ``b:real``] THEN ASM_REWRITE_TAC[]);

val INTERVAL_SUBSET_IS_INTERVAL = store_thm ("INTERVAL_SUBSET_IS_INTERVAL",
 ``!s a b:real.
     is_interval s
     ==> (interval[a,b] SUBSET s <=> (interval[a,b] = {}) \/ a IN s /\ b IN s)``,
  REWRITE_TAC[is_interval] THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``interval[a:real,b] = {}`` THEN
  ASM_REWRITE_TAC[EMPTY_SUBSET] THEN
  EQ_TAC THENL [ASM_MESON_TAC[ENDS_IN_INTERVAL, SUBSET_DEF], ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN ASM_MESON_TAC[]);

val INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD = store_thm
  ("INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD",
 ``!s x:real.
        is_interval s /\ x IN s
        ==> ?a b d. &0 < d /\ x IN interval[a,b] /\
                    interval[a,b] SUBSET s /\
                    ball(x,d) INTER s SUBSET interval[a,b]``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [INTERVAL_SUBSET_IS_INTERVAL] THEN
  SUBGOAL_THEN ``?a. (?y. y IN s /\ (y = a)) /\
                    (a < x \/ (a = (x:real)) /\
                        !y:real. y IN s ==> a <= y)``
  MP_TAC THENL [ASM_MESON_TAC[REAL_NOT_LT], SIMP_TAC std_ss []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  SUBGOAL_THEN
   ``?b. (?y. y IN s /\ (y = b)) /\
                (x < b \/ (b = (x:real)) /\
                            !y:real. y IN s ==> y <= b)``
  MP_TAC THENL [ASM_MESON_TAC[REAL_NOT_LT], SIMP_TAC std_ss []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``b:real``) THEN EXISTS_TAC ``b:real`` THEN
  EXISTS_TAC ``min (if a < x then (x:real) - a else &1)
                   (if x < b then (b:real) - x else &1)`` THEN
  REWRITE_TAC[REAL_LT_MIN, SUBSET_DEF, IN_BALL, IN_INTER] THEN
  SIMP_TAC std_ss [REAL_LT_INF_FINITE, IMAGE_EQ_EMPTY, IMAGE_FINITE,
                   FINITE_NUMSEG, NUMSEG_EMPTY, GSYM NOT_LESS_EQUAL] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_INTERVAL] THEN REPEAT CONJ_TAC THENL
   [METIS_TAC[REAL_SUB_LT, REAL_LT_01],
    METIS_TAC[REAL_SUB_LT, REAL_LT_01],
    ASM_MESON_TAC[REAL_LE_LT],
    ASM_MESON_TAC[REAL_LE_LT],
        METIS_TAC [], ALL_TAC] THEN
    X_GEN_TAC ``y:real`` THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    MATCH_MP_TAC MONO_AND THEN CONJ_TAC THEN
    (COND_CASES_TAC THENL [REWRITE_TAC[dist], ASM_MESON_TAC[]]) THEN
        REWRITE_TAC [abs] THEN COND_CASES_TAC THEN DISCH_TAC THENL
        [FULL_SIMP_TAC std_ss [REAL_ARITH ``x - y < x - a <=> a < y:real``, REAL_LE_LT],
     FULL_SIMP_TAC std_ss [REAL_NOT_LE, REAL_ARITH ``x - y < 0 <=> x < y:real``] THEN
         METIS_TAC [REAL_LE_TRANS, REAL_LE_LT],
         FULL_SIMP_TAC std_ss [REAL_SUB_LE] THEN METIS_TAC [REAL_LE_TRANS, REAL_LE_LT],
         FULL_SIMP_TAC std_ss [REAL_NEG_SUB,
          REAL_ARITH ``y - x < b - x <=> y < b:real``, REAL_LE_LT]]);

Theorem IS_INTERVAL_SUMS :
    !s t:real->bool.
        is_interval s /\ is_interval t
        ==> is_interval {x + y | x IN s /\ y IN t}
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[is_interval] THEN
  SIMP_TAC std_ss [IMP_CONJ, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
  MAP_EVERY X_GEN_TAC
   [``a:real``, ``a':real``, ``b:real``, ``b':real``, ``y:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (MP_TAC o SPECL [``a:real``, ``b:real``]) MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (MP_TAC o SPECL [``a':real``, ``b':real``]) ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [AND_IMP_INTRO, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(z:real = x + y) <=> (y = z - x)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN
  ONCE_REWRITE_TAC [METIS []
   ``!a b s. (!x. a <= x /\ x <= b \/ b <= x /\ x <= a ==> x IN s:real->bool) =
             (!x. (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x ==> x IN s)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(y - p_1) = (\x. y - x) (p_1:real)``] THEN
  MATCH_MP_TAC(METIS []
   ``(?x. P x /\ Q(f x))
    ==> (!x. Q x ==> x IN t) /\ (!x. P x ==> x IN s)
        ==> ?x. x IN s /\ f x IN t``) THEN
  POP_ASSUM MP_TAC THEN DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  SIMP_TAC std_ss [REAL_ARITH
   ``c <= y - x /\ y - x <= d <=> y - d <= x /\ x <= y - c:real``] THEN
  Know `!a b x. a <= x /\ x <= b \/ b <= x /\ x <= a:real <=>
                min a b <= x /\ x <= max a b`
  >- (KILL_TAC >> RW_TAC std_ss [max_def, min_def] \\
      REAL_ASM_ARITH_TAC) >> Rewr \\
  ONCE_REWRITE_TAC[TAUT `(p /\ q) /\ (r /\ s) <=> (p /\ r) /\ (q /\ s)`] THEN
  REWRITE_TAC[GSYM REAL_LE_MIN, GSYM REAL_MAX_LE] THEN
  REWRITE_TAC[GSYM REAL_LE_BETWEEN] THEN
  SIMP_TAC std_ss [min_def, max_def] THEN REPEAT COND_CASES_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN ASM_REAL_ARITH_TAC
QED

val IS_INTERVAL_SING = store_thm ("IS_INTERVAL_SING",
 ``!a:real. is_interval {a}``,
  SIMP_TAC std_ss [is_interval, IN_SING, CONJ_EQ_IMP, REAL_LE_ANTISYM]);

val IS_INTERVAL_SCALING = store_thm ("IS_INTERVAL_SCALING",
 ``!s:real->bool c. is_interval s ==> is_interval(IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO] THEN
    SUBGOAL_THEN ``(IMAGE ((\x. 0):real->real) (s:real->bool) = {}) \/
                   (IMAGE ((\x. 0):real->real) s = {0})``
    STRIP_ASSUME_TAC THENL
     [SET_TAC[],
      ASM_REWRITE_TAC[IS_INTERVAL_EMPTY],
      ASM_REWRITE_TAC[IS_INTERVAL_SING]],
    SIMP_TAC std_ss [is_interval, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN DISCH_TAC THEN
        SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
        POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_FORALL_THM]) THEN
    REWRITE_TAC[AND_IMP_INTRO] THEN
        DISCH_TAC THEN MAP_EVERY X_GEN_TAC [``a:real``,``b:real``] THEN
        POP_ASSUM (MP_TAC o Q.SPECL [`a:real`,`b:real`]) THEN
    DISCH_THEN(fn th => X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
                         MP_TAC(SPEC ``inv(c) * x:real`` th)) THEN
    ASM_SIMP_TAC std_ss [IN_IMAGE] THEN
    KNOW_TAC ``a <= inv c * x /\ inv c * x <= b \/
               b <= inv c * x /\ inv c * x <= a:real`` THENL
     [FIRST_X_ASSUM(MP_TAC) THEN
          DISCH_THEN (CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
          ASM_REWRITE_TAC[] THEN
      ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN REWRITE_TAC[GSYM real_div] THEN
          UNDISCH_TAC ``c <> 0:real`` THEN DISCH_TAC THEN
      FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP (REAL_ARITH
       ``~(c = &0:real) ==> &0 < c \/ &0 < -c``)) THEN
      ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ] THEN
      GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_LE_NEG2] THEN
      ASM_SIMP_TAC std_ss [GSYM REAL_MUL_RNEG, GSYM REAL_LE_RDIV_EQ, GSYM
                   REAL_LE_LDIV_EQ] THEN
      ASM_SIMP_TAC std_ss [real_div, GSYM REAL_NEG_INV] THEN REAL_ARITH_TAC,
          DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
      DISCH_TAC THEN EXISTS_TAC ``inv c * x:real`` THEN
      ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID]]]);

val IS_INTERVAL_SCALING_EQ = store_thm ("IS_INTERVAL_SCALING_EQ",
 ``!s:real->bool c.
        is_interval(IMAGE (\x. c * x) s) <=> (c = &0) \/ is_interval s``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO] THEN
    SUBGOAL_THEN ``(IMAGE ((\x. 0):real->real) s = {}) \/
                   (IMAGE ((\x. 0):real->real) s = {0})``
    STRIP_ASSUME_TAC THENL
     [SET_TAC[],
      ASM_REWRITE_TAC[IS_INTERVAL_EMPTY],
      ASM_REWRITE_TAC[IS_INTERVAL_SING]],
    ASM_REWRITE_TAC[] THEN EQ_TAC THEN REWRITE_TAC[IS_INTERVAL_SCALING] THEN
    DISCH_THEN(MP_TAC o SPEC ``inv c:real`` o MATCH_MP IS_INTERVAL_SCALING) THEN
    ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, REAL_MUL_ASSOC, o_DEF, REAL_MUL_LINV,
                 REAL_MUL_LID, IMAGE_ID]]);

val lemma0 = prove ((* unused *)
  ``!c. &0 < c
       ==> !s:real->bool. is_interval(IMAGE (\x. c * x) s) <=>
                            is_interval s``,
  SIMP_TAC std_ss [IS_INTERVAL_SCALING_EQ, REAL_LT_IMP_NE]);

val lemma = prove (
  ``~(?a b c:real. a < b /\ b < c /\
               a IN s /\ b IN s /\ c IN s)
     ==> FINITE s /\ CARD(s) <= 2``,
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    REWRITE_TAC[TAUT `~(p /\ q) <=> p ==> ~q`] THEN
    REWRITE_TAC[ARITH_PROVE ``~(n <= 2) <=> 3 <= n:num``] THEN
    DISCH_THEN(MP_TAC o MATCH_MP CHOOSE_SUBSET_STRONG) THEN
    REWRITE_TAC [ARITH_PROVE ``3 = SUC 2``, TWO, ONE,  HAS_SIZE_CLAUSES] THEN
    DISCH_TAC THEN KNOW_TAC ``(?a b c:real.
      ((~(b = c) /\ ~(a = c)) /\ ~(a = b)) /\ {a; b; c} SUBSET s)`` THENL
    [POP_ASSUM MP_TAC THEN
     REWRITE_TAC [ARITH_PROVE ``3 = SUC 2``, TWO, ONE,  HAS_SIZE_CLAUSES] THEN
     SET_TAC [], POP_ASSUM K_TAC] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, GSYM CONJ_ASSOC] THEN
    REWRITE_TAC[INSERT_SUBSET, EMPTY_SUBSET] THEN
    ONCE_REWRITE_TAC [METIS []
     ``(b <> c /\ a <> c /\ a <> b /\ a IN s /\ b IN s /\ c IN s ==>
     ?a b c:real. a < b /\ b < c /\ a IN s /\ b IN s /\ c IN s) =
    (\a b c. b <> c /\ a <> c /\ a <> b /\ a IN s /\ b IN s /\ c IN s ==>
     ?a b c:real. a < b /\ b < c /\ a IN s /\ b IN s /\ c IN s) a b c``] THEN
    MATCH_MP_TAC(METIS [REAL_LE_TOTAL]
     ``(!m n p:real. P m n p ==> P n p m /\ P n m p) /\
       (!m n p. m <= n /\ n <= p ==> P m n p)
       ==> !m n p. P m n p``) THEN
    CONJ_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    SIMP_TAC std_ss [REAL_LT_LE] THEN METIS_TAC[]);

val CARD_FRONTIER_INTERVAL = store_thm ("CARD_FRONTIER_INTERVAL",
 ``!s:real->bool.
        is_interval s ==> FINITE(frontier s) /\ CARD(frontier s) <= 2``,
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC lemma THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, FRONTIER_CLOSURES, IN_INTER] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``c:real``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MAP_EVERY UNDISCH_TAC
   [``b IN closure (univ(:real) DIFF s)``,
    ``(a:real) IN closure s``, ``(c:real) IN closure s``] THEN
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, IN_DIFF, IN_UNIV, dist] THEN
  DISCH_THEN(MP_TAC o SPEC ``(c - b) / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``(b - a) / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min ((b - a) / &2:real) ((c - b) / &2:real)`` THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT, REAL_LT_MIN] THEN
  X_GEN_TAC ``w:real`` THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``is_interval s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IS_INTERVAL]) THEN
  DISCH_THEN(MP_TAC o SPECL [``u:real``, ``v:real``, ``w:real``]) THEN
  ASM_REWRITE_TAC[] THEN FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Limit component bounds.                                                   *)
(* ------------------------------------------------------------------------- *)

val LIM_COMPONENT_UBOUND = store_thm ("LIM_COMPONENT_UBOUND",
 ``!net:('a)net f (l:real) b k.
        ~(trivial_limit net) /\ (f --> l) net /\
        eventually (\x. f x <= b) net
        ==> l <= b``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``net:('a)net``, ``f:'a->real``, ``{y:real | y <= b}``, ``l:real``]
   LIM_IN_CLOSED_SET) THEN
  ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, GSPECIFICATION]);

val LIM_COMPONENT_LBOUND = store_thm ("LIM_COMPONENT_LBOUND",
 ``!net:('a)net f (l:real) b.
        ~(trivial_limit net) /\ (f --> l) net /\
        eventually (\x. b <= (f x)) net
        ==> b <= l``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``net:('a)net``, ``f:'a->real``, ``{y:real | b <= y}``, ``l:real``]
   LIM_IN_CLOSED_SET) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[real_ge] CLOSED_HALFSPACE_COMPONENT_GE,
    GSPECIFICATION]);

val LIM_COMPONENT_EQ = store_thm ("LIM_COMPONENT_EQ",
 ``!net f:'a->real i l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. f(x) = b) net
        ==> (l = b)``,
  SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, EVENTUALLY_AND] THEN
  METIS_TAC [LIM_COMPONENT_UBOUND, LIM_COMPONENT_LBOUND]);

val LIM_COMPONENT_LE = store_thm ("LIM_COMPONENT_LE",
 ``!net:('a)net f:'a->real g:'a->real l m.
         ~(trivial_limit net) /\ (f --> l) net /\ (g --> m) net /\
        eventually (\x. (f x) <= (g x)) net
        ==> (l <= m)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_LE] THEN
  SIMP_TAC std_ss [LIM_COMPONENT_LBOUND] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c ==> d <=> b /\ a ==> c ==> d`] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_LBOUND THEN EXISTS_TAC ``net:'a net`` THEN
  EXISTS_TAC ``(\(x :'a). (g :'a -> real) x - (f :'a -> real) x)`` THEN
  METIS_TAC []);

val LIM_DROP_LE = store_thm ("LIM_DROP_LE",
 ``!net:('a)net f g l m.
         ~(trivial_limit net) /\ (f --> l) net /\ (g --> m) net /\
        eventually (\x. f x <= g x) net
        ==> l <= m``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``net:('a)net`` LIM_COMPONENT_LE) THEN
  MAP_EVERY EXISTS_TAC [``f:'a->real``, ``g:'a->real``] THEN
  ASM_REWRITE_TAC[LESS_EQ_REFL]);

val LIM_DROP_UBOUND = store_thm ("LIM_DROP_UBOUND",
 ``!net f:'a->real l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. f x <= b) net
        ==> l <= b``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_UBOUND THEN
  REWRITE_TAC[LESS_EQ_REFL] THEN METIS_TAC[]);

val LIM_DROP_LBOUND = store_thm ("LIM_DROP_LBOUND",
 ``!net f:'a->real l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. b <= f x) net
        ==> b <= l``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_LBOUND THEN
  REWRITE_TAC[LESS_EQ_REFL] THEN METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Also extending closed bounds to closures.                                 *)
(* ------------------------------------------------------------------------- *)

val IMAGE_CLOSURE_SUBSET = store_thm ("IMAGE_CLOSURE_SUBSET",
 ``!f (s:real->bool) (t:real->bool).
      f continuous_on closure s /\ closed t /\ IMAGE f s SUBSET t
      ==> IMAGE f (closure s) SUBSET t``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``closure s SUBSET {x | (f:real->real) x IN t}`` MP_TAC
  THENL [MATCH_MP_TAC SUBSET_TRANS, SET_TAC []]  THEN
  EXISTS_TAC ``{x | x IN closure s /\ (f:real->real) x IN t}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL, SET_TAC[]] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_CLOSED_PREIMAGE, CLOSED_CLOSURE] THEN
  MP_TAC (ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]);

val CLOSURE_IMAGE_CLOSURE = store_thm ("CLOSURE_IMAGE_CLOSURE",
 ``!f:real->real s.
        f continuous_on closure s
        ==> (closure(IMAGE f (closure s)) = closure(IMAGE f s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, IMAGE_SUBSET, CLOSURE_SUBSET] THEN
  SIMP_TAC std_ss [CLOSURE_MINIMAL_EQ, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC IMAGE_CLOSURE_SUBSET THEN
  ASM_REWRITE_TAC[CLOSED_CLOSURE, CLOSURE_SUBSET]);

val CLOSURE_IMAGE_BOUNDED = store_thm ("CLOSURE_IMAGE_BOUNDED",
 ``!f:real->real s.
        f continuous_on closure s /\ bounded s
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC EQ_TRANS THEN EXISTS_TAC ``closure(IMAGE (f:real->real) (closure s))`` THEN
  CONJ_TAC THENL [ASM_MESON_TAC[CLOSURE_IMAGE_CLOSURE], ALL_TAC] THEN
  MATCH_MP_TAC CLOSURE_CLOSED THEN MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE]);

val CONTINUOUS_ON_CLOSURE_ABS_LE = store_thm ("CONTINUOUS_ON_CLOSURE_ABS_LE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> abs(f y) <= b) /\
      x IN (closure s)
      ==> abs(f x) <= b``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET cball(0,b)``
    MP_TAC THENL
  [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC []] THEN
  ASM_REWRITE_TAC [CLOSED_CBALL] THEN ASM_SET_TAC []);

val CONTINUOUS_ON_CLOSURE_COMPONENT_LE = store_thm ("CONTINUOUS_ON_CLOSURE_COMPONENT_LE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> (f y) <= b) /\
      x IN (closure s)
      ==> (f x) <= b``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET {x | x <= b}``
  MP_TAC THENL
   [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC []] THEN
  ASM_REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_LE] THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_CLOSURE_COMPONENT_GE = store_thm ("CONTINUOUS_ON_CLOSURE_COMPONENT_GE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> b <= (f y)) /\
      x IN (closure s)
      ==> b <= (f x)``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET {x | x >= b}``
  MP_TAC THENL
   [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC [real_ge]] THEN
  ASM_REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_GE] THEN ASM_SET_TAC[real_ge]);

val CONTINUOUS_MAP_CLOSURES = store_thm ("CONTINUOUS_MAP_CLOSURES",
 ``!f:real->real.
        f continuous_on UNIV <=>
        !s. IMAGE f (closure s) SUBSET closure(IMAGE f s)``,
  GEN_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [GEN_TAC THEN MATCH_MP_TAC(MESON[SUBSET_DEF, CLOSURE_SUBSET]
     ``(closure s = t) ==> s SUBSET t``) THEN
    MATCH_MP_TAC CLOSURE_IMAGE_CLOSURE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_UNIV],
    REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
    REWRITE_TAC[GSYM CLOSED_IN, SUBTOPOLOGY_UNIV, IN_UNIV] THEN
    X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``{x | (f:real->real) x IN t}``) THEN
    REWRITE_TAC[GSYM CLOSURE_SUBSET_EQ] THEN
    SUBGOAL_THEN
     ``closure(IMAGE (f:real->real) {x | f x IN t}) SUBSET t``
    MP_TAC THENL
     [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SET_TAC[], SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Limits relative to a union.                                               *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_UNION = store_thm ("LIM_WITHIN_UNION",
 ``(f --> l) (at x within (s UNION t)) <=>
   (f --> l) (at x within s) /\ (f --> l) (at x within t)``,
  SIMP_TAC std_ss [LIM_WITHIN, IN_UNION, GSYM FORALL_AND_THM] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THENL [MESON_TAC[], ALL_TAC] THEN DISCH_THEN
   (CONJUNCTS_THEN2 (X_CHOOSE_TAC ``d:real``) (X_CHOOSE_TAC ``k:real``)) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

val CONTINUOUS_ON_UNION = store_thm ("CONTINUOUS_ON_UNION",
 ``!f s t. closed s /\ closed t /\ f continuous_on s /\ f continuous_on t
           ==> f continuous_on (s UNION t)``,
  REWRITE_TAC[CONTINUOUS_ON, CLOSED_LIMPT, IN_UNION, LIM_WITHIN_UNION] THEN
  MESON_TAC[LIM, TRIVIAL_LIMIT_WITHIN]);

val CONTINUOUS_ON_CASES = store_thm ("CONTINUOUS_ON_CASES",
 ``!P f g:real->real s t.
        closed s /\ closed t /\ f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_UNION_LOCAL = store_thm ("CONTINUOUS_ON_UNION_LOCAL",
 ``!f:real->real s.
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ f continuous_on t
        ==> f continuous_on (s UNION t)``,
  REWRITE_TAC[CONTINUOUS_ON, CLOSED_IN_LIMPT, IN_UNION, LIM_WITHIN_UNION] THEN
  MESON_TAC[LIM, TRIVIAL_LIMIT_WITHIN]);

val CONTINUOUS_ON_CASES_LOCAL = store_thm ("CONTINUOUS_ON_CASES_LOCAL",
 ``!P f g:real->real s t.
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_CASES_LE = store_thm ("CONTINUOUS_ON_CASES_LE",
 ``!f g:real->real h s a.
        f continuous_on {t | t IN s /\ h t <= a} /\
        g continuous_on {t | t IN s /\ a <= h t} /\
        (h) continuous_on s /\
        (!t. t IN s /\ (h t = a) ==> (f t = g t))
        ==> (\t. if h t <= a then f(t) else g(t)) continuous_on s``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_SUBSET THEN EXISTS_TAC
   ``{t | t IN s /\ (h:real->real) t <= a} UNION
     {t | t IN s /\ a <= h t}`` THEN
  CONJ_TAC THENL
   [ALL_TAC, SIMP_TAC std_ss [SUBSET_DEF, IN_UNION, GSPECIFICATION, REAL_LE_TOTAL]] THEN
  ONCE_REWRITE_TAC [METIS [] ``h t <= a <=> (\t:real. h t <= a:real) t``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN ASM_SIMP_TAC std_ss [] THEN
  SIMP_TAC std_ss [GSPECIFICATION, GSYM CONJ_ASSOC, REAL_LE_ANTISYM] THEN
  REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
   [ALL_TAC, METIS_TAC[]] THEN
  CONJ_TAC THENL
   [SUBGOAL_THEN
     ``{t | t IN s /\ (h:real->real) t <= a} =
       {t | t IN ({t | t IN s /\ h t <= a} UNION {t | t IN s /\ a <= h t}) /\
           (h) t IN {x | x <= a}}``
     (fn th => GEN_REWR_TAC RAND_CONV [th])
    THENL
     [SIMP_TAC std_ss [o_THM, GSPECIFICATION, EXTENSION, IN_UNION] THEN
      GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN ASM_SIMP_TAC std_ss [],
      MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, ETA_AX] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN SET_TAC[]],
    SUBGOAL_THEN
     ``{t | t IN s /\ a <= (h:real->real) t} =
       {t | t IN ({t | t IN s /\ h t <= a} UNION {t | t IN s /\ a <= h t}) /\
           (h) t IN {x | x >= a}}``
     (fn th => GEN_REWR_TAC RAND_CONV [th])
    THENL
     [SIMP_TAC std_ss [o_THM, GSPECIFICATION, EXTENSION, IN_UNION] THEN
      GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN ASM_SIMP_TAC std_ss [real_ge] THEN
      ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_GE, ETA_AX] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN
      SET_TAC[]]]);

val CONTINUOUS_ON_CASES_1 = store_thm ("CONTINUOUS_ON_CASES_1",
 ``!f g:real->real s a.
        f continuous_on {t | t IN s /\ t <= a} /\
        g continuous_on {t | t IN s /\ a <= t} /\
        (a IN s ==> (f(a) = g(a)))
        ==> (\t. if t <= a then f(t) else g(t)) continuous_on s``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``t <= a <=> (\t. t) t <= a:real``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_CASES_LE THEN
  ASM_SIMP_TAC std_ss [o_DEF, CONTINUOUS_ON_ID] THEN
  METIS_TAC[]);

val EXTENSION_FROM_CLOPEN = store_thm ("EXTENSION_FROM_CLOPEN",
 ``!f:real->real s t u.
        open_in (subtopology euclidean s) t /\
        closed_in (subtopology euclidean s) t /\
        f continuous_on t /\ IMAGE f t SUBSET u /\ ((u = {}) ==> (s = {}))
        ==> ?g. g continuous_on s /\ IMAGE g s SUBSET u /\
                !x. x IN t ==> (g x = f x)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_EMPTY, IMAGE_EMPTY, IMAGE_INSERT, SUBSET_EMPTY,
               IMAGE_EQ_EMPTY, NOT_IN_EMPTY] THEN
  STRIP_TAC THEN UNDISCH_TAC ``u <> {}:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN
  EXISTS_TAC ``\x. if x IN t then (f:real->real) x else a`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  SUBGOAL_THEN ``s:real->bool = t UNION (s DIFF t)`` SUBST1_TAC THENL
   [ASM_SET_TAC[],
    ONCE_REWRITE_TAC [METIS [] ``(\x. if x IN t then f x else a) =
                                 (\x. if (\x. x IN t) x then f x else (\x. a) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``t SUBSET s ==> (t UNION (s DIFF t) = s)``] THEN
  REWRITE_TAC[CONTINUOUS_ON_CONST, IN_DIFF] THEN
  CONJ_TAC THENL [MATCH_MP_TAC CLOSED_IN_DIFF, MESON_TAC[]] THEN
  ASM_REWRITE_TAC[CLOSED_IN_REFL]);

(* ------------------------------------------------------------------------- *)
(* Some more convenient intermediate-value theorem formulations.             *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_IVT_HYPERPLANE = store_thm ("CONNECTED_IVT_HYPERPLANE",
 ``!s x y:real a b.
        connected s /\
        x IN s /\ y IN s /\ a * x <= b /\ b <= a * y
        ==> ?z. z IN s /\ (a * z = b)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [connected]) THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN DISCH_THEN(MP_TAC o SPECL
   [``{x:real | a * x < b}``, ``{x:real | a * x > b}``]) THEN
  SIMP_TAC std_ss [OPEN_HALFSPACE_LT, OPEN_HALFSPACE_GT] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN SIMP_TAC std_ss [] THEN STRIP_TAC THEN
  SIMP_TAC real_ss [EXTENSION, GSPECIFICATION, IN_INTER, NOT_IN_EMPTY, SUBSET_DEF,
              IN_UNION, REAL_LT_LE, real_gt] THEN
  METIS_TAC[REAL_LE_TOTAL, REAL_LE_ANTISYM]);

val CONNECTED_IVT_COMPONENT = store_thm ("CONNECTED_IVT_COMPONENT",
 ``!s x y:real a.
        connected s /\ x IN s /\ y IN s /\ x <= a /\ a <= y
        ==> ?z. z IN s /\ (z = a)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``s:real->bool``, ``x:real``, ``y:real``, ``1:real``,
    ``a:real``] CONNECTED_IVT_HYPERPLANE) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

(* ------------------------------------------------------------------------- *)
(* Rather trivial observation that we can map any connected set on segment.  *)
(* ------------------------------------------------------------------------- *)

val MAPPING_CONNECTED_ONTO_SEGMENT = store_thm ("MAPPING_CONNECTED_ONTO_SEGMENT",
 ``!s:real->bool a b:real.
        connected s /\ ~(?a. s SUBSET {a})
        ==> ?f. f continuous_on s /\ (IMAGE f s = segment[a,b])``,
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o MATCH_MP (SET_RULE
   ``~(?a. s SUBSET {a}) ==> ?a b. a IN s /\ b IN s /\ ~(a = b)``)) THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN STRIP_TAC THEN EXISTS_TAC
   ``\x:real. a + dist(u,x) / (dist(u,x) + dist(v,x)) * (b - a:real)`` THEN
  CONJ_TAC THEN SIMP_TAC std_ss [] THENL
   [ONCE_REWRITE_TAC [METIS []
     ``(\x. a + dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
       (\x. (\x. a) x + (\x. dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
    ONCE_REWRITE_TAC [METIS []
    ``(\x. dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
      (\x. (\x. dist (u,x) / (dist (u,x) + dist (v,x))) x * (\x. (b - a)) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_MUL THEN SIMP_TAC std_ss [o_DEF, CONTINUOUS_ON_CONST],

    REWRITE_TAC[segment, REAL_ARITH
     ``(&1 - u) * a + u * b:real = a + u * (b - a)``] THEN
    ONCE_REWRITE_TAC [METIS []
    ``(\x. a + dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
      (\x. a + (\x. dist (u,x) / (dist (u,x) + dist (v,x))) x * (b - a))``] THEN
    ONCE_REWRITE_TAC [METIS [] ``(0 <= u /\ u <= 1:real) <=> (\u. 0 <= u /\ u <= 1) u``] THEN
    MATCH_MP_TAC(SET_RULE
     ``(IMAGE f s = {x | P x})
      ==> (IMAGE (\x. a + f x * b) s = {a + u * b:real | P u})``) THEN
    SIMP_TAC std_ss [GSYM SUBSET_ANTISYM_EQ, SUBSET_DEF, FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC real_ss [dist, GSPECIFICATION, REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ,
      REAL_ARITH ``~(u:real = v) ==> &0 < abs(u - x) + abs(v - x)``] THEN
    CONJ_TAC THENL [REAL_ARITH_TAC, REWRITE_TAC[IN_IMAGE]] THEN
    X_GEN_TAC ``t:real`` THEN STRIP_TAC THEN
    MP_TAC(ISPECL
     [``IMAGE (\x:real. dist(u,x) / (dist(u,x) + dist(v,x))) s``,
      ``0:real``, ``1:real``, ``t:real``]
        CONNECTED_IVT_COMPONENT) THEN
    ASM_SIMP_TAC arith_ss [] THEN
    SIMP_TAC std_ss [EXISTS_IN_IMAGE] THEN
    KNOW_TAC ``connected
   (IMAGE
      (\(x :real).
         (dist ((u :real),x) :real) /
         ((dist (u,x) :real) + (dist ((v :real),x) :real)))
      (s :real -> bool)) /\
 (0 :real) IN
 IMAGE
   (\(x :real).
      (dist (u,x) :real) / ((dist (u,x) :real) + (dist (v,x) :real)))
   s /\
 (1 :real) IN
 IMAGE
   (\(x :real).
      (dist (u,x) :real) / ((dist (u,x) :real) + (dist (v,x) :real)))
   s`` THENL
   [REWRITE_TAC[IN_IMAGE], DISCH_TAC THEN ASM_REWRITE_TAC [IN_IMAGE] THEN
    BETA_TAC THEN MESON_TAC[dist]] THEN
    REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[],
      EXISTS_TAC ``u:real`` THEN ASM_REWRITE_TAC[DIST_REFL, real_div, dist] THEN
      BETA_TAC THEN REAL_ARITH_TAC,
      EXISTS_TAC ``v:real`` THEN ASM_REWRITE_TAC[DIST_REFL] THEN
      ASM_SIMP_TAC std_ss [REAL_DIV_REFL, DIST_EQ_0, REAL_ADD_RID] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE
       [REAL_ARITH ``(u <> v) = (abs (u - v) <> 0:real)``]) THEN
      ASM_SIMP_TAC real_ss [REAL_DIV_REFL]]] THEN
  REWRITE_TAC[real_div] THENL
  [ONCE_REWRITE_TAC [METIS [] ``(\x. dist (u,x) * inv (dist (u,x) + dist (v,x))) =
                  (\x. (\x. dist (u,x)) x * (\x. inv (dist (u,x) + dist (v,x))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  REWRITE_TAC[CONTINUOUS_ON_DIST] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. inv (dist (u,x) + dist (v,x))) =
                          (\x. inv ((\x. (dist (u,x) + dist (v,x))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [dist, REAL_ARITH
   ``~(u:real = v) ==> ~(abs(u - x) + abs(v - x) = &0)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x:real. abs (u - x) + abs (v - x)) =
                       (\x. (\x. abs (u - x)) x + (\x. abs (v - x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
  SIMP_TAC std_ss [GSYM dist, REWRITE_RULE[o_DEF] CONTINUOUS_ON_DIST],
   ONCE_REWRITE_TAC [METIS [] ``(\x. dist (u,x) * inv (dist (u,x) + dist (v,x))) =
                  (\x. (\x. dist (u,x)) x * (\x. inv (dist (u,x) + dist (v,x))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  REWRITE_TAC[CONTINUOUS_ON_DIST] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. inv (dist (u,x) + dist (v,x))) =
                          (\x. inv ((\x. (dist (u,x) + dist (v,x))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [dist, REAL_ARITH
   ``~(u:real = v) ==> ~(abs(u - x) + abs(v - x) = &0)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x:real. abs (u - x) + abs (v - x)) =
                       (\x. (\x. abs (u - x)) x + (\x. abs (v - x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
  SIMP_TAC std_ss [GSYM dist, REWRITE_RULE[o_DEF] CONTINUOUS_ON_DIST],
  ALL_TAC] THEN
  FULL_SIMP_TAC std_ss [GSYM dist, DIST_REFL, REAL_ADD_RID] THEN
  REWRITE_TAC [GSYM real_div] THEN METIS_TAC [REAL_DIV_REFL]);

(* ------------------------------------------------------------------------- *)
(* Also more convenient formulations of monotone convergence.                *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_INCREASING_CONVERGENT = store_thm ("BOUNDED_INCREASING_CONVERGENT",
 ``!s:num->real.
        bounded {s n | n IN univ(:num)} /\ (!n. (s n) <= (s(SUC n)))
        ==> ?l. (s --> l) sequentially``,
  GEN_TAC THEN
  SIMP_TAC std_ss [bounded_def, GSPECIFICATION, LIM_SEQUENTIALLY, dist,
              IN_UNIV] THEN
  DISCH_TAC THEN MATCH_MP_TAC CONVERGENT_BOUNDED_MONOTONE THEN
  SIMP_TAC std_ss [LEFT_EXISTS_AND_THM] THEN
  CONJ_TAC THENL [METIS_TAC[], ALL_TAC] THEN DISJ1_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!m n. ((s:num->real) m <= s n) = (\m n. s m <= s n) m n``] THEN
  MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
  METIS_TAC [REAL_LE_TRANS, REAL_LE_REFL]);

val BOUNDED_DECREASING_CONVERGENT = store_thm ("BOUNDED_DECREASING_CONVERGENT",
 ``!s:num->real.
        bounded {s n | n IN univ(:num)} /\ (!n. (s(SUC n)) <= (s(n)))
        ==> ?l. (s --> l) sequentially``,
  GEN_TAC THEN SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MP_TAC(ISPEC ``\n. -((s:num->real) n)`` BOUNDED_INCREASING_CONVERGENT) THEN
  ASM_SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC, ABS_NEG, REAL_LE_NEG2] THEN
  GEN_REWR_TAC (LAND_CONV o BINDER_CONV) [GSYM LIM_NEG_EQ] THEN
  SIMP_TAC std_ss [REAL_NEG_NEG, ETA_AX] THEN METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Basic homeomorphism definitions.                                          *)
(* ------------------------------------------------------------------------- *)

val homeomorphism = new_definition ("homeomorphism",
  ``homeomorphism (s,t) (f,g) <=>
     (!x. x IN s ==> (g(f(x)) = x)) /\ (IMAGE f s = t) /\ f continuous_on s /\
     (!y. y IN t ==> (f(g(y)) = y)) /\ (IMAGE g t = s) /\ g continuous_on t``);

val _ = set_fixity "homeomorphic" (Infix(NONASSOC, 450));

val homeomorphic = new_definition ("homeomorphic",
  ``s homeomorphic t <=> ?f g. homeomorphism (s,t) (f,g)``);

val HOMEOMORPHISM = store_thm ("HOMEOMORPHISM",
 ``!s:real->bool t:real->bool f g.
        homeomorphism (s,t) (f,g) <=>
         f continuous_on s /\ IMAGE f s SUBSET t /\
         g continuous_on t /\ IMAGE g t SUBSET s /\
         (!x. x IN s ==> (g (f x) = x)) /\
         (!y. y IN t ==> (f (g y) = y))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphism] THEN
  EQ_TAC THEN SIMP_TAC std_ss [] THEN SET_TAC[]);

val HOMEOMORPHISM_OF_SUBSETS = store_thm ("HOMEOMORPHISM_OF_SUBSETS",
 ``!f g s t s' t'.
    homeomorphism (s,t) (f,g) /\ s' SUBSET s /\ t' SUBSET t /\ (IMAGE f s' = t')
    ==> homeomorphism (s',t') (f,g)``,
  REWRITE_TAC[homeomorphism] THEN
  REPEAT STRIP_TAC THEN
  TRY(MATCH_MP_TAC CONTINUOUS_ON_SUBSET) THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_ID = store_thm ("HOMEOMORPHISM_ID",
 ``!s:real->bool. homeomorphism (s,s) ((\x. x),(\x. x))``,
  SIMP_TAC std_ss [homeomorphism, IMAGE_ID, CONTINUOUS_ON_ID]);

val HOMEOMORPHIC_REFL = store_thm ("HOMEOMORPHIC_REFL",
 ``!s:real->bool. s homeomorphic s``,
  REWRITE_TAC[homeomorphic] THEN MESON_TAC[HOMEOMORPHISM_ID]);

val HOMEOMORPHISM_SYM = store_thm ("HOMEOMORPHISM_SYM",
 ``!f:real->real g s t.
        homeomorphism (s,t) (f,g) <=> homeomorphism (t,s) (g,f)``,
  REWRITE_TAC[homeomorphism] THEN MESON_TAC[]);

val HOMEOMORPHIC_SYM = store_thm ("HOMEOMORPHIC_SYM",
 ``!s t. s homeomorphic t <=> t homeomorphic s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic, homeomorphism] THEN
  ONCE_REWRITE_TAC [METIS []
       ``((!x. x IN t ==> (g (f x) = x)) /\ (IMAGE f t = s) /\
     f continuous_on t /\ (!y. y IN s ==> (f (g y) = y)) /\
     (IMAGE g s = t) /\ g continuous_on s) =
   (\f g. (!x. x IN t ==> (g (f x) = x)) /\ (IMAGE f t = s) /\
     f continuous_on t /\ (!y. y IN s ==> (f (g y) = y)) /\
     (IMAGE g s = t) /\ g continuous_on s) f g``] THEN
  GEN_REWR_TAC RAND_CONV [SWAP_EXISTS_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SIMP_TAC std_ss [] THEN
  TAUT_TAC);

val HOMEOMORPHISM_COMPOSE = store_thm ("HOMEOMORPHISM_COMPOSE",
 ``!f:real->real g h:real->real k s t u.
        homeomorphism (s,t) (f,g) /\ homeomorphism (t,u) (h,k)
        ==> homeomorphism (s,u) (h o f,g o k)``,
  SIMP_TAC std_ss [homeomorphism, CONTINUOUS_ON_COMPOSE, IMAGE_COMPOSE, o_THM] THEN
  SET_TAC[]);

val HOMEOMORPHIC_TRANS = store_thm ("HOMEOMORPHIC_TRANS",
 ``!s:real->bool t:real->bool u:real->bool.
        s homeomorphic t /\ t homeomorphic u ==> s homeomorphic u``,
  REWRITE_TAC[homeomorphic] THEN MESON_TAC[HOMEOMORPHISM_COMPOSE]);

val HOMEOMORPHIC_IMP_CARD_EQ = store_thm ("HOMEOMORPHIC_IMP_CARD_EQ",
 ``!s:real->bool t:real->bool. s homeomorphic t ==> s =_c t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic, homeomorphism, eq_c] THEN
  STRIP_TAC THEN EXISTS_TAC ``f:real->real`` THEN ASM_SET_TAC []);

val HOMEOMORPHIC_FINITENESS = store_thm ("HOMEOMORPHIC_FINITENESS",
 ``!s:real->bool t:real->bool.
        s homeomorphic t ==> (FINITE s <=> FINITE t)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
  DISCH_THEN(ACCEPT_TAC o MATCH_MP CARD_FINITE_CONG));

val HOMEOMORPHIC_EMPTY = store_thm ("HOMEOMORPHIC_EMPTY",
 ``(!s. (s:real->bool) homeomorphic ({}:real->bool) <=> (s = {})) /\
   (!s. ({}:real->bool) homeomorphic (s:real->bool) <=> (s = {}))``,
  REWRITE_TAC[homeomorphic, homeomorphism, IMAGE_EMPTY, IMAGE_INSERT, IMAGE_EQ_EMPTY] THEN
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [continuous_on, NOT_IN_EMPTY]);

val HOMEOMORPHIC_MINIMAL = store_thm ("HOMEOMORPHIC_MINIMAL",
 ``!s t. s homeomorphic t <=>
            ?f g. (!x. x IN s ==> f(x) IN t /\ (g(f(x)) = x)) /\
                  (!y. y IN t ==> g(y) IN s /\ (f(g(y)) = y)) /\
                  f continuous_on s /\ g continuous_on t``,
  REWRITE_TAC[homeomorphic, homeomorphism, EXTENSION, IN_IMAGE] THEN
  REPEAT GEN_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN MESON_TAC[]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (IMAGE f s) homeomorphic s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_LEFT_INVERSE]) THEN
  STRIP_TAC THEN EXISTS_TAC ``g:real->real`` THEN
  EXISTS_TAC ``f:real->real`` THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, FORALL_IN_IMAGE, FUN_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [continuous_on, CONJ_EQ_IMP, FORALL_IN_IMAGE] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_BOUNDED_BELOW_POS) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e * B:real`` THEN ASM_SIMP_TAC real_ss [REAL_LT_MUL] THEN
  X_GEN_TAC ``y:real`` THEN ASM_SIMP_TAC std_ss [dist, GSYM LINEAR_SUB] THEN
  DISCH_TAC THEN ASM_SIMP_TAC real_ss [GSYM REAL_LT_LDIV_EQ] THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> b < x ==> a < x:real``) THEN
  ASM_SIMP_TAC real_ss [REAL_LE_RDIV_EQ]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ",
 ``!f:real->real s t.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> ((IMAGE f s) homeomorphic t <=> s homeomorphic t)``,
  REPEAT GEN_TAC THEN DISCH_THEN(ASSUME_TAC o SPEC ``s:real->bool`` o
    MATCH_MP HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF) THEN
  EQ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o ONCE_REWRITE_RULE [HOMEOMORPHIC_SYM]),
    POP_ASSUM MP_TAC] THEN
  METIS_TAC[AND_IMP_INTRO, HOMEOMORPHIC_TRANS]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ",
 ``!f:real->real s t.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (s homeomorphic (IMAGE f t) <=> s homeomorphic t)``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  REWRITE_TAC[HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ]);

val HOMEOMORPHIC_TRANSLATION_SELF = store_thm ("HOMEOMORPHIC_TRANSLATION_SELF",
 ``!a:real s. (IMAGE (\x. a + x) s) homeomorphic s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  EXISTS_TAC ``\x:real. x - a`` THEN
  EXISTS_TAC ``\x:real. a + x`` THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, CONTINUOUS_ON_SUB, CONTINUOUS_ON_ID,
           CONTINUOUS_ON_CONST, CONTINUOUS_ON_ADD, REAL_ADD_SUB] THEN
  REWRITE_TAC[IN_IMAGE] THEN MESON_TAC[]);

val HOMEOMORPHIC_TRANSLATION_LEFT_EQ = store_thm ("HOMEOMORPHIC_TRANSLATION_LEFT_EQ",
 ``!a:real s t.
      (IMAGE (\x. a + x) s) homeomorphic t <=> s homeomorphic t``,
  METIS_TAC[HOMEOMORPHIC_TRANSLATION_SELF,
            HOMEOMORPHIC_SYM, HOMEOMORPHIC_TRANS]);

val HOMEOMORPHIC_TRANSLATION_RIGHT_EQ = store_thm ("HOMEOMORPHIC_TRANSLATION_RIGHT_EQ",
 ``!a:real s t.
      s homeomorphic (IMAGE (\x. a + x) t) <=> s homeomorphic t``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  REWRITE_TAC[HOMEOMORPHIC_TRANSLATION_LEFT_EQ]);

val HOMEOMORPHISM_IMP_QUOTIENT_MAP = store_thm ("HOMEOMORPHISM_IMP_QUOTIENT_MAP",
 ``!f:real->real g s t.
    homeomorphism (s,t) (f,g)
    ==> !u. u SUBSET t
            ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
                 open_in (subtopology euclidean t) u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphism] THEN
  STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP THEN
  EXISTS_TAC ``g:real->real`` THEN ASM_REWRITE_TAC[SUBSET_REFL]);

val HOMEOMORPHIC_SCALING_LEFT = store_thm ("HOMEOMORPHIC_SCALING_LEFT",
 ``!c. &0 < c
       ==> (!s t. (IMAGE (\x. c * x) s) homeomorphic t <=> s homeomorphic t)``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ THEN
  ASM_SIMP_TAC std_ss [REAL_EQ_LMUL, REAL_LT_IMP_NE, LINEAR_SCALING]);

val HOMEOMORPHIC_SCALING_RIGHT = store_thm ("HOMEOMORPHIC_SCALING_RIGHT",
 ``!c. &0 < c
       ==> (!s t. s homeomorphic (IMAGE (\x. c * x) t) <=> s homeomorphic t)``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ THEN
  ASM_SIMP_TAC std_ss [REAL_EQ_LMUL, REAL_LT_IMP_NE, LINEAR_SCALING]);

val HOMEOMORPHIC_FINITE = store_thm ("HOMEOMORPHIC_FINITE",
 ``!s:real->bool t:real->bool.
        FINITE s /\ FINITE t ==> (s homeomorphic t <=> (CARD s = CARD t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
    ASM_SIMP_TAC std_ss [CARD_EQ_CARD],
    STRIP_TAC THEN REWRITE_TAC[homeomorphic, HOMEOMORPHISM] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
        CARD_EQ_BIJECTIONS) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN POP_ASSUM MP_TAC THEN
    DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN
    MAP_EVERY EXISTS_TAC [``f:real->real``,``g:real->real``] THEN
    POP_ASSUM MP_TAC THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_ON_FINITE] THEN ASM_SET_TAC[]]);

val HOMEOMORPHIC_FINITE_STRONG = store_thm ("HOMEOMORPHIC_FINITE_STRONG",
 ``!s:real->bool t:real->bool.
        FINITE s \/ FINITE t
        ==> (s homeomorphic t <=> FINITE s /\ FINITE t /\ (CARD s = CARD t))``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN EQ_TAC THEN
  SIMP_TAC std_ss [HOMEOMORPHIC_FINITE] THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CARD_FINITE_CONG o MATCH_MP
    HOMEOMORPHIC_IMP_CARD_EQ) THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[HOMEOMORPHIC_FINITE]);

val HOMEOMORPHIC_SING = store_thm ("HOMEOMORPHIC_SING",
 ``!a:real b:real. {a} homeomorphic {b}``,
  SIMP_TAC std_ss [HOMEOMORPHIC_FINITE, FINITE_SING, CARD_SING]);

val LIFT_TO_QUOTIENT_SPACE_UNIQUE = store_thm ("LIFT_TO_QUOTIENT_SPACE_UNIQUE",
 ``!f:real->real g:real->real s t u.
        (IMAGE f s = t) /\
        (IMAGE g s = u) /\
        (!v. v SUBSET t
             ==> (open_in (subtopology euclidean s)
                  {x | x IN s /\ f x IN v} <=>
                  open_in (subtopology euclidean t) v)) /\
         (!v. v SUBSET u
             ==> (open_in (subtopology euclidean s)
                  {x | x IN s /\ g x IN v} <=>
                  open_in (subtopology euclidean u) v)) /\
        (!x y. x IN s /\ y IN s ==> ((f x = f y) <=> (g x = g y)))
        ==> t homeomorphic u``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [``f:real->real``, ``g:real->real``, ``s:real->bool``,
    ``t:real->bool``, ``u:real->bool``] LIFT_TO_QUOTIENT_SPACE) THEN
  MP_TAC(ISPECL
   [``g:real->real``, ``f:real->real``, ``s:real->bool``,
    ``u:real->bool``, ``t:real->bool``] LIFT_TO_QUOTIENT_SPACE) THEN
  ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``, ``t:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN DISCH_THEN SUBST1_TAC THEN
  KNOW_TAC ``(!(u :real -> bool).
    open_in (subtopology euclidean (t :real -> bool)) u ==>
    open_in (subtopology euclidean (s :real -> bool))
      {x | x IN s /\ (f :real -> real) x IN u})`` THENL
   [METIS_TAC[OPEN_IN_IMP_SUBSET],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``h:real->real`` STRIP_ASSUME_TAC)] THEN
  MP_TAC(ISPECL [``g:real->real``, ``s:real->bool``, ``u:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN DISCH_THEN SUBST1_TAC THEN
  KNOW_TAC ``(!(u' :real -> bool).
    open_in (subtopology euclidean (u :real -> bool)) u' ==>
    open_in (subtopology euclidean (s :real -> bool))
      {x | x IN s /\ (g :real -> real) x IN u'}) /\
 (!(x :real) (y :real).
    x IN s /\ y IN s /\ ((f :real -> real) x = f y) ==> (g x = g y))`` THENL
   [METIS_TAC[OPEN_IN_IMP_SUBSET],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``k:real->real`` STRIP_ASSUME_TAC)] THEN
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MAP_EVERY EXISTS_TAC
   [``k:real->real``, ``h:real->real``] THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Inverse function property for open/closed maps.                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_INVERSE_OPEN_MAP = store_thm ("CONTINUOUS_ON_INVERSE_OPEN_MAP",
 ``!f:real->real g s t.
        f continuous_on s /\ (IMAGE f s = t) /\ (!x. x IN s ==> (g(f x) = x)) /\
        (!u. open_in (subtopology euclidean s) u
             ==> open_in (subtopology euclidean t) (IMAGE f u))
        ==> g continuous_on t``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``g:real->real``, ``t:real->bool``, ``s:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (t :real -> bool) SUBSET (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   DISCH_THEN SUBST1_TAC] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
  ASM_SET_TAC[]);

val CONTINUOUS_ON_INVERSE_CLOSED_MAP = store_thm ("CONTINUOUS_ON_INVERSE_CLOSED_MAP",
 ``!f:real->real g s t.
        f continuous_on s /\ (IMAGE f s = t) /\ (!x. x IN s ==> (g(f x) = x)) /\
        (!u. closed_in (subtopology euclidean s) u
             ==> closed_in (subtopology euclidean t) (IMAGE f u))
        ==> g continuous_on t``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``g:real->real``, ``t:real->bool``, ``s:real->bool``]
        CONTINUOUS_ON_CLOSED_GEN) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (t :real -> bool) SUBSET (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   DISCH_THEN SUBST1_TAC] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [closed_in]) THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_INJECTIVE_OPEN_MAP = store_thm ("HOMEOMORPHISM_INJECTIVE_OPEN_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) /\
        (!u. open_in (subtopology euclidean s) u
             ==> open_in (subtopology euclidean t) (IMAGE f u))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``!(x :real) (y :real).
        x IN (s :real -> bool) /\ y IN s /\
        ((f :real -> real) x = f y) ==>
        (x = y)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [homeomorphism] THEN
  REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_ON_INVERSE_OPEN_MAP THEN ASM_MESON_TAC[]);

val HOMEOMORPHISM_INJECTIVE_CLOSED_MAP = store_thm ("HOMEOMORPHISM_INJECTIVE_CLOSED_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) /\
        (!u. closed_in (subtopology euclidean s) u
             ==> closed_in (subtopology euclidean t) (IMAGE f u))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``!(x :real) (y :real).
        x IN (s :real -> bool) /\ y IN s /\
        ((f :real -> real) x = f y) ==>
        (x = y)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [homeomorphism] THEN
  REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_ON_INVERSE_CLOSED_MAP THEN ASM_MESON_TAC[]);

val HOMEOMORPHISM_IMP_OPEN_MAP = store_thm ("HOMEOMORPHISM_IMP_OPEN_MAP",
 ``!f:real->real g s t u.
        homeomorphism (s,t) (f,g) /\ open_in (subtopology euclidean s) u
        ==> open_in (subtopology euclidean t) (IMAGE f u)``,
  REWRITE_TAC[homeomorphism] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) u =
                 {y | y IN t /\ g(y) IN u}``
  SUBST1_TAC THENL
   [FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
    ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_IMP_CLOSED_MAP = store_thm ("HOMEOMORPHISM_IMP_CLOSED_MAP",
 ``!f:real->real g s t u.
        homeomorphism (s,t) (f,g) /\ closed_in (subtopology euclidean s) u
        ==> closed_in (subtopology euclidean t) (IMAGE f u)``,
  REWRITE_TAC[homeomorphism] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) u =
                  {y | y IN t /\ g(y) IN u}``
  SUBST1_TAC THENL
   [FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [closed_in]) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_ON_IMP_CLOSED_IN THEN ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ = store_thm ("HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((?g. homeomorphism (s,t) (f,g)) <=>
             !u. open_in (subtopology euclidean s) u
                 ==> open_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN ASM_MESON_TAC[],
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ = store_thm ("HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((?g. homeomorphism (s,t) (f,g)) <=>
             !u. closed_in (subtopology euclidean s) u
                 ==> closed_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_IMP_CLOSED_MAP THEN ASM_MESON_TAC[],
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_CLOSED_MAP THEN
    ASM_REWRITE_TAC[]]);

val INJECTIVE_MAP_OPEN_IFF_CLOSED = store_thm ("INJECTIVE_MAP_OPEN_IFF_CLOSED",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. closed_in (subtopology euclidean s) u
                  ==> closed_in (subtopology euclidean t) (IMAGE f u)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC EQ_TRANS THEN
  EXISTS_TAC ``?g:real->real. homeomorphism (s,t) (f,g)`` THEN
  CONJ_TAC THENL
   [CONV_TAC SYM_CONV THEN MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ,
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ] THEN
  ASM_REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Relatively weak hypotheses if the domain of the function is compact.      *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_IMP_CLOSED_MAP = store_thm ("CONTINUOUS_IMP_CLOSED_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\ compact s
        ==> !u. closed_in (subtopology euclidean s) u
                ==> closed_in (subtopology euclidean t) (IMAGE f u)``,
  SIMP_TAC std_ss [CLOSED_IN_CLOSED_EQ, COMPACT_IMP_CLOSED] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSED_SUBSET THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN
  MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_TRANS,
                BOUNDED_SUBSET, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_IMP_QUOTIENT_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\ compact s
        ==> !u. u SUBSET t
                ==> (open_in (subtopology euclidean s)
                             {x | x IN s /\ f x IN u} <=>
                     open_in (subtopology euclidean t) u)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  MATCH_MP_TAC CLOSED_MAP_IMP_QUOTIENT_MAP THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_IMP_CLOSED_MAP THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_ON_INVERSE = store_thm ("CONTINUOUS_ON_INVERSE",
 ``!f:real->real g s.
        f continuous_on s /\ compact s /\ (!x. x IN s ==> (g(f(x)) = x))
        ==> g continuous_on (IMAGE f s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN
  SUBGOAL_THEN ``IMAGE g (IMAGE (f:real->real) s) = s`` SUBST1_TAC THENL
   [REWRITE_TAC[EXTENSION, IN_IMAGE] THEN ASM_MESON_TAC[], ALL_TAC] THEN
  X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``IMAGE (f:real->real) t`` THEN CONJ_TAC THENL
   [MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
    MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET) THEN
    REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_TRANS,
                  BOUNDED_SUBSET, CONTINUOUS_ON_SUBSET],
    SIMP_TAC std_ss [EXTENSION, IN_INTER, GSPECIFICATION, IN_IMAGE] THEN
    ASM_MESON_TAC[CLOSED_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_DEF]]);

val HOMEOMORPHISM_COMPACT = store_thm ("HOMEOMORPHISM_COMPACT",
 ``!s f t. compact s /\ f continuous_on s /\ (IMAGE f s = t) /\
           (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
           ==> ?g. homeomorphism(s,t) (f,g)``,
  REWRITE_TAC[INJECTIVE_ON_LEFT_INVERSE] THEN REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [EXTENSION, homeomorphism] THEN
  FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  ASM_MESON_TAC[CONTINUOUS_ON_INVERSE, IN_IMAGE]);

val HOMEOMORPHIC_COMPACT = store_thm ("HOMEOMORPHIC_COMPACT",
 ``!s f t. compact s /\ f continuous_on s /\ (IMAGE f s = t) /\
           (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
           ==> s homeomorphic t``,
  REWRITE_TAC[homeomorphic] THEN METIS_TAC[HOMEOMORPHISM_COMPACT]);

(* ------------------------------------------------------------------------- *)
(* Lemmas about composition of homeomorphisms.                               *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE = store_thm ("HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
        f continuous_on s /\ (IMAGE f s = t) /\
        g continuous_on t /\ IMAGE g t SUBSET u /\
        (?h. homeomorphism (s,u) (g o f,h))
        ==> (?f'. homeomorphism (s,t) (f,f')) /\
            (?g'. homeomorphism (t,u) (g,g'))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[homeomorphism, o_THM]) THEN
  MATCH_MP_TAC(TAUT `q /\ (q ==> p) ==> p /\ q`) THEN CONJ_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC OPEN_MAP_FROM_COMPOSITION_SURJECTIVE THEN
    MAP_EVERY EXISTS_TAC [``f:real->real``, ``s:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN
    MAP_EVERY EXISTS_TAC [``h:real->real``, ``s:real->bool``] THEN
    ASM_SIMP_TAC std_ss [homeomorphism, o_THM],
    REWRITE_TAC[homeomorphism, o_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``g':real->real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``((h:real->real) o (g:real->real))`` THEN
    ASM_SIMP_TAC std_ss [o_THM, IMAGE_COMPOSE] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]);

val HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE = store_thm ("HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
        f continuous_on s /\ IMAGE f s SUBSET t /\
        g continuous_on t /\ IMAGE g t SUBSET u /\
        (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
        (?h. homeomorphism (s,u) (g o f,h))
        ==> (?f'. homeomorphism (s,t) (f,f')) /\
            (?g'. homeomorphism (t,u) (g,g'))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[homeomorphism, o_THM]) THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC OPEN_MAP_FROM_COMPOSITION_INJECTIVE THEN
    MAP_EVERY EXISTS_TAC [``g:real->real``, ``u:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN
    MAP_EVERY EXISTS_TAC [``h:real->real``, ``s:real->bool``] THEN
    ASM_REWRITE_TAC[homeomorphism, o_THM],
    REWRITE_TAC[homeomorphism, o_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``f':real->real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(f:real->real) o (h:real->real)`` THEN
    ASM_SIMP_TAC std_ss [o_THM, IMAGE_COMPOSE] THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]);

(* ------------------------------------------------------------------------- *)
(* Preservation of topological properties.                                   *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_COMPACTNESS = store_thm ("HOMEOMORPHIC_COMPACTNESS",
 ``!s t. s homeomorphic t ==> (compact s <=> compact t)``,
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MESON_TAC[COMPACT_CONTINUOUS_IMAGE]);

val HOMEOMORPHIC_CONNECTEDNESS = store_thm ("HOMEOMORPHIC_CONNECTEDNESS",
 ``!s t. s homeomorphic t ==> (connected s <=> connected t)``,
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MESON_TAC[CONNECTED_CONTINUOUS_IMAGE]);

(* ------------------------------------------------------------------------- *)
(* Results on translation, scaling etc.                                      *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_SCALING = store_thm ("HOMEOMORPHIC_SCALING",
 ``!s:real->bool c. ~(c = &0) ==> s homeomorphic (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  MAP_EVERY EXISTS_TAC [``\x:real. c * x``, ``\x:real. inv(c) * x``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CMUL, CONTINUOUS_ON_ID, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_RINV] THEN
  SIMP_TAC std_ss [REAL_MUL_LID, IN_IMAGE, REAL_MUL_LID] THEN MESON_TAC[]);

val HOMEOMORPHIC_TRANSLATION = store_thm ("HOMEOMORPHIC_TRANSLATION",
 ``!s a:real. s homeomorphic (IMAGE (\x. a + x) s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  MAP_EVERY EXISTS_TAC [``\x:real. a +  x``, ``\x:real. -a + x``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID] THEN
  SIMP_TAC std_ss [REAL_ADD_ASSOC, REAL_ADD_LINV, REAL_ADD_RINV,
           FORALL_IN_IMAGE, REAL_ADD_LID] THEN
  REWRITE_TAC[IN_IMAGE] THEN MESON_TAC[]);

val HOMEOMORPHIC_AFFINITY = store_thm ("HOMEOMORPHIC_AFFINITY",
 ``!s a:real c. ~(c = &0) ==> s homeomorphic (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_TRANS THEN
  EXISTS_TAC ``IMAGE (\x:real. c * x) s`` THEN
  ASM_SIMP_TAC std_ss [HOMEOMORPHIC_SCALING] THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  SIMP_TAC std_ss [IMAGE_COMPOSE, HOMEOMORPHIC_TRANSLATION]);

val HOMEOMORPHIC_BALLS_CBALL_SPHERE = store_thm ("HOMEOMORPHIC_BALLS_CBALL_SPHERE",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> ball(a,d) homeomorphic ball(b,e)) /\
   (!a:real b:real d e.
      &0 < d /\ &0 < e ==> cball(a,d) homeomorphic cball(b,e)) /\
   (!a:real b:real d e.
      &0 < d /\ &0 < e ==> sphere(a,d) homeomorphic sphere(b,e))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  EXISTS_TAC ``\x:real. b + (e / d) * (x - a)`` THEN
  EXISTS_TAC ``\x:real. a + (d / e) * (x - b)`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_SUB, CONTINUOUS_ON_CMUL,
    CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID, IN_BALL, IN_CBALL, IN_SPHERE] THEN
  REWRITE_TAC[dist, REAL_ARITH ``a - (a + b) = -b:real``, ABS_NEG] THEN
  REWRITE_TAC[real_div, REAL_ARITH
   ``a + d * ((b + e * (x - a)) - b) = (&1 - d * e) * a + (d * e) * x:real``] THEN
  ONCE_REWRITE_TAC[REAL_ARITH
    ``(e * d') * (d * e') = (d * d') * (e * e':real)``] THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_RINV, REAL_LT_IMP_NE, REAL_MUL_LID, REAL_SUB_REFL] THEN
  REWRITE_TAC[ABS_MUL, REAL_MUL_LZERO, REAL_MUL_LID, REAL_ADD_LID] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_INV, REAL_ARITH
   ``&0 < x ==> (abs x = x:real)``, REAL_LT_IMP_NE] THEN
  GEN_REWR_TAC(BINOP_CONV o BINDER_CONV o funpow 2 RAND_CONV)
        [GSYM REAL_MUL_RID] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(a * b) * c = (a * c) * b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL, GSYM real_div, REAL_LE_LDIV_EQ, REAL_MUL_LID,
    GSYM REAL_MUL_ASSOC, REAL_LT_LMUL, REAL_LT_LDIV_EQ, ABS_SUB] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_REFL, REAL_LT_IMP_NE, REAL_MUL_RID]);

val HOMEOMORPHIC_BALLS = store_thm ("HOMEOMORPHIC_BALLS",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> ball(a,d) homeomorphic ball(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

val HOMEOMORPHIC_CBALL = store_thm ("HOMEOMORPHIC_CBALL",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> cball(a,d) homeomorphic cball(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

val HOMEOMORPHIC_SPHERE = store_thm ("HOMEOMORPHIC_SPHERE",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> sphere(a,d) homeomorphic sphere(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphism of one-point compactifications.                             *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS = store_thm ("HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS",
 ``!s:real->bool t:real->bool a b.
        compact s /\ compact t /\ a IN s /\ b IN t /\
        (s DELETE a) homeomorphic (t DELETE b)
        ==> s homeomorphic t``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HOMEOMORPHIC_COMPACT THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [homeomorphic]) THEN
  SIMP_TAC std_ss [HOMEOMORPHISM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``f:real->real``, ``g:real->real``] THEN
  STRIP_TAC THEN
  EXISTS_TAC ``\x. if x = a then b else (f:real->real) x`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``x:real = a`` THEN ASM_REWRITE_TAC[] THENL
   [REWRITE_TAC[continuous_within] THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
    MP_TAC(ISPECL [``b:real``, ``e:real``] CENTRE_IN_BALL) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
    SUBGOAL_THEN
      ``closed_in (subtopology euclidean s)
                 { x | x IN (s DELETE a) /\
                       (f:real->real)(x) IN t DIFF ball(b,e)}``
    MP_TAC THENL
     [MATCH_MP_TAC CLOSED_SUBSET THEN CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
      MATCH_MP_TAC COMPACT_IMP_CLOSED THEN SUBGOAL_THEN
       ``{x | x IN s DELETE a /\ f x IN t DIFF ball(b,e)} =
        IMAGE (g:real->real) (t DIFF ball (b,e))``
      SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
      MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
      ASM_SIMP_TAC std_ss [COMPACT_DIFF, OPEN_BALL] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN ASM_SET_TAC[],
      REWRITE_TAC[closed_in, open_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
      DISCH_THEN(MP_TAC o SPEC ``a:real`` o last o CONJUNCTS) THEN
      ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_DIFF, IN_DELETE] THEN
      SIMP_TAC std_ss [CONJ_EQ_IMP, DE_MORGAN_THM] THEN
      STRIP_TAC THEN EXISTS_TAC ``e':real`` THEN
      ASM_REWRITE_TAC[] THEN GEN_TAC THEN COND_CASES_TAC THEN
      ASM_REWRITE_TAC[DIST_REFL] THEN
      GEN_REWR_TAC (RAND_CONV o RAND_CONV o LAND_CONV) [DIST_SYM] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[IN_BALL]) THEN ASM_SET_TAC[]],
    UNDISCH_TAC ``(f:real->real) continuous_on (s DELETE a)`` THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    REWRITE_TAC[continuous_within] THEN
    DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
    ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``min d (dist(a:real,x))`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MIN, GSYM DIST_NZ] THEN
    METIS_TAC[REAL_LT_REFL]]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphisms between open intervals in real and then in real.       *)
(* Could prove similar things for closed intervals, but they drop out of     *)
(* later stuff in "convex.ml" even more easily.                              *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_OPEN_INTERVALS = store_thm ("HOMEOMORPHIC_OPEN_INTERVALS",
 ``!a b c d.
        a < b /\ c < d
        ==> interval(a,b) homeomorphic interval(c,d)``,
  SUBGOAL_THEN
   ``!a b. a < b
          ==> interval(0:real,1) homeomorphic interval(a,b)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
    EXISTS_TAC ``(\x. a + x * (b - a)):real->real`` THEN
    EXISTS_TAC ``(\x. inv(b - a) * (x - a)):real->real`` THEN
    ASM_SIMP_TAC std_ss [IN_INTERVAL] THEN
    REWRITE_TAC[METIS [REAL_MUL_SYM, GSYM real_div] ``inv b * a:real = a / b``] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ, REAL_SUB_LT,
       REAL_LT_ADDR, REAL_EQ_LDIV_EQ, REAL_DIV_RMUL, REAL_LT_IMP_NE,
       REAL_LT_MUL, REAL_MUL_LZERO, REAL_ADD_SUB, REAL_LT_RMUL,
       REAL_ARITH ``a + x < b <=> x < &1 * (b - a:real)``] THEN
    REPEAT CONJ_TAC THENL
     [REAL_ARITH_TAC,
      ONCE_REWRITE_TAC [METIS [] ``(\x. a + x * (b - a)) =
                      (\x. (\x. a) x + (\x. x * (b - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. x * (b - a)) =
                      (\x. (\x. x) x * (\x. (b - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
      REWRITE_TAC[o_DEF, CONTINUOUS_ON_ID, CONTINUOUS_ON_CONST],
      ONCE_REWRITE_TAC [METIS [real_div, REAL_MUL_SYM] ``(\x. (x - a) / (b - a))  =
                                       (\x. inv(b - a) * (\x. (x - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CMUL THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]],
    REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC o SPECL [``a:real``, ``b:real``]) THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``c:real``, ``d:real``]) THEN
    ASM_REWRITE_TAC[GSYM IMP_CONJ_ALT] THEN
    GEN_REWR_TAC (LAND_CONV o LAND_CONV) [HOMEOMORPHIC_SYM] THEN
    REWRITE_TAC[HOMEOMORPHIC_TRANS]]);

val HOMEOMORPHIC_OPEN_INTERVAL_UNIV = store_thm ("HOMEOMORPHIC_OPEN_INTERVAL_UNIV",
 ``!a b. a < b ==> interval(a,b) homeomorphic univ(:real)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``a:real``, ``b:real``, ``-1:real``, ``1:real``]
        HOMEOMORPHIC_OPEN_INTERVALS) THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC [REAL_ARITH ``-1 < 1:real``] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] HOMEOMORPHIC_TRANS) THEN
  POP_ASSUM_LIST(K ALL_TAC) THEN
  REWRITE_TAC[HOMEOMORPHIC_MINIMAL, IN_UNIV] THEN
  EXISTS_TAC ``\x:real. inv(&1 - abs x) * x`` THEN
  EXISTS_TAC ``\y:real. if &0 <= y then inv(&1 + y) * y
                  else inv(&1 - y) * y`` THEN
  SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL
   [X_GEN_TAC ``x:real`` THEN REWRITE_TAC[IN_INTERVAL] THEN
    SIMP_TAC std_ss [REAL_LE_MUL, REAL_LT_INV_EQ, REAL_LE_MUL, REAL_ARITH
     ``-a < x /\ x < a ==> &0 < a - abs x:real``] THEN
    SIMP_TAC std_ss [abs, REAL_MUL_ASSOC] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN COND_CASES_TAC THEN
    (Cases_on `x = 0:real` THENL
     [ASM_REWRITE_TAC [REAL_INV1, REAL_NEG_0, REAL_SUB_RZERO,
      REAL_ADD_RID, REAL_MUL_RZERO] THEN REAL_ARITH_TAC, ALL_TAC]) THEN
     (KNOW_TAC ``!y. y <> 0:real ==> ((1 + inv y * x) = (y + x) / y:real) /\
                                     ((1 - inv y * x) = (y - x) / y:real)`` THENL
     [ASM_SIMP_TAC real_ss [real_div, REAL_ADD_RDISTRIB, REAL_MUL_RINV, REAL_SUB_RDISTRIB] THEN
      REAL_ARITH_TAC, STRIP_TAC] THEN
     KNOW_TAC ``(1 - x) <> 0 /\ (1 - -x) <> 0:real`` THENL
     [METIS_TAC [REAL_ARITH ``x < 1 ==> 1 - x <> 0:real``,
                 REAL_ARITH ``-1 < x ==> 1 - -x <> 0:real``],
      STRIP_TAC] THEN ASM_SIMP_TAC real_ss []) THENL
     [METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV],
      FULL_SIMP_TAC real_ss [REAL_LT_IMP_LE] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN
      FULL_SIMP_TAC real_ss [GSYM real_div, REAL_LE_RDIV_EQ,
       REAL_ARITH ``(-1 < x) =  (0 < 1 + x:real)``],
      FULL_SIMP_TAC real_ss [REAL_LT_IMP_LE, REAL_NOT_LE] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN
      FULL_SIMP_TAC real_ss [GSYM real_div, REAL_LT_LDIV_EQ,
       REAL_ARITH ``(x < 1) =  (0 < 1 - x:real)``] THEN
      METIS_TAC [REAL_ARITH ``~(x < 0 /\ 0 <= x:real)``],
      FULL_SIMP_TAC real_ss [] THEN
      METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV]],
    X_GEN_TAC ``y:real`` THEN COND_CASES_TAC THEN
    ASM_SIMP_TAC real_ss [IN_INTERVAL, REAL_BOUNDS_LT] THEN
    ASM_SIMP_TAC real_ss [ABS_MUL, ABS_INV, REAL_ARITH
     ``(0 <= y ==> 1 + y <> 0:real) /\ (~(0 <= y) ==> 1 - y <> 0:real)``] THEN
    REWRITE_TAC[GSYM(ONCE_REWRITE_RULE[REAL_MUL_SYM] real_div)] THEN
    ASM_SIMP_TAC real_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``&0 <= x ==> &0 < abs(&1 + x:real)``,
                 REAL_ARITH ``~(&0 <= x) ==> &0 < abs(&1 - x:real)``] THEN
    (CONJ_TAC THENL [ASM_REAL_ARITH_TAC, ALL_TAC]) THEN
    REWRITE_TAC [real_div] THEN
    ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = c * b * a:real``] THEN
    REWRITE_TAC[REAL_MUL_ASSOC] THEN REWRITE_TAC[ABS_MUL] THEN
    ASM_REWRITE_TAC[abs,  REAL_LE_INV_EQ] THEN
    ASM_SIMP_TAC real_ss [REAL_ARITH ``&0 <= x ==> &0 <= &1 + x:real``,
                 REAL_ARITH ``~(&0 <= x) ==> &0 <= &1 - x:real``] THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN
    (KNOW_TAC ``!x. x <> 0:real ==> ((1 + y * inv x) = (x + y) / x:real) /\
                                   ((1 - y * inv x) = (x - y) / x:real)`` THENL
     [ASM_SIMP_TAC real_ss [real_div, REAL_ADD_RDISTRIB, REAL_MUL_RINV, REAL_SUB_RDISTRIB],
      STRIP_TAC]) THENL
     [KNOW_TAC ``(1 + y) <> 0:real`` THENL
      [METIS_TAC [REAL_ARITH ``(0 <= x) ==> 1 + x <> 0:real``],
       STRIP_TAC] THEN ASM_SIMP_TAC real_ss [],
      KNOW_TAC ``(1 - y) <> 0:real`` THENL
      [METIS_TAC [REAL_ARITH ``~(0 <= x) ==> 1 - x <> 0:real``],
       STRIP_TAC] THEN ASM_SIMP_TAC real_ss []] THEN
     METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV],
    MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
    X_GEN_TAC ``x:real`` THEN
    REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN
    ONCE_REWRITE_TAC [METIS [] ``(\x. inv (1 - abs x) * x) =
                    (\x. (\x. inv (1 - abs x)) x * (\x. x) x:real)``] THEN
    MATCH_MP_TAC CONTINUOUS_MUL THEN
    REWRITE_TAC[CONTINUOUS_AT_ID] THEN
    ONCE_REWRITE_TAC [METIS [] ``(\x. inv (1 - abs x)) =
                             (\x. inv ((\x. 1 - abs x) x:real))``] THEN
    ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
    SIMP_TAC real_ss [NETLIMIT_AT, o_DEF] THEN
    CONJ_TAC THENL
     [ONCE_REWRITE_TAC [METIS []
      ``(\x. 1 - abs x) = (\x. (\x. 1) x - (\x. abs x) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_SUB THEN
      SIMP_TAC std_ss [CONTINUOUS_CONST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. abs x) = (\x. abs ((\x. x) x:real))``] THEN
      METIS_TAC [REWRITE_RULE[o_DEF] CONTINUOUS_AT_ABS], ASM_REAL_ARITH_TAC],
    SUBGOAL_THEN ``univ(:real) = {x | x >= &0} UNION {x | x <= &0}``
    SUBST1_TAC THENL
     [SIMP_TAC std_ss [EXTENSION, IN_UNION, IN_UNION, GSPECIFICATION, IN_UNIV] THEN
      REAL_ARITH_TAC,
      ONCE_REWRITE_TAC [METIS []
      ``(\y. if 0 <= y then inv (1 + y) * y else inv (1 - y) * y) =
        (\y. if (\y. 0 <= y) y then (\y. inv (1 + y) * y) y
                               else (\y. inv (1 - y) * y) y:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CASES THEN
      SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, CLOSED_HALFSPACE_COMPONENT_GE,
                  GSPECIFICATION] THEN
      REWRITE_TAC[REAL_NOT_LE, real_ge, REAL_LET_ANTISYM] THEN
      SIMP_TAC std_ss [REAL_LE_ANTISYM, REAL_SUB_RZERO, REAL_ADD_RID] THEN
      CONJ_TAC THENL
      [MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
       X_GEN_TAC ``y:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, real_ge] THEN
       DISCH_TAC THEN ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 + y) * y) =
                                      (\y. (\y. inv (1 + y)) y * (\y. y) y:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_MUL THEN
      REWRITE_TAC[CONTINUOUS_AT_ID] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 + y)) = (\y. inv ((\y. (1 + y)) y:real))``] THEN
      ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
      SIMP_TAC std_ss [NETLIMIT_AT, o_DEF] THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_AT_ID, CONTINUOUS_SUB,
                   CONTINUOUS_CONST] THEN
      ASM_REAL_ARITH_TAC, ALL_TAC] THEN CONJ_TAC THENL
      [MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
       X_GEN_TAC ``y:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, real_ge] THEN
       DISCH_TAC THEN ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 - y) * y) =
                                      (\y. (\y. inv (1 - y)) y * (\y. y) y:real)``] THEN
       MATCH_MP_TAC CONTINUOUS_MUL THEN
       REWRITE_TAC[CONTINUOUS_AT_ID] THEN
       ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 - y)) = (\y. inv ((\y. (1 - y)) y:real))``] THEN
       ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
       SIMP_TAC std_ss [NETLIMIT_AT, o_DEF] THEN
       ASM_SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_AT_ID, CONTINUOUS_SUB,
                   CONTINUOUS_CONST] THEN
       ASM_REAL_ARITH_TAC,
       REPEAT STRIP_TAC THENL [METIS_TAC [REAL_ARITH ``~(0 <= x /\ x < 0:real)``],
        ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC]]]]);

(* ------------------------------------------------------------------------- *)
(* Cardinality of the reals. This is done in a rather laborious way to avoid *)
(* any dependence on the theories of analysis.                               *)
(* ------------------------------------------------------------------------- *)

Triviality lemma:
  !s m n. sum (s INTER (m..n)) (\i. inv(&3 pow i)) < &3 / &2 / &3 pow m
Proof
    REPEAT GEN_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``sum (m..n) (\i. inv(&3 pow i))`` THEN CONJ_TAC THENL
    [ (* goal 1 (of 2) *)
      MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
      SIMP_TAC std_ss [FINITE_NUMSEG, INTER_SUBSET, REAL_LE_INV_EQ,
               POW_POS, REAL_POS],
      (* goal 2 (of 2) *)
      completeInduct_on `n - m:num` THEN GEN_TAC THEN GEN_TAC THEN
      DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN POP_ASSUM K_TAC THEN
      KNOW_TAC ``(!m'. m' < n - m ==>
        !n m''. (m' = n - m'') ==>
          sum (m'' .. n) (\i. inv (3 pow i)) < 3 / 2 / 3 pow m'') ==>
       (!n' m''. (n' - m'' < n - m) ==>
          sum (m'' .. n') (\i. inv (3 pow i)) < 3 / 2 / 3 pow m'')`` THENL
      [ METIS_TAC [], ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC ] THEN
      ASM_CASES_TAC ``m:num <= n`` THENL
      [ (* goal 2.1 (of 2) *)
        ASM_SIMP_TAC std_ss [SUM_CLAUSES_LEFT] THEN ASM_CASES_TAC ``m + 1 <= n:num`` THENL
        [ (* goal 2.1.1 (of 2) *)
          FIRST_X_ASSUM (MP_TAC o SPECL [``n:num``, ``SUC m``]) THEN
          KNOW_TAC ``n - SUC m < n - m`` THENL
          [ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
           ASM_SIMP_TAC arith_ss [ADD1, REAL_POW_ADD]] THEN
          MATCH_MP_TAC (REAL_ARITH
                        ``a + j:real <= k ==> x < j ==> a + x < k:real``) THEN
          KNOW_TAC ``3 pow m <> 0:real`` THENL
          [MATCH_MP_TAC POW_NZ THEN REAL_ARITH_TAC, DISCH_TAC] THEN
          ASM_SIMP_TAC real_ss [real_div, REAL_INV_MUL, POW_1] THEN
          ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
          GEN_REWR_TAC (LAND_CONV o LAND_CONV) [GSYM REAL_MUL_RID] THEN
          REWRITE_TAC [GSYM REAL_ADD_LDISTRIB, GSYM REAL_MUL_ASSOC] THEN
          MATCH_MP_TAC REAL_LE_LMUL_IMP THEN CONJ_TAC THENL
          [REWRITE_TAC [REAL_LE_INV_EQ] THEN MATCH_MP_TAC POW_POS THEN
           REAL_ARITH_TAC, ALL_TAC] THEN REWRITE_TAC [GSYM real_div] THEN
           SIMP_TAC real_ss [REAL_LE_RDIV_EQ, REAL_ADD_RDISTRIB, real_div] THEN
           REWRITE_TAC [REAL_MUL_ASSOC] THEN SIMP_TAC real_ss [REAL_MUL_LINV],
          ALL_TAC], ALL_TAC] THEN
      RULE_ASSUM_TAC (REWRITE_RULE[NOT_LESS_EQUAL, GSYM NUMSEG_EMPTY]) THEN
      ASM_REWRITE_TAC [SUM_CLAUSES, REAL_ADD_RID] THEN
      (KNOW_TAC ``0:real < 3 pow m`` THENL
          [MATCH_MP_TAC REAL_POW_LT THEN REAL_ARITH_TAC, DISCH_TAC] THEN
       ASM_SIMP_TAC real_ss [REAL_LT_RDIV_EQ, REAL_MUL_LINV, REAL_LT_IMP_NE])]
QED

Theorem CARD_EQ_REAL:   univ(:real) =_c univ(:num->bool)
Proof
  REWRITE_TAC [GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
  [ (* goal 1 (of 2) *)
    KNOW_TAC ``univ(:real) <=_c (univ(:num) *_c univ(:num->bool)) /\
               (univ(:num) *_c univ(:num->bool)) <=_c univ(:num -> bool)`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    CONJ_TAC THENL
     [ALL_TAC,
      MATCH_MP_TAC CARD_MUL2_ABSORB_LE THEN REWRITE_TAC[INFINITE_CARD_LE] THEN
      SIMP_TAC std_ss [CANTOR_THM_UNIV, CARD_LT_IMP_LE, CARD_LE_REFL]] THEN
    `univ(:real) <=_c (univ(:num) *_c {x:real | &0 <= x}) /\
     univ(:num) *_c {x:real | &0 <= x} <=_c univ(:num) *_c univ(:num -> bool)`
       suffices_by METIS_TAC[CARD_LE_TRANS] THEN
    CONJ_TAC THENL
     [SIMP_TAC std_ss [LE_C, mul_c, EXISTS_PROD, IN_ELIM_PAIR_THM, IN_UNIV] THEN
      EXISTS_TAC ``\(n,x:real). -(&1) pow n * x`` THEN X_GEN_TAC ``x:real`` THEN
      `?p_2. (p_2 IN {x | 0r <= x} /\ ((\ (n,x). -1 pow n * x) (0,p_2) = x)) \/
             (p_2 IN {x | 0r <= x} /\ ((\ (n,x). -1 pow n * x) (1,p_2) = x))`
        suffices_by METIS_TAC[OR_EXISTS_THM] THEN EXISTS_TAC ``abs x:real`` THEN
      SIMP_TAC std_ss [GSPECIFICATION, pow, POW_1] THEN REAL_ARITH_TAC,
      ALL_TAC] THEN
    MATCH_MP_TAC CARD_LE_MUL THEN SIMP_TAC std_ss [CARD_LE_REFL] THEN
    MP_TAC(ISPECL [``univ(:num)``, ``univ(:num)``] CARD_MUL_ABSORB_LE) THEN
    SIMP_TAC std_ss [CARD_LE_REFL, num_INFINITE] THEN
    SIMP_TAC std_ss [le_c, mul_c, IN_UNIV, FORALL_PROD, IN_ELIM_PAIR_THM] THEN
    REWRITE_TAC [GSYM PAIR_EQ] THEN
    SIMP_TAC std_ss [GSYM FORALL_PROD, INJECTIVE_LEFT_INVERSE] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]

    THEN
    MAP_EVERY X_GEN_TAC [``Pair:num#num->num``, ``Unpair:num->num#num``] THEN
    DISCH_TAC THEN
    EXISTS_TAC ``\x:real n:num. &(FST(Unpair n)) * x <= &(SND(Unpair n))`` THEN
    SIMP_TAC std_ss [] THEN
    HO_MATCH_MP_TAC REAL_WLOG_LT THEN
    SIMP_TAC std_ss [GSPECIFICATION, FUN_EQ_THM] THEN
    CONJ_TAC THENL [SIMP_TAC std_ss [EQ_SYM_EQ, CONJ_ACI], ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o GENL [``p:num``, ``q:num``] o
      SPEC ``(Pair:num#num->num) (p,q)``) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(TAUT `~p ==> p ==> q`) THEN
    MP_TAC(SPEC ``y - x:real`` REAL_ARCH) THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LT, NOT_FORALL_THM] THEN
    DISCH_THEN(MP_TAC o SPEC ``&2:real``) THEN
    DISCH_THEN (X_CHOOSE_TAC ``p:num``) THEN EXISTS_TAC ``p:num`` THEN
    MP_TAC(ISPEC ``&p * x:real`` REAL_BIGNUM) THEN
    ONCE_REWRITE_TAC [METIS [] ``(?n. &p * x < &n:real) = (?n. (\n. &p * x < &n) n)``] THEN
    DISCH_THEN (MP_TAC o MATCH_MP WOP) THEN SIMP_TAC std_ss [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``n:num``) THEN EXISTS_TAC ``n:num`` THEN
    POP_ASSUM MP_TAC THEN SPEC_TAC (``n:num``,``n:num``) THEN
    KNOW_TAC ``!n. (\n. &p * x < &n:real /\ (!m. m < n ==> ~(&p * x < &m)) ==>
                      ~(&p * x <= &n <=> &p * y <= &n:real)) n`` THENL
    [ALL_TAC, METIS_TAC []] THEN MATCH_MP_TAC INDUCTION THEN

    ASM_SIMP_TAC std_ss [REAL_LE_MUL, REAL_POS,
      REAL_ARITH ``x:real < &0 <=> ~(&0 <= x)``]

    THEN
    X_GEN_TAC ``q:num`` THEN REWRITE_TAC[GSYM REAL_OF_NUM_SUC] THEN
    DISCH_THEN(K ALL_TAC) THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``q:num``) THEN
    SIMP_TAC arith_ss [LT] THEN POP_ASSUM MP_TAC THEN
    POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN
    POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN REAL_ARITH_TAC,

    (* goal 2 (of 2) *)
    REWRITE_TAC[le_c, IN_UNIV] THEN
    EXISTS_TAC ``\s:num->bool. sup { sum (s INTER ((0:num)..n)) (\i. inv(&3 pow i)) |
                                    n IN univ(:num) }`` THEN
    MAP_EVERY X_GEN_TAC [``x:num->bool``, ``y:num->bool``] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [EXTENSION, NOT_FORALL_THM] THEN
    ONCE_REWRITE_TAC [METIS [] ``(?x':num. x' IN x <=/=> x' IN y) =
                           (?x'. (\x'. x' IN x <=/=> x' IN y) x')``] THEN
    DISCH_THEN (MP_TAC o MATCH_MP WOP) THEN SIMP_TAC std_ss [] THEN
    MAP_EVERY (fn w => SPEC_TAC(w,w)) [``y:num->bool``, ``x:num->bool``] THEN
    KNOW_TAC ``!x y.
     (?n. ~(n IN x <=> n IN y) /\ (\x y n. !m. m < n ==> (m IN x <=> m IN y)) x y n) ==>
     (\x y. sup {sum (x INTER (0 .. n)) (\i. inv (3 pow i)) | n IN univ(:num)} <>
            sup {sum (y INTER (0 .. n)) (\i. inv (3 pow i)) | n IN univ(:num)}) x y`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC(MESON[]
     ``((!P Q n. R P Q n <=> R Q P n) /\ (!P Q. SS P Q <=> SS Q P)) /\
       (!P Q. (?n. n IN P /\ ~(n IN Q) /\ R P Q n) ==> SS P Q)
       ==> !P Q. (?n:num. ~(n IN P <=> n IN Q) /\ R P Q n) ==> SS P Q``) THEN
    SIMP_TAC std_ss [] THEN CONJ_TAC THENL
    [ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN METIS_TAC [], SIMP_TAC std_ss []] THEN
    MAP_EVERY X_GEN_TAC [``x:num->bool``, ``y:num->bool``] THEN
    DISCH_THEN(X_CHOOSE_THEN ``n:num`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC(REAL_ARITH ``!z:real. y < z /\ z <= x ==> ~(x = y)``) THEN

    EXISTS_TAC ``sum (x INTER ((0:num)..n)) (\i. inv(&3 pow i))`` THEN CONJ_TAC THENL
    [ (* goal 2.1 (of 2) *)
      MATCH_MP_TAC REAL_LET_TRANS THEN
      EXISTS_TAC
       ``sum (y INTER ((0:num)..n)) (\i. inv(&3 pow i)) +
         &3 / &2 / &3 pow (SUC n)`` THEN

      CONJ_TAC THENL
       [MATCH_MP_TAC REAL_SUP_LE' THEN
        CONJ_TAC THENL [SET_TAC[], SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV]] THEN
        X_GEN_TAC ``p:num`` THEN ASM_CASES_TAC ``n:num <= p`` THENL
         [MATCH_MP_TAC(REAL_ARITH
           ``!d. (s:real = t + d) /\ d <= e ==> s <= t + e``) THEN
          EXISTS_TAC ``sum(y INTER (n+(1:num)..p)) (\i. inv (&3 pow i))`` THEN
          CONJ_TAC THENL
           [ONCE_REWRITE_TAC[INTER_COMM] THEN
            SIMP_TAC std_ss [INTER_DEF, SUM_RESTRICT_SET] THEN
            ASM_SIMP_TAC std_ss [SUM_COMBINE_R, ZERO_LESS_EQ],
            SIMP_TAC std_ss [ADD1, lemma, REAL_LT_IMP_LE]],
          MATCH_MP_TAC(REAL_ARITH ``y:real <= x /\ &0 <= d ==> y <= x + d``) THEN
          SIMP_TAC real_ss [REAL_LE_DIV, REAL_POS, POW_POS] THEN
          MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
          SIMP_TAC real_ss [REAL_LE_INV_EQ, POW_POS, REAL_POS] THEN
          SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN MATCH_MP_TAC
           (SET_RULE ``s SUBSET t ==> u INTER s SUBSET u INTER t``) THEN
          REWRITE_TAC[SUBSET_NUMSEG] THEN ASM_SIMP_TAC arith_ss []],
        ONCE_REWRITE_TAC[INTER_COMM] THEN
        SIMP_TAC std_ss [INTER_DEF, SUM_RESTRICT_SET] THEN ASM_CASES_TAC ``n = 0:num`` THENL
         [FIRST_X_ASSUM SUBST_ALL_TAC THEN
          FULL_SIMP_TAC real_ss [SUM_SING, NUMSEG_SING, pow] THEN
          SIMP_TAC real_ss [REAL_LT_LDIV_EQ, REAL_INV1] THEN REAL_ARITH_TAC,
          ASM_SIMP_TAC std_ss [SUM_CLAUSES_RIGHT, LE_1, ZERO_LESS_EQ, REAL_ADD_RID] THEN
          MATCH_MP_TAC(REAL_ARITH ``(s:real = t) /\ d < e ==> s + d < t + e``) THEN
          CONJ_TAC THENL
           [MATCH_MP_TAC SUM_EQ_NUMSEG THEN
            ASM_SIMP_TAC std_ss [ARITH_PROVE ``~(n = 0:num) /\ m <= n - 1 ==> m < n``],
            SIMP_TAC real_ss [pow, real_div, REAL_INV_MUL, REAL_MUL_ASSOC] THEN
            KNOW_TAC ``3 pow n <> 0:real`` THENL
            [MATCH_MP_TAC POW_NZ THEN REAL_ARITH_TAC, DISCH_TAC] THEN
            KNOW_TAC ``0:real < 3 pow n`` THENL
            [MATCH_MP_TAC REAL_POW_LT THEN REAL_ARITH_TAC, DISCH_TAC] THEN
            ASM_SIMP_TAC real_ss [REAL_INV_MUL, REAL_MUL_ASSOC] THEN
            GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
            MATCH_MP_TAC REAL_LT_RMUL_IMP THEN ASM_SIMP_TAC real_ss [REAL_LT_INV_EQ] THEN
            ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
            SIMP_TAC real_ss [REAL_MUL_ASSOC, REAL_MUL_LINV] THEN
            SIMP_TAC real_ss [REAL_INV_1OVER, REAL_LT_LDIV_EQ]]]],
      MP_TAC(ISPEC ``{ sum (x INTER ((0:num)..n)) (\i. inv(&3 pow i)) | n IN univ(:num) }``
          SUP) THEN SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV] THEN
      KNOW_TAC ``{sum (x INTER (0 .. n)) (\i. inv (3 pow i)) | n | T} <> {} /\
         (?b. !n. sum (x INTER (0 .. n)) (\i. inv (3 pow i)) <= b)`` THENL
      [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
       SIMP_TAC std_ss []] THEN
      CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
      EXISTS_TAC ``&3 / &2 / (&3:real) pow 0`` THEN
      SIMP_TAC std_ss [lemma, REAL_LT_IMP_LE]]
  ]
QED

val UNCOUNTABLE_REAL = store_thm ("UNCOUNTABLE_REAL",
 ``~COUNTABLE univ(:real)``,
  REWRITE_TAC[COUNTABLE, ge_c] THEN
  KNOW_TAC ``univ(:num) <_c univ(:num->bool) /\
             univ(:num->bool) <=_c univ(:real)`` THENL
  [ALL_TAC, METIS_TAC [CARD_LTE_TRANS]] THEN
  REWRITE_TAC[CANTOR_THM_UNIV] THEN MATCH_MP_TAC CARD_EQ_IMP_LE THEN
  ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN REWRITE_TAC[CARD_EQ_REAL]);

val CARD_EQ_REAL_IMP_UNCOUNTABLE = store_thm ("CARD_EQ_REAL_IMP_UNCOUNTABLE",
 ``!s:real->bool. s =_c univ(:real) ==> ~COUNTABLE s``,
  GEN_TAC THEN STRIP_TAC THEN
  DISCH_THEN (MP_TAC o SPEC ``univ(:real)`` o MATCH_MP
    (SIMP_RULE std_ss [CONJ_EQ_IMP] CARD_EQ_COUNTABLE)) THEN
  REWRITE_TAC[UNCOUNTABLE_REAL] THEN ASM_MESON_TAC[CARD_EQ_SYM]);

(* ------------------------------------------------------------------------- *)
(* Cardinalities of various useful sets.                                     *)
(* ------------------------------------------------------------------------- *)

val CARD_EQ_EUCLIDEAN = store_thm ("CARD_EQ_EUCLIDEAN",
 ``univ(:real) =_c univ(:real)``,
  REWRITE_TAC [eq_c, IN_UNIV] THEN EXISTS_TAC ``(\x. x:real)`` THEN
  METIS_TAC []);

val UNCOUNTABLE_EUCLIDEAN = store_thm ("UNCOUNTABLE_EUCLIDEAN",
 ``~COUNTABLE univ(:real)``,
  MATCH_MP_TAC CARD_EQ_REAL_IMP_UNCOUNTABLE THEN
  REWRITE_TAC[CARD_EQ_EUCLIDEAN]);

val CARD_EQ_INTERVAL = store_thm ("CARD_EQ_INTERVAL",
 ``(!a b:real. ~(interval(a,b) = {}) ==> (interval[a,b] =_c univ(:real))) /\
   (!a b:real. ~(interval(a,b) = {}) ==> (interval(a,b) =_c univ(:real)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``interval(a:real,b) = {}`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    KNOW_TAC ``univ(:real) <=_c interval(a:real,b) /\
               interval(a:real,b) <=_c interval [(a,b)]`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    SIMP_TAC std_ss [CARD_LE_SUBSET, INTERVAL_OPEN_SUBSET_CLOSED],
    REWRITE_TAC[CARD_LE_UNIV],
    ALL_TAC] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [INTERVAL_NE_EMPTY]) THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP HOMEOMORPHIC_OPEN_INTERVAL_UNIV) THEN
  DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
  MESON_TAC[CARD_EQ_IMP_LE, CARD_EQ_SYM]);

val UNCOUNTABLE_INTERVAL = store_thm ("UNCOUNTABLE_INTERVAL",
 ``(!a b. ~(interval(a,b) = {}) ==> ~COUNTABLE(interval[a,b])) /\
   (!a b. ~(interval(a,b) = {}) ==> ~COUNTABLE(interval(a,b)))``,
  SIMP_TAC std_ss [CARD_EQ_REAL_IMP_UNCOUNTABLE, CARD_EQ_INTERVAL]);

val COUNTABLE_OPEN_INTERVAL = store_thm ("COUNTABLE_OPEN_INTERVAL",
 ``!a b. COUNTABLE(interval(a,b)) <=> (interval(a,b) = {})``,
  MESON_TAC[COUNTABLE_EMPTY, UNCOUNTABLE_INTERVAL]);

val CARD_EQ_OPEN = store_thm ("CARD_EQ_OPEN",
 ``!s:real->bool. open s /\ ~(s = {}) ==> s =_c univ(:real)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_INTERVAL]) THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``c:real``) THEN
    DISCH_THEN(MP_TAC o SPEC ``c:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN
    ASM_CASES_TAC ``interval(a:real,b) = {}`` THEN
    ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN STRIP_TAC THEN
    KNOW_TAC ``univ(:real) <=_c interval[a:real,b] /\
               interval[a:real,b] <=_c s:real->bool`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    ASM_SIMP_TAC std_ss [CARD_LE_SUBSET] THEN MATCH_MP_TAC CARD_EQ_IMP_LE THEN
    ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN ASM_SIMP_TAC std_ss [CARD_EQ_INTERVAL]]);

val UNCOUNTABLE_OPEN = store_thm ("UNCOUNTABLE_OPEN",
 ``!s:real->bool. open s /\ ~(s = {}) ==> ~(COUNTABLE s)``,
  SIMP_TAC std_ss [CARD_EQ_OPEN, CARD_EQ_REAL_IMP_UNCOUNTABLE]);

val CARD_EQ_BALL = store_thm ("CARD_EQ_BALL",
 ``!a:real r. &0 < r ==> ball(a,r) =_c  univ(:real)``,
  SIMP_TAC std_ss [CARD_EQ_OPEN, OPEN_BALL, BALL_EQ_EMPTY, GSYM REAL_NOT_LT]);

val CARD_EQ_CBALL = store_thm ("CARD_EQ_CBALL",
 ``!a:real r. &0 < r ==> cball(a,r) =_c univ(:real)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    KNOW_TAC ``univ(:real) <=_c ball(a:real,r) /\
               ball(a:real,r) <=_c cball (a,r:real)`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    SIMP_TAC std_ss [CARD_LE_SUBSET, BALL_SUBSET_CBALL] THEN
    MATCH_MP_TAC CARD_EQ_IMP_LE THEN
    ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN ASM_SIMP_TAC std_ss [CARD_EQ_BALL]]);

val FINITE_IMP_NOT_OPEN = store_thm ("FINITE_IMP_NOT_OPEN",
 ``!s:real->bool. FINITE s /\ ~(s = {}) ==> ~(open s)``,
  MESON_TAC[UNCOUNTABLE_OPEN, FINITE_IMP_COUNTABLE]);

val OPEN_IMP_INFINITE = store_thm ("OPEN_IMP_INFINITE",
 ``!s. open s ==> (s = {}) \/ INFINITE s``,
  MESON_TAC[FINITE_IMP_NOT_OPEN]);

val EMPTY_INTERIOR_FINITE = store_thm ("EMPTY_INTERIOR_FINITE",
 ``!s:real->bool. FINITE s ==> (interior s = {})``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPEC ``s:real->bool`` OPEN_INTERIOR) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] FINITE_IMP_NOT_OPEN) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``s:real->bool`` THEN
  ASM_REWRITE_TAC[INTERIOR_SUBSET]);

val FINITE_CBALL = store_thm ("FINITE_CBALL",
 ``!a:real r. FINITE(cball(a,r)) <=> r <= &0``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``r < &0:real`` THEN
  ASM_SIMP_TAC std_ss [CBALL_EMPTY, REAL_LT_IMP_LE, FINITE_EMPTY] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN
  ASM_REWRITE_TAC[CBALL_TRIVIAL, FINITE_SING, REAL_LE_REFL] THEN
  EQ_TAC THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  DISCH_THEN(MP_TAC o MATCH_MP EMPTY_INTERIOR_FINITE) THEN
  REWRITE_TAC[INTERIOR_CBALL, BALL_EQ_EMPTY] THEN ASM_REAL_ARITH_TAC);

val FINITE_BALL = store_thm ("FINITE_BALL",
 ``!a:real r. FINITE(ball(a,r)) <=> r <= &0``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``r <= &0:real`` THEN
  ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LT_IMP_LE, FINITE_EMPTY] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (ONCE_REWRITE_RULE[CONJ_EQ_IMP]
        FINITE_IMP_NOT_OPEN)) THEN
  REWRITE_TAC[OPEN_BALL, BALL_EQ_EMPTY] THEN ASM_REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* "Iff" forms of constancy of function from connected set into a set that   *)
(* is smaller than R, or countable, or finite, or disconnected, or discrete. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ",
  ``(!s. connected s <=>
         !f:real->real t.
            f continuous_on s /\ IMAGE f s SUBSET t /\
            (!y. y IN t ==> (connected_component t y = {y}))
            ==> ?a. !x. x IN s ==> (f x = a)) /\
    (!s. connected s <=>
         !f:real->real.
            f continuous_on s /\
            (!x. x IN s
                 ==> ?e. &0 < e /\
                         !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
            ==> ?a. !x. x IN s ==> (f x = a)) /\
    (!s. connected s <=>
         !f:real->real.
            f continuous_on s /\ FINITE(IMAGE f s)
            ==> ?a. !x. x IN s ==> (f x = a))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN X_GEN_TAC ``s:real->bool`` THEN
  MATCH_MP_TAC(TAUT
    `(s ==> t) /\ (t ==> u) /\ (u ==> v) /\ (v ==> s)
     ==> (s <=> t) /\ (s <=> u) /\ (s <=> v)`) THEN
  REPEAT CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
    ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC ``x:real`` o
        REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    EXISTS_TAC ``(f:real->real) x`` THEN
    MATCH_MP_TAC(SET_RULE
     ``IMAGE f s SUBSET {a} ==> !y. y IN s ==> (f y = a)``) THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``(f:real->real) x``) THEN
    KNOW_TAC ``(f:real->real) x IN t`` THENL
    [ASM_SET_TAC [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     DISCH_THEN(SUBST1_TAC o SYM)] THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CONTINUOUS_IMAGE] THEN ASM_SET_TAC [],
    REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC ``IMAGE (f:real->real) s`` THEN
    ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, SUBSET_REFL] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC(SET_RULE
     ``(!y. y IN s /\ f y IN connected_component (IMAGE f s) a ==> (f y = a)) /\
       connected_component (IMAGE f s) a SUBSET (IMAGE f s) /\
       connected_component (IMAGE f s) a a
       ==> (connected_component (IMAGE f s) a = {a})``) THEN
    SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET, CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_SIMP_TAC std_ss [FUN_IN_IMAGE] THEN X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
    MP_TAC(ISPEC ``connected_component (IMAGE (f:real->real) s) (f x)``
        CONNECTED_CLOSED) THEN
    REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    ASM_REWRITE_TAC[] THEN MAP_EVERY EXISTS_TAC
     [``cball((f:real->real) x,e / &2)``,
      ``univ(:real) DIFF ball((f:real->real) x,e)``] THEN
    SIMP_TAC std_ss [GSYM OPEN_CLOSED, OPEN_BALL, CLOSED_CBALL] THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REPEAT CONJ_TAC THENL
     [REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_UNION, IN_DIFF, IN_BALL, IN_UNIV] THEN
      ONCE_REWRITE_TAC [METIS []
       ``(dist (f x,x') <= e / 2 \/ ~(dist (f x,x') < e)) =
         (\x'. dist (f x,x') <= e / 2 \/ ~(dist (f x,x') < e)) x'``] THEN
      MATCH_MP_TAC(MESON[SUBSET_DEF, CONNECTED_COMPONENT_SUBSET]
       ``(!x. x IN s ==> P x)
        ==> (!x. x IN connected_component s y ==> P x)``) THEN
      SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN X_GEN_TAC ``z:real`` THEN
      DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN
      ASM_SIMP_TAC real_ss [dist, REAL_LE_RDIV_EQ] THEN ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC(SET_RULE
       ``(!x. x IN s /\ x IN t ==> F) ==> (s INTER t INTER u = {})``) THEN
      REWRITE_TAC[IN_BALL, IN_CBALL, IN_DIFF, IN_UNIV] THEN
      UNDISCH_TAC ``&0 < e:real`` THEN
      ASM_SIMP_TAC real_ss [dist, REAL_LE_RDIV_EQ] THEN REAL_ARITH_TAC,
      EXISTS_TAC ``(f:real->real) x`` THEN
      ASM_SIMP_TAC std_ss [CENTRE_IN_CBALL, REAL_HALF, REAL_LT_IMP_LE, IN_INTER] THEN
      SIMP_TAC std_ss [SPECIFICATION] THEN
      ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ, FUN_IN_IMAGE],
      EXISTS_TAC ``(f:real->real) y`` THEN
      ASM_REWRITE_TAC[IN_INTER, IN_DIFF, IN_UNIV, IN_BALL, REAL_NOT_LT] THEN
      ASM_SIMP_TAC std_ss [ONCE_REWRITE_RULE[DIST_SYM] dist]],
    DISCH_TAC THEN X_GEN_TAC ``f:real->real`` THEN
    POP_ASSUM (MP_TAC o SPEC ``f:real->real``) THEN
    DISCH_THEN(fn th => STRIP_TAC THEN MATCH_MP_TAC th) THEN
    ASM_REWRITE_TAC[] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    ASM_CASES_TAC ``IMAGE (f:real->real) s DELETE (f x) = {}`` THENL
     [EXISTS_TAC ``&1:real`` THEN REWRITE_TAC[REAL_LT_01] THEN ASM_SET_TAC [],
      ALL_TAC] THEN
    EXISTS_TAC
     ``inf{abs(z - f x) |z| z IN IMAGE (f:real->real) s DELETE (f x)}`` THEN
    SIMP_TAC real_ss [GSYM IMAGE_DEF] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_INF_FINITE, REAL_INF_LE_FINITE, FINITE_DELETE,
                 IMAGE_FINITE, IMAGE_EQ_EMPTY] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE, EXISTS_IN_IMAGE] THEN
    SIMP_TAC real_ss [IN_DELETE, GSYM ABS_NZ, REAL_SUB_0, IN_IMAGE] THEN
    MESON_TAC[REAL_LE_REFL],
    REWRITE_TAC[CONNECTED_CLOSED_IN_EQ] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``t:real->bool``, ``u:real->bool``] THEN
    STRIP_TAC THEN EXISTS_TAC
     ``(\x. if x IN t then 0 else 1:real):real->real`` THEN
    SIMP_TAC std_ss [NOT_IMP] THEN REPEAT CONJ_TAC THENL
     [EXPAND_TAC "s" THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x:real. if x IN t then 0 else 1:real) =
                   (\x. if (\x. x IN t) x then (\x. 0) x else (\x. 1) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CONST] THEN ASM_SET_TAC [],
      MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``{0:real;1:real}`` THEN
      REWRITE_TAC[FINITE_INSERT, FINITE_EMPTY] THEN SET_TAC[],
      SUBGOAL_THEN ``?a b:real. a IN s /\ a IN t /\ b IN s /\ ~(b IN t)``
      STRIP_ASSUME_TAC THENL
       [ASM_SET_TAC [], GEN_TAC] THEN CCONTR_TAC THEN
      POP_ASSUM (MP_TAC o SIMP_RULE std_ss []) THEN
      DISCH_THEN(fn th => MP_TAC(SPEC ``a:real`` th) THEN
                           MP_TAC(SPEC ``b:real`` th)) THEN
      ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC]]);

val CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real t.
            f continuous_on s /\ IMAGE f s SUBSET t /\
            (!y. y IN t ==> (connected_component t y = {y}))
            ==> ?a. !x. x IN s ==> (f x = a))``,
  REWRITE_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real.
            f continuous_on s /\
            (!x. x IN s
                 ==> ?e. &0 < e /\
                         !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
            ==> ?a. !x. x IN s ==> (f x = a)) ``,
  METIS_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_FINITE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_FINITE_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real.
            f continuous_on s /\ FINITE(IMAGE f s)
            ==> ?a. !x. x IN s ==> (f x = a))``,
  METIS_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCONNECTED_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_DISCONNECTED_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\ IMAGE f s SUBSET t /\
        (!y. y IN t ==> (connected_component t y = {y}))
        ==> ?a. !x. x IN s ==> (f x = a)``,
  MESON_TAC[CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCRETE_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_DISCRETE_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\
        (!x. x IN s
             ==> ?e. &0 < e /\
                     !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
        ==> ?a. !x. x IN s ==> (f x = a)``,
  KNOW_TAC ``!s f:real->real.
        connected s /\
        f continuous_on s /\
        (!x. x IN s
             ==> ?e. &0 < e /\
                     !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
        ==> ?a. !x. x IN s ==> (f x = a)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP] THEN
  SIMP_TAC std_ss [AND_IMP_INTRO, GSYM CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_FINITE_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_FINITE_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\
        FINITE(IMAGE f s)
        ==> ?a. !x. x IN s ==> (f x = a)``,
  MESON_TAC[CONTINUOUS_FINITE_RANGE_CONSTANT_EQ]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphism of hyperplanes.                                             *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``~(a = 0)
     ==> {x:real | a * x = b} homeomorphic {x:real | x = &0}``,
    REPEAT STRIP_TAC THEN SUBGOAL_THEN ``?c:real. a * c = b``
    STRIP_ASSUME_TAC THENL
     [EXISTS_TAC ``inv a * b:real`` THEN
      ASM_SIMP_TAC real_ss [REAL_MUL_RINV, REAL_MUL_ASSOC], ALL_TAC] THEN
     REWRITE_TAC [homeomorphic, homeomorphism] THEN
     EXISTS_TAC ``(\x. 0):real->real`` THEN
     EXISTS_TAC ``(\x:real. inv a * b:real)`` THEN
     SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
     SIMP_TAC std_ss [CONTINUOUS_ON_CONST] THEN
     REPEAT STRIP_TAC THENL
     [ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
      ASM_CASES_TAC ``0 < a:real`` THENL
      [ASM_SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN ASM_REAL_ARITH_TAC, ALL_TAC] THEN
      FULL_SIMP_TAC real_ss [REAL_NOT_LT, REAL_LE_LT] THENL [ALL_TAC, METIS_TAC []] THEN
      KNOW_TAC ``a < 0 ==> 0 < -a:real`` THENL [REAL_ARITH_TAC, ASM_REWRITE_TAC []] THEN
      DISCH_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN
      REWRITE_TAC [real_div, REAL_ARITH ``-(a * b) = a * -b:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN
      ASM_SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN ASM_REAL_ARITH_TAC,
      METIS_TAC [],
      ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
      ASM_CASES_TAC ``0 < a:real`` THENL
      [ASM_SIMP_TAC real_ss [REAL_EQ_RDIV_EQ] THEN ASM_REAL_ARITH_TAC, ALL_TAC] THEN
      FULL_SIMP_TAC real_ss [REAL_NOT_LT, REAL_LE_LT] THENL [ALL_TAC, METIS_TAC []] THEN
      KNOW_TAC ``a < 0 ==> 0 < -a:real`` THENL [REAL_ARITH_TAC, ASM_REWRITE_TAC []] THEN
      DISCH_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN
      REWRITE_TAC [real_div, REAL_ARITH ``-(a * b) = a * -b:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN
      ASM_SIMP_TAC real_ss [REAL_EQ_RDIV_EQ] THEN ASM_REAL_ARITH_TAC]);

val HOMEOMORPHIC_HYPERPLANES = store_thm ("HOMEOMORPHIC_HYPERPLANES",
 ``!a:real b c:real d.
        ~(a = 0) /\ ~(c = 0)
        ==> {x | a * x = b} homeomorphic {x | c * x = d}``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_TRANS THEN EXISTS_TAC ``{x:real | x = &0}`` THEN
  ASM_SIMP_TAC std_ss [lemma] THEN ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  ASM_SIMP_TAC std_ss [lemma]);

val HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE = store_thm
  ("HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE",
 ``!a:real b c.
        ~(a = 0)
        ==> {x | a * x = b} homeomorphic {x:real | x = c}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x:real | x = c} = {x | 1 * x = c}`` SUBST1_TAC
  THENL [ASM_SIMP_TAC real_ss [], MATCH_MP_TAC HOMEOMORPHIC_HYPERPLANES] THEN
  ASM_SIMP_TAC real_ss []);

val HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE = store_thm
  ("HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE",
 ``!a:real b c.
        ~(a = 0)
        ==> {x:real | x = c} homeomorphic {x | a * x = b}``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  SIMP_TAC std_ss [HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE]);

(* ------------------------------------------------------------------------- *)
(* "Isometry" (up to constant bounds) of injective linear map etc.           *)
(* ------------------------------------------------------------------------- *)

val CAUCHY_ISOMETRIC = store_thm ("CAUCHY_ISOMETRIC",
 ``!f s e x.
        &0 < e /\ subspace s /\
        linear f /\ (!x. x IN s ==> abs(f x) >= e * abs(x)) /\
        (!n. x(n) IN s) /\ cauchy(f o x)
        ==> cauchy x``,
  REPEAT GEN_TAC THEN REWRITE_TAC[real_ge] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SIMP_TAC std_ss [CAUCHY, dist, o_THM] THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_SUB th)]) THEN
  DISCH_THEN(fn th => X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN MP_TAC th) THEN
  DISCH_THEN(MP_TAC o SPEC ``d * e:real``) THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL] THEN
  METIS_TAC[REAL_LE_RDIV_EQ, REAL_MUL_SYM, REAL_LET_TRANS, SUBSPACE_SUB,
                REAL_LT_LDIV_EQ]);

val COMPLETE_ISOMETRIC_IMAGE = store_thm ("COMPLETE_ISOMETRIC_IMAGE",
 ``!f:real->real s e.
        &0 < e /\ subspace s /\
        linear f /\ (!x. x IN s ==> abs(f x) >= e * abs(x)) /\
        complete s
        ==> complete(IMAGE f s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [complete, EXISTS_IN_IMAGE] THEN
  STRIP_TAC THEN X_GEN_TAC ``g:num->real`` THEN
  SIMP_TAC std_ss [IN_IMAGE, SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` MP_TAC) THEN
  ONCE_REWRITE_TAC [METIS [] ``(!n. g n = f (x n)) = (!n. g n = (\n. f (x n)) n)``] THEN
  GEN_REWR_TAC (LAND_CONV o LAND_CONV) [GSYM FUN_EQ_THM] THEN
  REWRITE_TAC[GSYM o_DEF] THEN
  DISCH_THEN(CONJUNCTS_THEN2 SUBST_ALL_TAC ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN
  ASM_MESON_TAC[CAUCHY_ISOMETRIC, LINEAR_CONTINUOUS_AT,
                CONTINUOUS_AT_SEQUENTIALLY]);

val INJECTIVE_IMP_ISOMETRIC = store_thm ("INJECTIVE_IMP_ISOMETRIC",
 ``!f:real->real s.
        closed s /\ subspace s /\
        linear f /\ (!x. x IN s /\ (f x = 0) ==> (x = 0))
        ==> ?e. &0 < e /\ !x. x IN s ==> abs(f x) >= e * abs(x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s SUBSET {0 :real}`` THENL
   [EXISTS_TAC ``&1:real`` THEN REWRITE_TAC[REAL_LT_01, REAL_MUL_LID, real_ge] THEN
    ASM_MESON_TAC[SUBSET_DEF, IN_SING, ABS_0, LINEAR_0, REAL_LE_REFL],
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, IN_SING] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL
   [``{(f:real->real) x | x IN s /\ (abs(x) = abs(a:real))}``,
    ``0:real``] DISTANCE_ATTAINS_INF) THEN
  KNOW_TAC ``closed {(f:real->real) x | x IN s /\ (abs x = abs a)} /\
   {f x | x IN s /\ (abs x = abs a)} <> {}`` THENL
   [SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, GSPECIFICATION] THEN
    CONJ_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
    MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
    SUBST1_TAC(SET_RULE
     ``{f x | x IN s /\ (abs(x) = abs(a:real))} =
       IMAGE (f:real->real) (s INTER {x | abs x = abs a})``) THEN
    MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
    ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON] THEN
    MATCH_MP_TAC CLOSED_INTER_COMPACT THEN ASM_REWRITE_TAC[] THEN
    SUBGOAL_THEN
     ``{x:real | abs x = abs(a:real)} = frontier(cball(0,abs a))``
    SUBST1_TAC THENL
     [ASM_SIMP_TAC real_ss [FRONTIER_CBALL, GSYM ABS_NZ, dist, REAL_SUB_LZERO,
                   ABS_NEG, sphere],
      ASM_SIMP_TAC std_ss [COMPACT_FRONTIER, COMPACT_CBALL]],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``{(f:real->real) x | x IN s /\ (abs x = abs a)} =
                          {f x | (\x. x IN s /\ (abs x = abs a)) x}``] THEN
  ONCE_REWRITE_TAC[SET_RULE ``{f x | P x} = IMAGE f {x | P x}``] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, EXISTS_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real`` MP_TAC) THEN
  SIMP_TAC std_ss [GSPECIFICATION, dist, REAL_SUB_LZERO, ABS_NEG] THEN
  STRIP_TAC THEN SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE] THEN
  EXISTS_TAC ``abs((f:real->real) b) / abs(b)`` THEN CONJ_TAC THENL
   [ASM_MESON_TAC[REAL_LT_DIV, GSYM ABS_NZ, ABS_ZERO], ALL_TAC] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``x:real = 0`` THENL
   [FIRST_ASSUM(fn th => ASM_REWRITE_TAC[MATCH_MP LINEAR_0 th]) THEN
    REWRITE_TAC[ABS_0, REAL_MUL_RZERO, real_ge, REAL_LE_REFL],
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(abs(a:real) / abs(x)) * x:real``) THEN
  KNOW_TAC ``abs a / abs x * x IN s /\ (abs (abs a / abs x * x) = abs a:real)`` THENL
   [KNOW_TAC ``(abs x <> 0:real) /\ (abs a <> 0:real)`` THENL
    [UNDISCH_TAC ``a <> 0:real`` THEN POP_ASSUM MP_TAC THEN
     REAL_ARITH_TAC, STRIP_TAC] THEN
    ASM_SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS] THEN
    FULL_SIMP_TAC std_ss [subspace] THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL, ABS_ZERO],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  UNDISCH_TAC ``linear f`` THEN DISCH_TAC THEN
  FIRST_ASSUM(fn th => SIMP_TAC std_ss [MATCH_MP LINEAR_CMUL th]) THEN
  KNOW_TAC ``(abs x <> 0:real) /\ (abs a <> 0:real)`` THENL
    [UNDISCH_TAC ``a <> 0:real`` THEN UNDISCH_TAC ``x <> 0:real`` THEN
     REAL_ARITH_TAC, STRIP_TAC] THEN
  ASM_SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS, real_ge] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ, GSYM ABS_NZ] THEN
  SIMP_TAC std_ss [real_div, REAL_MUL_ASSOC] THEN REAL_ARITH_TAC);

val CLOSED_INJECTIVE_IMAGE_SUBSPACE = store_thm ("CLOSED_INJECTIVE_IMAGE_SUBSPACE",
 ``!f s. subspace s /\
         linear f /\
         (!x. x IN s /\ (f(x) = 0) ==> (x = 0)) /\
         closed s
         ==> closed(IMAGE f s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM COMPLETE_EQ_CLOSED] THEN
  MATCH_MP_TAC COMPLETE_ISOMETRIC_IMAGE THEN
  ASM_SIMP_TAC std_ss [COMPLETE_EQ_CLOSED] THEN
  MATCH_MP_TAC INJECTIVE_IMP_ISOMETRIC THEN
  ASM_REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Relating linear images to open/closed/interior/closure.                   *)
(* ------------------------------------------------------------------------- *)

val OPEN_SURJECTIVE_LINEAR_IMAGE = store_thm ("OPEN_SURJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!y. ?x. f x = y)
        ==> !s. open s ==> open(IMAGE f s)``,
  GEN_TAC THEN STRIP_TAC THEN
  SIMP_TAC std_ss [open_def, FORALL_IN_IMAGE] THEN
  FIRST_ASSUM(MP_TAC o GEN ``k:num`` o SPEC ``if (1 = k:num) then &1 else &0:real``) THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:num->real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``bounded(IMAGE (b:num->real) ((1:num)..(1:num)))`` MP_TAC THENL
   [SIMP_TAC std_ss [FINITE_IMP_BOUNDED, IMAGE_FINITE, FINITE_NUMSEG], ALL_TAC] THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE, IN_NUMSEG] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  X_GEN_TAC ``s:real->bool`` THEN DISCH_TAC THEN
  X_GEN_TAC ``x:real`` THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e / B / &(1):real`` THEN
  ASM_SIMP_TAC real_ss [REAL_LT_DIV, REAL_LT, LE_1] THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_IMAGE] THEN
  ABBREV_TAC ``u = y - (f:real->real) x`` THEN
  EXISTS_TAC ``x + sum(1 .. 1) (\i. (u:real) * b i):real`` THEN
  ASM_SIMP_TAC std_ss [LINEAR_ADD, LINEAR_SUM, FINITE_NUMSEG, o_DEF,
               LINEAR_CMUL] THEN
  CONJ_TAC THENL [EXPAND_TAC "u" THEN SIMP_TAC std_ss [NUMSEG_SING, SUM_SING] THEN
                  REAL_ARITH_TAC, ALL_TAC] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC [dist] THEN
  REWRITE_TAC[REAL_ARITH ``abs(x + y - x) = abs y:real``] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``(dist(y,(f:real->real) x) * &(1)) * B:real`` THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LT_RDIV_EQ, REAL_LT, LE_1] THEN
  MATCH_MP_TAC SUM_ABS_TRIANGLE THEN REWRITE_TAC[FINITE_NUMSEG] THEN
  EXPAND_TAC "u" THEN SIMP_TAC std_ss [NUMSEG_SING, SUM_SING] THEN
  REWRITE_TAC [ABS_MUL] THEN
  UNDISCH_TAC ``!x. 1 <= x /\ x <= 1 ==> abs ((b:num->real) x) <= B`` THEN
  DISCH_THEN (MP_TAC o SPEC ``1:num``) THEN ASM_SIMP_TAC real_ss [dist] THEN
  DISCH_TAC THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
  ASM_SIMP_TAC std_ss [ABS_POS]);

val OPEN_BIJECTIVE_LINEAR_IMAGE_EQ = store_thm ("OPEN_BIJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y)) /\ (!y. ?x. f x = y)
        ==> (open(IMAGE f s) <=> open s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_TAC, ASM_MESON_TAC[OPEN_SURJECTIVE_LINEAR_IMAGE]] THEN
  SUBGOAL_THEN ``s = {x | (f:real->real) x IN IMAGE f s}``
  SUBST1_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE_UNIV THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_AT]);

val CLOSED_INJECTIVE_LINEAR_IMAGE = store_thm ("CLOSED_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> !s. closed s ==> closed(IMAGE f s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_LEFT_INVERSE) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC CLOSED_IN_CLOSED_TRANS THEN
  EXISTS_TAC ``IMAGE (f:real->real) univ(:real)`` THEN
  CONJ_TAC THENL
   [MP_TAC(ISPECL [``g:real->real``, ``IMAGE (f:real->real) univ(:real)``,
                   ``IMAGE (g:real->real) (IMAGE (f:real->real) s)``]
        CONTINUOUS_CLOSED_IN_PREIMAGE) THEN
    ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON] THEN
    KNOW_TAC ``closed (IMAGE (g:real->real) (IMAGE (f:real->real) s))`` THENL
     [ASM_REWRITE_TAC[GSYM IMAGE_COMPOSE, IMAGE_ID],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [FUN_EQ_THM]) THEN
    SIMP_TAC std_ss [EXTENSION, o_THM, I_THM] THEN SET_TAC[],
    MATCH_MP_TAC CLOSED_INJECTIVE_IMAGE_SUBSPACE THEN
    ASM_REWRITE_TAC[IN_UNIV, SUBSPACE_UNIV, CLOSED_UNIV] THEN
    X_GEN_TAC ``x:real`` THEN
    DISCH_THEN(MP_TAC o AP_TERM ``g:real->real``) THEN
    RULE_ASSUM_TAC(SIMP_RULE std_ss [FUN_EQ_THM, I_THM, o_THM]) THEN
    ASM_MESON_TAC[LINEAR_0]]);

val CLOSED_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("CLOSED_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (closed(IMAGE f s) <=> closed s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_TAC, ASM_MESON_TAC[CLOSED_INJECTIVE_LINEAR_IMAGE]] THEN
  SUBGOAL_THEN ``s = {x | (f:real->real) x IN IMAGE f s}``
  SUBST1_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE_UNIV THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_AT]);

val CLOSURE_LINEAR_IMAGE_SUBSET = store_thm ("CLOSURE_LINEAR_IMAGE_SUBSET",
 ``!f:real->real s.
        linear f ==> IMAGE f (closure s) SUBSET closure(IMAGE f s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC IMAGE_CLOSURE_SUBSET THEN
  ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, CLOSURE_SUBSET, LINEAR_CONTINUOUS_ON]);

val CLOSURE_INJECTIVE_LINEAR_IMAGE  = store_thm ("CLOSURE_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_SIMP_TAC std_ss [CLOSURE_LINEAR_IMAGE_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
  ASM_MESON_TAC[CLOSED_INJECTIVE_LINEAR_IMAGE, CLOSED_CLOSURE]);

val CLOSURE_BOUNDED_LINEAR_IMAGE = store_thm ("CLOSURE_BOUNDED_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ bounded s
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_SIMP_TAC std_ss [CLOSURE_LINEAR_IMAGE_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
  MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_LINEAR_IMAGE THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE]);

val LINEAR_INTERIOR_IMAGE_SUBSET = store_thm ("LINEAR_INTERIOR_IMAGE_SUBSET",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
       ==> interior(IMAGE f s) SUBSET IMAGE f (interior s)``,
  MESON_TAC[INTERIOR_IMAGE_SUBSET, LINEAR_CONTINUOUS_AT]);

val LINEAR_IMAGE_SUBSET_INTERIOR = store_thm ("LINEAR_IMAGE_SUBSET_INTERIOR",
 ``!f:real->real s.
        linear f /\ (!y. ?x. f x = y)
        ==> IMAGE f (interior s) SUBSET interior(IMAGE f s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_MAXIMAL THEN
  ASM_SIMP_TAC std_ss [OPEN_SURJECTIVE_LINEAR_IMAGE, OPEN_INTERIOR,
               IMAGE_SUBSET, INTERIOR_SUBSET]);

val INTERIOR_BIJECTIVE_LINEAR_IMAGE = store_thm ("INTERIOR_BIJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y)) /\ (!y. ?x. f x = y)
        ==> (interior(IMAGE f s) = IMAGE f (interior s))``,
  ONCE_REWRITE_TAC [GSYM SURJECTIVE_IMAGE] THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC [interior] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
   STRIP_TAC THEN UNDISCH_TAC ``(t:real->bool) SUBSET IMAGE (f:real->real) s`` THEN
   DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SIMP_RULE std_ss [SUBSET_DEF, IN_IMAGE]) THEN
   DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
   EXISTS_TAC ``x':real`` THEN ASM_REWRITE_TAC [] THEN EXISTS_TAC ``s':real->bool`` THEN
   REPEAT CONJ_TAC THENL
   [UNDISCH_TAC ``open t`` THEN MATCH_MP_TAC EQ_IMPLIES THEN
    EXPAND_TAC "t" THEN MATCH_MP_TAC OPEN_BIJECTIVE_LINEAR_IMAGE_EQ THEN
    METIS_TAC [SURJECTIVE_IMAGE],
    UNDISCH_TAC ``IMAGE (f:real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``(f:real->real) x'``) THEN SIMP_TAC std_ss [IN_IMAGE] THEN
    METIS_TAC [],
    REWRITE_TAC [SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``IMAGE (f:real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``(f:real->real) y``) THEN REWRITE_TAC [IN_IMAGE] THEN
    KNOW_TAC ``(?x. (f y = (f:real->real) x) /\ x IN s')`` THENL
    [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN UNDISCH_TAC ``t SUBSET IMAGE (f:real->real) s`` THEN
    REWRITE_TAC [SUBSET_DEF] THEN DISCH_THEN (MP_TAC o SPEC ``(f:real->real) y``) THEN
    ASM_REWRITE_TAC [] THEN REWRITE_TAC [IN_IMAGE] THEN STRIP_TAC THEN
    METIS_TAC []], ALL_TAC] THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
  STRIP_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
  STRIP_TAC THEN EXISTS_TAC ``IMAGE (f:real->real) t`` THEN
  REPEAT CONJ_TAC THENL
  [UNDISCH_TAC ``open t`` THEN MATCH_MP_TAC OPEN_SURJECTIVE_LINEAR_IMAGE THEN
   METIS_TAC [SURJECTIVE_IMAGE],
   REWRITE_TAC [IN_IMAGE] THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [],
   MATCH_MP_TAC IMAGE_SUBSET THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* Corollaries, reformulations and special cases for M = N.                  *)
(* ------------------------------------------------------------------------- *)

val IN_INTERIOR_LINEAR_IMAGE = store_thm ("IN_INTERIOR_LINEAR_IMAGE",
 ``!f:real->real g s x.
        linear f /\ linear g /\ (f o g = I) /\ x IN interior s
        ==> (f x) IN interior (IMAGE f s)``,
  SIMP_TAC std_ss [FUN_EQ_THM, o_THM, I_THM] THEN REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``]
    LINEAR_IMAGE_SUBSET_INTERIOR) THEN
  ASM_SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  ASM_MESON_TAC[]);

val LINEAR_OPEN_MAPPING = store_thm ("LINEAR_OPEN_MAPPING",
 ``!f:real->real g.
        linear f /\ linear g /\ (f o g = I)
        ==> !s. open s ==> open(IMAGE f s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM, o_THM, I_THM] THEN DISCH_TAC THEN
  MATCH_MP_TAC OPEN_SURJECTIVE_LINEAR_IMAGE THEN
  ASM_MESON_TAC[]);

val INTERIOR_INJECTIVE_LINEAR_IMAGE = store_thm ("INTERIOR_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (interior(IMAGE f s) = IMAGE f (interior s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_BIJECTIVE_LINEAR_IMAGE THEN
  METIS_TAC[LINEAR_INJECTIVE_IMP_SURJECTIVE]);

val COMPLETE_INJECTIVE_LINEAR_IMAGE = store_thm ("COMPLETE_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> !s. complete s ==> complete(IMAGE f s)``,
  REWRITE_TAC[COMPLETE_EQ_CLOSED, CLOSED_INJECTIVE_LINEAR_IMAGE]);

val COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (complete(IMAGE f s) <=> complete s)``,
  REWRITE_TAC[COMPLETE_EQ_CLOSED, CLOSED_INJECTIVE_LINEAR_IMAGE_EQ]);

val LIMPT_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("LIMPT_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> ((f x) limit_point_of (IMAGE f s) <=> x limit_point_of s)``,
  SIMP_TAC std_ss [LIMPT_APPROACHABLE, EXISTS_IN_IMAGE] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THENL
   [MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_BOUNDED_BELOW_POS),
    MP_TAC(ISPEC ``f:real->real`` LINEAR_BOUNDED_POS)] THEN
  ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THENL
   [UNDISCH_TAC ``!(e :real).
        (0 :real) < e ==>
        ?(x' :real).
          x' IN (s :real -> bool) /\
          (f :real -> real) x' <> f (x :real) /\
          (dist (f x',f x) :real) < e`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e * B:real``),
    UNDISCH_TAC ``!(e :real).
        (0 :real) < e ==>
        ?(x' :real).
          x' IN (s :real -> bool) /\ x' <> (x :real) /\
          (dist (x',x) :real) < e`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``e / B:real``)] THEN
  ASM_SIMP_TAC real_ss [REAL_LT_DIV, REAL_LT_MUL, dist, GSYM LINEAR_SUB] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
  POP_ASSUM MP_TAC THEN
  REPEAT(MATCH_MP_TAC MONO_AND THEN
         CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC]) THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ] THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> b < x ==> a < x:real``) THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_SIMP_TAC real_ss [REAL_LE_RDIV_EQ]);

(* ------------------------------------------------------------------------- *)
(* Even more special cases.                                                  *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_NEGATIONS = store_thm ("INTERIOR_NEGATIONS",
 ``!s. interior(IMAGE (\x. -x) s) = IMAGE (\x. -x) (interior s)``,
  GEN_TAC THEN MATCH_MP_TAC INTERIOR_INJECTIVE_LINEAR_IMAGE THEN
  SIMP_TAC std_ss [linear] THEN REPEAT CONJ_TAC THEN REAL_ARITH_TAC);

val SYMMETRIC_INTERIOR = store_thm ("SYMMETRIC_INTERIOR",
 ``!s:real->bool.
        (!x. x IN s ==> -x IN s)
        ==> !x. x IN interior s ==> (-x) IN interior s``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP(ISPEC ``(\x. -x):real->real`` FUN_IN_IMAGE)) THEN
  SIMP_TAC std_ss [GSYM INTERIOR_NEGATIONS] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE] THEN METIS_TAC[REAL_NEG_NEG]);

val CLOSURE_NEGATIONS = store_thm ("CLOSURE_NEGATIONS",
 ``!s. closure(IMAGE (\x. -x) s) = IMAGE (\x. -x) (closure s)``,
  GEN_TAC THEN MATCH_MP_TAC CLOSURE_INJECTIVE_LINEAR_IMAGE THEN
  SIMP_TAC std_ss [linear] THEN REPEAT CONJ_TAC THEN REAL_ARITH_TAC);

val SYMMETRIC_CLOSURE = store_thm ("SYMMETRIC_CLOSURE",
 ``!s:real->bool.
        (!x. x IN s ==> -x IN s)
        ==> !x. x IN closure s ==> (-x) IN closure s``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP(ISPEC ``(\x. -x):real->real`` FUN_IN_IMAGE)) THEN
  SIMP_TAC std_ss [GSYM CLOSURE_NEGATIONS] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE] THEN ASM_MESON_TAC[REAL_NEG_NEG]);

(* ------------------------------------------------------------------------- *)
(* Some properties of a canonical subspace.                                  *)
(* ------------------------------------------------------------------------- *)

val SUBSPACE_SUBSTANDARD = store_thm ("SUBSPACE_SUBSTANDARD",
 ``subspace {x:real | (x = &0)}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION, REAL_MUL_RZERO, REAL_ADD_LID]);

val CLOSED_SUBSTANDARD = store_thm ("CLOSED_SUBSTANDARD",
 ``closed {x:real | x = &0}``,
  REWRITE_TAC [GSPEC_EQ, CLOSED_SING]);

val DIM_SUBSTANDARD = store_thm ("DIM_SUBSTANDARD",
  ``dim {x:real | x = &0} = 0``,
  REWRITE_TAC [dim, GSPEC_EQ] THEN MATCH_MP_TAC SELECT_UNIQUE THEN
  RW_TAC std_ss [] THEN EQ_TAC THENL
  [ONCE_REWRITE_TAC [MONO_NOT_EQ] THEN RW_TAC std_ss [] THEN
   ASM_CASES_TAC ``~(b SUBSET {0:real})`` THEN
   ASM_REWRITE_TAC [] THEN FULL_SIMP_TAC std_ss [SET_RULE
    ``b SUBSET {0:real} <=> (b = {}) \/ (b = {0})``] THENL
   [DISJ2_TAC THEN DISJ2_TAC THEN SIMP_TAC std_ss [HAS_SIZE] THEN
    DISJ2_TAC THEN REWRITE_TAC [CARD_EMPTY] THEN METIS_TAC [],
    REWRITE_TAC [INDEPENDENT_SING]], ALL_TAC] THEN
  DISCH_TAC THEN EXISTS_TAC ``{}:real->bool`` THEN
  ASM_SIMP_TAC std_ss [SPAN_EMPTY, SUBSET_REFL, EMPTY_SUBSET, INDEPENDENT_EMPTY] THEN
  ASM_REWRITE_TAC [HAS_SIZE_0]);

(* ------------------------------------------------------------------------- *)
(* Affine transformations of intervals.                                      *)
(* ------------------------------------------------------------------------- *)

val AFFINITY_INVERSES = store_thm ("AFFINITY_INVERSES",
 ``!m c. ~(m = &0:real)
         ==> ((\x. m * x + c) o (\x. inv(m) * x + (-(inv(m) * c))) = (\x. x)) /\
             ((\x. inv(m) * x + (-(inv(m) * c))) o (\x. m * x + c) = (\x. x))``,
  SIMP_TAC std_ss [FUN_EQ_THM, o_THM] THEN
  SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_RNEG] THEN
  SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_RINV] THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val REAL_AFFINITY_LE = store_thm ("REAL_AFFINITY_LE",
 ``!m c x y. &0:real < m ==> ((m * x + c <= y) <=> (x <= inv(m) * y + -(c / m)))``,
  REWRITE_TAC[REAL_ARITH ``(m * x + c <= y:real) <=> (x * m <= y - c)``] THEN
  SIMP_TAC std_ss [GSYM REAL_LE_RDIV_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, REAL_SUB_RDISTRIB]);

val REAL_LE_AFFINITY = store_thm ("REAL_LE_AFFINITY",
 ``!m c x y. &0:real < m ==> ((y <= m * x + c) <=> (inv(m) * y + -(c / m) <= x))``,
  REWRITE_TAC[REAL_ARITH ``(y <= m * x + c:real) <=> (y - c <= x * m)``] THEN
  SIMP_TAC std_ss [GSYM REAL_LE_LDIV_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, REAL_SUB_RDISTRIB]);

val REAL_AFFINITY_LT = store_thm ("REAL_AFFINITY_LT",
 ``!m c x y. &0:real < m ==> (m * x + c < y <=> x < inv(m) * y + -(c / m))``,
  SIMP_TAC std_ss [REAL_LE_AFFINITY, GSYM REAL_NOT_LE]);

val REAL_LT_AFFINITY = store_thm ("REAL_LT_AFFINITY",
 ``!m c x y. &0:real < m ==> (y < m * x + c <=> inv(m) * y + -(c / m) < x)``,
  SIMP_TAC std_ss [REAL_AFFINITY_LE, GSYM REAL_NOT_LE]);

val REAL_AFFINITY_EQ = store_thm ("REAL_AFFINITY_EQ",
 ``!m c x y. ~(m = &0:real) ==> ((m * x + c = y) <=> (x = inv(m) * y + -(c / m)))``,
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, GSYM REAL_SUB_RDISTRIB] THEN
  REWRITE_TAC [GSYM REAL_EQ_SUB_LADD, GSYM real_div] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN
   ASM_SIMP_TAC arith_ss [real_div, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_MUL_RID], DISCH_TAC THEN METIS_TAC [REAL_DIV_RMUL]]);

val REAL_EQ_AFFINITY = store_thm ("REAL_EQ_AFFINITY",
 ``!m c x y. ~(m = &0:real) ==> ((y = m * x + c)  <=> (inv(m) * y + -(c / m) = x))``,
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, GSYM REAL_SUB_RDISTRIB] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
  REWRITE_TAC [GSYM REAL_EQ_SUB_LADD, GSYM real_div] THEN EQ_TAC THENL
  [GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN
   ASM_SIMP_TAC arith_ss [real_div, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_MUL_RID], DISCH_TAC THEN METIS_TAC [REAL_DIV_RMUL]]);

val IMAGE_AFFINITY_INTERVAL = store_thm ("IMAGE_AFFINITY_INTERVAL",
 ``!a b:real m c.
        IMAGE (\x. m * x + c) (interval[a,b]) =
            if interval[a,b] = {} then {}
            else if &0 <= m then interval[m * a + c,m * b + c]
            else interval[m * b + c,m * a + c]``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_CASES_TAC ``m = &0:real`` THEN ASM_REWRITE_TAC[REAL_LE_LT] THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO, REAL_ADD_LID, COND_ID] THEN
    REWRITE_TAC[INTERVAL_SING] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP (REAL_ARITH
   ``~(x = &0:real) ==> &0 < x \/ &0 < -x``)) THEN
  ASM_SIMP_TAC std_ss [EXTENSION, IN_IMAGE, REAL_ARITH ``&0 < -x ==> ~(&0 < x:real)``] THENL
   [ALL_TAC,
    ONCE_REWRITE_TAC[REAL_ARITH ``(x = m * y + c:real) <=> (c = (-m) * y + x)``]] THEN
  (ASM_SIMP_TAC std_ss [REAL_EQ_AFFINITY, REAL_LT_IMP_NE, UNWIND_THM1] THEN
  SIMP_TAC std_ss [IN_INTERVAL] THEN
  POP_ASSUM(MP_TAC o ONCE_REWRITE_RULE [GSYM REAL_LT_INV_EQ]) THEN
  SIMP_TAC std_ss [REAL_AFFINITY_LE, REAL_LE_AFFINITY, real_div] THEN
  DISCH_THEN(K ALL_TAC) THEN REWRITE_TAC[REAL_INV_INV] THEN
  REWRITE_TAC[REAL_MUL_LNEG, REAL_NEGNEG] THEN
  KNOW_TAC ``-m <> 0:real`` THENL [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN
  ASM_SIMP_TAC std_ss [METIS [REAL_MUL_RID, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_ARITH ``b * inv a * a = b * a * inv a:real``]
   ``m <> 0:real ==> (x * inv m * m = x)``] THEN
  GEN_TAC THEN ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN REWRITE_TAC [GSYM real_sub] THEN
  REAL_ARITH_TAC));

(* ------------------------------------------------------------------------- *)
(* Infinite sums of vectors. Allow general starting point (and more).        *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "sums" (Infix(NONASSOC, 450));

val _ = hide "sums";
val _ = hide "summable";

val sums = new_definition ("sums",
  ``(f sums l) s = ((\n. sum (s INTER ((0:num)..n)) f) --> l) sequentially``);

val infsum = new_definition ("infsum",
 ``infsum s f = @l. (f sums l) s``);

val summable = new_definition ("summable",
 ``summable s f = ?l. (f sums l) s``);

val SUMS_SUMMABLE = store_thm ("SUMS_SUMMABLE",
 ``!f l s. (f sums l) s ==> summable s f``,
  REWRITE_TAC[summable] THEN MESON_TAC[]);

val SUMS_INFSUM = store_thm ("SUMS_INFSUM",
 ``!f s. (f sums (infsum s f)) s <=> summable s f``,
  REWRITE_TAC[infsum, summable] THEN METIS_TAC[]);

val SUMS_LIM = store_thm ("SUMS_LIM",
 ``!f:num->real s.
      (f sums lim sequentially (\n. sum (s INTER ((0:num)..n)) f)) s
      <=> summable s f``,
  GEN_TAC THEN GEN_TAC THEN EQ_TAC THENL [MESON_TAC[summable],
  REWRITE_TAC[summable, sums] THEN STRIP_TAC THEN REWRITE_TAC[lim_def] THEN
  METIS_TAC[]]);

val FINITE_INTER_NUMSEG = store_thm ("FINITE_INTER_NUMSEG",
 ``!s m n. FINITE(s INTER (m..n))``,
  MESON_TAC[SUBSET_FINITE_I, FINITE_NUMSEG, INTER_SUBSET]);

val SERIES_FROM = store_thm ("SERIES_FROM",
 ``!f l k. (f sums l) (from k) = ((\n. sum(k..n) f) --> l) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, numseg, from_def, GSPECIFICATION, IN_INTER] THEN ARITH_TAC);

val SERIES_UNIQUE = store_thm ("SERIES_UNIQUE",
 ``!f:num->real l l' s. (f sums l) s /\ (f sums l') s ==> (l = l')``,
  REWRITE_TAC[sums] THEN MESON_TAC[TRIVIAL_LIMIT_SEQUENTIALLY, LIM_UNIQUE]);

val INFSUM_UNIQUE = store_thm ("INFSUM_UNIQUE",
 ``!f:num->real l s. (f sums l) s ==> (infsum s f = l)``,
  MESON_TAC[SERIES_UNIQUE, SUMS_INFSUM, summable]);

val SERIES_TERMS_TOZERO = store_thm ("SERIES_TERMS_TOZERO",
 ``!f l n. (f sums l) (from n) ==> (f --> 0) sequentially``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [sums, LIM_SEQUENTIALLY, FROM_INTER_NUMSEG] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
  EXISTS_TAC ``N + n + 1:num`` THEN X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``m - 1:num`` th) THEN MP_TAC(SPEC ``m:num`` th)) THEN
  SUBGOAL_THEN ``0 < m:num /\ n <= m`` (fn th => SIMP_TAC std_ss [SUM_CLAUSES_RIGHT, th])
  THENL [CONJ_TAC THENL
   [MATCH_MP_TAC LESS_LESS_EQ_TRANS THEN EXISTS_TAC ``N + n + 1:num`` THEN
    ASM_REWRITE_TAC [] THEN ARITH_TAC,
    MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``N + n + 1:num`` THEN
    ASM_REWRITE_TAC [] THEN ARITH_TAC], ALL_TAC] THEN
  KNOW_TAC ``N <= m:num`` THENL [MATCH_MP_TAC LESS_EQ_TRANS THEN
   EXISTS_TAC ``N + n + 1:num`` THEN ASM_REWRITE_TAC [] THEN ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  KNOW_TAC ``N <= m:num - 1`` THENL [MATCH_MP_TAC LESS_EQ_TRANS THEN
   EXISTS_TAC ``N + n:num`` THEN CONJ_TAC THENL [ARITH_TAC, ALL_TAC] THEN
   ONCE_REWRITE_TAC [ARITH_PROVE ``(a <= b) = (a + 1 <= b + 1:num)``] THEN
   MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``m:num`` THEN
   ASM_REWRITE_TAC [] THEN ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  REWRITE_TAC [DIST_0] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  FULL_SIMP_TAC std_ss [dist] THEN ASM_REAL_ARITH_TAC);

val SERIES_FINITE = store_thm ("SERIES_FINITE",
 ``!f s. FINITE s ==> (f sums (sum s f)) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [num_FINITE, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``n:num`` THEN SIMP_TAC std_ss [sums, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``n:num`` THEN
  X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``s INTER ((0:num)..m) = s``
   (fn th => ASM_REWRITE_TAC[th, DIST_REFL]) THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTER, IN_NUMSEG, ZERO_LESS_EQ] THEN
  METIS_TAC[LESS_EQ_TRANS]);

val SERIES_LINEAR = store_thm ("SERIES_LINEAR",
 ``!f h l s. (f sums l) s /\ linear h ==> ((\n. h(f n)) sums h l) s``,
  SIMP_TAC std_ss [sums, LIM_LINEAR, FINITE_INTER, FINITE_NUMSEG,
           GSYM(REWRITE_RULE[o_DEF] LINEAR_SUM)]);

val SERIES_0 = store_thm ("SERIES_0",
 ``!s. ((\n. 0) sums (0)) s``,
  REWRITE_TAC[sums, SUM_0, LIM_CONST]);

val SERIES_ADD = store_thm ("SERIES_ADD",
 ``!x x0 y y0 s.
     (x sums x0) s /\ (y sums y0) s ==> ((\n. x n + y n) sums (x0 + y0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_ADD, LIM_ADD]);

val SERIES_SUB = store_thm ("SERIES_SUB",
 ``!x x0 y y0 s.
     (x sums x0) s /\ (y sums y0) s ==> ((\n. x n - y n) sums (x0 - y0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_SUB, LIM_SUB]);

val SERIES_CMUL = store_thm ("SERIES_CMUL",
 ``!x x0 c s. (x sums x0) s ==> ((\n. c * x n) sums (c * x0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_LMUL, LIM_CMUL]);

val SERIES_NEG = store_thm ("SERIES_NEG",
 ``!x x0 s. (x sums x0) s ==> ((\n. -(x n)) sums (-x0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_NEG, LIM_NEG]);

val SUMS_IFF = store_thm ("SUMS_IFF",
 ``!f g k. (!x. x IN k ==> (f x = g x)) ==> ((f sums l) k <=> (g sums l) k)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  MATCH_MP_TAC SUM_EQ THEN ASM_SIMP_TAC std_ss [IN_INTER]);

val SUMS_EQ = store_thm ("SUMS_EQ",
 ``!f g k. (!x. x IN k ==> (f x = g x)) /\ (f sums l) k ==> (g sums l) k``,
  MESON_TAC[SUMS_IFF]);

val SUMS_0 = store_thm ("SUMS_0",
 ``!f:num->real s. (!n. n IN s ==> (f n = 0)) ==> (f sums 0) s``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMS_EQ THEN
  EXISTS_TAC ``\n:num. 0:real`` THEN ASM_SIMP_TAC std_ss [SERIES_0]);

val SERIES_FINITE_SUPPORT = store_thm ("SERIES_FINITE_SUPPORT",
 ``!f:num->real s k.
     FINITE (s INTER k) /\ (!x. x IN k /\ ~(x IN s) ==> (f x = 0))
     ==> (f sums sum (s INTER k) f) k``,
  REWRITE_TAC[sums, LIM_SEQUENTIALLY] THEN REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``\x:num. x`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN
  EXISTS_TAC ``N:num`` THEN POP_ASSUM MP_TAC THEN
  STRIP_TAC THEN X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``sum (k INTER ((0:num)..n)) (f:num->real) = sum(s INTER k) f``
   (fn th => ASM_SIMP_TAC std_ss [DIST_REFL, th]) THEN
  MATCH_MP_TAC SUM_SUPERSET THEN
  ASM_SIMP_TAC std_ss [SUBSET_DEF, IN_INTER, IN_NUMSEG, ZERO_LESS_EQ] THEN
  METIS_TAC[IN_INTER, LESS_EQ_TRANS]);

val SERIES_COMPONENT = store_thm ("SERIES_COMPONENT",
 ``!f s l:real. (f sums l) s
          ==> ((\i. f(i)) sums l) s``,
  METIS_TAC []);

val SERIES_DIFFS = store_thm ("SERIES_DIFFS",
 ``!f:num->real k. (f --> 0) sequentially
        ==> ((\n. f(n) - f(n + 1)) sums f(k)) (from k)``,
  REWRITE_TAC[sums, FROM_INTER_NUMSEG, SUM_DIFFS] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC ``\n. (f:num->real) k - f(n + 1)`` THEN CONJ_TAC THENL
   [REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC ``k:num`` THEN
    SIMP_TAC std_ss [],
    GEN_REWR_TAC LAND_CONV [GSYM REAL_SUB_RZERO] THEN
    KNOW_TAC ``((\n. (\n. f k) n - (\n. f (n + 1)) n)
                   --> ((f:num->real) k - 0)) sequentially`` THENL
    [ALL_TAC, SIMP_TAC std_ss []] THEN
    MATCH_MP_TAC LIM_SUB THEN REWRITE_TAC[LIM_CONST] THEN
    MATCH_MP_TAC SEQ_OFFSET THEN ASM_REWRITE_TAC[]]);

val SERIES_TRIVIAL = store_thm ("SERIES_TRIVIAL",
 ``!f. (f sums 0) {}``,
  SIMP_TAC std_ss [sums, INTER_EMPTY, SUM_CLAUSES, LIM_CONST]);

val SERIES_RESTRICT = store_thm ("SERIES_RESTRICT",
 ``!f k l:real.
        ((\n. if n IN k then f(n) else 0) sums l) univ(:num) <=>
        (f sums l) k``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM, INTER_UNIV] THEN GEN_TAC THEN
  SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC(METIS [] ``(sum s f = sum t f) /\ (sum t f = sum t g)
                        ==> (sum s f = sum t g)``) THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC SUM_SUPERSET THEN SET_TAC[],
    MATCH_MP_TAC SUM_EQ THEN SIMP_TAC std_ss [IN_INTER]]);

val SERIES_SUM = store_thm ("SERIES_SUM",
 ``!f l k s. FINITE s /\ s SUBSET k /\ (!x. ~(x IN s) ==> (f x = 0)) /\
             (sum s f = l) ==> (f sums l) k``,
  REPEAT STRIP_TAC THEN EXPAND_TAC "l" THEN
  SUBGOAL_THEN ``s INTER k = s:num->bool`` ASSUME_TAC THENL
   [ASM_SET_TAC [], ASM_MESON_TAC [SERIES_FINITE_SUPPORT]]);

val SUMS_REINDEX = store_thm ("SUMS_REINDEX",
 ``!k a l:real n.
   ((\x. a(x + k)) sums l) (from n) <=> (a sums l) (from(n + k))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums, FROM_INTER_NUMSEG] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM SUM_OFFSET] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  ASM_MESON_TAC[ARITH_PROVE ``N + k:num <= n ==> (n = (n - k) + k) /\ N <= n - k``,
                ARITH_PROVE ``N + k:num <= n ==> N <= n + k``]);

val SUMS_REINDEX_GEN = store_thm ("SUMS_REINDEX_GEN",
 ``!k a l:real s.
     ((\x. a(x + k)) sums l) s <=> (a sums l) (IMAGE (\i. i + k) s)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  MP_TAC(ISPECL
   [``k:num``,
    ``\i. if i IN IMAGE (\i. i + k) s then (a:num->real) i else 0``,
    ``l:real``, ``0:num``] SUMS_REINDEX) THEN
  REWRITE_TAC[FROM_0] THEN
  SIMP_TAC std_ss [EQ_ADD_RCANCEL, SET_RULE
   ``(!x y:num. (x + k = y + k) <=> (x = y))
         ==> ((x + k) IN IMAGE (\i. i + k) s <=> x IN s)``] THEN
  DISCH_THEN SUBST1_TAC THEN
  GEN_REWR_TAC LAND_CONV [GSYM SERIES_RESTRICT] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM, IN_FROM, ADD_CLAUSES] THEN
  SUBGOAL_THEN ``!x:num. x IN IMAGE (\i. i + k) s ==> k <= x`` MP_TAC THENL
   [SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN ARITH_TAC, SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Similar combining theorems just for summability.                          *)
(* ------------------------------------------------------------------------- *)

val SUMMABLE_LINEAR = store_thm ("SUMMABLE_LINEAR",
 ``!f h s. summable s f /\ linear h ==> summable s (\n. h(f n))``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_LINEAR]);

val SUMMABLE_0 = store_thm ("SUMMABLE_0",
 ``!s. summable s (\n. 0)``,
  REWRITE_TAC[summable] THEN MESON_TAC[SERIES_0]);

val SUMMABLE_ADD = store_thm ("SUMMABLE_ADD",
 ``!x y s. summable s x /\ summable s y ==> summable s (\n. x n + y n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_ADD]);

val SUMMABLE_SUB = store_thm ("SUMMABLE_SUB",
 ``!x y s. summable s x /\ summable s y ==> summable s (\n. x n - y n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_SUB]);

val SUMMABLE_CMUL = store_thm ("SUMMABLE_CMUL",
 ``!s x c. summable s x ==> summable s (\n. c * x n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_CMUL]);

val SUMMABLE_NEG = store_thm ("SUMMABLE_NEG",
 ``!x s. summable s x ==> summable s (\n. -(x n))``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_NEG]);

val SUMMABLE_IFF = store_thm ("SUMMABLE_IFF",
 ``!f g k. (!x. x IN k ==> (f x = g x)) ==> (summable k f <=> summable k g)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SUMS_IFF]);

val SUMMABLE_EQ = store_thm ("SUMMABLE_EQ",
 ``!f g k. (!x. x IN k ==> (f x = g x)) /\ summable k f ==> summable k g``,
  REWRITE_TAC[summable] THEN METIS_TAC[SUMS_EQ]);

val SUMMABLE_COMPONENT = store_thm ("SUMMABLE_COMPONENT",
 ``!f:num->real s.
        summable s f ==> summable s (\i. f(i))``,
  METIS_TAC []);

val SERIES_SUBSET = store_thm ("SERIES_SUBSET",
 ``!x s t l.
        s SUBSET t /\
        ((\i. if i IN s then x i else 0) sums l) t
        ==> (x sums l) s``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[sums] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  ASM_SIMP_TAC std_ss [GSYM SUM_RESTRICT_SET, FINITE_INTER_NUMSEG] THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN POP_ASSUM MP_TAC THEN SET_TAC[]);

val SUMMABLE_SUBSET = store_thm ("SUMMABLE_SUBSET",
 ``!x s t.
        s SUBSET t /\
        summable t (\i. if i IN s then x i else 0)
        ==> summable s x``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_SUBSET]);

val SUMMABLE_TRIVIAL = store_thm ("SUMMABLE_TRIVIAL",
 ``!f:num->real. summable {} f``,
  GEN_TAC THEN REWRITE_TAC[summable] THEN EXISTS_TAC ``0:real`` THEN
  REWRITE_TAC[SERIES_TRIVIAL]);

val SUMMABLE_RESTRICT = store_thm ("SUMMABLE_RESTRICT",
 ``!f:num->real k.
        summable univ(:num) (\n. if n IN k then f(n) else 0) <=>
        summable k f``,
  SIMP_TAC std_ss [summable, SERIES_RESTRICT]);

val SUMS_FINITE_DIFF = store_thm ("SUMS_FINITE_DIFF",
 ``!f:num->real t s l.
        t SUBSET s /\ FINITE t /\ (f sums l) s
        ==> (f sums (l - sum t f)) (s DIFF t)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``f:num->real`` o MATCH_MP SERIES_FINITE) THEN
  ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  DISCH_THEN(MP_TAC o MATCH_MP SERIES_SUB) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``x:num`` THEN REWRITE_TAC[IN_DIFF] THEN
  UNDISCH_TAC ``t SUBSET s:num->bool`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``x:num`` o REWRITE_RULE [SUBSET_DEF]) THEN
  MAP_EVERY ASM_CASES_TAC [``(x:num) IN s``, ``(x:num) IN t``] THEN
  ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC);

val SUMS_FINITE_UNION = store_thm ("SUMS_FINITE_UNION",
 ``!f:num->real s t l.
        FINITE t /\ (f sums l) s
        ==> (f sums (l + sum (t DIFF s) f)) (s UNION t)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``s:num->bool`` o MATCH_MP FINITE_DIFF) THEN
  DISCH_THEN(MP_TAC o ISPEC ``f:num->real`` o MATCH_MP SERIES_FINITE) THEN
  ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  DISCH_THEN(MP_TAC o MATCH_MP SERIES_ADD) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``x:num`` THEN
  REWRITE_TAC[IN_DIFF, IN_UNION] THEN
  MAP_EVERY ASM_CASES_TAC [``(x:num) IN s``, ``(x:num) IN t``] THEN
  ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC);

val SUMS_OFFSET = store_thm ("SUMS_OFFSET",
 ``!f l:real m n.
           (f sums l) (from m) /\ 0 < n /\ m <= n
           ==> (f sums l - sum (m..n - 1) f) (from n)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``from n = from m DIFF (m..(n-1:num))`` SUBST1_TAC THENL
   [SIMP_TAC std_ss [EXTENSION, IN_FROM, IN_DIFF, IN_NUMSEG] THEN
    GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN CONJ_TAC THENL
     [MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``n:num`` THEN ASM_REWRITE_TAC [],
      REWRITE_TAC [NOT_LESS_EQUAL] THEN DISJ2_TAC THEN
      MATCH_MP_TAC LESS_LESS_EQ_TRANS THEN EXISTS_TAC ``n:num`` THEN ASM_REWRITE_TAC [] THEN
      MATCH_MP_TAC SUB_LESS THEN CONJ_TAC THENL [ARITH_TAC , ALL_TAC] THEN
      REWRITE_TAC [ONE] THEN ASM_REWRITE_TAC [GSYM LESS_EQ]], ARITH_TAC],
    MATCH_MP_TAC SUMS_FINITE_DIFF THEN ASM_REWRITE_TAC[FINITE_NUMSEG] THEN
    SIMP_TAC std_ss [SUBSET_DEF, IN_FROM, IN_NUMSEG]]);

val SUMS_OFFSET_REV = store_thm ("SUMS_OFFSET_REV",
 ``!f:num->real l m n.
        (f sums l) (from m) /\ 0 < m /\ n <= m
        ==> (f sums (l + sum(n..m-1) f)) (from n)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``from m``, ``n..m-1``, ``l:real``]
                SUMS_FINITE_UNION) THEN
  ASM_REWRITE_TAC[FINITE_NUMSEG] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  BINOP_TAC THENL [AP_TERM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC, ALL_TAC] THEN
  REWRITE_TAC[EXTENSION, IN_DIFF, IN_UNION, IN_FROM, IN_NUMSEG] THEN
  ASM_SIMP_TAC arith_ss []);

val SUMMABLE_REINDEX = store_thm ("SUMMABLE_REINDEX",
 ``!k a n. summable (from n) (\x. a (x + k)) <=> summable (from(n + k)) a``,
  REWRITE_TAC[summable, GSYM SUMS_REINDEX]);

val SERIES_DROP_LE = store_thm ("SERIES_DROP_LE",
 ``!f g s a b.
        (f sums a) s /\ (g sums b) s /\
        (!x. x IN s ==> (f x <= g x))
        ==> a <= b``,
  REWRITE_TAC[sums] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_DROP_LE) THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  EXISTS_TAC ``\n. sum (s INTER ((0:num)..n)) (f:num->real)`` THEN
  EXISTS_TAC ``\n. sum (s INTER ((0:num)..n)) (g:num->real)`` THEN
  ASM_REWRITE_TAC[] THEN EXISTS_TAC ``0:num`` THEN REPEAT STRIP_TAC THEN
  SIMP_TAC std_ss [] THEN MATCH_MP_TAC SUM_LE THEN
  ASM_SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG, IN_INTER, IN_NUMSEG]);

val SERIES_DROP_POS = store_thm ("SERIES_DROP_POS",
 ``!f s a.
        (f sums a) s /\ (!x. x IN s ==> &0 <= f x)
        ==> &0 <= a``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``(\n. 0):num->real``, ``f:num->real``, ``s:num->bool``,
                 ``0:real``, ``a:real``] SERIES_DROP_LE) THEN
  ASM_SIMP_TAC std_ss [SUMS_0]);

val SERIES_BOUND = store_thm ("SERIES_BOUND",
 ``!f:num->real g s a b.
        (f sums a) s /\ (g sums b) s /\
        (!i. i IN s ==> abs(f i) <= g i)
        ==> abs (a) <= b``,
  REWRITE_TAC[sums] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_ABS_UBOUND) THEN
  EXISTS_TAC ``\n. sum (s INTER ((0:num)..n)) (f:num->real)`` THEN
  ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC ``0:num`` THEN
  X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``sum (s INTER ((0:num)..m)) g`` THEN CONJ_TAC THEN
  ASM_SIMP_TAC std_ss [SUM_ABS_LE, IN_INTER, FINITE_NUMSEG, FINITE_INTER] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM sums]) THEN
  UNDISCH_TAC ``(g sums b) s`` THEN
  GEN_REWR_TAC LAND_CONV [GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[GSYM FROM_0] THEN DISCH_THEN(MP_TAC o SPEC ``m + 1:num`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] SUMS_OFFSET)) THEN
  KNOW_TAC ``0 < m + 1 /\ 0 <= m + 1:num`` THENL
  [ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[ARITH_PROVE ``0 < m + 1:num``, o_DEF, ADD_SUB] THEN
  SIMP_TAC std_ss [GSYM SUM_RESTRICT_SET] THEN
  SIMP_TAC std_ss [ETA_AX] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP] SERIES_DROP_POS)) THEN
  REWRITE_TAC[ONCE_REWRITE_RULE[INTER_COMM] (GSYM INTER_DEF),
              REAL_SUB_LE] THEN
  DISCH_THEN MATCH_MP_TAC THEN REPEAT STRIP_TAC THEN SIMP_TAC std_ss [] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [REAL_LE_REFL] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x:real) <= y ==> &0 <= y``]);

(* ------------------------------------------------------------------------- *)
(* Similar combining theorems for infsum.                                    *)
(* ------------------------------------------------------------------------- *)

val INFSUM_LINEAR = store_thm ("INFSUM_LINEAR",
 ``!f h s. summable s f /\ linear h
           ==> (infsum s (\n. h(f n)) = h(infsum s f))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_LINEAR THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_0 = store_thm ("INFSUM_0",
 ``infsum s (\i. 0) = 0``,
  MATCH_MP_TAC INFSUM_UNIQUE THEN REWRITE_TAC[SERIES_0]);

val INFSUM_ADD = store_thm ("INFSUM_ADD",
 ``!x y s. summable s x /\ summable s y
           ==> (infsum s (\i. x i + y i) = infsum s x + infsum s y)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_ADD THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_SUB = store_thm ("INFSUM_SUB",
 ``!x y s. summable s x /\ summable s y
           ==> (infsum s (\i. x i - y i) = infsum s x - infsum s y)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_SUB THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_CMUL = store_thm ("INFSUM_CMUL",
 ``!s x c. summable s x ==> (infsum s (\n. c * x n) = c * infsum s x)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_CMUL THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_NEG = store_thm ("INFSUM_NEG",
 ``!s x. summable s x ==> (infsum s (\n. -(x n)) = -(infsum s x))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_NEG THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_EQ = store_thm ("INFSUM_EQ",
 ``!f g k. summable k f /\ summable k g /\ (!x. x IN k ==> (f x = g x))
           ==> (infsum k f = infsum k g)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[infsum] THEN
  AP_TERM_TAC THEN ABS_TAC THEN ASM_MESON_TAC[SUMS_EQ, SUMS_INFSUM]);

val INFSUM_RESTRICT = store_thm ("INFSUM_RESTRICT",
 ``!k a:num->real.
        infsum univ(:num) (\n. if n IN k then a n else 0) = infsum k a``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``a:num->real``, ``k:num->bool``] SUMMABLE_RESTRICT) THEN
  ASM_CASES_TAC ``summable k (a:num->real)`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THENL
   [MATCH_MP_TAC INFSUM_UNIQUE THEN
    ASM_REWRITE_TAC[SERIES_RESTRICT, SUMS_INFSUM],
    FULL_SIMP_TAC std_ss [summable, NOT_EXISTS_THM] THEN
    ASM_REWRITE_TAC[infsum]]);

val PARTIAL_SUMS_COMPONENT_LE_INFSUM = store_thm ("PARTIAL_SUMS_COMPONENT_LE_INFSUM",
 ``!f:num->real s n.
        (!i. i IN s ==> &0 <= f i) /\ summable s f
        ==> (sum (s INTER ((0:num)..n)) f) <= (infsum s f)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM SUMS_INFSUM] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[sums, LIM_SEQUENTIALLY] THEN DISCH_TAC THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``sum (s INTER ((0:num)..n)) (f:num->real) - (infsum s f)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` (MP_TAC o SPEC ``N + n:num``)) THEN
  REWRITE_TAC[LE_ADD, REAL_NOT_LT, dist] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs((sum (s INTER ((0:num)..N + n)) f - infsum s f:real))`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_REFL] THEN
  MATCH_MP_TAC(REAL_ARITH ``s < a /\ a <= b ==> a - s <= abs(b - s:real)``) THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[ADD_SYM] THEN
  KNOW_TAC ``sum (s INTER ((0:num)..n)) f <=
              sum (s INTER ((0:num)..n) UNION s INTER (n + (1:num)..n + N)) f`` THENL
  [ALL_TAC, SIMP_TAC std_ss [GSYM NUMSEG_ADD_SPLIT, ZERO_LESS_EQ, GSYM UNION_OVER_INTER]] THEN
  KNOW_TAC ``(sum (s INTER ((0:num)..n) UNION s INTER (n + (1:num)..n + N)) f =
              sum (s INTER ((0:num)..n)) f + sum (s INTER (n + (1:num)..n + N)) f)`` THENL
  [MATCH_MP_TAC SUM_UNION THEN
   SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG, DISJOINT_DEF, EXTENSION] THEN
   SIMP_TAC arith_ss [IN_INTER, NOT_IN_EMPTY, IN_NUMSEG] THEN CCONTR_TAC THEN
   FULL_SIMP_TAC arith_ss [], ALL_TAC] THEN
  DISCH_THEN SUBST1_TAC THEN
  REWRITE_TAC[REAL_LE_ADDR] THEN
  ASM_SIMP_TAC std_ss [] THEN MATCH_MP_TAC SUM_POS_LE THEN
  ASM_SIMP_TAC std_ss [FINITE_INTER, IN_INTER, FINITE_NUMSEG]);

val PARTIAL_SUMS_DROP_LE_INFSUM = store_thm ("PARTIAL_SUMS_DROP_LE_INFSUM",
 ``!f s n.
        (!i. i IN s ==> &0 <= f i) /\
        summable s f
        ==> sum (s INTER ((0:num)..n)) f <= (infsum s f)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC PARTIAL_SUMS_COMPONENT_LE_INFSUM THEN
  ASM_REWRITE_TAC[LESS_EQ_REFL]);

(* ------------------------------------------------------------------------- *)
(* Cauchy criterion for series.                                              *)
(* ------------------------------------------------------------------------- *)

val SEQUENCE_CAUCHY_WLOG = store_thm ("SEQUENCE_CAUCHY_WLOG",
 ``!P s. (!m n:num. P m /\ P n ==> dist(s m,s n) < e) <=>
         (!m n. P m /\ P n /\ m <= n ==> dist(s m,s n) < e)``,
  MESON_TAC[DIST_SYM, LE_CASES]);

val SUM_DIFF_LEMMA = store_thm ("SUM_DIFF_LEMMA",
 ``!f:num->real k m n.
        m <= n
        ==> (sum (k INTER ((0:num) .. n)) f - sum (k INTER ((0:num)..m)) f =
             sum (k INTER ((m+1:num) .. n)) f)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``k INTER ((0:num)..n)``, ``k INTER ((0:num)..m)``]
    SUM_DIFF) THEN
  KNOW_TAC ``FINITE (k INTER ((0:num) .. n)) /\
             k INTER ((0:num) .. m) SUBSET k INTER ((0:num) .. n)`` THENL
   [SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN MATCH_MP_TAC
     (SET_RULE ``s SUBSET t ==> (u INTER s SUBSET u INTER t)``) THEN
    REWRITE_TAC[SUBSET_DEF, IN_NUMSEG] THEN POP_ASSUM MP_TAC THEN ARITH_TAC,
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(SUBST1_TAC o SYM) THEN AP_THM_TAC THEN AP_TERM_TAC THEN
    REWRITE_TAC[SET_RULE
     ``(k INTER s) DIFF (k INTER t) = k INTER (s DIFF t)``] THEN
    AP_TERM_TAC THEN REWRITE_TAC[EXTENSION, IN_DIFF, IN_NUMSEG] THEN
    POP_ASSUM MP_TAC THEN ARITH_TAC]);

val ABS_SUM_TRIVIAL_LEMMA = store_thm ("ABS_SUM_TRIVIAL_LEMMA",
 ``!e:real. &0 < e ==> (P ==> abs(sum(s INTER (m..n)) f) < e <=>
                        P ==> n < m \/ abs(sum(s INTER (m..n)) f) < e)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``n:num < m`` THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(SUBST1_TAC o REWRITE_RULE [GSYM NUMSEG_EMPTY]) THEN
  ASM_REWRITE_TAC[SUM_CLAUSES, ABS_0, INTER_EMPTY]);

val SERIES_CAUCHY = store_thm ("SERIES_CAUCHY",
 ``!f s. (?l. (f sums l) s) =
         !e. &0 < e
             ==> ?N. !m n. m >= N
                           ==> abs(sum(s INTER (m..n)) f) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums, CONVERGENT_EQ_CAUCHY, cauchy] THEN
  SIMP_TAC std_ss [SEQUENCE_CAUCHY_WLOG] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  SIMP_TAC std_ss [dist, SUM_DIFF_LEMMA, ABS_SUM_TRIVIAL_LEMMA] THEN
  REWRITE_TAC[GE, TAUT `a ==> b \/ c <=> a /\ ~b ==> c`] THEN
  REWRITE_TAC[NOT_LESS, ARITH_PROVE
   ``(N:num <= m /\ N <= n /\ m <= n) /\ m + 1 <= n <=>
    N + 1 <= m + 1 /\ m + 1 <= n``] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THENL
   [EXISTS_TAC ``N + 1:num``, EXISTS_TAC ``N:num``] THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= m + 1 ==> N <= m + 1:num``] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``m - 1:num``, ``n:num``]) THEN
  SUBGOAL_THEN ``m - 1 + 1 = m:num`` SUBST_ALL_TAC THENL
   [ALL_TAC,
    KNOW_TAC ``N <= m - 1 /\ m <= n:num`` THENL
    [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []]] THEN
  ASM_ARITH_TAC);

val SUMMABLE_CAUCHY = store_thm ("SUMMABLE_CAUCHY",
 ``!f s. summable s f <=>
         !e. &0 < e
             ==> ?N. !m n. m >= N ==> abs(sum(s INTER (m..n)) f) < e``,
  REWRITE_TAC[summable, GSYM SERIES_CAUCHY]);

val SUMMABLE_IFF_EVENTUALLY = store_thm ("SUMMABLE_IFF_EVENTUALLY",
 ``!f g k. (?N. !n. N <= n /\ n IN k ==> (f n = g n))
           ==> (summable k f <=> summable k g)``,
  REWRITE_TAC[summable, SERIES_CAUCHY] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``N0:num`` STRIP_ASSUME_TAC) THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  BETA_TAC THEN AP_TERM_TAC THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``N1:num``
   (fn th => EXISTS_TAC ``N0 + N1:num`` THEN MP_TAC th)) THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`m:num`,`n:num`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  (KNOW_TAC ``m >= N1:num`` THENL [POP_ASSUM MP_TAC THEN ARITH_TAC,
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC]) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  MATCH_MP_TAC SUM_EQ THEN ASM_SIMP_TAC std_ss [IN_INTER, IN_NUMSEG] THEN
  REPEAT STRIP_TAC THENL [ALL_TAC, CONV_TAC SYM_CONV] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_ARITH_TAC);

val SUMMABLE_EQ_EVENTUALLY = store_thm ("SUMMABLE_EQ_EVENTUALLY",
 ``!f g k. (?N. !n. N <= n /\ n IN k ==> (f n = g n)) /\ summable k f
           ==> summable k g``,
  MESON_TAC[SUMMABLE_IFF_EVENTUALLY]);

val SUMMABLE_IFF_COFINITE = store_thm ("SUMMABLE_IFF_COFINITE",
 ``!f s t. FINITE((s DIFF t) UNION (t DIFF s))
           ==> (summable s f <=> summable t f)``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[GSYM SUMMABLE_RESTRICT] THEN
  MATCH_MP_TAC SUMMABLE_IFF_EVENTUALLY THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``\x:num.x`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` MP_TAC) THEN REWRITE_TAC[IN_UNIV] THEN
  DISCH_TAC THEN EXISTS_TAC ``N + 1:num`` THEN
  REWRITE_TAC[ARITH_PROVE ``N + 1 <= n <=> ~(n <= N:num)``] THEN ASM_SET_TAC[]);

val SUMMABLE_EQ_COFINITE = store_thm ("SUMMABLE_EQ_COFINITE",
 ``!f s t. FINITE((s DIFF t) UNION (t DIFF s)) /\ summable s f
           ==> summable t f``,
  MESON_TAC[SUMMABLE_IFF_COFINITE]);

val SUMMABLE_FROM_ELSEWHERE = store_thm ("SUMMABLE_FROM_ELSEWHERE",
 ``!f m n. summable (from m) f ==> summable (from n) f``,
  REPEAT GEN_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] SUMMABLE_EQ_COFINITE) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``(0:num)..(m+n)`` THEN
  SIMP_TAC std_ss [FINITE_NUMSEG, SUBSET_DEF, IN_NUMSEG, IN_UNION, IN_DIFF, IN_FROM] THEN
  ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Uniform vesion of Cauchy criterion.                                       *)
(* ------------------------------------------------------------------------- *)

val SERIES_CAUCHY_UNIFORM = store_thm ("SERIES_CAUCHY_UNIFORM",
 ``!P f:'a->num->real k.
        (?l. !e. &0 < e
                 ==> ?N. !n x. N <= n /\ P x
                               ==> dist(sum(k INTER ((0:num)..n)) (f x),
                                        l x) < e) <=>
        (!e. &0 < e ==> ?N. !m n x. N <= m /\ P x
                                    ==> abs(sum(k INTER (m..n)) (f x)) < e)``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [sums, UNIFORMLY_CONVERGENT_EQ_CAUCHY, cauchy] THEN
  ONCE_REWRITE_TAC [METIS [] ``(dist (sum (k INTER (0 .. n)) (f x),
                                      sum (k INTER (0 .. n')) (f x)) < e) =
                      (\n n' x. dist (sum (k INTER (0 .. n)) (f x),
                                      sum (k INTER (0 .. n')) (f x)) < e) n n' x``] THEN
  ONCE_REWRITE_TAC[MESON[]
   ``(!m n:num y. N <= m /\ N <= n /\ P y ==> Q m n y) <=>
     (!y. P y ==> !m n. N <= m /\ N <= n ==> Q m n y)``] THEN
  SIMP_TAC std_ss [SEQUENCE_CAUCHY_WLOG] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  SIMP_TAC std_ss [dist, SUM_DIFF_LEMMA, ABS_SUM_TRIVIAL_LEMMA] THEN
  REWRITE_TAC[GE, TAUT `a ==> b \/ c <=> a /\ ~b ==> c`] THEN
  REWRITE_TAC[NOT_LESS, ARITH_PROVE
   ``(N <= m /\ N <= n /\ m <= n) /\ m + 1 <= n <=>
      N + 1 <= m + 1 /\ m + 1 <= n:num``] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THENL
   [EXISTS_TAC ``N + 1:num``, EXISTS_TAC ``N:num``] THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= m + 1 ==> N <= m + 1:num``] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:'a``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPECL [``m - 1:num``, ``n:num``]) THEN
  SUBGOAL_THEN ``m - 1 + 1 = m:num`` SUBST_ALL_TAC THENL
   [ASM_ARITH_TAC, ALL_TAC] THEN
  KNOW_TAC ``N <= m - 1 /\ m <= n:num`` THENL
  [ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* So trivially, terms of a convergent series go to zero.                    *)
(* ------------------------------------------------------------------------- *)

val SERIES_GOESTOZERO = store_thm ("SERIES_GOESTOZERO",
 ``!s x. summable s x
         ==> !e. &0 < e
                 ==> eventually (\n. n IN s ==> abs(x n) < e) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[summable, SERIES_CAUCHY] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  X_GEN_TAC ``n:num`` THEN BETA_TAC THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``n:num``, ``n:num``]) THEN
  ASM_SIMP_TAC std_ss [NUMSEG_SING, GE, SET_RULE ``n IN s ==> (s INTER {n} = {n})``] THEN
  REWRITE_TAC[SUM_SING]);

val SUMMABLE_IMP_TOZERO = store_thm ("SUMMABLE_IMP_TOZERO",
 ``!f:num->real k.
       summable k f
       ==> ((\n. if n IN k then f(n) else 0) --> 0) sequentially``,
  REPEAT GEN_TAC THEN GEN_REWR_TAC LAND_CONV [GSYM SUMMABLE_RESTRICT] THEN
  REWRITE_TAC[summable, LIM_SEQUENTIALLY, INTER_UNIV, sums] THEN
  DISCH_THEN(X_CHOOSE_TAC ``l:real``) THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_HALF, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``N:num`` THEN DISCH_TAC THEN EXISTS_TAC ``N + 1:num`` THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!n:num. N <= n ==>
        dist (sum ((0:num) .. n) (\n. if n IN k then f n else 0),l) < e / 2:real`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``n - 1:num`` th) THEN MP_TAC(SPEC ``n:num`` th)) THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= n ==> N <= n /\ N <= n - 1:num``] THEN
  ABBREV_TAC ``m = n - 1:num`` THEN
  SUBGOAL_THEN ``n = SUC m`` SUBST1_TAC THENL
   [ASM_ARITH_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [SUM_CLAUSES_NUMSEG, ZERO_LESS_EQ, dist] THEN
  SIMP_TAC std_ss [REAL_ARITH ``abs(x - 0) = abs x:real``] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [ABS_0] THEN
  SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val SUMMABLE_IMP_BOUNDED = store_thm ("SUMMABLE_IMP_BOUNDED",
 ``!f:num->real k. summable k f ==> bounded (IMAGE f k)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP SUMMABLE_IMP_TOZERO) THEN
  DISCH_THEN(MP_TAC o MATCH_MP CONVERGENT_IMP_BOUNDED) THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE, IN_UNIV] THEN
  METIS_TAC[REAL_LT_IMP_LE, ABS_0]);

val SUMMABLE_IMP_SUMS_BOUNDED = store_thm ("SUMMABLE_IMP_SUMS_BOUNDED",
 ``!f:num->real k.
       summable (from k) f ==> bounded { sum(k..n) f | n IN univ(:num) }``,
  SIMP_TAC std_ss [summable, sums, LEFT_IMP_EXISTS_THM] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP CONVERGENT_IMP_BOUNDED) THEN
  SIMP_TAC std_ss [FROM_INTER_NUMSEG, GSYM IMAGE_DEF]);

(* ------------------------------------------------------------------------- *)
(* Comparison test.                                                          *)
(* ------------------------------------------------------------------------- *)

val SERIES_COMPARISON = store_thm ("SERIES_COMPARISON",
 ``!f g s. (?l. (g sums l) s) /\
           (?N. !n. n >= N /\ n IN s ==> abs(f n) <= g n)
           ==> ?l:real. (f sums l) s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SERIES_CAUCHY] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC (X_CHOOSE_TAC ``N1:num``)) THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
  EXISTS_TAC ``N1 + N2:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs (sum (s INTER (m .. n)) g)`` THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [FINITE_INTER_NUMSEG] THEN
    MATCH_MP_TAC(REAL_ARITH ``x <= a ==> x <= abs(a:real)``) THEN
    MATCH_MP_TAC SUM_ABS_LE THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, IN_INTER, IN_NUMSEG] THEN
    ASM_MESON_TAC[ARITH_PROVE ``m >= N1 + N2:num /\ m <= x ==> x >= N1``],
    ASM_MESON_TAC[ARITH_PROVE ``m >= N1 + N2:num ==> m >= N2``]]);

val SUMMABLE_COMPARISON = store_thm ("SUMMABLE_COMPARISON",
 ``!f g s. summable s g /\
           (?N. !n. n >= N /\ n IN s ==> abs(f n) <= g n)
           ==> summable s f``,
  REWRITE_TAC[summable, SERIES_COMPARISON]);

val SERIES_ABSCONV_IMP_CONV = store_thm ("SERIES_ABSCONV_IMP_CONV",
 ``!x:num->real k. summable k (\n. (abs(x n))) ==> summable k x``,
  REWRITE_TAC[summable] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SERIES_COMPARISON THEN
  EXISTS_TAC ``\n:num. abs(x n:real)`` THEN
  ASM_SIMP_TAC std_ss [o_DEF, REAL_LE_REFL] THEN ASM_MESON_TAC[]);

val SUMMABLE_SUBSET_ABSCONV = store_thm ("SUMMABLE_SUBSET_ABSCONV",
 ``!x:num->real s t.
        summable s (\n. abs(x n)) /\ t SUBSET s
        ==> summable t (\n. abs(x n))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMMABLE_SUBSET THEN
  EXISTS_TAC ``s:num->bool`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[summable] THEN MATCH_MP_TAC SERIES_COMPARISON THEN
  EXISTS_TAC ``\n:num. abs(x n:real)`` THEN
  ASM_SIMP_TAC std_ss [o_DEF, GSYM summable] THEN
  EXISTS_TAC ``0:num`` THEN REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [REAL_LE_REFL, ABS_ABS, ABS_0, ABS_POS]);

val SERIES_COMPARISON_BOUND = store_thm ("SERIES_COMPARISON_BOUND",
 ``!f:num->real g s a.
        (g sums a) s /\ (!i. i IN s ==> abs(f i) <= (g i))
        ==> ?l. (f sums l) s /\ abs(l) <= a``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``g:num->real``, ``s:num->bool``]
        SUMMABLE_COMPARISON) THEN
  SIMP_TAC std_ss [o_DEF, GE, ETA_AX, summable] THEN
  KNOW_TAC ``(?l. ((g:num->real) sums l) s) /\
             (?N:num. !n. N <= n /\ n IN s ==> abs (f n) <= g n)`` THENL
  [ASM_MESON_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``l:real`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[FROM_0, INTER_UNIV, sums]) THEN
  MATCH_MP_TAC SERIES_BOUND THEN MAP_EVERY EXISTS_TAC
   [``f:num->real``, ``g:num->real``, ``s:num->bool``] THEN
  ASM_SIMP_TAC std_ss [sums, o_DEF, ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Uniform version of comparison test.                                       *)
(* ------------------------------------------------------------------------- *)

val SERIES_COMPARISON_UNIFORM = store_thm ("SERIES_COMPARISON_UNIFORM",
 ``!f g P s. (?l. (g sums l) s) /\
             (?N. !n x. N <= n /\ n IN s /\ P x ==> abs(f x n) <= g n)
             ==> ?l:'a->real.
                    !e. &0 < e
                        ==> ?N. !n x. N <= n /\ P x
                                      ==> dist(sum(s INTER ((0:num)..n)) (f x),
                                               l x) < e``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GE, SERIES_CAUCHY, SERIES_CAUCHY_UNIFORM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC (X_CHOOSE_TAC ``N1:num``)) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
  EXISTS_TAC ``N1 + N2:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``, ``x:'a``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs (sum (s INTER (m .. n)) g)`` THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [FINITE_INTER_NUMSEG] THEN
    MATCH_MP_TAC(REAL_ARITH ``x <= a ==> x <= abs(a:real)``) THEN
    MATCH_MP_TAC SUM_ABS_LE THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, IN_INTER, IN_NUMSEG] THEN
    ASM_MESON_TAC[ARITH_PROVE ``N1 + N2:num <= m /\ m <= x ==> N1 <= x``],
    ASM_MESON_TAC[ARITH_PROVE ``N1 + N2:num <= m ==> N2 <= m``]]);

(* ------------------------------------------------------------------------- *)
(* Ratio test.                                                               *)
(* ------------------------------------------------------------------------- *)

val SERIES_RATIO = store_thm ("SERIES_RATIO",
 ``!c a s N.
      c < &1 /\
      (!n. n >= N ==> abs(a(SUC n)) <= c * abs(a(n)))
      ==> ?l:real. (a sums l) s``,
  REWRITE_TAC[GE] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SERIES_COMPARISON THEN
  DISJ_CASES_TAC(REAL_ARITH ``c <= &0 \/ &0 < c:real``) THENL
   [EXISTS_TAC ``\n:num. &0:real`` THEN REWRITE_TAC[o_DEF] THEN
    CONJ_TAC THENL [MESON_TAC[SERIES_0], ALL_TAC] THEN
    EXISTS_TAC ``N + 1:num`` THEN REWRITE_TAC[GE] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``c * abs(a(n - 1:num):real)`` THEN
    CONJ_TAC THENL
     [ASM_MESON_TAC[ARITH_PROVE ``N + 1 <= n ==> (SUC(n - 1) = n) /\ N <= n - 1``],
      ALL_TAC] THEN
    MATCH_MP_TAC(REAL_ARITH ``&0 <= -c * x ==> c * x <= &0:real``) THEN
    MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[ABS_POS] THEN
    UNDISCH_TAC ``c <= &0:real`` THEN REAL_ARITH_TAC,
    ASSUME_TAC(MATCH_MP REAL_LT_IMP_LE (ASSUME ``&0 < c:real``))] THEN
  EXISTS_TAC ``\n:num. abs(a(N):real) * c pow (n - N)`` THEN
  REWRITE_TAC[] THEN CONJ_TAC THENL
   [ALL_TAC,
    EXISTS_TAC ``N:num`` THEN
    SIMP_TAC std_ss [GE, LESS_EQ_EXISTS, CONJ_EQ_IMP, ADD_SUB2, LEFT_IMP_EXISTS_THM] THEN
    SUBGOAL_THEN ``!d:num. abs(a(N + d):real) <= abs(a N) * c pow d``
     (fn th => MESON_TAC[th]) THEN INDUCT_TAC THEN
    REWRITE_TAC[ADD_CLAUSES, pow, REAL_MUL_RID, REAL_LE_REFL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``c * abs((a:num->real) (N + d:num))`` THEN
    ASM_SIMP_TAC std_ss [LE_ADD] THEN
    ASM_MESON_TAC[REAL_LE_LMUL, REAL_MUL_ASSOC, REAL_MUL_COMM]] THEN
  GEN_REWR_TAC I [SERIES_CAUCHY] THEN X_GEN_TAC ``e:real`` THEN
  SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [SUM_LMUL, FINITE_INTER, FINITE_NUMSEG] THEN
  ASM_CASES_TAC ``(a:num->real) N = 0:real`` THENL
   [ASM_REWRITE_TAC[ABS_0, REAL_MUL_LZERO, ABS_N], ALL_TAC] THEN
  MP_TAC(SPECL [``c:real``, ``((&1 - c) * e) / abs((a:num->real) N)``]
               REAL_ARCH_POW_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT_MUL, REAL_SUB_LT, GSYM ABS_NZ, GE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``M:num``) THEN EXISTS_TAC ``N + M:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs(abs((a:num->real) N) *
                  sum(m..n) (\i. c pow (i - N)))`` THEN
  CONJ_TAC THENL
   [REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
    REWRITE_TAC[ABS_POS] THEN
    MATCH_MP_TAC(REAL_ARITH ``&0 <= x /\ x <= y ==> abs x <= abs y:real``) THEN
    ASM_SIMP_TAC std_ss [SUM_POS_LE, FINITE_INTER_NUMSEG, POW_POS] THEN
    MATCH_MP_TAC SUM_SUBSET THEN ASM_SIMP_TAC std_ss [POW_POS] THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, FINITE_NUMSEG] THEN
    REWRITE_TAC[IN_INTER, IN_DIFF] THEN MESON_TAC[],
    ALL_TAC] THEN
  REWRITE_TAC[ABS_MUL, ABS_ABS] THEN
  DISJ_CASES_TAC(ARITH_PROVE ``n:num < m \/ m <= n``) THENL
   [ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, ABS_N, REAL_MUL_RZERO], ALL_TAC] THEN
  SUBGOAL_THEN ``(m = 0 + m) /\ (n = (n - m) + m:num)`` (CONJUNCTS_THEN SUBST1_TAC) THENL
   [UNDISCH_TAC ``m:num <= n`` THEN ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[SUM_OFFSET] THEN UNDISCH_TAC ``N + M:num <= m`` THEN
  SIMP_TAC std_ss [LESS_EQ_EXISTS] THEN DISCH_THEN(X_CHOOSE_THEN ``d:num`` SUBST_ALL_TAC) THEN
  REWRITE_TAC[ARITH_PROVE ``(i + (N + M + d) - N:num) = (M + d) + i``] THEN
  ONCE_REWRITE_TAC[POW_ADD] THEN SIMP_TAC arith_ss [SUM_LMUL, SUM_GP] THEN
  ASM_SIMP_TAC std_ss [LT, REAL_LT_IMP_NE] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  FULL_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ, ABS_NZ, ABS_MUL] THEN
  REWRITE_TAC[GSYM POW_ABS] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  KNOW_TAC ``1 - c:real <> 0`` THENL
  [UNDISCH_TAC ``c < 1:real`` THEN REAL_ARITH_TAC, DISCH_TAC] THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ, ABS_DIV, REAL_POW_LT, ABS_NZ, REAL_ARITH
   ``&0 < c /\ c < &1 ==> &0 < abs c /\ &0 < abs(&1 - c:real)``, REAL_LT_LDIV_EQ] THEN
  ONCE_REWRITE_TAC [METIS [pow] ``x pow 0 = 1:real``] THEN
  MATCH_MP_TAC(REAL_ARITH
   ``&0 < x /\ x <= &1 /\ &1 <= e ==> abs(1 - x) < e:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_POW_LT, REAL_POW_1_LE, REAL_LT_IMP_LE] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``c < &1 ==> (x * abs(&1 - c) = (&1 - c) * x:real)``] THEN
  KNOW_TAC ``(abs (c pow M) <> 0:real) /\ (abs (c pow d) <> 0:real)`` THENL
  [CONJ_TAC THEN ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   REWRITE_TAC [GSYM ABS_NZ] THEN ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN
   MATCH_MP_TAC REAL_LT_IMP_NE THEN METIS_TAC [REAL_POW_LT], STRIP_TAC] THEN
  FULL_SIMP_TAC real_ss [real_div, REAL_INV_MUL, ABS_NZ, REAL_POW_LT, REAL_POW_ADD,
                        REAL_MUL_ASSOC, REAL_LT_IMP_NE, POW_ABS, ABS_MUL] THEN
  REWRITE_TAC[REAL_ARITH
   ``(a * b * c * d * e) = (e * ((a * b) * c)) * d:real``] THEN
  ASM_SIMP_TAC real_ss [GSYM real_div, REAL_LE_RDIV_EQ, REAL_POW_LT, REAL_MUL_LID,
               REAL_ARITH ``&0 < c ==> (abs c = c:real)``] THEN
  REWRITE_TAC [real_div] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``xm < e ==> &0 <= (d - &1) * e ==> xm <= d * e:real``)) THEN
  MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL
   [REWRITE_TAC[REAL_SUB_LE, GSYM REAL_POW_INV] THEN
    MATCH_MP_TAC REAL_POW_LE_1 THEN
    MATCH_MP_TAC REAL_INV_1_LE THEN ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE],
    MATCH_MP_TAC REAL_LT_IMP_LE THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LT, REAL_LT_MUL, REAL_LT_DIV, ABS_NZ, GSYM real_div]]);

(* ------------------------------------------------------------------------- *)
(* Ostensibly weaker versions of the boundedness of partial sums.            *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_PARTIAL_SUMS = store_thm ("BOUNDED_PARTIAL_SUMS",
 ``!f:num->real k.
        bounded { sum(k..n) f | n IN univ(:num) }
        ==> bounded { sum(m..n) f | m IN univ(:num) /\ n IN univ(:num) }``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``bounded { sum((0:num)..n) f:real | n IN univ(:num) }`` MP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
    REWRITE_TAC[bounded_def] THEN
    SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IN_UNIV] THEN
    DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``sum { i:num | i < k} (\i. abs(f i:real)) + B`` THEN
    X_GEN_TAC ``i:num`` THEN ASM_CASES_TAC ``i:num < k`` THENL
     [MATCH_MP_TAC(REAL_ARITH
       ``!y. x <= y /\ y <= a /\ &0 < b ==> x <= a + b:real``) THEN
      EXISTS_TAC ``sum ((0:num)..i) (\i. abs(f i:real))`` THEN
      ASM_SIMP_TAC std_ss [SUM_ABS, FINITE_NUMSEG] THEN
      MATCH_MP_TAC SUM_SUBSET THEN
      REWRITE_TAC[FINITE_NUMSEG, FINITE_NUMSEG_LT, ABS_POS] THEN
      SIMP_TAC std_ss [IN_DIFF, IN_NUMSEG, GSPECIFICATION] THEN
      ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC,
      ALL_TAC] THEN
    ASM_CASES_TAC ``k = 0:num`` THENL
     [FIRST_X_ASSUM SUBST_ALL_TAC THEN MATCH_MP_TAC(REAL_ARITH
       ``x <= B /\ &0 <= b ==> x <= b + B:real``) THEN
      ASM_SIMP_TAC std_ss [SUM_POS_LE, FINITE_NUMSEG_LT, ABS_POS],
      ALL_TAC] THEN
    MP_TAC(ISPECL [``f:num->real``, ``0:num``, ``k:num``, ``i:num``]
      SUM_COMBINE_L) THEN
    KNOW_TAC ``0 < k /\ 0 <= k /\ k <= i + 1:num`` THENL
    [ASM_SIMP_TAC arith_ss [],
     DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(SUBST1_TAC o SYM) THEN ASM_REWRITE_TAC[NUMSEG_LT] THEN
    MATCH_MP_TAC(REAL_ARITH
     ``abs(x) <= a /\ abs(y) <= b ==> abs(x + y) <= a + b:real``) THEN
    ASM_SIMP_TAC std_ss [SUM_ABS, FINITE_NUMSEG],
    ALL_TAC] THEN
  DISCH_THEN(fn th =>
    MP_TAC(MATCH_MP BOUNDED_DIFFS (W CONJ th)) THEN MP_TAC th) THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM BOUNDED_UNION] THEN
  MATCH_MP_TAC(REWRITE_RULE[TAUT `a /\ b ==> c <=> b ==> a ==> c`]
        BOUNDED_SUBSET) THEN
  KNOW_TAC ``!x:real m n:num.
     (x = sum (m..n) f)
     ==> (?n. x = sum ((0:num)..n) f) \/
         (?x' y.
              ((?n. x' = sum ((0:num)..n) f) /\ (?n. y = sum ((0:num)..n) f)) /\
              (x = x' - y))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNION, LEFT_IMP_EXISTS_THM,
                             IN_UNIV, EXISTS_PROD] THEN METIS_TAC []] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``m:num``, ``n:num``] THEN
  DISCH_THEN SUBST1_TAC THEN
  ASM_CASES_TAC ``m = 0:num`` THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``n:num < m`` THENL
   [DISJ2_TAC THEN REPEAT(EXISTS_TAC ``sum((0:num)..(0:num)) (f:num->real)``) THEN
    ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, REAL_SUB_REFL] THEN MESON_TAC[],
    ALL_TAC] THEN
  DISJ2_TAC THEN MAP_EVERY EXISTS_TAC
   [``sum((0:num)..n) (f:num->real)``, ``sum((0:num)..(m-1:num)) (f:num->real)``] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``f:num->real``, ``0:num``, ``m:num``, ``n:num``]
      SUM_COMBINE_L) THEN ASM_SIMP_TAC arith_ss [] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* General Dirichlet convergence test (could make this uniform on a set).    *)
(* ------------------------------------------------------------------------- *)

val SUMMABLE_BILINEAR_PARTIAL_PRE = store_thm ("SUMMABLE_BILINEAR_PARTIAL_PRE",
 ``!f g h:real->real->real l k.
        bilinear h /\
        ((\n. h (f(n + 1)) (g(n))) --> l) sequentially /\
        summable (from k) (\n. h (f(n + 1) - f(n)) (g(n)))
        ==> summable (from k) (\n. h (f n) (g(n) - g(n - 1)))``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [summable, sums, FROM_INTER_NUMSEG] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(fn th =>
   REWRITE_TAC[MATCH_MP BILINEAR_SUM_PARTIAL_PRE th]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``l':real``) THEN
  EXISTS_TAC ``l - (h:real->real->real) ((f:num->real) k) (g(k - 1)) - l'`` THEN
  SIMP_TAC std_ss [LIM_CASES_SEQUENTIALLY] THEN
  KNOW_TAC  ``(((\(n :num).
     (\n. (h :real -> real -> real) ((f :num -> real) (n + (1 :num)))
       ((g :num -> real) n) - h (f (k :num)) (g (k - (1 :num)))) n -
     (\n. sum (k .. n) (\(k :num). h (f (k + (1 :num)) - f k) (g k))) n) -->
  ((l :real) - h (f k) (g (k - (1 :num))) - (l' :real))) sequentially :
   bool)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [LIM_CONST] THEN
  KNOW_TAC ``(((\(n :num).
     (\n. (h :real -> real -> real) ((f :num -> real) (n + (1 :num)))
       ((g :num -> real) n)) n - (\n. h (f (k :num)) (g (k - (1 :num)))) n) -->
  ((l :real) - h (f k) (g (k - (1 :num))))) sequentially :bool)`` THENL
  [ALL_TAC, METIS_TAC []] THEN MATCH_MP_TAC LIM_SUB THEN
  ASM_SIMP_TAC std_ss [LIM_CONST]);

val SERIES_DIRICHLET_BILINEAR = store_thm ("SERIES_DIRICHLET_BILINEAR",
 ``!f g h:real->real->real k m p l.
        bilinear h /\
        bounded {sum (m..n) f | n IN univ(:num)} /\
        summable (from p) (\n. abs(g(n + 1) - g(n))) /\
        ((\n. h (g(n + 1)) (sum((1:num)..n) f)) --> l) sequentially
        ==> summable (from k) (\n. h (g n) (f n))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMMABLE_FROM_ELSEWHERE THEN
  EXISTS_TAC ``1:num`` THEN
  FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP BOUNDED_PARTIAL_SUMS) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
  SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, LEFT_IMP_EXISTS_THM, EXISTS_PROD] THEN
  X_GEN_TAC ``B:real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP BILINEAR_BOUNDED_POS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``C:real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC SUMMABLE_EQ THEN
  EXISTS_TAC ``\n. (h:real->real->real)
                   (g n) (sum ((1:num)..n) f - sum ((1:num)..n-1:num) f)`` THEN
  SIMP_TAC std_ss [IN_FROM, GSYM NUMSEG_RREC] THEN
  SIMP_TAC std_ss [SUM_CLAUSES, FINITE_NUMSEG, IN_NUMSEG,
           ARITH_PROVE ``1 <= n ==> ~(n <= n - 1:num)``] THEN
  CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [BILINEAR_RADD, BILINEAR_RSUB] THEN
    REAL_ARITH_TAC,
    ALL_TAC] THEN
  MATCH_MP_TAC SUMMABLE_FROM_ELSEWHERE THEN EXISTS_TAC ``p:num`` THEN
  MP_TAC(ISPECL [``g:num->real``, ``\n. sum((1:num)..n) f:real``,
                 ``h:real->real->real``, ``l:real``, ``p:num``]
         SUMMABLE_BILINEAR_PARTIAL_PRE) THEN
  SIMP_TAC std_ss [] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN
    ``summable (from p) ((\n. C * B * abs(g(n + 1) - g(n):real)))``
  MP_TAC THENL [ASM_SIMP_TAC std_ss [o_DEF, SUMMABLE_CMUL], ALL_TAC] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUMMABLE_COMPARISON) THEN
  EXISTS_TAC ``0:num`` THEN REWRITE_TAC[IN_FROM, GE, ZERO_LESS_EQ] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
   ``C * abs(g(n + 1:num) - g(n):real) * abs(sum ((1:num)..n) f:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN
  REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN
  GEN_REWR_TAC RAND_CONV [REAL_MUL_SYM] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP, ABS_POS]);

val SERIES_DIRICHLET = store_thm ("SERIES_DIRICHLET",
 ``!f:num->real g N k m.
        bounded {sum (m..n) f | n IN univ(:num)} /\
        (!n. N <= n ==> g(n + 1) <= g(n)) /\
        (g --> 0) sequentially
        ==> summable (from k) (\n. g(n) * f(n))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``g:num->real``,
                 ``\x y:real. x * y``] SERIES_DIRICHLET_BILINEAR) THEN
  SIMP_TAC std_ss [o_THM] THEN DISCH_THEN MATCH_MP_TAC THEN
  MAP_EVERY EXISTS_TAC [``m:num``, ``N:num``, ``0:real``] THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [bilinear, linear] THEN
    REPEAT STRIP_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  ASM_REWRITE_TAC [] THEN
  FIRST_ASSUM(MP_TAC o SPEC ``1:num`` o MATCH_MP SEQ_OFFSET) THEN
  SIMP_TAC std_ss [o_THM] THEN DISCH_TAC THEN CONJ_TAC THENL
   [MATCH_MP_TAC SUMMABLE_EQ_EVENTUALLY THEN
    EXISTS_TAC ``(\n. (g:num->real)(n) - g(n + 1))`` THEN SIMP_TAC std_ss [] THEN
    CONJ_TAC THENL
     [EXISTS_TAC ``N:num`` THEN REPEAT STRIP_TAC THEN
      UNDISCH_TAC ``!n. N <= n ==> g (n + 1) <= (g:num->real) n`` THEN
      DISCH_THEN (MP_TAC o SPEC ``n:num``) THEN
      ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC,
      SIMP_TAC std_ss [summable, sums, FROM_INTER_NUMSEG, SUM_DIFFS] THEN
      SIMP_TAC std_ss [LIM_CASES_SEQUENTIALLY] THEN
      EXISTS_TAC ``(g(N:num)) - 0:real`` THEN
      ONCE_REWRITE_TAC [METIS [] ``((\n:num. g N - g (n + 1)) --> (g N - 0:real)) =
                       ((\n. (\n. g N) n - (\n. g (n + 1)) n) --> (g N - 0))``] THEN
      MATCH_MP_TAC LIM_SUB THEN ASM_REWRITE_TAC[LIM_CONST]],
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
    ONCE_REWRITE_TAC [METIS []
        ``((\n. sum (1 .. n) f * (g:num->real) (n + 1)) --> 0) =
      ((\n. (\n. sum (1 .. n) f) n * (\n. g (n + 1)) n) --> 0)``] THEN
    MATCH_MP_TAC LIM_NULL_CMUL_BOUNDED THEN ASM_SIMP_TAC std_ss [o_DEF] THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
    FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP BOUNDED_PARTIAL_SUMS) THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, EXISTS_PROD] THEN METIS_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Rearranging absolutely convergent series.                                 *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``!f:'a->real s t.
          FINITE s /\ FINITE t
          ==> (sum s f - sum t f = sum (s DIFF t) f - sum (t DIFF s) f)``,
    REPEAT STRIP_TAC THEN
    ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s DIFF (s INTER t)``] THEN
    ASM_SIMP_TAC std_ss [SUM_DIFF, INTER_SUBSET] THEN
    GEN_REWR_TAC (RAND_CONV o RAND_CONV o ONCE_DEPTH_CONV) [INTER_COMM] THEN
    REAL_ARITH_TAC);

val SERIES_INJECTIVE_IMAGE_STRONG = store_thm ("SERIES_INJECTIVE_IMAGE_STRONG",
 ``!x:num->real s f.
        summable (IMAGE f s) (\n. abs(x n)) /\
        (!m n. m IN s /\ n IN s /\ (f m = f n) ==> (m = n))
        ==> ((\n. sum (IMAGE f s INTER ((0:num)..n)) x -
                  sum (s INTER ((0:num)..n)) (x o f)) --> 0)
            sequentially``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``(summable (IMAGE (f :num -> num) (s :num -> bool))
         (\(n :num). abs ((x :num -> real) n)) :bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUMMABLE_CAUCHY]) THEN
  SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [o_DEF] THEN
  SIMP_TAC std_ss [SUM_POS_LE, ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[dist, GE, REAL_SUB_RZERO, REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!(m :num) (n :num).
        m IN (s :num -> bool) /\ n IN s /\ ((f :num -> num) m = f n) ==>
        (m = n)`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``g:num->num``) THEN
  MP_TAC(ISPECL [``g:num->num``, ``((0:num)..N)``] UPPER_BOUND_FINITE_SET) THEN
  REWRITE_TAC[FINITE_NUMSEG, IN_NUMSEG, ZERO_LESS_EQ] THEN
  DISCH_THEN(X_CHOOSE_TAC ``P:num``) THEN
  EXISTS_TAC ``MAX N P:num`` THEN X_GEN_TAC ``n:num`` THEN
  REWRITE_TAC [MAX_DEF] THEN
  SIMP_TAC std_ss [ARITH_PROVE ``(if a < b then b else a) <= c <=> a <= c /\ b <= c:num``] THEN
  DISCH_TAC THEN
  W(MP_TAC o PART_MATCH (rand o rand) SUM_IMAGE o rand o
    rand o lhand o snd) THEN
  KNOW_TAC ``(!(x :num) (y :num).
    x IN (s :num -> bool) INTER ((0 :num) .. (n :num)) /\
    y IN s INTER ((0 :num) .. n) /\ ((f :num -> num) x = f y) ==>
    (x = y))`` THENL
   [ASM_MESON_TAC[FINITE_INTER, FINITE_NUMSEG, IN_INTER],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(SUBST1_TAC o SYM)] THEN
  W(MP_TAC o PART_MATCH (lhand o rand) lemma o rand o lhand o snd) THEN
  SIMP_TAC std_ss [FINITE_INTER, IMAGE_FINITE, FINITE_NUMSEG] THEN
  DISCH_THEN SUBST1_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
   MATCH_MP_TAC(REAL_ARITH
   ``abs a < x /\ abs b < y ==> abs(a - b:real) < x + y:real``) THEN
  CONJ_TAC THEN
  W(MP_TAC o PART_MATCH (lhand o rand) SUM_ABS o lhand o snd) THEN
  SIMP_TAC std_ss [FINITE_DIFF, IMAGE_FINITE, FINITE_INTER, FINITE_NUMSEG] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LET_TRANS) THEN
  MATCH_MP_TAC REAL_LET_TRANS THENL
   [EXISTS_TAC
     ``sum((IMAGE (f:num->num) s) INTER (N..n)) (\i. abs(x i :real))`` THEN
    CONJ_TAC THENL [ALL_TAC,
     MATCH_MP_TAC (REAL_ARITH ``abs x < y ==> x < y:real``) THEN
     ASM_SIMP_TAC real_ss []] THEN
    MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
    SIMP_TAC std_ss [ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
    MATCH_MP_TAC(SET_RULE
     ``(!x. x IN s /\ f(x) IN n /\ ~(x IN m) ==> f x IN t)
      ==> (IMAGE f s INTER n) DIFF (IMAGE f (s INTER m)) SUBSET
          IMAGE f s INTER t``) THEN
    ASM_SIMP_TAC std_ss [IN_NUMSEG, ZERO_LESS_EQ, NOT_LESS_EQUAL] THEN
    X_GEN_TAC ``i:num`` THEN STRIP_TAC THEN
    MATCH_MP_TAC LESS_IMP_LESS_OR_EQ THEN ONCE_REWRITE_TAC[GSYM NOT_LESS_EQUAL] THEN
    UNDISCH_TAC ``!(x :num). x <= (N :num) ==> (g :num -> num) x <= (P :num)`` THEN
    DISCH_TAC THEN POP_ASSUM(MATCH_MP_TAC o ONCE_REWRITE_RULE [MONO_NOT_EQ]) THEN
    ASM_SIMP_TAC arith_ss [],
    MP_TAC(ISPECL [``f:num->num``, ``((0:num)..n)``] UPPER_BOUND_FINITE_SET) THEN
    REWRITE_TAC[FINITE_NUMSEG, IN_NUMSEG, ZERO_LESS_EQ] THEN
    DISCH_THEN(X_CHOOSE_TAC ``p:num``) THEN
    EXISTS_TAC
     ``sum(IMAGE (f:num->num) s INTER (N..p)) (\i. abs(x i :real))`` THEN
    CONJ_TAC THENL [ALL_TAC,
     MATCH_MP_TAC (REAL_ARITH ``abs x < y ==> x < y:real``) THEN
     ASM_SIMP_TAC real_ss []] THEN MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
    SIMP_TAC std_ss [ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
    MATCH_MP_TAC(SET_RULE
     ``(!x. x IN s /\ x IN n /\ ~(f x IN m) ==> f x IN t)
      ==> (IMAGE f (s INTER n) DIFF (IMAGE f s) INTER m) SUBSET
          (IMAGE f s INTER t)``) THEN
    ASM_SIMP_TAC arith_ss [IN_NUMSEG, ZERO_LESS_EQ]]);

val SERIES_INJECTIVE_IMAGE = store_thm ("SERIES_INJECTIVE_IMAGE",
 ``!x:num->real s f l.
        summable (IMAGE f s) (\n. abs(x n)) /\
        (!m n. m IN s /\ n IN s /\ (f m = f n) ==> (m = n))
        ==> (((x o f) sums l) s <=> (x sums l) (IMAGE f s))``,
  REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN REWRITE_TAC[sums] THEN
  MATCH_MP_TAC LIM_TRANSFORM_EQ THEN SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC SERIES_INJECTIVE_IMAGE_STRONG THEN
  ASM_REWRITE_TAC[]);

val SERIES_REARRANGE_EQ = store_thm ("SERIES_REARRANGE_EQ",
 ``!x:num->real s p l.
        (summable s (\n. abs(x n))) /\ (p permutes s)
        ==> (((x o p) sums l) s <=> (x sums l) s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``x:num->real``, ``s:num->bool``, ``p:num->num``, ``l:real``]
        SERIES_INJECTIVE_IMAGE) THEN
  ASM_SIMP_TAC std_ss [PERMUTES_IMAGE] THEN
  ASM_MESON_TAC[PERMUTES_INJECTIVE]);

val SERIES_REARRANGE = store_thm ("SERIES_REARRANGE",
 ``!x:num->real s p l.
        summable s (\n. abs(x n)) /\ p permutes s /\ (x sums l) s
        ==> ((x o p) sums l) s``,
  METIS_TAC[SERIES_REARRANGE_EQ]);

val SUMMABLE_REARRANGE = store_thm ("SUMMABLE_REARRANGE",
 ``!x s p.
        summable s (\n. abs(x n)) /\ p permutes s
        ==> summable s (x o p)``,
  METIS_TAC[SERIES_ABSCONV_IMP_CONV, summable, SERIES_REARRANGE]);

(* ------------------------------------------------------------------------- *)
(* Banach fixed point theorem (not really topological...)                    *)
(* ------------------------------------------------------------------------- *)

val BANACH_FIX = store_thm ("BANACH_FIX",
 ``!f s c. complete s /\ ~(s = {}) /\
           &0 <= c /\ c < &1 /\
           (IMAGE f s) SUBSET s /\
           (!x y. x IN s /\ y IN s ==> dist(f(x),f(y)) <= c * dist(x,y))
           ==> ?!x:real. x IN s /\ (f x = x)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [EXISTS_UNIQUE_THM] THEN CONJ_TAC THENL
   [ALL_TAC,
    MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``dist((f:real->real) x,f y) <= c * dist(x,y)`` MP_TAC THENL
     [ASM_MESON_TAC[], ALL_TAC] THEN
    ASM_REWRITE_TAC[REAL_ARITH ``a <= c * a <=> &0 <= -a * (&1 - c:real)``] THEN
    ASM_SIMP_TAC std_ss [GSYM REAL_LE_LDIV_EQ, REAL_SUB_LT, real_div] THEN
    REWRITE_TAC[REAL_MUL_LZERO, REAL_ARITH ``&0:real <= -x <=> ~(&0 < x)``] THEN
    MESON_TAC[DIST_POS_LT]] THEN
  KNOW_TAC ``?z. (z 0 = @x:real. x IN s) /\ (!n. z(SUC n) = f(z n))`` THENL
  [RW_TAC std_ss [num_Axiom], STRIP_TAC] THEN
  SUBGOAL_THEN ``!n. (z:num->real) n IN s`` ASSUME_TAC THENL
   [INDUCT_TAC THEN ASM_SIMP_TAC std_ss [] THEN
    METIS_TAC[MEMBER_NOT_EMPTY, SUBSET_DEF, IN_IMAGE],
    ALL_TAC] THEN
  UNDISCH_THEN ``z (0:num) = @x:real. x IN s`` (K ALL_TAC) THEN
  SUBGOAL_THEN ``?x:real. x IN s /\ (z --> x) sequentially`` MP_TAC THENL
   [ALL_TAC,
    DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    ABBREV_TAC ``e = dist(f(a:real),a)`` THEN
    SUBGOAL_THEN ``~(&0 < e:real)`` (fn th => METIS_TAC[th, DIST_POS_LT]) THEN
    DISCH_TAC THEN UNDISCH_TAC ``(z --> a) sequentially`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
    ASM_REWRITE_TAC[REAL_HALF] THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
    SUBGOAL_THEN
     ``dist(f(z N),a:real) < e / &2 /\ dist(f(z(N:num)),f(a)) < e / &2``
     (fn th => ASM_MESON_TAC[th, DIST_TRIANGLE_HALF_R, REAL_LT_REFL]) THEN
    CONJ_TAC THENL [ASM_MESON_TAC[ARITH_PROVE ``N <= SUC N``], ALL_TAC] THEN
    MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``c * dist((z:num->real) N,a)`` THEN ASM_SIMP_TAC std_ss [] THEN
    MATCH_MP_TAC(REAL_ARITH ``x < y /\ c * x <= &1 * x ==> c * x < y:real``) THEN
    ASM_SIMP_TAC std_ss [LESS_EQ_REFL, REAL_LE_RMUL_IMP, DIST_POS_LE, REAL_LT_IMP_LE]] THEN
  UNDISCH_TAC ``complete s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE [complete]) THEN
  ASM_REWRITE_TAC[CAUCHY] THEN
  SUBGOAL_THEN ``!n. dist(z(n):real,z(SUC n)) <= c pow n * dist(z(0),z(1))``
  ASSUME_TAC THENL
   [INDUCT_TAC THEN
    SIMP_TAC arith_ss [pow, REAL_MUL_LID, REAL_LE_REFL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``c * dist(z(n):real,z(SUC n))`` THEN
    CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
    REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP],
    ALL_TAC] THEN
  SUBGOAL_THEN
   ``!m n:num. (&1 - c) * dist(z(m):real,z(m+n))
                <= c pow m * dist(z(0),z(1:num)) * (&1 - c pow n)``
  ASSUME_TAC THENL
   [GEN_TAC THEN INDUCT_TAC THENL
     [REWRITE_TAC[ADD_CLAUSES, DIST_REFL, REAL_MUL_RZERO, GSYM REAL_MUL_ASSOC] THEN
      MATCH_MP_TAC REAL_LE_MUL THEN
      ASM_SIMP_TAC std_ss [REAL_LE_MUL, POW_POS, DIST_POS_LE, REAL_SUB_LE,
                   REAL_POW_1_LE, REAL_LT_IMP_LE],
      ALL_TAC] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
    ``(&1 - c) * (dist(z m:real,z(m + n)) + dist(z(m + n),z(m + SUC n)))`` THEN
    ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP, REAL_SUB_LE, REAL_LT_IMP_LE, DIST_TRIANGLE] THEN
    FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
      ``c * x <= y ==> c * x' + y <= y' ==> c * (x + x') <= y':real``)) THEN
    REWRITE_TAC[REAL_ARITH
     ``q + a * b * (&1 - x) <= a * b * (&1 - y) <=> q <= a * b * (x - y:real)``] THEN
    REWRITE_TAC[ADD_CLAUSES, pow] THEN
    REWRITE_TAC[REAL_ARITH ``a * b * (d - c * d) = (&1 - c) * a * d * b:real``] THEN
    REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LE, REAL_LT_IMP_LE] THEN
    REWRITE_TAC[GSYM REAL_POW_ADD, REAL_MUL_ASSOC] THEN ASM_MESON_TAC[],
    ALL_TAC] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``(z:num->real) 0 = z 1`` THENL
   [FIRST_X_ASSUM SUBST_ALL_TAC THEN EXISTS_TAC ``0:num`` THEN
    REWRITE_TAC[GE, ZERO_LESS_EQ] THEN X_GEN_TAC ``n:num`` THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``0:num``, ``n:num``]) THEN
    REWRITE_TAC[ADD_CLAUSES, DIST_REFL, REAL_MUL_LZERO, REAL_MUL_RZERO] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    ASM_CASES_TAC ``(z:num->real) 0 = z n`` THEN
    ASM_REWRITE_TAC[DIST_REFL, REAL_NOT_LE] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MUL, DIST_POS_LT, REAL_SUB_LT],
    ALL_TAC] THEN
  MP_TAC(SPECL [``c:real``, ``e * (&1 - c) / dist((z:num->real) 0,z 1)``]
   REAL_ARCH_POW_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_MUL, REAL_LT_DIV, REAL_SUB_LT, DIST_POS_LT] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[real_div, GE, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, GSYM real_div, DIST_POS_LT] THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_LT_LDIV_EQ, REAL_SUB_LT] THEN DISCH_TAC THEN
  SIMP_TAC std_ss [LESS_EQ_EXISTS, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``d:num`` THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP(REAL_ARITH
    ``d < e ==> x <= d ==> x < e:real``)) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_SUB_LT] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``N:num``, ``d:num``]) THEN
  MATCH_MP_TAC(REAL_ARITH
  ``(c * d) * e <= (c * d) * &1 ==> x * y <= c * d * e ==> y * x <= c * d:real``) THEN
  MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
  ASM_SIMP_TAC std_ss [REAL_LE_MUL, POW_POS, DIST_POS_LE, REAL_ARITH
   ``&0 <= x ==> &1 - x <= &1:real``]);

(* ------------------------------------------------------------------------- *)
(* Dini's theorem.                                                           *)
(* ------------------------------------------------------------------------- *)

val DINI = store_thm ("DINI",
 ``!f:num->real->real g s.
        compact s /\ (!n. (f n) continuous_on s) /\ g continuous_on s /\
        (!x. x IN s ==> ((\n. (f n x)) --> g x) sequentially) /\
        (!n x. x IN s ==> (f n x) <= (f (n + 1) x))
        ==> !e. &0 < e
                ==> eventually (\n. !x. x IN s ==> abs(f n x - g x) < e)
                               sequentially``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``!x:real m n:num. x IN s /\ m <= n ==> (f m x):real <= (f n x)``
  ASSUME_TAC THENL
   [GEN_TAC THEN ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
    ONCE_REWRITE_TAC [METIS [] ``!m n. (f:num->real->real) m x <= f n x <=>
                                       (\m n. f m x <= f n x) m n``] THEN
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM_SIMP_TAC std_ss [ADD1] THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  SUBGOAL_THEN ``!n:num x:real. x IN s ==> (f n x):real <= (g x)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN
    MATCH_MP_TAC(ISPEC ``sequentially`` LIM_DROP_LE) THEN
    EXISTS_TAC ``\m:num. (f:num->real->real) n x`` THEN
    EXISTS_TAC ``\m:num. (f:num->real->real) m x`` THEN
    ASM_SIMP_TAC std_ss [LIM_CONST, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN ASM_MESON_TAC[],
    ALL_TAC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[LIM_SEQUENTIALLY, dist]) THEN
  UNDISCH_TAC ``compact s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE
   [COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY]) THEN
  DISCH_THEN(MP_TAC o SPEC
   ``IMAGE (\n. { x | x IN s /\ abs((f:num->real->real) n x - g x) < e})
          univ(:num)``) THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_UNIV] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, SUBSET_UNION, BIGUNION_IMAGE] THEN
  SIMP_TAC std_ss [IN_UNIV, GSPECIFICATION, EVENTUALLY_SEQUENTIALLY] THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_UNIV, GSPECIFICATION] THEN
  KNOW_TAC ``(!(n :num).
    open_in (subtopology euclidean (s :real -> bool))
      {x |
       x IN s /\
       abs ((f :num -> real -> real) n x - (g :real -> real) x) <
       (e :real)}) /\
 (!(x :real). x IN s ==> ?(n :num). abs (f n x - g x) < e)`` THENL
   [CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[LESS_EQ_REFL]] THEN
    X_GEN_TAC ``n:num`` THEN REWRITE_TAC[GSYM IN_BALL_0] THEN
    ONCE_REWRITE_TAC [METIS [] ``f n x - g x =
          (\x. (f:num->real->real) n x - g x) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE THEN
    METIS_TAC [OPEN_BALL, CONTINUOUS_ON_SUB, ETA_AX],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``k:num->bool`` (CONJUNCTS_THEN2
     (MP_TAC o SPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET)
     ASSUME_TAC)) THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    POP_ASSUM MP_TAC THEN
    SIMP_TAC std_ss [] THEN STRIP_TAC THEN X_GEN_TAC ``n:num`` THEN
    DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``!x. x IN s ==> ?n. n IN k /\
                  abs ((f:num->real->real) n x - g x) < e`` THEN
    DISCH_TAC THEN
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``m:num`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(REAL_ARITH
     ``m <= n /\ n <= g ==> abs(m - g) < e ==> abs(n - g) < e:real``) THEN
    METIS_TAC[LESS_EQ_TRANS]]);

(* ------------------------------------------------------------------------- *)
(* Closest point of a (closed) set to a point.                               *)
(* ------------------------------------------------------------------------- *)

val closest_point = new_definition ("closest_point",
 ``closest_point s a = @x. x IN s /\ !y. y IN s ==> dist(a,x) <= dist(a,y)``);

val CLOSEST_POINT_EXISTS = store_thm ("CLOSEST_POINT_EXISTS",
 ``!s a. closed s /\ ~(s = {})
         ==> (closest_point s a) IN s /\
             !y. y IN s ==> dist(a,closest_point s a) <= dist(a,y)``,
  REWRITE_TAC[closest_point] THEN CONV_TAC(ONCE_DEPTH_CONV SELECT_CONV) THEN
  REWRITE_TAC[DISTANCE_ATTAINS_INF]);

val CLOSEST_POINT_IN_SET = store_thm ("CLOSEST_POINT_IN_SET",
 ``!s a. closed s /\ ~(s = {}) ==> (closest_point s a) IN s``,
  MESON_TAC[CLOSEST_POINT_EXISTS]);

val CLOSEST_POINT_LE = store_thm ("CLOSEST_POINT_LE",
 ``!s a x. closed s /\ x IN s ==> dist(a,closest_point s a) <= dist(a,x)``,
  MESON_TAC[CLOSEST_POINT_EXISTS, MEMBER_NOT_EMPTY]);

val CLOSEST_POINT_SELF = store_thm ("CLOSEST_POINT_SELF",
 ``!s x:real. x IN s ==> (closest_point s x = x)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[closest_point] THEN
  MATCH_MP_TAC SELECT_UNIQUE THEN REWRITE_TAC[] THEN GEN_TAC THEN EQ_TAC THENL
   [BETA_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [DIST_LE_0, DIST_REFL],
    BETA_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[DIST_REFL, DIST_POS_LE]]);

val CLOSEST_POINT_REFL = store_thm ("CLOSEST_POINT_REFL",
 ``!s x:real. closed s /\ ~(s = {}) ==> ((closest_point s x = x) <=> x IN s)``,
  MESON_TAC[CLOSEST_POINT_IN_SET, CLOSEST_POINT_SELF]);

val DIST_CLOSEST_POINT_LIPSCHITZ = store_thm ("DIST_CLOSEST_POINT_LIPSCHITZ",
 ``!s x y:real.
        closed s /\ ~(s = {})
        ==> abs(dist(x,closest_point s x) - dist(y,closest_point s y))
            <= dist(x,y)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CLOSEST_POINT_EXISTS) THEN
  DISCH_THEN(fn th =>
    CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC o SPEC ``closest_point s (y:real)``) (SPEC ``x:real`` th) THEN
    CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC o SPEC ``closest_point s (x:real)``) (SPEC ``y:real`` th)) THEN
  ASM_SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_AT_DIST_CLOSEST_POINT = store_thm ("CONTINUOUS_AT_DIST_CLOSEST_POINT",
 ``!s x:real.
        closed s /\ ~(s = {})
        ==> (\x. (dist(x,closest_point s x))) continuous (at x)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [continuous_at] THEN REWRITE_TAC [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] DIST_CLOSEST_POINT_LIPSCHITZ, REAL_LET_TRANS]);

val CONTINUOUS_ON_DIST_CLOSEST_POINT = store_thm ("CONTINUOUS_ON_DIST_CLOSEST_POINT",
 ``!s t. closed s /\ ~(s = {})
         ==> (\x. (dist(x,closest_point s x))) continuous_on t``,
  METIS_TAC[CONTINUOUS_AT_IMP_CONTINUOUS_ON,
            CONTINUOUS_AT_DIST_CLOSEST_POINT]);

val UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT = store_thm ("UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT",
 ``!s t:real->bool.
        closed s /\ ~(s = {})
        ==> (\x. (dist(x,closest_point s x))) uniformly_continuous_on t``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  REWRITE_TAC [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] DIST_CLOSEST_POINT_LIPSCHITZ, REAL_LET_TRANS]);

val SEGMENT_TO_CLOSEST_POINT = store_thm ("SEGMENT_TO_CLOSEST_POINT",
 ``!s a:real.
        closed s /\ ~(s = {})
        ==> (segment(a,closest_point s a) INTER s = {})``,
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> !x. x IN s ==> ~(x IN t)``] THEN
  GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP DIST_IN_OPEN_SEGMENT) THEN
  MATCH_MP_TAC(TAUT `(r ==> ~p) ==> p /\ q ==> ~r`) THEN
  METIS_TAC [CLOSEST_POINT_EXISTS, REAL_NOT_LT, DIST_SYM]);

val SEGMENT_TO_POINT_EXISTS = store_thm ("SEGMENT_TO_POINT_EXISTS",
 ``!s a:real.
        closed s /\ ~(s = {}) ==> ?b. b IN s /\ (segment(a,b) INTER s = {})``,
  MESON_TAC[SEGMENT_TO_CLOSEST_POINT, CLOSEST_POINT_EXISTS]);

val CLOSEST_POINT_IN_INTERIOR = store_thm
  ("CLOSEST_POINT_IN_INTERIOR",
 ``!s x:real.
        closed s /\ ~(s = {})
        ==> ((closest_point s x) IN interior s <=> x IN interior s)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``(x:real) IN s`` THEN
  ASM_SIMP_TAC std_ss [CLOSEST_POINT_SELF] THEN
  MATCH_MP_TAC(TAUT `~q /\ ~p ==> (p <=> q)`) THEN
  CONJ_TAC THENL [METIS_TAC[INTERIOR_SUBSET, SUBSET_DEF], STRIP_TAC] THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [IN_INTERIOR_CBALL]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``closest_point s (x:real) IN s`` ASSUME_TAC THENL
   [METIS_TAC[INTERIOR_SUBSET, SUBSET_DEF], ALL_TAC] THEN
  SUBGOAL_THEN ``~(closest_point s (x:real) = x)`` ASSUME_TAC THENL
   [ASM_MESON_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``x:real``,
  ``closest_point s x -
    (min (&1) (e / abs(closest_point s x - x))) *
    (closest_point s x - x):real``]
    CLOSEST_POINT_LE) THEN
  ASM_REWRITE_TAC[dist, NOT_IMP, REAL_ARITH
   ``x - (y - e * (y - x)):real = (&1 - e) * (x - y:real)``] THEN
  CONJ_TAC THENL
  [ (* goal 1 (of 2) *)
    UNDISCH_TAC ``cball (closest_point s x,e) SUBSET s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
    REWRITE_TAC[dist, IN_CBALL, REAL_ARITH ``abs(a:real - a - x) = abs x``] THEN
    SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM REAL_SUB_0]) THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [ABS_NZ]) THEN

    ASM_SIMP_TAC std_ss [GSYM REAL_LE_RDIV_EQ, min_def] THEN
    KNOW_TAC ``!a:real. &0 <= a ==> abs (if 1 <= a then 1 else a) <= a``
    >- ( RW_TAC real_ss [] >> PROVE_TAC [abs, REAL_LE_REFL] ) THEN
    DISCH_THEN MATCH_MP_TAC THEN
    ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, REAL_LE_DIV, ABS_POS],
    (* goal 2 (of 2) *)
    REWRITE_TAC[ABS_MUL, REAL_ARITH
     ``~(n <= a * n) <=> &0 < (&1 - a) * n:real``] THEN
    MATCH_MP_TAC REAL_LT_MUL THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(a <> b) <=> (b - a <> 0:real)``]) THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [ABS_NZ]) THEN ASM_SIMP_TAC std_ss [] THEN
    KNOW_TAC ``!e:real. &0 < e /\ e <= &1 ==> &0 < &1 - abs(&1 - e)``
    >- ( RW_TAC real_ss [] \\
         `0 <= 1 - e'` by ASM_REAL_ARITH_TAC \\
         ASM_SIMP_TAC real_ss [abs] ) THEN
    DISCH_THEN MATCH_MP_TAC THEN
    REWRITE_TAC[REAL_MIN_LE, REAL_LT_MIN, REAL_LT_01, REAL_LE_REFL] THEN
    METIS_TAC [REAL_LT_DIV, ABS_SUB] ]);

val CLOSEST_POINT_IN_FRONTIER = store_thm ("CLOSEST_POINT_IN_FRONTIER",
 ``!s x:real.
        closed s /\ ~(s = {}) /\ ~(x IN interior s)
        ==> (closest_point s x) IN frontier s``,
  SIMP_TAC std_ss [frontier, IN_DIFF, CLOSEST_POINT_IN_INTERIOR] THEN
  SIMP_TAC std_ss [CLOSEST_POINT_IN_SET, CLOSURE_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* More general infimum of distance between two sets.                        *)
(* ------------------------------------------------------------------------- *)

val setdist = new_definition ("setdist",
 ``setdist(s,t) =
        if (s = {}) \/ (t = {}) then &0
        else inf {dist(x,y) | x IN s /\ y IN t}``);

val SETDIST_EMPTY = store_thm ("SETDIST_EMPTY",
 ``(!t. setdist({},t) = &0) /\ (!s. setdist(s,{}) = &0)``,
  REWRITE_TAC[setdist]);

val SETDIST_POS_LE = store_thm ("SETDIST_POS_LE",
 ``!s t. &0 <= setdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_INF THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, DIST_POS_LE] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_SUBSETS_EQ = store_thm ("SETDIST_SUBSETS_EQ",
 ``!s t s' t':real->bool.
     s' SUBSET s /\ t' SUBSET t /\
     (!x y. x IN s /\ y IN t
            ==> ?x' y'. x' IN s' /\ y' IN t' /\ dist(x',y') <= dist(x,y))
     ==> (setdist(s',t') = setdist(s,t))``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [ASM_CASES_TAC ``s':real->bool = {}`` THEN
    ASM_REWRITE_TAC[SETDIST_EMPTY] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [ASM_CASES_TAC ``t':real->bool = {}`` THEN
    ASM_REWRITE_TAC[SETDIST_EMPTY] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``s':real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``t':real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  ASM_REWRITE_TAC[setdist] THEN MATCH_MP_TAC INF_EQ THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  CONJ_TAC >- (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
                                EXISTS_PROD, NOT_IN_EMPTY] \\
               fs [GSYM MEMBER_NOT_EMPTY] \\
               rename1 `a IN s'` >> Q.EXISTS_TAC `a` \\
               rename1 `b IN t'` >> Q.EXISTS_TAC `b` \\
               ASM_REWRITE_TAC []) \\
  CONJ_TAC >- (Q.EXISTS_TAC `0` >> rw [DIST_POS_LE]) \\
  CONJ_TAC >- (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
                                EXISTS_PROD, NOT_IN_EMPTY] \\
               fs [GSYM MEMBER_NOT_EMPTY] \\
               rename1 `a IN s` >> Q.EXISTS_TAC `a` \\
               rename1 `b IN t` >> Q.EXISTS_TAC `b` \\
               ASM_REWRITE_TAC []) \\
  CONJ_TAC >- (Q.EXISTS_TAC `0` >> rw [DIST_POS_LE]) \\
  ASM_MESON_TAC[SUBSET_DEF, REAL_LE_TRANS]);

val REAL_LE_SETDIST = store_thm ("REAL_LE_SETDIST",
  ``!s t:real->bool d.
        ~(s = {}) /\ ~(t = {}) /\
        (!x y. x IN s /\ y IN t ==> d <= dist(x,y))
        ==> d <= setdist(s,t)``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[setdist] THEN
  MP_TAC(ISPEC ``{dist(x:real,y) | x IN s /\ y IN t}`` INF) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{dist (x,y) | x IN s /\ y IN t} <> {} /\
             (?b. !x y. x IN s /\ y IN t ==> b <= dist (x,y))`` THENL
   [CONJ_TAC THENL
    [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
     ASM_SET_TAC[], MESON_TAC[DIST_POS_LE]],
     DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_MESON_TAC[]);

val SETDIST_LE_DIST = store_thm ("SETDIST_LE_DIST",
 ``!s t x y:real. x IN s /\ y IN t ==> setdist(s,t) <= dist(x,y)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN
  COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPEC ``{dist(x:real,y) | x IN s /\ y IN t}`` INF) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{dist (x,y) | x IN s /\ y IN t} <> {} /\
             (?b. !x y. x IN s /\ y IN t ==> b <= dist (x,y))`` THENL
   [CONJ_TAC THENL
    [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
     ASM_SET_TAC[], MESON_TAC[DIST_POS_LE]],
     DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_MESON_TAC[]);

val REAL_LE_SETDIST_EQ = store_thm ("REAL_LE_SETDIST_EQ",
 ``!d s t:real->bool.
        d <= setdist(s,t) <=>
        (!x y. x IN s /\ y IN t ==> d <= dist(x,y)) /\
        ((s = {}) \/ (t = {}) ==> d <= &0)``,
  REPEAT GEN_TAC THEN MAP_EVERY ASM_CASES_TAC
   [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, NOT_IN_EMPTY] THEN
  ASM_MESON_TAC[REAL_LE_SETDIST, SETDIST_LE_DIST, REAL_LE_TRANS]);

val REAL_SETDIST_LT_EXISTS = store_thm ("REAL_SETDIST_LT_EXISTS",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\ setdist(s,t) < b
        ==> ?x y. x IN s /\ y IN t /\ dist(x,y) < b``,
  REWRITE_TAC[GSYM REAL_NOT_LE, REAL_LE_SETDIST_EQ] THEN MESON_TAC[]);

val SETDIST_REFL = store_thm ("SETDIST_REFL",
 ``!s:real->bool. setdist(s,s) = &0``,
  GEN_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM, SETDIST_POS_LE] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [ASM_REWRITE_TAC[setdist, REAL_LE_REFL], ALL_TAC] THEN
  ASM_MESON_TAC[SETDIST_LE_DIST, MEMBER_NOT_EMPTY, DIST_REFL]);

val SETDIST_SYM = store_thm ("SETDIST_SYM",
 ``!s t. setdist(s,t) = setdist(t,s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN ONCE_REWRITE_TAC [DISJ_SYM] THEN
  COND_CASES_TAC THEN ONCE_REWRITE_TAC [DISJ_SYM] THEN ASM_SIMP_TAC std_ss [] THEN
  AP_TERM_TAC THEN SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC[DIST_SYM]);

val SETDIST_TRIANGLE = store_thm ("SETDIST_TRIANGLE",
 ``!s a t:real->bool.
        setdist(s,t) <= setdist(s,{a}) + setdist({a},t)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_ADD_LID, SETDIST_POS_LE] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_ADD_RID, SETDIST_POS_LE] THEN
  ONCE_REWRITE_TAC[GSYM REAL_LE_SUB_RADD] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN
  ASM_SIMP_TAC std_ss [NOT_INSERT_EMPTY, IN_SING, CONJ_EQ_IMP,
                  RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``x - y <= z <=> x - z <= y:real``] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN
  ASM_REWRITE_TAC[NOT_INSERT_EMPTY, IN_SING, CONJ_EQ_IMP,
                  RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``y:real`` THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC[REAL_LE_SUB_RADD] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``dist(x:real,y')`` THEN
  ASM_SIMP_TAC std_ss [SETDIST_LE_DIST, dist] THEN REAL_ARITH_TAC);

val SETDIST_SINGS = store_thm ("SETDIST_SINGS",
 ``!x y. setdist({x},{y}) = dist(x,y)``,
  REWRITE_TAC[setdist, NOT_INSERT_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (x,y) = (\x y. dist (x,y)) x y``] THEN
  KNOW_TAC ``!f:real->real->real x y a b. {f x y | x IN {a} /\ y IN {b}} = {f a b}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [],
   DISCH_TAC] THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [INF_INSERT_FINITE, FINITE_EMPTY]);

val SETDIST_LIPSCHITZ = store_thm ("SETDIST_LIPSCHITZ",
 ``!s t x y:real. abs(setdist({x},s) - setdist({y},s)) <= dist(x,y)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM SETDIST_SINGS] THEN
  REWRITE_TAC[REAL_ARITH
   ``abs(x - y) <= z <=> x <= z + y /\ y <= z + x:real``] THEN
  MESON_TAC[SETDIST_TRIANGLE, SETDIST_SYM]);

val CONTINUOUS_AT_SETDIST = store_thm ("CONTINUOUS_AT_SETDIST",
 ``!s x:real. (\y. setdist({y},s)) continuous (at x)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[continuous_at] THEN
  SIMP_TAC std_ss [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] SETDIST_LIPSCHITZ, REAL_LET_TRANS]);

val CONTINUOUS_ON_SETDIST = store_thm ("CONTINUOUS_ON_SETDIST",
 ``!s t:real->bool. (\y. setdist({y},s)) continuous_on t``,
  METIS_TAC[CONTINUOUS_AT_IMP_CONTINUOUS_ON,
            CONTINUOUS_AT_SETDIST]);

val UNIFORMLY_CONTINUOUS_ON_SETDIST = store_thm ("UNIFORMLY_CONTINUOUS_ON_SETDIST",
 ``!s t:real->bool.
         (\y. setdist({y},s)) uniformly_continuous_on t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  BETA_TAC THEN METIS_TAC[dist, SETDIST_LIPSCHITZ, REAL_LET_TRANS]);

val SETDIST_DIFFERENCES = store_thm ("SETDIST_DIFFERENCES",
 ``!s t. setdist(s,t) = setdist({0},{x - y:real | x IN s /\ y IN t})``,
  REPEAT GEN_TAC THEN
  KNOW_TAC ``!f:real->real->real x y s t.
   ({f x y | x IN s /\ y IN t} = {}) <=> (s = {}) \/ (t = {})`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [],
   DISCH_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``x - y = (\x y. x - y) x y:real``] THEN
  ASM_REWRITE_TAC[setdist, NOT_INSERT_EMPTY] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [] THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_SING, EXISTS_PROD] THEN
  SIMP_TAC std_ss [GSYM CONJ_ASSOC, RIGHT_EXISTS_AND_THM, UNWIND_THM2, DIST_0] THEN
  REWRITE_TAC[dist] THEN MESON_TAC[]);

val SETDIST_SUBSET_RIGHT = store_thm ("SETDIST_SUBSET_RIGHT",
 ``!s t u:real->bool.
    ~(t = {}) /\ t SUBSET u ==> setdist(s,u) <= setdist(s,t)``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``u:real->bool = {}``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_EMPTY, SETDIST_POS_LE, REAL_LE_REFL] THEN
  ASM_REWRITE_TAC[setdist] THEN MATCH_MP_TAC REAL_LE_INF_SUBSET THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, SUBSET_DEF, EXISTS_PROD, GSPECIFICATION] THEN
  REPEAT(CONJ_TAC THENL
  [ASM_SIMP_TAC std_ss [EXTENSION, EXISTS_PROD, GSPECIFICATION] THEN ASM_SET_TAC[],
   ALL_TAC]) THEN METIS_TAC[DIST_POS_LE]);

val SETDIST_SUBSET_LEFT = store_thm ("SETDIST_SUBSET_LEFT",
 ``!s t u:real->bool.
    ~(s = {}) /\ s SUBSET t ==> setdist(t,u) <= setdist(s,u)``,
  MESON_TAC[SETDIST_SUBSET_RIGHT, SETDIST_SYM]);

val SETDIST_CLOSURE = store_thm ("SETDIST_CLOSURE",
 ``(!s t:real->bool. setdist(closure s,t) = setdist(s,t)) /\
   (!s t:real->bool. setdist(s,closure t) = setdist(s,t))``,
  REWRITE_TAC [METIS [SWAP_FORALL_THM]
   ``(!s t. setdist (s,closure t) = setdist (s,t)) =
     (!t s. setdist (s,closure t) = setdist (s,t))``] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SETDIST_SYM] THEN
  SIMP_TAC std_ss [] THEN
  REWRITE_TAC[MESON[REAL_LE_ANTISYM]
   ``(x:real = y) <=> !d. d <= x <=> d <= y``] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[CLOSURE_EQ_EMPTY, CLOSURE_EMPTY, NOT_IN_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``d <= dist (x,y) <=> (\x y. d <= dist (x,y)) x y``] THEN
  ONCE_REWRITE_TAC [METIS [] ``x IN s /\ y IN t <=> x IN s /\ (\y. y IN t) y``] THEN
  MATCH_MP_TAC(SET_RULE
   ``s SUBSET c /\
    (!y. Q y /\ (!x. x IN s ==> P x y) ==> (!x. x IN c ==> P x y))
   ==> ((!x y. x IN c /\ Q y ==> P x y) <=>
        (!x y. x IN s /\ Q y ==> P x y))``) THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET] THEN GEN_TAC THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (x,y) = (\x. dist (x, y)) x``] THEN
  MATCH_MP_TAC CONTINUOUS_GE_ON_CLOSURE THEN ASM_SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [o_DEF, dist] THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y) = abs ((\x. x - y) x:real)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ABS_COMPOSE THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]);

val SETDIST_FRONTIER = store_thm ("SETDIST_FRONTIER",
 ``(!s t:real->bool.
        DISJOINT s t ==> (setdist(frontier s,t) = setdist(s,t))) /\
   (!s t:real->bool.
        DISJOINT s t ==> (setdist(s,frontier t) = setdist(s,t)))``,
  MATCH_MP_TAC(TAUT `(p ==> q) /\ p ==> p /\ q`) THEN
  CONJ_TAC THENL [MESON_TAC[SETDIST_SYM, DISJOINT_SYM], ALL_TAC] THEN
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM(CONJUNCT1 SETDIST_CLOSURE)] THEN
  MATCH_MP_TAC SETDIST_SUBSETS_EQ THEN
  SIMP_TAC std_ss [frontier, IN_DIFF, DIFF_SUBSET, SUBSET_REFL] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  ASM_CASES_TAC  ``(x:real) IN interior s`` THENL
   [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN
  KNOW_TAC ``?y' x'. (x' IN closure s /\ x' NOTIN interior s) /\
                      y' IN t /\ dist (x',y') <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  EXISTS_TAC ``y:real`` THEN ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL [``segment[x:real,y]``, ``s:real->bool``]
        CONNECTED_INTER_FRONTIER) THEN
  REWRITE_TAC[CONNECTED_SEGMENT, GSYM MEMBER_NOT_EMPTY] THEN
  KNOW_TAC ``(?x'. x' IN segment [(x,y)] INTER s) /\
             (?x'. x' IN segment [(x,y)] DIFF s)`` THENL
   [CONJ_TAC THENL [EXISTS_TAC ``x:real``, EXISTS_TAC ``y:real``] THEN
    ASM_SIMP_TAC std_ss [IN_INTER, IN_DIFF, ENDS_IN_SEGMENT] THEN
    MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
    POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, frontier, IN_DIFF] THEN
    MESON_TAC[DIST_IN_CLOSED_SEGMENT]]);

val SETDIST_COMPACT_CLOSED = store_thm ("SETDIST_COMPACT_CLOSED",
 ``!s t:real->bool.
        compact s /\ closed t /\ ~(s = {}) /\ ~(t = {})
        ==> ?x y. x IN s /\ y IN t /\ (dist(x,y) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
  KNOW_TAC ``?x y. (\x. x IN s) x /\ (\y. y IN t) y /\
                   (\x y. dist (x,y) <= setdist (s,t)) x y /\
                   (\x y. setdist (s,t) <= dist (x,y)) x y`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS []
   ``(!x y. P x /\ Q y ==> R' x y) /\ (?x y. (P x /\ Q y /\ R x y))
    ==> (?x y. P x /\ Q y /\ R x y /\ R' x y)``) THEN
  SIMP_TAC std_ss [SETDIST_LE_DIST] THEN
  ASM_REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
        DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [COMPACT_CLOSED_DIFFERENCES, EXISTS_IN_GSPEC, FORALL_IN_GSPEC,
               DIST_0, GSYM CONJ_ASSOC, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[dist] THEN DISCH_THEN MATCH_MP_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_CLOSED_COMPACT = store_thm ("SETDIST_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t /\ ~(s = {}) /\ ~(t = {})
        ==> ?x y. x IN s /\ y IN t /\ (dist(x,y) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
   KNOW_TAC ``?x y. (\x. x IN s) x /\ (\y. y IN t) y /\
                   (\x y. dist (x,y) <= setdist (s,t)) x y /\
                   (\x y. setdist (s,t) <= dist (x,y)) x y`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS[]
   ``(!x y. P x /\ Q y ==> R' x y) /\ (?x y. P x /\ Q y /\ R x y)
    ==> ?x y. P x /\ Q y /\ R x y /\ R' x y``) THEN
  SIMP_TAC std_ss [SETDIST_LE_DIST] THEN
  ASM_REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
        DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [CLOSED_COMPACT_DIFFERENCES, EXISTS_IN_GSPEC, FORALL_IN_GSPEC,
               DIST_0, GSYM CONJ_ASSOC, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[dist] THEN DISCH_THEN MATCH_MP_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_EQ_0_COMPACT_CLOSED = store_thm ("SETDIST_EQ_0_COMPACT_CLOSED",
 ``!s t:real->bool.
        compact s /\ closed t
        ==> ((setdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ ~(s INTER t = {}))``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY] THEN EQ_TAC THENL
   [MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
      SETDIST_COMPACT_CLOSED) THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN MESON_TAC[DIST_EQ_0],
    REWRITE_TAC[GSYM REAL_LE_ANTISYM, SETDIST_POS_LE] THEN
    REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
    MESON_TAC[SETDIST_LE_DIST, DIST_EQ_0]]);

val SETDIST_EQ_0_CLOSED_COMPACT = store_thm ("SETDIST_EQ_0_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t
        ==> ((setdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ ~(s INTER t = {}))``,
  ONCE_REWRITE_TAC[SETDIST_SYM] THEN
  SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED] THEN SET_TAC[]);

val SETDIST_EQ_0_BOUNDED = store_thm ("SETDIST_EQ_0_BOUNDED",
 ``!s t:real->bool.
        (bounded s \/ bounded t)
        ==> ((setdist(s,t) = &0) <=>
             (s = {}) \/ (t = {}) \/ ~(closure(s) INTER closure(t) = {}))``,
  REPEAT GEN_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[MESON[SETDIST_CLOSURE]
   ``setdist(s,t) = setdist(closure s,closure t)``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED, SETDIST_EQ_0_CLOSED_COMPACT,
               COMPACT_CLOSURE, CLOSED_CLOSURE, CLOSURE_EQ_EMPTY]);

val SETDIST_TRANSLATION = store_thm ("SETDIST_TRANSLATION",
 ``!a:real s t.
        setdist(IMAGE (\x. a + x) s,IMAGE (\x. a + x) t) = setdist(s,t)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[SETDIST_DIFFERENCES] THEN
  AP_TERM_TAC THEN AP_TERM_TAC THEN
  KNOW_TAC ``!f:real->real->real x:real y:real g:real->real s:real->bool t:real->bool.
   {f x y | x IN IMAGE g s /\ y IN IMAGE g t} = {f (g x) (g y) | x IN s /\ y IN t}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
   ASM_SET_TAC[], DISCH_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``x - y = (\x y. x - y) x y:real``] THEN
  ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(a + x) - (a + y):real = x - y``]);

val SETDIST_LINEAR_IMAGE = store_thm ("SETDIST_LINEAR_IMAGE",
 ``!f:real->real s t.
        linear f /\ (!x. abs(f x) = abs x)
        ==> (setdist(IMAGE f s,IMAGE f t) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[setdist, IMAGE_EQ_EMPTY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[dist] THEN AP_TERM_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y) = (\x y. abs (x - y)) x y:real``] THEN
  KNOW_TAC ``!f:real->real->real x:real y:real g:real->real s:real->bool t:real->bool.
   {f x y | x IN IMAGE g s /\ y IN IMAGE g t} = {f (g x) (g y) | x IN s /\ y IN t}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
   ASM_SET_TAC[], DISCH_TAC] THEN ASM_REWRITE_TAC [] THEN BETA_TAC THEN
  FIRST_X_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_SUB th)]) THEN
  ASM_SIMP_TAC std_ss []);

val SETDIST_UNIQUE = store_thm ("SETDIST_UNIQUE",
 ``!s t a b:real d.
        a IN s /\ b IN t /\ (dist(a,b) = d) /\
        (!x y. x IN s /\ y IN t ==> dist(a,b) <= dist(x,y))
        ==> (setdist(s,t) = d)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [ASM_MESON_TAC[SETDIST_LE_DIST],
    MATCH_MP_TAC REAL_LE_SETDIST THEN ASM_SET_TAC[]]);

val SETDIST_UNIV = store_thm ("SETDIST_UNIV",
 ``(!s. setdist(s,univ(:real)) = &0) /\
   (!t. setdist(univ(:real),t) = &0)``,
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SETDIST_SYM] THEN
  REWRITE_TAC[] THEN X_GEN_TAC ``s:real->bool`` THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[SETDIST_EMPTY] THEN
  MATCH_MP_TAC SETDIST_UNIQUE THEN
  SIMP_TAC std_ss [IN_UNIV, DIST_EQ_0, RIGHT_EXISTS_AND_THM] THEN
  ASM_REWRITE_TAC[UNWIND_THM1, DIST_REFL, DIST_POS_LE, MEMBER_NOT_EMPTY]);

val SETDIST_ZERO = store_thm ("SETDIST_ZERO",
 ``!s t:real->bool. ~(DISJOINT s t) ==> (setdist(s,t) = &0)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_UNIQUE THEN
  KNOW_TAC ``?a. a IN s /\ a IN t /\ (dist (a,a) = 0) /\
             !x y. x IN s /\ y IN t ==> dist (a,a) <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r /\ s <=> r /\ p /\ q /\ s`] THEN
  REWRITE_TAC[DIST_EQ_0, UNWIND_THM2, DIST_REFL, DIST_POS_LE] THEN
  ASM_SET_TAC[]);

val SETDIST_ZERO_STRONG = store_thm ("SETDIST_ZERO_STRONG",
 ``!s t:real->bool.
      ~(DISJOINT (closure s) (closure t)) ==> (setdist(s,t) = &0)``,
  MESON_TAC[SETDIST_CLOSURE, SETDIST_ZERO]);

val SETDIST_FRONTIERS = store_thm ("SETDIST_FRONTIERS",
 ``!s t:real->bool.
        setdist(s,t) =
        if DISJOINT s t then setdist(frontier s,frontier t) else &0``,
  REPEAT STRIP_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [SETDIST_ZERO] THEN
  ASSUME_TAC SETDIST_FRONTIER THEN POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  DISCH_THEN (CONJUNCTS_THEN2 K_TAC ASSUME_TAC) THEN ASM_SIMP_TAC std_ss [] THEN
  POP_ASSUM K_TAC THEN
  ASM_CASES_TAC ``DISJOINT s (frontier t:real->bool)`` THENL
   [ASM_MESON_TAC[SETDIST_FRONTIER], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [GSYM(CONJUNCT1 SETDIST_CLOSURE)] THEN
  CONV_TAC SYM_CONV THEN MATCH_MP_TAC SETDIST_SUBSETS_EQ THEN
  SIMP_TAC std_ss [frontier, DIFF_SUBSET, SUBSET_REFL, IN_DIFF] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  KNOW_TAC ``?y' x'.
  (x' IN closure s /\ x' NOTIN interior s) /\
  (y' IN closure t /\ y' NOTIN interior t) /\ dist (x',y') <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN EXISTS_TAC ``y:real`` THEN
  ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC ``(x:real) IN interior s`` THENL
   [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN
  MP_TAC(ISPECL [``segment[x:real,y]``, ``interior s:real->bool``]
        CONNECTED_INTER_FRONTIER) THEN
  REWRITE_TAC[CONNECTED_SEGMENT, GSYM MEMBER_NOT_EMPTY] THEN
  KNOW_TAC ``(?x'. x' IN segment [(x,y)] INTER interior s) /\
             (?x'. x' IN segment [(x,y)] DIFF interior s)`` THENL
   [CONJ_TAC THENL [EXISTS_TAC ``x:real``, EXISTS_TAC ``y:real``] THEN
    ASM_SIMP_TAC std_ss [IN_INTER, IN_DIFF, ENDS_IN_SEGMENT] THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
     ``y IN u ==> (u INTER v = {}) ==> ~(y IN v)``)) THEN
    REWRITE_TAC[INTERIOR_CLOSURE, SET_RULE
     ``(s INTER (UNIV DIFF t) = {}) <=> s SUBSET t``] THEN
    MATCH_MP_TAC SUBSET_CLOSURE THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
    POP_ASSUM MP_TAC THEN
    SIMP_TAC std_ss [IN_INTER, GSYM frontier, GSYM IN_DIFF] THEN
    MESON_TAC[FRONTIER_INTERIOR_SUBSET, SUBSET_DEF, DIST_IN_CLOSED_SEGMENT]]);

val SETDIST_SING_FRONTIER = store_thm ("SETDIST_SING_FRONTIER",
 ``!s x:real. ~(x IN s) ==> (setdist({x},frontier s) = setdist({x},s))``,
  MESON_TAC[SET_RULE ``DISJOINT {x} s <=> ~(x IN s)``, SETDIST_FRONTIER]);

val SETDIST_CLOSEST_POINT = store_thm ("SETDIST_CLOSEST_POINT",
 ``!a:real s.
      closed s /\ ~(s = {}) ==> (setdist({a},s) = dist(a,closest_point s a))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_UNIQUE THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, IN_SING, UNWIND_THM2] THEN
  EXISTS_TAC ``closest_point s (a:real)`` THEN
  ASM_MESON_TAC[CLOSEST_POINT_EXISTS, DIST_SYM]);

val SETDIST_EQ_0_SING = store_thm ("SETDIST_EQ_0_SING",
 ``(!s x:real. (setdist({x},s) = &0) <=> (s = {}) \/ x IN closure s) /\
   (!s x:real. (setdist(s,{x}) = &0) <=> (s = {}) \/ x IN closure s)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_BOUNDED, BOUNDED_SING, CLOSURE_SING] THEN SET_TAC[]);

val SETDIST_EQ_0_CLOSED = store_thm ("SETDIST_EQ_0_CLOSED",
 ``!s x. closed s ==> ((setdist({x},s) = &0) <=> (s = {}) \/ x IN s)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED, COMPACT_SING] THEN SET_TAC[]);

val SETDIST_EQ_0_CLOSED_IN = store_thm ("SETDIST_EQ_0_CLOSED_IN",
 ``!u s x. closed_in (subtopology euclidean u) s /\ x IN u
           ==> ((setdist({x},s) = &0) <=> (s = {}) \/ x IN s)``,
  REWRITE_TAC[SETDIST_EQ_0_SING, CLOSED_IN_INTER_CLOSURE] THEN SET_TAC[]);

val SETDIST_SING_IN_SET = store_thm ("SETDIST_SING_IN_SET",
 ``!x s. x IN s ==> (setdist({x},s) = &0)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_SING, REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET]);

val SETDIST_SING_FRONTIER_CASES = store_thm ("SETDIST_SING_FRONTIER_CASES",
 ``!s x:real.
        setdist({x},s) = if x IN s then &0 else setdist({x},frontier s)``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, SETDIST_SING_FRONTIER]);

val SETDIST_SING_TRIANGLE = store_thm ("SETDIST_SING_TRIANGLE",
 ``!s x y:real. abs(setdist({x},s) - setdist({y},s)) <= dist(x,y)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_SUB_REFL, ABS_N, DIST_POS_LE] THEN
  REWRITE_TAC[ABS_BOUNDS, REAL_NEG_SUB] THEN REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a - b <= c <=> a - c <= b:real``,
                   REAL_ARITH ``-a <= b - c <=> c - a <= b:real``] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN ASM_REWRITE_TAC[NOT_INSERT_EMPTY] THEN
  SIMP_TAC std_ss [IN_SING, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN REWRITE_TAC [dist] THENL
   [MATCH_MP_TAC(REAL_ARITH
     ``a <= abs(y:real - z) ==> a - abs(x - y) <= abs(x - z:real)``),
    MATCH_MP_TAC(REAL_ARITH
     ``a <= abs(x:real - z) ==> a - abs(x - y) <= abs(y - z)``)] THEN
  REWRITE_TAC [GSYM dist] THEN
  MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_REWRITE_TAC[IN_SING]);

val SETDIST_LE_SING = store_thm ("SETDIST_LE_SING",
 ``!s t x:real. x IN s ==> setdist(s,t) <= setdist({x},t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_SUBSET_LEFT THEN ASM_SET_TAC[]);

val SETDIST_BALLS = store_thm ("SETDIST_BALLS",
 ``(!a b:real r s.
        setdist(ball(a,r),ball(b,s)) =
        if r <= &0 \/ s <= &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(ball(a,r),cball(b,s)) =
        if r <= &0 \/ s < &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(cball(a,r),ball(b,s)) =
        if r < &0 \/ s <= &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(cball(a,r),cball(b,s)) =
        if r < &0 \/ s < &0 then &0 else max (&0) (dist(a,b) - (r + s)))``,
  REWRITE_TAC[METIS[]
   ``(x = if p then y else z) <=> (p ==> (x = y)) /\ (~p ==> (x = z))``] THEN
  SIMP_TAC std_ss [TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC std_ss [BALL_EMPTY, CBALL_EMPTY, SETDIST_EMPTY, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[METIS[SETDIST_CLOSURE]
   ``setdist(s,t) = setdist(closure s,closure t)``] THEN
  SIMP_TAC std_ss [REAL_NOT_LE, REAL_NOT_LT, CLOSURE_BALL] THEN
  REWRITE_TAC[SETDIST_CLOSURE] THEN
  MATCH_MP_TAC(TAUT `(s ==> p /\ q /\ r) /\ s ==> p /\ q /\ r /\ s`) THEN
  CONJ_TAC THENL [METIS_TAC[REAL_LT_IMP_LE], REPEAT GEN_TAC] THEN
  REWRITE_TAC[max_def, REAL_SUB_LE] THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [SETDIST_EQ_0_BOUNDED, BOUNDED_CBALL, CLOSED_CBALL, CLOSURE_CLOSED,
           CBALL_EQ_EMPTY, INTER_BALLS_EQ_EMPTY]
  THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  ASM_CASES_TAC ``b:real = a`` THENL
   [FIRST_X_ASSUM SUBST_ALL_TAC THEN
    RULE_ASSUM_TAC(REWRITE_RULE[DIST_REFL]) THEN
    ASM_CASES_TAC ``(r = &0:real) /\ (s = &0:real)`` THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
    ASM_SIMP_TAC std_ss [CBALL_SING, SETDIST_SINGS, dist] THEN REAL_ARITH_TAC,
    STRIP_TAC] THEN
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [ALL_TAC,
    MATCH_MP_TAC REAL_LE_SETDIST THEN
    ASM_REWRITE_TAC[CBALL_EQ_EMPTY, REAL_NOT_LT, IN_CBALL, dist] THEN
    REAL_ARITH_TAC] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``dist(a + r / dist(a,b) * (b - a):real,
                   b - s / dist(a,b) * (b - a))`` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC SETDIST_LE_DIST THEN
    REWRITE_TAC[dist, IN_CBALL, REAL_ARITH ``abs(a - (a + x)) = abs x:real``,
                                REAL_ARITH ``abs(a - (a - x)) = abs x:real``] THEN
    REWRITE_TAC [GSYM dist] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
    FULL_SIMP_TAC real_ss [dist, ABS_MUL, ABS_DIV, ABS_ABS, ABS_NZ,
      REAL_LT_IMP_NE, REAL_ARITH ``(b <> a) = (b - a <> 0:real)``] THEN
    KNOW_TAC ``abs (b - a:real) <> 0`` THENL [METIS_TAC [REAL_LT_IMP_NE], DISCH_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_SUB_0, ABS_ZERO] THEN
    ASM_REAL_ARITH_TAC,
    REWRITE_TAC[dist, REAL_ARITH
     ``(a + d * (b - a)) - (b - e * (b - a)):real =
       (&1 - d - e) * (a - b:real)``] THEN
    REWRITE_TAC[ABS_MUL, real_div, REAL_ARITH
      ``&1 - r * y - s * y = &1 - (r + s) * y:real``] THEN REWRITE_TAC [GSYM real_div] THEN
    REWRITE_TAC [METIS [GSYM ABS_ABS] ``d * abs (a - b) = d * abs(abs (a - b:real))``] THEN
    REWRITE_TAC[GSYM ABS_MUL] THEN
    KNOW_TAC ``!n x:real. ~(n = &0) ==> ((&1 - x / n) * n = n - x)`` THENL
    [REPEAT GEN_TAC THEN DISCH_TAC THEN
     ASM_SIMP_TAC std_ss [REAL_SUB_RDISTRIB, REAL_DIV_RMUL] THEN
     REAL_ARITH_TAC, DISCH_TAC] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(b <> a) = (abs (a - b) <> 0:real)``]) THEN
    ASM_SIMP_TAC real_ss [REAL_SUB_0, ABS_ZERO] THEN
    FULL_SIMP_TAC std_ss [dist] THEN SIMP_TAC std_ss [REAL_LE_LT] THEN
    DISJ2_TAC THEN REWRITE_TAC [ABS_REFL, REAL_SUB_LE] THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* Use set distance for an easy proof of separation properties etc.          *)
(* ------------------------------------------------------------------------- *)

val SEPARATION_CLOSURES = store_thm ("SEPARATION_CLOSURES",
 ``!s t:real->bool.
        (s INTER closure(t) = {}) /\ (t INTER closure(s) = {})
        ==> ?u v. DISJOINT u v /\ open u /\ open v /\
                  s SUBSET u /\ t SUBSET v``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``{}:real->bool``, ``univ(:real)``] THEN
    ASM_REWRITE_TAC[OPEN_EMPTY, OPEN_UNIV] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``univ(:real)``, ``{}:real->bool``] THEN
    ASM_REWRITE_TAC[OPEN_EMPTY, OPEN_UNIV] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  EXISTS_TAC ``{x | x IN univ(:real) /\
                   (setdist({x},t) - setdist({x},s)) IN
                   {x | &0 < x}}`` THEN
  EXISTS_TAC ``{x | x IN univ(:real) /\
                   (setdist({x},t) - setdist({x},s)) IN
                   {x | x < &0}}`` THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[SET_RULE ``DISJOINT s t <=> !x. x IN s /\ x IN t ==> F``] THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV] THEN REAL_ARITH_TAC,
    ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                             (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE THEN
    SIMP_TAC std_ss [REWRITE_RULE[real_gt] OPEN_HALFSPACE_COMPONENT_GT, OPEN_UNIV] THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST],
    ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                             (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE THEN
    SIMP_TAC std_ss [OPEN_HALFSPACE_COMPONENT_LT, OPEN_UNIV] THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST],
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNIV] THEN
    GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC(REAL_ARITH
     ``&0 <= x /\ (y = &0) /\ ~(x = &0) ==> &0 < x - y:real``),
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNIV] THEN
    GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC(REAL_ARITH
     ``&0 <= y /\ (x = &0) /\ ~(y = &0) ==> x - y < &0:real``)] THEN
  ASM_SIMP_TAC std_ss [SETDIST_POS_LE, SETDIST_EQ_0_BOUNDED, BOUNDED_SING] THEN
  ASM_SIMP_TAC std_ss [CLOSED_SING, CLOSURE_CLOSED, NOT_INSERT_EMPTY,
               REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET,
               SET_RULE ``({a} INTER s = {}) <=> ~(a IN s)``] THEN
  ASM_SET_TAC[]);

val SEPARATION_NORMAL = store_thm ("SEPARATION_NORMAL",
 ``!s t:real->bool.
        closed s /\ closed t /\ (s INTER t = {})
        ==> ?u v. open u /\ open v /\
                  s SUBSET u /\ t SUBSET v /\ (u INTER v = {})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM DISJOINT_DEF] THEN
  ONCE_REWRITE_TAC[TAUT
    `a /\ b /\ c /\ d /\ e <=> e /\ a /\ b /\ c /\ d`] THEN
  MATCH_MP_TAC SEPARATION_CLOSURES THEN
  ASM_SIMP_TAC std_ss [CLOSURE_CLOSED] THEN ASM_SET_TAC[]);

val SEPARATION_NORMAL_LOCAL = store_thm ("SEPARATION_NORMAL_LOCAL",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {})
        ==> ?s' t'. open_in (subtopology euclidean u) s' /\
                    open_in (subtopology euclidean u) t' /\
                    s SUBSET s' /\ t SUBSET t' /\ (s' INTER t' = {})``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``{}:real->bool``, ``u:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_REFL, OPEN_IN_EMPTY, INTER_EMPTY, EMPTY_SUBSET] THEN
    ASM_MESON_TAC[CLOSED_IN_IMP_SUBSET],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``u:real->bool``, ``{}:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_REFL, OPEN_IN_EMPTY, INTER_EMPTY, EMPTY_SUBSET] THEN
    ASM_MESON_TAC[CLOSED_IN_IMP_SUBSET],
    ALL_TAC] THEN
  EXISTS_TAC ``{x:real | x IN u /\ setdist({x},s) < setdist({x},t)}`` THEN
  EXISTS_TAC ``{x:real | x IN u /\ setdist({x},t) < setdist({x},s)}`` THEN
  SIMP_TAC std_ss [EXTENSION, SUBSET_DEF, GSPECIFICATION, SETDIST_SING_IN_SET, IN_INTER,
           NOT_IN_EMPTY, SETDIST_POS_LE, CONJ_ASSOC,
           REAL_ARITH ``&0 < x <=> &0 <= x /\ ~(x = &0:real)``] THEN
  CONJ_TAC THENL [ALL_TAC, METIS_TAC[REAL_LT_ANTISYM]] THEN
  ONCE_REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [ALL_TAC,
    ASM_MESON_TAC[SETDIST_EQ_0_CLOSED_IN, CLOSED_IN_IMP_SUBSET, SUBSET_DEF,
                  MEMBER_NOT_EMPTY, IN_INTER]] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN
  ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                           (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
  REWRITE_TAC[SET_RULE
   ``{x:real | x IN u /\ &0 < (f:real->real) x} =
     {x:real | x IN u /\ f x IN {x | &0 < x}}``] THEN
  CONJ_TAC THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE THEN
  REWRITE_TAC[OPEN_HALFSPACE_COMPONENT_LT,
           REWRITE_RULE[real_gt] OPEN_HALFSPACE_COMPONENT_GT, OPEN_UNIV] THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST]);

val SEPARATION_NORMAL_COMPACT = store_thm ("SEPARATION_NORMAL_COMPACT",
 ``!s t:real->bool.
        compact s /\ closed t /\ (s INTER t = {})
        ==> ?u v. open u /\ compact(closure u) /\ open v /\
                  s SUBSET u /\ t SUBSET v /\ (u INTER v = {})``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
  REPEAT STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_BALL) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t UNION (univ(:real) DIFF ball(0,r))``]
        SEPARATION_NORMAL) THEN
  ASM_SIMP_TAC std_ss [CLOSED_UNION, GSYM OPEN_CLOSED, OPEN_BALL] THEN
  KNOW_TAC ``((s :real -> bool) INTER
  ((t :real -> bool) UNION
   (univ(:real) DIFF ball ((0 :real),(r :real)))) =
  ({} :real -> bool))`` THENL [ASM_SET_TAC[], DISCH_TAC THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``u:real->bool`` THEN
  EXISTS_TAC ``v:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL [MATCH_MP_TAC BOUNDED_CLOSURE, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC BOUNDED_SUBSET THEN EXISTS_TAC ``ball(0:real,r)`` THEN
  REWRITE_TAC[BOUNDED_BALL] THEN ASM_SET_TAC[]);

val SEPARATION_HAUSDORFF = store_thm ("SEPARATION_HAUSDORFF",
 ``!x:real y.
      ~(x = y)
      ==> ?u v. open u /\ open v /\ x IN u /\ y IN v /\ (u INTER v = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``{x:real}``, ``{y:real}``] SEPARATION_NORMAL) THEN
  REWRITE_TAC[SING_SUBSET, CLOSED_SING] THEN
  DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val SEPARATION_T2 = store_thm ("SEPARATION_T2",
 ``!x:real y.
        ~(x = y) <=> ?u v. open u /\ open v /\ x IN u /\ y IN v /\
                           (u INTER v = {})``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC std_ss [SEPARATION_HAUSDORFF] THEN
  REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN MESON_TAC[]);

val SEPARATION_T1 = store_thm ("SEPARATION_T1",
 ``!x:real y.
        ~(x = y) <=> ?u v. open u /\ open v /\ x IN u /\ ~(y IN u) /\
                           ~(x IN v) /\ y IN v``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_SIMP_TAC std_ss [SEPARATION_T2, EXTENSION, NOT_IN_EMPTY, IN_INTER],
    ALL_TAC] THEN MESON_TAC[]);

val SEPARATION_T0 = store_thm ("SEPARATION_T0",
 ``!x:real y. ~(x = y) <=> ?u. open u /\ ~(x IN u <=> y IN u)``,
  MESON_TAC[SEPARATION_T1]);

(* ------------------------------------------------------------------------- *)
(* Connectedness of the intersection of a chain.                             *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_CHAIN = store_thm ("CONNECTED_CHAIN",
 ``!f:(real->bool)->bool.
        (!s. s IN f ==> compact s /\ connected s) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
        ==> connected(BIGINTER f)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGINTER_EMPTY, CONNECTED_UNIV] THEN
  ABBREV_TAC ``c:real->bool = BIGINTER f`` THEN
  SUBGOAL_THEN ``compact(c:real->bool)`` ASSUME_TAC THENL
   [EXPAND_TAC "c" THEN MATCH_MP_TAC COMPACT_BIGINTER THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_CLOSED_SET, COMPACT_IMP_CLOSED, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``a:real->bool``, ``b:real->bool``] THEN CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL [``a:real->bool``, ``b:real->bool``] SEPARATION_NORMAL) THEN
  ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``?k:real->bool. k IN f`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``?n:real->bool. open n /\ k SUBSET n`` MP_TAC THENL
   [ASM_MESON_TAC[BOUNDED_SUBSET_BALL, COMPACT_IMP_BOUNDED, OPEN_BALL],
    REWRITE_TAC[BIGUNION_SUBSET] THEN STRIP_TAC] THEN
  MP_TAC(ISPEC ``k:real->bool`` COMPACT_IMP_HEINE_BOREL) THEN
  ASM_SIMP_TAC std_ss [] THEN
  KNOW_TAC ``~(!(f' :(real -> bool) -> bool).
  ((!(t :real -> bool). t IN f' ==> (open t :bool)) /\
   (k :real -> bool) SUBSET BIGUNION f') ==>
  ?(f'' :(real -> bool) -> bool).
    (f'' SUBSET f') /\ FINITE f'' /\ (k SUBSET BIGUNION f''))`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_THEN (MP_TAC o SPEC
   ``(u UNION v:real->bool) INSERT {n DIFF s | s IN f}``) THEN
  SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_INSERT, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION, OPEN_DIFF, COMPACT_IMP_CLOSED, NOT_IMP] THEN
  CONJ_TAC THENL
   [REWRITE_TAC[BIGUNION_INSERT] THEN REWRITE_TAC[SUBSET_DEF] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN ONCE_REWRITE_TAC[IN_UNION] THEN
    ASM_CASES_TAC ``(x:real) IN c`` THENL [ASM_SET_TAC[], DISJ2_TAC] THEN
    SIMP_TAC std_ss [BIGUNION_IMAGE, GSPECIFICATION] THEN
    UNDISCH_TAC ``~((x:real) IN c)`` THEN
    SUBST1_TAC(SYM(ASSUME ``BIGINTER f:real->bool = c``)) THEN
    SIMP_TAC std_ss [IN_BIGINTER, NOT_FORALL_THM] THEN
    STRIP_TAC THEN EXISTS_TAC ``P:real->bool`` THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  X_GEN_TAC ``g:(real->bool)->bool`` THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[SUBSET_INSERT_DELETE] THEN
  SUBGOAL_THEN ``FINITE(g DELETE (u UNION v:real->bool))`` MP_TAC THENL
   [ASM_REWRITE_TAC[FINITE_DELETE],
    REWRITE_TAC[TAUT `p ==> ~q <=> ~(p /\ q)`]] THEN
  REWRITE_TAC[FINITE_SUBSET_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``f':(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``?j:real->bool. j IN f /\
                   BIGUNION(IMAGE (\s. n DIFF s) f') SUBSET (n DIFF j)``
  STRIP_ASSUME_TAC THENL
   [ASM_CASES_TAC ``f':(real->bool)->bool = {}`` THEN
    ASM_REWRITE_TAC[IMAGE_EMPTY, IMAGE_INSERT, BIGUNION_EMPTY, EMPTY_SUBSET] THENL
     [ASM_SET_TAC[], ALL_TAC] THEN
    SUBGOAL_THEN
     ``?j:real->bool. j IN f' /\
                       BIGUNION(IMAGE (\s. n DIFF s) f') SUBSET (n DIFF j)``
    MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[SUBSET_DEF]] THEN
    SUBGOAL_THEN
     ``!s t:real->bool. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s``
    MP_TAC THENL [ASM_MESON_TAC[SUBSET_DEF], ALL_TAC] THEN
    UNDISCH_TAC ``~(f':(real->bool)->bool = {})`` THEN
    UNDISCH_TAC ``FINITE(f':(real->bool)->bool)`` THEN
    SPEC_TAC(``f':(real->bool)->bool``,``f':(real->bool)->bool``) THEN
    KNOW_TAC ``!(f' :(real -> bool) -> bool). (f' <> {} ==>
  (!s t. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s) ==>
  ?j. j IN f' /\ BIGUNION (IMAGE (\s. n DIFF s) f') SUBSET n DIFF j) =
        (\f'. f' <> {} ==>
  (!s t. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s) ==>
  ?j. j IN f' /\ BIGUNION (IMAGE (\s. n DIFF s) f') SUBSET n DIFF j) f'``
    THENL [METIS_TAC [], DISC_RW_KILL] THEN
    MATCH_MP_TAC FINITE_INDUCT THEN SIMP_TAC std_ss [] THEN
    SIMP_TAC std_ss [EXISTS_IN_INSERT, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
    SIMP_TAC std_ss [FORALL_IN_INSERT] THEN POP_ASSUM_LIST(K ALL_TAC) THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    MAP_EVERY X_GEN_TAC [``f:(real->bool)->bool``, ``i:real->bool``] THEN
    ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
    ASM_SIMP_TAC std_ss [IMAGE_EMPTY, IMAGE_INSERT, BIGUNION_INSERT, NOT_IN_EMPTY,
                    BIGUNION_EMPTY, UNION_EMPTY, SUBSET_REFL] THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
    REWRITE_TAC [GSYM CONJ_ASSOC] THEN REWRITE_TAC [GSYM AND_IMP_INTRO] THEN
    DISCH_THEN(fn th => REPEAT DISCH_TAC THEN MP_TAC th) THEN
    KNOW_TAC ``(!(s' :real -> bool) (t :real -> bool).
               s' IN (f :(real -> bool) -> bool) ==> t IN f ==>
               s' SUBSET t \/ t SUBSET s')`` THENL
    [ASM_MESON_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN ``j:real->bool`` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN ``(n DIFF j) SUBSET (n DIFF i) \/
                  (n DIFF i:real->bool) SUBSET (n DIFF j)``
    STRIP_ASSUME_TAC THENL
     [ASM_SET_TAC[],
      DISJ1_TAC THEN ASM_SET_TAC[],
      DISJ2_TAC THEN EXISTS_TAC ``j:real->bool`` THEN ASM_SET_TAC[]],
    ALL_TAC] THEN
  SUBGOAL_THEN ``(j INTER k:real->bool) SUBSET (u UNION v)`` ASSUME_TAC THENL
   [MATCH_MP_TAC(SET_RULE
     ``k SUBSET (u UNION v) UNION (n DIFF j)
      ==> (j INTER k) SUBSET (u UNION v)``) THEN
    MATCH_MP_TAC SUBSET_TRANS THEN
    EXISTS_TAC ``BIGUNION g :real->bool`` THEN ASM_SIMP_TAC std_ss [] THEN
    MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC
     ``BIGUNION((u UNION v:real->bool) INSERT (g DELETE (u UNION v)))`` THEN
    CONJ_TAC THENL [MATCH_MP_TAC SUBSET_BIGUNION THEN SET_TAC[], ALL_TAC] THEN
    ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[BIGUNION_INSERT] THEN
    ASM_SET_TAC[],
    ALL_TAC] THEN
  SUBGOAL_THEN ``connected(j INTER k:real->bool)`` MP_TAC THENL
   [ASM_MESON_TAC[SET_RULE ``s SUBSET t ==> (s INTER t = s)``, INTER_COMM],
    REWRITE_TAC[connected] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]]);

val CONNECTED_CHAIN_GEN = store_thm ("CONNECTED_CHAIN_GEN",
 ``!f:(real->bool)->bool.
       (!s. s IN f ==> closed s /\ connected s) /\
       (?s. s IN f /\ compact s) /\
       (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
       ==> connected(BIGINTER f)``,
  GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``BIGINTER f = BIGINTER(IMAGE (\t:real->bool. s INTER t) f)``
  SUBST1_TAC THENL
   [SIMP_TAC std_ss [EXTENSION, BIGINTER_IMAGE] THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONNECTED_CHAIN THEN
    SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC std_ss [COMPACT_INTER_CLOSED] THEN
    CONJ_TAC THENL [X_GEN_TAC ``t:real->bool``, ASM_SET_TAC[]] THEN
    DISCH_TAC THEN
    SUBGOAL_THEN ``(s INTER t:real->bool = s) \/ (s INTER t = t)``
     (DISJ_CASES_THEN SUBST1_TAC) THEN
    ASM_SET_TAC[]]);

val CONNECTED_NEST = store_thm ("CONNECTED_NEST",
 ``!s. (!n. compact(s n) /\ connected(s n)) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> connected(BIGINTER {s n | n IN univ(:num)})``,
  GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC CONNECTED_CHAIN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(s n SUBSET s n' \/ s n' SUBSET s n) =
                        (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

val CONNECTED_NEST_GEN = store_thm ("CONNECTED_NEST_GEN",
 ``!s. (!n. closed(s n) /\ connected(s n)) /\ (?n. compact(s n)) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> connected(BIGINTER {s n | n IN univ(:num)})``,
  GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL DISJ_CASES_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC CONNECTED_CHAIN_GEN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM,
               EXISTS_IN_GSPEC] THEN
  ONCE_REWRITE_TAC [METIS [] ``(s n SUBSET s n' \/ s n' SUBSET s n) =
                        (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Hausdorff distance between sets.                                          *)
(* ------------------------------------------------------------------------- *)

val hausdist = new_definition ("hausdist",
 ``hausdist(s:real->bool,t:real->bool) =
        if (({setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t} <> {}) /\
            (?b. !d. d IN {setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t} ==> d <= b))
        then sup ({setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t}) else &0``);

val HAUSDIST_POS_LE = store_thm ("HAUSDIST_POS_LE",
 ``!s t:real->bool. &0 <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_SUP THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION, SETDIST_POS_LE] THEN
  KNOW_TAC ``?(y :real) (b :real).
  y IN {setdist ({x},(t :real -> bool)) | x IN (s :real -> bool)} UNION
  {setdist ({y},s) | y IN t} /\ (0 :real) <= y /\
  (!(x :real). x IN s ==> setdist ({x},t) <= b) /\
  !(y :real). y IN t ==> setdist ({y},s) <= b`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  ASM_SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(0 <= y:real) = (\y. 0 <= y) y``] THEN
  MATCH_MP_TAC(SET_RULE
   ``~(s = {}) /\ (!x. x IN s ==> P x) ==> ?y. y IN s /\ P y``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION, SETDIST_POS_LE]);

val HAUSDIST_REFL = store_thm ("HAUSDIST_REFL",
 ``!s:real->bool. hausdist(s,s) = &0``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, HAUSDIST_POS_LE] THEN
  REWRITE_TAC[hausdist] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_SUP_LE' THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, REAL_LE_REFL]);

val HAUSDIST_SYM = store_thm ("HAUSDIST_SYM",
 ``!s t:real->bool. hausdist(s,t) = hausdist(t,s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [UNION_COMM] THEN
  REWRITE_TAC[]);

val HAUSDIST_EMPTY = store_thm ("HAUSDIST_EMPTY",
 ``(!t:real->bool. hausdist ({},t) = &0) /\
   (!s:real->bool. hausdist (s,{}) = &0)``,
  REWRITE_TAC[hausdist, SETDIST_EMPTY] THEN
  REWRITE_TAC[SET_RULE ``{setdist ({x},t) | x IN {}} = {}``, UNION_EMPTY] THEN
  REWRITE_TAC[SET_RULE ``({c |x| x IN s} = {}) <=> (s = {})``] THEN
  X_GEN_TAC ``s:real->bool`` THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``~(s = {}) ==> ({c |x| x IN s} = {c})``] THEN
  REWRITE_TAC[SUP_SING, COND_ID]);

val HAUSDIST_SINGS = store_thm ("HAUSDIST_SINGS",
 ``!x y:real. hausdist({x},{y}) = dist(x,y)``,
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  REWRITE_TAC[SET_RULE ``{dist (x,y) | x IN {a}} = {dist (a,y)}``] THEN
  ONCE_REWRITE_TAC [METIS [DIST_SYM] ``{dist (x,y)} UNION {dist (y,x)} =
                               {dist (x,y)} UNION {dist (x,y)}``] THEN
  SIMP_TAC std_ss [UNION_IDEMPOT, SUP_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC std_ss [IN_SING, UNWIND_FORALL_THM2] THEN
  METIS_TAC[REAL_LE_REFL]);

val HAUSDIST_EQ = store_thm ("HAUSDIST_EQ",
 ``!s t:real->bool s' t':real->bool.
        (!b. (!x. x IN s ==> setdist({x},t) <= b) /\
             (!y. y IN t ==> setdist({y},s) <= b) <=>
             (!x. x IN s' ==> setdist({x},t') <= b) /\
             (!y. y IN t' ==> setdist({y},s') <= b))
        ==> (hausdist(s,t) = hausdist(s',t'))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[hausdist] THEN
  MATCH_MP_TAC(METIS[]
   ``(p <=> p') /\ (s = s')
    ==> ((if p then s else &0:real) = (if p' then s' else &0:real))``) THEN
  CONJ_TAC THENL
   [BINOP_TAC THENL
     [PURE_REWRITE_TAC[SET_RULE ``(s = {}) <=> !x. x IN s ==> F``],
      AP_TERM_TAC THEN ABS_TAC],
    MATCH_MP_TAC SUP_EQ] THEN
  SIMP_TAC std_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN
  ASM_REWRITE_TAC[] THEN
  ONCE_REWRITE_TAC [METIS [] ``(a = b) = (~a = ~b:bool)``] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, MEMBER_NOT_EMPTY] THEN
  REWRITE_TAC[GSYM DE_MORGAN_THM] THEN AP_TERM_TAC THEN EQ_TAC THEN
  DISCH_THEN(fn th => POP_ASSUM MP_TAC THEN ASSUME_TAC th) THEN
  ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
  DISCH_THEN(MP_TAC o SPEC ``-(&1):real``) THEN
  SIMP_TAC std_ss [SETDIST_POS_LE, REAL_ARITH ``&0 <= x ==> ~(x <= -(&1:real))``] THEN
  SET_TAC[]);

val HAUSDIST_TRANSLATION = store_thm ("HAUSDIST_TRANSLATION",
 ``!a s t:real->bool.
        hausdist(IMAGE (\x. a + x) s,IMAGE (\x. a + x) t) = hausdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC real_ss [SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
  SIMP_TAC real_ss [SET_RULE ``{a + x:real} = IMAGE (\x. a + x) {x}``] THEN
  REWRITE_TAC[SETDIST_TRANSLATION]);

val HAUSDIST_LINEAR_IMAGE = store_thm ("HAUSDIST_LINEAR_IMAGE",
 ``!f:real->real s t.
           linear f /\ (!x. abs(f x) = abs x)
           ==> (hausdist(IMAGE f s,IMAGE f t) = hausdist(s,t))``,
  REPEAT STRIP_TAC THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC real_ss [SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
  ONCE_REWRITE_TAC[SET_RULE ``{(f:real->real) x} = IMAGE f {x}``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_LINEAR_IMAGE]);

val HAUSDIST_CLOSURE = store_thm ("HAUSDIST_CLOSURE",
 ``(!s t:real->bool. hausdist(closure s,t) = hausdist(s,t)) /\
   (!s t:real->bool. hausdist(s,closure t) = hausdist(s,t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HAUSDIST_EQ THEN
  GEN_TAC THEN BINOP_TAC THEN REWRITE_TAC[SETDIST_CLOSURE] THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) <= b <=> (\x. setdist ({x},t) <= b) x``] THEN
  PURE_ONCE_REWRITE_TAC[SET_RULE
   ``(!x. x IN P ==> Q x) <=> (!x. x IN P ==> (\x. x) x IN {x | Q x})``] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE_EQ THEN
  SIMP_TAC std_ss [GSPEC_F, CONTINUOUS_ON_ID, CLOSED_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) = (\x. setdist ({x},t)) x``] THEN
  REWRITE_TAC[SET_RULE
    ``{x | (f x) <= b:real} =
      {x | x IN UNIV /\ (f x) IN {x | x <= b}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
  SIMP_TAC std_ss [CLOSED_UNIV, CONTINUOUS_ON_SETDIST] THEN
  REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_LE]);

val REAL_HAUSDIST_LE = store_thm ("REAL_HAUSDIST_LE",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\
        (!x. x IN s ==> setdist({x},t) <= b) /\
        (!y. y IN t ==> setdist({y},s) <= b)
        ==> hausdist(s,t) <= b``,
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  SIMP_TAC std_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN
  COND_CASES_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
  MATCH_MP_TAC REAL_SUP_LE' THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  ASM_SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC]);

val REAL_HAUSDIST_LE_SUMS = store_thm ("REAL_HAUSDIST_LE_SUMS",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\
        s SUBSET {y + z | y IN t /\ z IN cball(0,b)} /\
        t SUBSET {y + z | y IN s /\ z IN cball(0,b)}
        ==> hausdist(s,t) <= b``,
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD, IN_CBALL_0] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  REWRITE_TAC[GSYM dist] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_HAUSDIST_LE THEN
  METIS_TAC[SETDIST_LE_DIST, REAL_LE_TRANS, IN_SING]);

val REAL_LE_HAUSDIST = store_thm ("REAL_LE_HAUSDIST",
 ``!s t:real->bool a b c z.
        ~(s = {}) /\ ~(t = {}) /\
        (!x. x IN s ==> setdist({x},t) <= b) /\
        (!y. y IN t ==> setdist({y},s) <= c) /\
        (z IN s /\ a <= setdist({z},t) \/ z IN t /\ a <= setdist({z},s))
        ==> a <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN COND_CASES_TAC THENL
   [MATCH_MP_TAC REAL_LE_SUP THEN
    ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
    SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC],
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [NOT_EXISTS_THM]) THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    SIMP_TAC real_ss [NOT_FORALL_THM]] THEN
  EXISTS_TAC ``max b c:real`` THEN
  ASM_SIMP_TAC real_ss [REAL_LE_MAX] THEN ASM_SET_TAC[]);

val SETDIST_LE_HAUSDIST = store_thm ("SETDIST_LE_HAUSDIST",
 ``!s t:real->bool.
        bounded s /\ bounded t ==> setdist(s,t) <= hausdist(s,t)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_HAUSDIST THEN REWRITE_TAC[CONJ_ASSOC] THEN
  ASM_SIMP_TAC real_ss [RIGHT_EXISTS_AND_THM, LEFT_EXISTS_AND_THM] THEN
  CONJ_TAC THENL
   [ALL_TAC, METIS_TAC[SETDIST_LE_SING, MEMBER_NOT_EMPTY]] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC, GSYM dist] THEN
  DISCH_THEN(X_CHOOSE_TAC ``b:real``) THEN
  CONJ_TAC THEN EXISTS_TAC ``b:real`` THEN REPEAT STRIP_TAC THEN
  METIS_TAC[REAL_LE_TRANS, SETDIST_LE_DIST, MEMBER_NOT_EMPTY, IN_SING, DIST_SYM]);

val SETDIST_SING_LE_HAUSDIST = store_thm ("SETDIST_SING_LE_HAUSDIST",
 ``!s t x:real.
        bounded s /\ bounded t /\ x IN s ==> setdist({x},t) <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LE_HAUSDIST THEN
  ASM_SIMP_TAC real_ss [RIGHT_EXISTS_AND_THM] THEN
  SIMP_TAC real_ss [LEFT_EXISTS_AND_THM, EXISTS_OR_THM, CONJ_ASSOC] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN CONJ_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM dist] THENL
   [ALL_TAC,
    KNOW_TAC ``(!y x:real. x IN s /\ y IN t ==> dist (x,y) <= a) ==>
                !y. y IN t ==> setdist ({y},s) <= a`` THENL
    [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]]] THEN
  DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN POP_ASSUM (MP_TAC o SPEC ``y:real``) THEN
  REPEAT STRIP_TAC THENL
   [UNDISCH_TAC ``~(t:real->bool = {})``,
    UNDISCH_TAC ``~(s:real->bool = {})``] THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] REAL_LE_TRANS) THENL
   [ALL_TAC, ONCE_REWRITE_TAC[DIST_SYM]] THEN
  MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_REWRITE_TAC[IN_SING]);

val SETDIST_HAUSDIST_TRIANGLE = store_thm ("SETDIST_HAUSDIST_TRIANGLE",
 ``!s t u:real->bool.
        ~(t = {}) /\ bounded t /\ bounded u
        ==> setdist(s,u) <= setdist(s,t) + hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``u:real->bool = {}``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, REAL_LE_ADD, REAL_ADD_LID,
                        SETDIST_POS_LE, HAUSDIST_POS_LE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a <= b + c <=> a - c <= b:real``] THEN
  ASM_SIMP_TAC real_ss [REAL_LE_SETDIST_EQ, NOT_INSERT_EMPTY, IN_SING] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  REWRITE_TAC[REAL_LE_SUB_RADD] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},u)`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_LE_SING] THEN
  MP_TAC(ISPECL [``u:real->bool``, ``x:real``, ``y:real``]
        SETDIST_SING_TRIANGLE) THEN
  MATCH_MP_TAC(REAL_ARITH
   ``yu <= z ==> abs(xu - yu) <= d ==> xu <= d + z:real``) THEN
  MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN ASM_REWRITE_TAC[]);

val HAUSDIST_SETDIST_TRIANGLE = store_thm ("HAUSDIST_SETDIST_TRIANGLE",
 ``!s t u:real->bool.
        ~(t = {}) /\ bounded s /\ bounded t
        ==> setdist(s,u) <= hausdist(s,t) + setdist(t,u)``,
  ONCE_REWRITE_TAC[SETDIST_SYM, HAUSDIST_SYM] THEN
  ONCE_REWRITE_TAC[REAL_ADD_SYM] THEN
  SIMP_TAC real_ss [SETDIST_HAUSDIST_TRIANGLE]);

val REAL_LT_HAUSDIST_POINT_EXISTS = store_thm ("REAL_LT_HAUSDIST_POINT_EXISTS",
 ``!s t x:real d.
        bounded s /\ bounded t /\ ~(t = {}) /\ hausdist(s,t) < d /\ x IN s
        ==> ?y. y IN t /\ dist(x,y) < d``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{x:real}``, ``t:real->bool``, ``d:real``]
        REAL_SETDIST_LT_EXISTS) THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[NOT_INSERT_EMPTY] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``hausdist(s:real->bool,t)`` THEN
  ASM_SIMP_TAC real_ss [] THEN MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN
  ASM_REWRITE_TAC[]);

val UPPER_LOWER_HEMICONTINUOUS = store_thm ("UPPER_LOWER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
      (!x. x IN s ==> f(x) SUBSET t) /\
      (!u. open_in (subtopology euclidean t) u
           ==> open_in (subtopology euclidean s)
                       {x | x IN s /\ f(x) SUBSET u}) /\
      (!u. closed_in (subtopology euclidean t) u
           ==> closed_in (subtopology euclidean s)
                         {x | x IN s /\ f(x) SUBSET u})
      ==> !x e. x IN s /\ &0 < e /\ bounded(f x)
                ==> ?d. &0 < d /\
                        !x'. x' IN s /\ dist(x,x') < d
                             ==> hausdist(f x,f x') < e``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``(f:real->real->bool) x = {}`` THENL
   [ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN METIS_TAC[REAL_LT_01], ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC o SPECL [``x:real``, ``e / &2:real``] o MATCH_MP
        UPPER_LOWER_HEMICONTINUOUS_EXPLICIT) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_BALL) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``t INTER ball(0:real,r)`` o
        CONJUNCT1 o CONJUNCT2) THEN
  SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN REWRITE_TAC[open_in] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN
  ASM_SIMP_TAC std_ss [SUBSET_INTER, GSPECIFICATION] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  X_GEN_TAC ``x':real`` THEN STRIP_TAC THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC o SPEC ``x':real``)) THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN STRIP_TAC THEN
  ASM_CASES_TAC ``(f:real->real->bool) x' = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN
  KNOW_TAC ``0 < e / 2:real`` THENL [ASM_REWRITE_TAC [REAL_HALF], DISCH_TAC] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < e / 2 /\ x <= e / &2 ==> x < e / 2 + e / 2:real``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_HAUSDIST_LE THEN
  METIS_TAC[SETDIST_LE_DIST, DIST_SYM, REAL_LE_TRANS,
                IN_SING, REAL_LT_IMP_LE]);

val HAUSDIST_NONTRIVIAL = store_thm ("HAUSDIST_NONTRIVIAL",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
             sup({setdist ({x},t) | x IN s} UNION {setdist ({y},s) | y IN t}))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[hausdist] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC real_ss [] THEN
  FIRST_X_ASSUM(MP_TAC o SIMP_RULE real_ss [DE_MORGAN_THM]) THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, GSYM IMAGE_DEF, IMAGE_EQ_EMPTY] THEN
  REWRITE_TAC [METIS [] ``(!b. ?d. d IN P /\ ~(d <= b)) =
                              ~(?b. !d. d IN P ==> d <= b:real)``] THEN
  MATCH_MP_TAC(TAUT `p ==> ~p ==> q`) THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC] THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_NONTRIVIAL_ALT = store_thm ("HAUSDIST_NONTRIVIAL_ALT",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) = max (sup {setdist ({x},t) | x IN s})
                                (sup {setdist ({y},s) | y IN t}))``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL] THEN
  MATCH_MP_TAC SUP_UNION THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IMAGE_EQ_EMPTY] THEN
  CONJ_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC real_ss [FORALL_IN_GSPEC, GSYM dist] THEN
  METIS_TAC [SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val REAL_HAUSDIST_LE_EQ = store_thm ("REAL_HAUSDIST_LE_EQ",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\ bounded s /\ bounded t
        ==> (hausdist(s,t) <= b <=>
             (!x. x IN s ==> setdist({x},t) <= b) /\
             (!y. y IN t ==> setdist({y},s) <= b))``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL_ALT, REAL_MAX_LE] THEN
  BINOP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) = (\x. setdist ({x},t)) x:real``] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(!x. x IN s ==> f x <= b) <=>
                               (!y. y IN {f x | x IN s} ==> y <= b:real)``] THEN
  MATCH_MP_TAC REAL_SUP_LE_EQ THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC real_ss [FORALL_IN_GSPEC, GSYM dist] THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_UNION_LE = store_thm ("HAUSDIST_UNION_LE",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {}) /\ ~(u = {})
        ==> hausdist(s UNION t,s UNION u) <= hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ, BOUNDED_UNION, EMPTY_UNION] THEN
  SIMP_TAC real_ss [FORALL_IN_UNION] THEN
  SIMP_TAC real_ss [SETDIST_SING_IN_SET, IN_UNION, HAUSDIST_POS_LE] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_HAUSDIST_LE_EQ, BOUNDED_UNION, EMPTY_UNION] THEN
  CONJ_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THENL
   [MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},u)``,
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},t)``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_SUBSET_RIGHT, SUBSET_UNION] THENL
   [ALL_TAC, ONCE_REWRITE_TAC[HAUSDIST_SYM]] THEN
  MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN ASM_REWRITE_TAC[]);

val HAUSDIST_INSERT_LE = store_thm ("HAUSDIST_INSERT_LE",
 ``!s t a:real.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> hausdist(a INSERT s,a INSERT t) <= hausdist(s,t)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_UNION_LE, NOT_INSERT_EMPTY, BOUNDED_SING]);

val HAUSDIST_COMPACT_EXISTS = store_thm ("HAUSDIST_COMPACT_EXISTS",
 ``!s t:real->bool.
        bounded s /\ compact t /\ ~(t = {})
        ==> !x. x IN s ==> ?y. y IN t /\ dist(x,y) <= hausdist(s,t)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``{x:real}``, ``t:real->bool``]
        SETDIST_COMPACT_CLOSED) THEN
  ASM_SIMP_TAC real_ss [COMPACT_SING, COMPACT_IMP_CLOSED, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, UNWIND_THM2, RIGHT_EXISTS_AND_THM, UNWIND_THM1] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN POP_ASSUM MP_TAC THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LE_HAUSDIST THEN
  ASM_SIMP_TAC real_ss [LEFT_EXISTS_AND_THM, RIGHT_EXISTS_AND_THM] THEN
  REWRITE_TAC[CONJ_ASSOC] THEN
  CONJ_TAC THENL [CONJ_TAC, METIS_TAC[REAL_LE_REFL]] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [COMPACT_IMP_BOUNDED] THEN
  SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_TRIANGLE = store_thm ("HAUSDIST_TRIANGLE",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {})
        ==> hausdist(s,u) <= hausdist(s,t) + hausdist(t,u)``,
  ONCE_REWRITE_TAC[GSYM(CONJUNCT1 HAUSDIST_CLOSURE)] THEN
  ONCE_REWRITE_TAC[GSYM(CONJUNCT2 HAUSDIST_CLOSURE)] THEN
  ONCE_REWRITE_TAC[GSYM COMPACT_CLOSURE, GSYM CLOSURE_EQ_EMPTY] THEN
  REPEAT GEN_TAC THEN MAP_EVERY
   (fn t => SPEC_TAC(mk_comb(``closure:(real->bool)->real->bool``,t),t))
   [``u:real->bool``, ``t:real->bool``, ``s:real->bool``] THEN
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, HAUSDIST_POS_LE, REAL_ADD_LID] THEN
  ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, HAUSDIST_POS_LE, REAL_ADD_RID] THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ, COMPACT_IMP_BOUNDED] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [HAUSDIST_SYM] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [REAL_ADD_SYM] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
   MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``u:real->bool``, ``t:real->bool``, ``s:real->bool``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(~(u = {}) /\ ~(s = {}) /\ ~(t = {}) /\
                                compact u /\ compact t /\ compact s) =
                       (\s t u. ~(u = {}) /\ ~(s = {}) /\ ~(t = {}) /\
                                compact u /\ compact t /\ compact s) s t u``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(!x. x IN s ==> setdist ({x},u) <=
                                hausdist (s,t) + hausdist (t,u)) =
                       (\s t u. !x. x IN s ==> setdist ({x},u) <=
                                hausdist (s,t) + hausdist (t,u)) s t u ``] THEN
  MATCH_MP_TAC(METIS[]
   ``(!s t u. P s t u ==> P u t s) /\
     (!s t u. P s t u ==> Q s t u)
     ==> (!s t u. P s t u ==> Q s t u /\ Q u t s)``) THEN BETA_TAC THEN
  CONJ_TAC THENL [METIS_TAC[CONJ_ACI], REPEAT GEN_TAC THEN STRIP_TAC] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?y:real. y IN t /\ dist(x,y) <= hausdist(s,t)``
  STRIP_ASSUME_TAC THENL
   [METIS_TAC[HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED], ALL_TAC] THEN
  SUBGOAL_THEN ``?z:real. z IN u /\ dist(y,z) <= hausdist(t,u)``
  STRIP_ASSUME_TAC THENL
   [METIS_TAC[HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED], ALL_TAC] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [dist]) THEN
  FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``abs(y - z) <= b ==> abs(x - y) <= a /\ s <= abs(x - z) ==> s <= a + b:real``)) THEN
  ASM_REWRITE_TAC[GSYM dist] THEN MATCH_MP_TAC SETDIST_LE_DIST THEN
  ASM_REWRITE_TAC[IN_SING]);

val HAUSDIST_COMPACT_SUMS = store_thm ("HAUSDIST_COMPACT_SUMS",
 ``!s t:real->bool.
        bounded s /\ compact t /\ ~(t = {})
        ==> s SUBSET {y + z | y IN t /\ z IN cball(0,hausdist(s,t))}``,
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, IN_CBALL_0, EXISTS_PROD] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  SIMP_TAC real_ss [GSYM dist, HAUSDIST_COMPACT_EXISTS]);

val lemma = prove (
 ``!s t u:real->bool.
          bounded s /\ bounded t /\ bounded u /\
          ~(s = {}) /\ ~(t = {}) /\ ~(u = {})
          ==> !x. x IN s ==> setdist({x},u) <= hausdist(s,t) + hausdist(t,u)``,
    REPEAT STRIP_TAC THEN
    MP_TAC(ISPECL [``closure s:real->bool``, ``closure t:real->bool``]
        HAUSDIST_COMPACT_EXISTS) THEN
    ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC real_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET, HAUSDIST_CLOSURE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPECL [``closure t:real->bool``, ``closure u:real->bool``]
      HAUSDIST_COMPACT_EXISTS) THEN
    ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``y:real``) THEN
    ASM_SIMP_TAC real_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET, HAUSDIST_CLOSURE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,z)`` THEN CONJ_TAC THENL
     [METIS_TAC[SETDIST_CLOSURE, SETDIST_LE_DIST, IN_SING], ALL_TAC] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,y) + dist(y,z)`` THEN
    REWRITE_TAC[DIST_TRIANGLE] THEN ASM_REAL_ARITH_TAC);

val HAUSDIST_TRANS = store_thm ("HAUSDIST_TRANS",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {})
        ==> hausdist(s,u) <= hausdist(s,t) + hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, REAL_ADD_LID, HAUSDIST_POS_LE] THEN
  ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, REAL_ADD_RID, HAUSDIST_POS_LE] THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ] THEN
  ASM_MESON_TAC[lemma, HAUSDIST_SYM, SETDIST_SYM, REAL_ADD_SYM]);

val HAUSDIST_EQ_0 = store_thm ("HAUSDIST_EQ_0",
 ``!s t:real->bool.
      bounded s /\ bounded t
      ==> ((hausdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ (closure s = closure t))``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LE_ANTISYM, HAUSDIST_POS_LE, REAL_HAUSDIST_LE_EQ] THEN
  SIMP_TAC real_ss [SETDIST_POS_LE, REAL_ARITH ``&0 <= x ==> (x <= &0 <=> (x = &0:real))``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_EQ_0_SING, GSYM SUBSET_ANTISYM_EQ, SUBSET_DEF] THEN
  SIMP_TAC std_ss [FORALL_IN_CLOSURE_EQ, CLOSED_CLOSURE, CONTINUOUS_ON_ID]);

val HAUSDIST_COMPACT_NONTRIVIAL = store_thm ("HAUSDIST_COMPACT_NONTRIVIAL",
 ``!s t:real->bool.
        compact s /\ compact t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
            inf {e | &0 <= e /\
                   s SUBSET {x + y | x IN t /\ abs y <= e} /\
                   t SUBSET {x + y | x IN s /\ abs y <= e}})``,
  REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN
  MATCH_MP_TAC REAL_INF_UNIQUE THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC, EXISTS_IN_GSPEC] THEN
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  REWRITE_TAC[GSYM dist] THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN
    MATCH_MP_TAC REAL_HAUSDIST_LE THEN
    METIS_TAC[SETDIST_LE_DIST, DIST_SYM, REAL_LE_TRANS,
              IN_SING, REAL_LT_IMP_LE],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``hausdist(s:real->bool,t)`` THEN
    ASM_REWRITE_TAC[HAUSDIST_POS_LE] THEN
    METIS_TAC[DIST_SYM, HAUSDIST_SYM,
                  HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED]]);

Theorem HAUSDIST_BALLS :
   (!a b:real r s.
        hausdist(ball(a,r),ball(b,s)) =
        if r <= &0 \/ s <= &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(ball(a,r),cball(b,s)) =
        if r <= &0 \/ s < &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(cball(a,r),ball(b,s)) =
        if r < &0 \/ s <= &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(cball(a,r),cball(b,s)) =
        if r < &0 \/ s < &0 then &0 else dist(a,b) + abs(r - s))
Proof
  REWRITE_TAC[METIS[]
   ``(x = if p then y else z) <=> (p ==> (x = y)) /\ (~p ==> (x = z))``] THEN
  SIMP_TAC real_ss [TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC real_ss [BALL_EMPTY, CBALL_EMPTY, HAUSDIST_EMPTY, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[METIS[HAUSDIST_CLOSURE]
   ``hausdist(s,t) = hausdist(closure s,closure t)``] THEN
  SIMP_TAC real_ss [REAL_NOT_LE, REAL_NOT_LT, CLOSURE_BALL] THEN
  REWRITE_TAC[HAUSDIST_CLOSURE] THEN
  MATCH_MP_TAC(TAUT `(s ==> p /\ q /\ r) /\ s ==> p /\ q /\ r /\ s`) THEN
  CONJ_TAC THENL [MESON_TAC[REAL_LT_IMP_LE], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL, BOUNDED_CBALL, CBALL_EQ_EMPTY,
               REAL_NOT_LT] THEN
  MATCH_MP_TAC SUP_UNIQUE THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  REWRITE_TAC[MESON[CBALL_SING] ``{a} = cball(a:real,&0)``] THEN
  ASM_REWRITE_TAC[SETDIST_BALLS, REAL_LT_REFL] THEN
  X_GEN_TAC ``c:real`` THEN REWRITE_TAC[IN_CBALL] THEN
  Reverse EQ_TAC
  >- (RW_TAC real_ss [dist, max_def] \\
     `~(r < 0)` by PROVE_TAC [real_lte] >> rw [] \\
      REAL_ASM_ARITH_TAC) THEN
  ASM_CASES_TAC ``b:real = a`` THENL
  [ (* goal 1 (of 2) *)
    ONCE_ASM_REWRITE_TAC [DIST_SYM] THEN ASM_REWRITE_TAC[DIST_REFL, REAL_MAX_LE] THEN
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC o SPEC ``a + r * 1:real``)
     (MP_TAC o SPEC ``a + s * 1:real``)) THEN
    REWRITE_TAC[dist, REAL_ARITH ``abs(a:real - (a + x)) = abs x``] THEN
    SIMP_TAC real_ss [ABS_MUL, LESS_EQ_REFL, max_def] \\
   `~(r < 0)` by PROVE_TAC [real_lte] >> rw [] \\
    ASM_REAL_ARITH_TAC,
    (* goal 2 (of 2) *)
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC o SPEC ``a - r / dist(a,b) * (b - a):real``)
     (MP_TAC o SPEC ``b - s / dist(a,b) * (a - b):real``)) THEN
    REWRITE_TAC[dist, REAL_ARITH ``abs(a:real - (a - x)) = abs x``] THEN
    REWRITE_TAC[dist, ABS_MUL, REAL_ARITH
     ``b - e * (a - b) - a:real = (&1 + e) * (b - a)``] THEN
    ONCE_REWRITE_TAC [METIS [ABS_ABS] ``abs x * abs (a - b) =
                                        abs x * abs (abs (a - b:real))``] THEN
    REWRITE_TAC[GSYM ABS_MUL] THEN REWRITE_TAC[ABS_ABS] THEN
    ONCE_REWRITE_TAC [METIS [ABS_SUB] ``r / abs (a - b) * abs (b - a) =
                                   r / abs (a - b) * abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ADD_RDISTRIB, REAL_MUL_LID] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(b <> a) = (abs (a - b) <> 0:real)``]) THEN
    ONCE_REWRITE_TAC [METIS [ABS_SUB] ``r / abs (a - b) * abs (b - a) =
                                   r / abs (a - b) * abs (a - b:real)``] THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL, ABS_ZERO, REAL_SUB_0, max_def] THEN
   `~(r < 0)` by PROVE_TAC [real_lte] >> rw [] \\
    ASM_REAL_ARITH_TAC ]
QED

val HAUSDIST_ALT = store_thm ("HAUSDIST_ALT",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
             sup {abs(setdist({x},s) - setdist({x},t)) | x IN univ(:real)})``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[GSYM COMPACT_CLOSURE, GSYM(CONJUNCT2 SETDIST_CLOSURE),
    GSYM CLOSURE_EQ_EMPTY, METIS[HAUSDIST_CLOSURE]
    ``hausdist(s:real->bool,t) = hausdist(closure s,closure t)``] THEN
  SPEC_TAC(``closure t:real->bool``,``t:real->bool``) THEN
  SPEC_TAC(``closure s:real->bool``,``s:real->bool``) THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL, COMPACT_IMP_BOUNDED] THEN
  MATCH_MP_TAC SUP_EQ THEN
  SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC, IN_UNIV] THEN
  REWRITE_TAC[REAL_ARITH ``abs(y - x) <= b <=> x <= y + b /\ y <= x + b:real``] THEN
  GEN_TAC THEN SIMP_TAC real_ss [FORALL_AND_THM] THEN BINOP_TAC THEN
  (EQ_TAC THENL [ALL_TAC, METIS_TAC[SETDIST_SING_IN_SET, REAL_ADD_LID]]) THEN
  DISCH_TAC THEN X_GEN_TAC ``z:real`` THENL
   [MP_TAC(ISPECL[``{z:real}``, ``s:real->bool``] SETDIST_CLOSED_COMPACT),
    MP_TAC(ISPECL[``{z:real}``, ``t:real->bool``] SETDIST_CLOSED_COMPACT)] THEN
  ASM_REWRITE_TAC[CLOSED_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` (STRIP_ASSUME_TAC o GSYM)) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_REWRITE_TAC[] THENL
   [MP_TAC(ISPECL[``{y:real}``, ``t:real->bool``] SETDIST_CLOSED_COMPACT),
    MP_TAC(ISPECL[``{y:real}``, ``s:real->bool``] SETDIST_CLOSED_COMPACT)] THEN
  ASM_REWRITE_TAC[CLOSED_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:real`` (STRIP_ASSUME_TAC o GSYM)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(z:real,x)`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_LE_DIST, IN_SING] THEN
  UNDISCH_TAC ``dist(y:real,x) <= b`` THEN REWRITE_TAC [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_DIAMETER = store_thm ("CONTINUOUS_DIAMETER",
 ``!s:real->bool e.
        bounded s /\ ~(s = {}) /\ &0 < e
        ==> ?d. &0 < d /\
                !t. bounded t /\ ~(t = {}) /\ hausdist(s,t) < d
                    ==> abs(diameter s - diameter t) < e``,
  REPEAT STRIP_TAC THEN EXISTS_TAC ``e / &2:real`` THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``diameter(s:real->bool) - diameter(t:real->bool) =
                 diameter(closure s) - diameter(closure t)``
  SUBST1_TAC THENL [ASM_MESON_TAC[DIAMETER_CLOSURE], ALL_TAC] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``&2 * hausdist(s:real->bool,t)`` THEN
  CONJ_TAC THENL [ALL_TAC,
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   ASM_REAL_ARITH_TAC] THEN
  MP_TAC(ISPECL [``0:real``, ``hausdist(s:real->bool,t)``]
    DIAMETER_CBALL) THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_POS_LE, GSYM REAL_NOT_LE] THEN
  DISCH_THEN(SUBST1_TAC o SYM) THEN MATCH_MP_TAC(REAL_ARITH
   ``x <= y + e /\ y <= x + e ==> abs(x - y) <= e:real``) THEN
  CONJ_TAC THEN
  W(MP_TAC o PART_MATCH (rand o rand) DIAMETER_SUMS o rand o snd) THEN
  ASM_SIMP_TAC real_ss [BOUNDED_CBALL, BOUNDED_CLOSURE] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] REAL_LE_TRANS) THEN
  MATCH_MP_TAC DIAMETER_SUBSET THEN
  ASM_SIMP_TAC real_ss [BOUNDED_SUMS, BOUNDED_CBALL, BOUNDED_CLOSURE] THEN
  ONCE_REWRITE_TAC[METIS[HAUSDIST_CLOSURE]
   ``hausdist(s:real->bool,t) = hausdist(closure s,closure t)``]
  THENL [ALL_TAC, ONCE_REWRITE_TAC[HAUSDIST_SYM]] THEN
  MATCH_MP_TAC HAUSDIST_COMPACT_SUMS THEN
  ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY]);

(* ------------------------------------------------------------------------- *)
(* Isometries are embeddings, and even surjective in the compact case.       *)
(* ------------------------------------------------------------------------- *)

val ISOMETRY_IMP_OPEN_MAP = store_thm ("ISOMETRY_IMP_OPEN_MAP",
 ``!f:real->real s t u.
        (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y))) /\
        open_in (subtopology euclidean s) u
        ==> open_in (subtopology euclidean t) (IMAGE f u)``,
  SIMP_TAC std_ss [open_in, FORALL_IN_IMAGE] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``x:real`` THEN DISCH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[CONJ_EQ_IMP] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN
  ASM_SIMP_TAC std_ss [IN_IMAGE] THEN ASM_MESON_TAC[]);

val ISOMETRY_IMP_EMBEDDING = store_thm ("ISOMETRY_IMP_EMBEDDING",
 ``!f:real->real s t.
        (IMAGE f s = t) /\ (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
  ASM_SIMP_TAC std_ss [ISOMETRY_ON_IMP_CONTINUOUS_ON] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[DIST_EQ_0], REPEAT STRIP_TAC] THEN
  MATCH_MP_TAC ISOMETRY_IMP_OPEN_MAP THEN ASM_MESON_TAC[]);

val ISOMETRY_IMP_HOMEOMORPHISM_COMPACT = store_thm ("ISOMETRY_IMP_HOMEOMORPHISM_COMPACT",
 ``!f s:real->bool.
        compact s /\ IMAGE f s SUBSET s /\
        (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
        ==> ?g. homeomorphism (s,s) (f,g)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) s = s``
   (fn th => ASM_MESON_TAC[th, ISOMETRY_IMP_EMBEDDING]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP ISOMETRY_ON_IMP_CONTINUOUS_ON) THEN
  ASM_REWRITE_TAC[GSYM SUBSET_ANTISYM_EQ] THEN REWRITE_TAC[SUBSET_DEF] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``setdist({x},IMAGE (f:real->real) s) = &0`` MP_TAC THENL
   [MATCH_MP_TAC(REAL_ARITH ``&0 <= x /\ ~(&0 < x) ==> (x = &0:real)``) THEN
    REWRITE_TAC[SETDIST_POS_LE] THEN DISCH_TAC THEN
    KNOW_TAC ``?z. (z 0 = (x:real)) /\ !n. z(SUC n) = f(z n)`` THENL
    [RW_TAC std_ss [num_Axiom], STRIP_TAC] THEN
    SUBGOAL_THEN ``!n. (z:num->real) n IN s`` ASSUME_TAC THENL
     [INDUCT_TAC THEN ASM_SET_TAC[], ALL_TAC] THEN
    UNDISCH_TAC ``compact s`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o REWRITE_RULE [compact]) THEN
    DISCH_THEN(MP_TAC o SPEC ``z:num->real``) THEN
    ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN CCONTR_TAC THEN
    FULL_SIMP_TAC std_ss [] THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP CONVERGENT_IMP_CAUCHY) THEN
    REWRITE_TAC[cauchy] THEN
    DISCH_THEN(MP_TAC o SPEC ``setdist({x},IMAGE (f:real->real) s)``) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``N:num``
     (MP_TAC o SPECL [``N:num``, ``N + 1:num``])) THEN
    KNOW_TAC ``N >= N /\ N + 1 >= N:num`` THENL
    [ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN REWRITE_TAC[REAL_NOT_LT, o_THM]] THEN
    SUBGOAL_THEN ``(r:num->num) N < r (N + 1)`` MP_TAC THENL
     [RULE_ASSUM_TAC (REWRITE_RULE [METIS [] ``(~a \/ b) = (a ==> b)``]) THEN
      FIRST_X_ASSUM MATCH_MP_TAC THEN ARITH_TAC,
      SIMP_TAC std_ss [LT_EXISTS, LEFT_IMP_EXISTS_THM]] THEN
    X_GEN_TAC ``d:num`` THEN DISCH_THEN SUBST1_TAC THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,z(SUC d))`` THEN CONJ_TAC THENL
     [MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC REAL_EQ_IMP_LE THEN
    SPEC_TAC(``(r:num->num) N``,``m:num``) THEN
    INDUCT_TAC THEN ASM_MESON_TAC[ADD_CLAUSES],
    REWRITE_TAC[SETDIST_EQ_0_SING, IMAGE_EQ_EMPTY] THEN
    ASM_MESON_TAC[COMPACT_IMP_CLOSED, NOT_IN_EMPTY,
                  COMPACT_CONTINUOUS_IMAGE, CLOSURE_CLOSED]]);

(* ------------------------------------------------------------------------- *)
(* Urysohn's lemma (for real, where the proof is easy using distances).      *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``!s t u a b.
          closed_in (subtopology euclidean u) s /\
          closed_in (subtopology euclidean u) t /\
          (s INTER t = {}) /\ ~(s = {}) /\ ~(t = {}) /\ ~(a = b)
          ==> ?f:real->real.
                 f continuous_on u /\
                 (!x. x IN u ==> f(x) IN segment[a,b]) /\
                 (!x. x IN u ==> ((f x = a) <=> x IN s)) /\
                 (!x. x IN u ==> ((f x = b) <=> x IN t))``,
    REPEAT STRIP_TAC THEN EXISTS_TAC
      ``\x:real. a + setdist({x},s) / (setdist({x},s) + setdist({x},t)) *
                      (b - a:real)`` THEN SIMP_TAC std_ss [] THEN
    SUBGOAL_THEN
     ``(!x:real. x IN u ==> ((setdist({x},s) = &0) <=> x IN s)) /\
       (!x:real. x IN u ==> ((setdist({x},t) = &0) <=> x IN t))``
    STRIP_ASSUME_TAC THENL
     [ASM_REWRITE_TAC[SETDIST_EQ_0_SING] THEN CONJ_TAC THENL
       [MP_TAC(ISPEC ``s:real->bool`` CLOSED_IN_CLOSED),
        MP_TAC(ISPEC ``t:real->bool`` CLOSED_IN_CLOSED)] THEN
      DISCH_THEN(MP_TAC o SPEC ``u:real->bool``) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``v:real->bool``
       (CONJUNCTS_THEN2 ASSUME_TAC SUBST_ALL_TAC)) THEN
      ASM_MESON_TAC[CLOSURE_CLOSED, INTER_SUBSET, SUBSET_CLOSURE, SUBSET_DEF,
                    IN_INTER, CLOSURE_SUBSET],
      ALL_TAC] THEN
    SUBGOAL_THEN ``!x:real. x IN u ==> &0 < setdist({x},s) + setdist({x},t)``
    ASSUME_TAC THENL
     [REPEAT STRIP_TAC THEN MATCH_MP_TAC(REAL_ARITH
        ``&0 <= x /\ &0 <= y /\ ~((x = &0) /\ (y = &0)) ==> &0 < x + y:real``) THEN
      REWRITE_TAC[SETDIST_POS_LE] THEN ASM_SET_TAC[],
      ALL_TAC] THEN
    REPEAT CONJ_TAC THENL
     [ONCE_REWRITE_TAC [METIS [] ``(\x. a +
       setdist ({x},s) / (setdist ({x},s) + setdist ({x},t)) * (b - a)) =
                                   (\x. (\x. a) x +
       (\x. setdist ({x},s) / (setdist ({x},s) + setdist ({x},t)) * (b - a)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      REWRITE_TAC[real_div, GSYM REAL_MUL_ASSOC] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. setdist ({x},s) *
       (inv (setdist ({x},s) + setdist ({x},t)) * (b - a))) =
                                   (\x. (\x. setdist ({x},s)) x *
       (\x. (inv (setdist ({x},s) + setdist ({x},t)) * (b - a))) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN CONJ_TAC THENL
      [REWRITE_TAC[CONTINUOUS_ON_SETDIST], ALL_TAC] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. inv (setdist ({x},s) + setdist ({x},t)) * (b - a)) =
            (\x. (\x. inv (setdist ({x},s) + setdist ({x},t))) x * (\x. (b - a)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN REWRITE_TAC[CONTINUOUS_ON_CONST, o_DEF] THEN
      REWRITE_TAC[CONTINUOUS_ON_SETDIST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. inv (setdist ({x},s) + setdist ({x},t))) =
                              (\x. inv ((\x. setdist ({x},s) + setdist ({x},t)) x))``] THEN
      MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
      ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. setdist ({x},s) + setdist ({x},t)) =
                      (\x. (\x. setdist ({x},s)) x + (\x. setdist ({x},t)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
      REWRITE_TAC[CONTINUOUS_ON_SETDIST],
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      SIMP_TAC std_ss[segment, GSPECIFICATION] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
      SIMP_TAC real_ss [REAL_ENTIRE, LEFT_AND_OVER_OR, REAL_ARITH
       ``(a + x * (b - a):real = (&1 - u) * a + u * b) <=>
        ((x - u) * (b - a) = 0)``, EXISTS_OR_THM] THEN
      DISJ1_TAC THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
      REWRITE_TAC[REAL_SUB_0, UNWIND_THM1] THEN
      ASM_SIMP_TAC std_ss [REAL_LE_DIV, REAL_LE_ADD, SETDIST_POS_LE, REAL_LE_LDIV_EQ,
                   REAL_ARITH ``a <= &1 * (a + b) <=> &0 <= b:real``],
      SIMP_TAC real_ss [REAL_ARITH ``(a + x:real = a) <=> (x = 0)``],
      REWRITE_TAC[REAL_ARITH ``(a + x * (b - a):real = b) <=>
                               ((x - &1) * (b - a) = 0)``]] THEN
    ASM_REWRITE_TAC[REAL_ENTIRE, REAL_SUB_0] THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_0, REAL_EQ_LDIV_EQ,
                 REAL_MUL_LZERO, REAL_MUL_LID] THEN
    REWRITE_TAC[REAL_ARITH ``(x:real = x + y) <=> (y = &0)``] THEN
    ASM_REWRITE_TAC[]);

val URYSOHN_LOCAL_STRONG = store_thm ("URYSOHN_LOCAL_STRONG",
 ``!s t u a b.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {}) /\ ~(a = b)
        ==> ?f:real->real.
               f continuous_on u /\
               (!x. x IN u ==> f(x) IN segment[a,b]) /\
               (!x. x IN u ==> ((f x = a) <=> x IN s)) /\
               (!x. x IN u ==> ((f x = b) <=> x IN t))``,
  KNOW_TAC ``!(s :real -> bool) (t :real -> bool).
   (\s t. !(u :real -> bool) (a :real) (b :real).
  closed_in (subtopology euclidean u) s /\
  closed_in (subtopology euclidean u) t /\
  (s INTER t = ({} :real -> bool)) /\ a <> b ==>
  ?(f :real -> real).
    f continuous_on u /\
    (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
    (!(x :real). x IN u ==> ((f x = a) <=> x IN s)) /\
    !(x :real). x IN u ==> ((f x = b) <=> x IN t)) s t`` THENL
  [ALL_TAC, SIMP_TAC std_ss []] THEN
  MATCH_MP_TAC(MESON[]
   ``(!s t. P s t <=> P t s) /\
    (!s t. ~(s = {}) /\ ~(t = {}) ==> P s t) /\
    P {} {} /\ (!t. ~(t = {}) ==> P {} t)
    ==> !s t. P s t``) THEN
  SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL

   [REPEAT GEN_TAC THEN
    KNOW_TAC ``(!(u :real -> bool) (a :real) (b :real).
   closed_in (subtopology euclidean u) (s :real -> bool) /\
   closed_in (subtopology euclidean u) (t :real -> bool) /\
   (s INTER t = ({} :real -> bool)) /\ a <> b ==>
   ?(f :real -> real).
     f continuous_on u /\
     (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
     (!(x :real). x IN u ==> ((f x = a) <=> x IN s)) /\
     !(x :real). x IN u ==> ((f x = b) <=> x IN t)) <=>
   !(u :real -> bool) (b :real) (a :real).
   closed_in (subtopology euclidean u) t /\
   closed_in (subtopology euclidean u) s /\
   (t INTER s = ({} :real -> bool)) /\ a <> b ==>
   ?(f :real -> real).
    f continuous_on u /\
    (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
    (!(x :real). x IN u ==> ((f x = a) <=> x IN t)) /\
    !(x :real). x IN u ==> ((f x = b) <=> x IN s)`` THENL
    [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     EQ_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THENL
     [POP_ASSUM (MP_TAC o SPECL [``u:real->bool``,``b:real``,``a:real``]),
      POP_ASSUM (MP_TAC o SPECL [``u:real->bool``,``a:real``,``b:real``])] THEN
     SIMP_TAC std_ss []] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    METIS_TAC[SEGMENT_SYM, INTER_COMM, CONJ_ACI, EQ_SYM_EQ],
    SIMP_TAC real_ss [lemma],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``(\x. midpoint(a,b)):real->real`` THEN
    ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, CONTINUOUS_ON_CONST, MIDPOINT_IN_SEGMENT] THEN
    REWRITE_TAC[midpoint] THEN CONJ_TAC THEN GEN_TAC THEN DISCH_TAC THEN
    UNDISCH_TAC ``~(a:real = b)`` THEN REWRITE_TAC[GSYM MONO_NOT_EQ] THEN
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
    SIMP_TAC std_ss [REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
    REAL_ARITH_TAC,
    REPEAT STRIP_TAC THEN ASM_CASES_TAC ``t:real->bool = u`` THENL
     [EXISTS_TAC ``(\x. b):real->real`` THEN
      ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, ENDS_IN_SEGMENT, IN_UNIV,
                      CONTINUOUS_ON_CONST],
      SUBGOAL_THEN ``?c:real. c IN u /\ ~(c IN t)`` STRIP_ASSUME_TAC THENL
       [REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET)) THEN
        REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[],
        ALL_TAC] THEN
      MP_TAC(ISPECL [``{c:real}``, ``t:real->bool``, ``u:real->bool``,
                     ``midpoint(a,b):real``, ``b:real``] lemma) THEN
      ASM_REWRITE_TAC[CLOSED_IN_SING, MIDPOINT_EQ_ENDPOINT] THEN
      KNOW_TAC ``({(c :real)} INTER (t :real -> bool) = ({} :real -> bool)) /\
                   {c} <> ({} :real -> bool)`` THENL
      [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN EXISTS_TAC ``f:real->real`` THEN
      POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IN_EMPTY] THEN
      STRIP_TAC THEN CONJ_TAC THENL
       [SUBGOAL_THEN
         ``segment[midpoint(a,b):real,b] SUBSET segment[a,b]`` MP_TAC
        THENL
         [REWRITE_TAC[SUBSET_DEF, IN_SEGMENT, midpoint] THEN GEN_TAC THEN
          DISCH_THEN(X_CHOOSE_THEN ``u:real`` STRIP_ASSUME_TAC) THEN
          EXISTS_TAC ``(&1 + u) / &2:real`` THEN ASM_REWRITE_TAC[] THEN
          SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
          CONJ_TAC THENL [UNDISCH_TAC ``0 <= u:real`` THEN REAL_ARITH_TAC, ALL_TAC] THEN
          CONJ_TAC THENL [UNDISCH_TAC ``u <= 1:real`` THEN REAL_ARITH_TAC, ALL_TAC] THEN
          ONCE_REWRITE_TAC [REAL_ARITH ``a * (b * c) = (a * c) * b:real``] THEN
          GEN_REWR_TAC (LAND_CONV o RAND_CONV) [GSYM REAL_MUL_RID] THEN
          ONCE_REWRITE_TAC [METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``]
           ``u * b * 1 = u * b * (2 / 2:real)``] THEN REWRITE_TAC [real_div] THEN
          ONCE_REWRITE_TAC [REAL_ARITH ``u * b * (2 * inv 2) = (u * b * 2) * inv 2:real``] THEN
          REWRITE_TAC [GSYM REAL_ADD_RDISTRIB] THEN REWRITE_TAC [GSYM real_div] THEN
          SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN REWRITE_TAC [REAL_ADD_RDISTRIB] THEN
          REWRITE_TAC [real_div, REAL_SUB_RDISTRIB] THEN
          REWRITE_TAC [REAL_ARITH
          ``(1 + u) * inv 2 * a * 2 = (1 + u) * a * (inv 2 * 2:real)``] THEN
          SIMP_TAC real_ss [REAL_MUL_LINV] THEN REAL_ARITH_TAC,
          ASM_SET_TAC[]],
        SUBGOAL_THEN ``~(a IN segment[midpoint(a,b):real,b])`` MP_TAC THENL
         [ALL_TAC, ASM_MESON_TAC[]] THEN
        DISCH_THEN(MP_TAC o CONJUNCT2 o MATCH_MP DIST_IN_CLOSED_SEGMENT) THEN
        REWRITE_TAC[DIST_MIDPOINT] THEN
        UNDISCH_TAC ``~(a:real = b)`` THEN REWRITE_TAC [dist] THEN
        SIMP_TAC real_ss [REAL_LE_RDIV_EQ] THEN REWRITE_TAC [REAL_NOT_LE] THEN
        REWRITE_TAC [abs] THEN COND_CASES_TAC THEN POP_ASSUM MP_TAC THEN REAL_ARITH_TAC]]]);

val URYSOHN_LOCAL = store_thm ("URYSOHN_LOCAL",
 ``!s t u a b.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {})
        ==> ?f:real->real.
               f continuous_on u /\
               (!x. x IN u ==> f(x) IN segment[a,b]) /\
               (!x. x IN s ==> (f x = a)) /\
               (!x. x IN t ==> (f x = b))``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``a:real = b`` THENL
   [EXISTS_TAC ``(\x. b):real->real`` THEN
    ASM_REWRITE_TAC[ENDS_IN_SEGMENT, CONTINUOUS_ON_CONST],
    MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``, ``u:real->bool``,
                   ``a:real``, ``b:real``] URYSOHN_LOCAL_STRONG) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN
    EXISTS_TAC ``f:real->real`` THEN POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET)) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN SET_TAC[]]);

val URYSOHN_STRONG = store_thm ("URYSOHN_STRONG",
 ``!s t a b.
        closed s /\ closed t /\ (s INTER t = {}) /\ ~(a = b)
        ==> ?f:real->real.
               f continuous_on univ(:real) /\ (!x. f(x) IN segment[a,b]) /\
               (!x. (f x = a) <=> x IN s) /\ (!x. (f x = b) <=> x IN t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN] THEN
  ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN
  DISCH_THEN(MP_TAC o MATCH_MP URYSOHN_LOCAL_STRONG) THEN
  REWRITE_TAC[IN_UNIV]);

val URYSOHN = store_thm ("URYSOHN",
 ``!s t a b.
        closed s /\ closed t /\ (s INTER t = {})
        ==> ?f:real->real.
               f continuous_on univ(:real) /\ (!x. f(x) IN segment[a,b]) /\
               (!x. x IN s ==> (f x = a)) /\ (!x. x IN t ==> (f x = b))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN] THEN
  ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN DISCH_THEN
   (MP_TAC o ISPECL [``a:real``, ``b:real``] o MATCH_MP URYSOHN_LOCAL) THEN
  REWRITE_TAC[IN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Basics about "local" properties in general.                               *)
(* ------------------------------------------------------------------------- *)

val locally = new_definition ("locally",
 ``locally P (s:real->bool) <=>
        !w x. open_in (subtopology euclidean s) w /\ x IN w
              ==> ?u v. open_in (subtopology euclidean s) u /\ P v /\
                        x IN u /\ u SUBSET v /\ v SUBSET w``);

val LOCALLY_MONO = store_thm ("LOCALLY_MONO",
 ``!P Q s. (!t. P t ==> Q t) /\ locally P s ==> locally Q s``,
  REWRITE_TAC[locally] THEN MESON_TAC[]);

val LOCALLY_OPEN_SUBSET = store_thm ("LOCALLY_OPEN_SUBSET",
 ``!P s t:real->bool.
        locally P s /\ open_in (subtopology euclidean s) t
        ==> locally P t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[locally] THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real->bool``, ``x:real``]) THEN
  KNOW_TAC ``open_in (subtopology euclidean s) w /\ x IN w`` THENL
  [ASM_MESON_TAC[OPEN_IN_TRANS],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``u:real->bool`` THEN EXISTS_TAC ``v:real->bool`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC OPEN_IN_SUBSET_TRANS THEN
  EXISTS_TAC ``s:real->bool`` THEN ASM_MESON_TAC[open_in, SUBSET_DEF]);

val LOCALLY_DIFF_CLOSED = store_thm ("LOCALLY_DIFF_CLOSED",
 ``!P s t:real->bool.
        locally P s /\ closed_in (subtopology euclidean s) t
        ==> locally P (s DIFF t)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LOCALLY_OPEN_SUBSET THEN
  EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN
  ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_REFL, SUBSET_UNIV, TOPSPACE_EUCLIDEAN]);

val LOCALLY_EMPTY = store_thm ("LOCALLY_EMPTY",
 ``!P. locally P {}``,
  REWRITE_TAC[locally] THEN MESON_TAC[open_in, SUBSET_DEF, NOT_IN_EMPTY]);

val LOCALLY_SING = store_thm ("LOCALLY_SING",
 ``!P a. locally P {a} <=> P {a}``,
  REWRITE_TAC[locally, open_in] THEN
  REWRITE_TAC[SET_RULE
   ``(w SUBSET {a} /\ P) /\ x IN w <=> (w = {a}) /\ (x = a) /\ P``] THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2, IN_SING] THEN
  REWRITE_TAC[SET_RULE
   ``(u SUBSET {a} /\ P) /\ Q /\ a IN u /\ u SUBSET v /\ v SUBSET {a} <=>
    (u = {a}) /\ (v = {a}) /\ P /\ Q``] THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, UNWIND_THM2, IN_SING] THEN
  REWRITE_TAC[UNWIND_FORALL_THM2, MESON[REAL_LT_01] ``?x:real. &0 < x``]);

val LOCALLY_INTER = store_thm ("LOCALLY_INTER",
 ``!P:(real->bool)->bool.
        (!s t. P s /\ P t ==> P(s INTER t))
        ==> !s t. locally P s /\ locally P t ==> locally P (s INTER t)``,
  GEN_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THEN
  REWRITE_TAC[locally, OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  ONCE_REWRITE_TAC [METIS [] ``( ?v t.
     open t /\ P v /\ x IN s INTER t /\ s INTER t SUBSET v /\
           v SUBSET w) = (\w x.  ?v t.
     open t /\ P v /\ x IN s INTER t /\ s INTER t SUBSET v /\
           v SUBSET w) w x``] THEN
  ONCE_REWRITE_TAC [METIS [] ``s INTER t = (\t. s INTER t:real->bool) t``] THEN
  ONCE_REWRITE_TAC [METIS [] ``x IN w <=> (\w x.  x IN w) w x``] THEN
  ONCE_REWRITE_TAC [METIS[]
   ``(!w x. (?t. P t /\ (w = f t) /\ Q w x) ==> R w x) <=>
     (!t x. P t /\ Q (f t) x ==> R (f t) x)``] THEN
  SIMP_TAC std_ss [] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, UNWIND_THM2, IN_INTER] THEN
  DISCH_TAC THEN X_GEN_TAC ``w:real->bool`` THEN X_GEN_TAC ``x:real`` THEN
  POP_ASSUM (MP_TAC o SPECL [``w:real->bool``,``x:real``]) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``u1:real->bool`` (X_CHOOSE_THEN ``v1:real->bool``
        STRIP_ASSUME_TAC))
   (X_CHOOSE_THEN ``u2:real->bool`` (X_CHOOSE_THEN ``v2:real->bool``
        STRIP_ASSUME_TAC))) THEN
  EXISTS_TAC ``u1 INTER u2:real->bool`` THEN
  EXISTS_TAC ``v1 INTER v2:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER] THEN ASM_SET_TAC[]);

val lemma = prove (
  ``!P Q f g. (!s t. P s /\ homeomorphism (s,t) (f,g) ==> Q t)
        ==> (!s:real->bool t:real->bool.
                locally P s /\ homeomorphism (s,t) (f,g) ==> locally Q t)``,
    REPEAT GEN_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THEN
    REWRITE_TAC[locally] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(STRIP_ASSUME_TAC o REWRITE_RULE [homeomorphism]) THEN
    MAP_EVERY X_GEN_TAC [``w:real->bool``, ``y:real``] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPECL
     [``IMAGE (g:real->real) w``, ``(g:real->real) y``]) THEN
    KNOW_TAC ``open_in (subtopology euclidean (s :real -> bool))
                     (IMAGE (g :real -> real) (w :real -> bool)) /\
                             g (y :real) IN IMAGE g w`` THENL
     [CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
      SUBGOAL_THEN ``IMAGE (g:real->real) w =
                     {x | x IN s /\ f(x) IN w}``
      SUBST1_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[],
        MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``IMAGE (f:real->real) u``, ``IMAGE (f:real->real) v``] THEN
    CONJ_TAC THENL
     [SUBGOAL_THEN ``IMAGE (f:real->real) u =
                     {x | x IN t /\ g(x) IN u}``
      SUBST1_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[],
        MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]],
      ALL_TAC] THEN
    CONJ_TAC THENL
     [FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``v:real->bool`` THEN
      ASM_REWRITE_TAC[homeomorphism] THEN
      REWRITE_TAC[homeomorphism] THEN REPEAT CONJ_TAC THEN
      TRY(FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
          CONTINUOUS_ON_SUBSET))),
      ALL_TAC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_LOCALLY = store_thm ("HOMEOMORPHISM_LOCALLY",
 ``!P Q f:real->real g.
        (!s t. homeomorphism (s,t) (f,g) ==> (P s <=> Q t))
        ==> (!s t. homeomorphism (s,t) (f,g)
                   ==> (locally P s <=> locally Q t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  MATCH_MP_TAC(SIMP_RULE std_ss [RIGHT_IMP_FORALL_THM,
        TAUT `p ==> q /\ r ==> s <=> p /\ r ==> q ==> s`] lemma) THEN
  ASM_MESON_TAC[HOMEOMORPHISM_SYM]);

val HOMEOMORPHIC_LOCALLY = store_thm ("HOMEOMORPHIC_LOCALLY",
 ``!P Q. (!s:real->bool t:real->bool. s homeomorphic t ==> (P s <=> Q t))
         ==> (!s t. s homeomorphic t ==> (locally P s <=> locally Q t))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SIMP_TAC std_ss [homeomorphic, LEFT_IMP_EXISTS_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(homeomorphism (s,t) (f,g) ==>
                               (locally P s <=> locally Q t)) =
                     (\s t f g. homeomorphism (s,t) (f,g) ==>
                               (locally P s <=> locally Q t)) s t f g``] THEN
  ONCE_REWRITE_TAC[METIS[]
   ``(!a b c d. P a b c d) <=> (!c d a b. P a b c d)``] THEN
  GEN_TAC THEN GEN_TAC THEN BETA_TAC THEN MATCH_MP_TAC HOMEOMORPHISM_LOCALLY THEN
  ASM_MESON_TAC[homeomorphic]);

val LOCALLY_TRANSLATION = store_thm ("LOCALLY_TRANSLATION",
 ``!P:(real->bool)->bool.
        (!a s. P (IMAGE (\x. a + x) s) <=> P s)
        ==> (!a s. locally P (IMAGE (\x. a + x) s) <=> locally P s)``,
  GEN_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  MP_TAC(ISPECL
   [``P:(real->bool)->bool``, ``P:(real->bool)->bool``,
    ``\x:real. a + x``, ``\x:real. -a + x``]
     HOMEOMORPHISM_LOCALLY) THEN
  SIMP_TAC real_ss [homeomorphism] THEN
  SIMP_TAC real_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID] THEN
  SIMP_TAC real_ss [UNWIND_FORALL_THM1, CONJ_EQ_IMP, GSYM IMAGE_COMPOSE, o_DEF] THEN
  REWRITE_TAC [REAL_ARITH ``(-a + (a + x:real) = x) /\ (a + (-a + x) = x:real)``] THEN
  REWRITE_TAC [IMAGE_ID] THEN METIS_TAC[]);

val LOCALLY_INJECTIVE_LINEAR_IMAGE = store_thm ("LOCALLY_INJECTIVE_LINEAR_IMAGE",
 ``!P:(real->bool)->bool Q:(real->bool)->bool.
        (!f s. linear f /\ (!x y. (f x = f y) ==> (x = y))
               ==> (P (IMAGE f s) <=> Q s))
        ==>  (!f s. linear f /\ (!x y. (f x = f y) ==> (x = y))
                    ==> (locally P (IMAGE f s) <=> locally Q s))``,
  GEN_TAC THEN GEN_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``f:real->real``) THEN
  ASM_CASES_TAC ``linear(f:real->real) /\ (!x y. (f x = f y) ==> (x = y))`` THEN
  ASM_REWRITE_TAC[] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LINEAR_INJECTIVE_LEFT_INVERSE) THEN
  REWRITE_TAC[FUN_EQ_THM, o_THM, I_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL
   [``Q:(real->bool)->bool``, ``P:(real->bool)->bool``,
    ``f:real->real``, ``g:real->real``]
     HOMEOMORPHISM_LOCALLY) THEN
  ASM_SIMP_TAC std_ss [homeomorphism, LINEAR_CONTINUOUS_ON] THEN
  ASM_SIMP_TAC std_ss [UNWIND_FORALL_THM1, CONJ_EQ_IMP, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID] THEN MESON_TAC[]);

val LOCALLY_OPEN_MAP_IMAGE = store_thm ("LOCALLY_OPEN_MAP_IMAGE",
 ``!P Q f:real->real s.
        f continuous_on s /\
        (!t. open_in (subtopology euclidean s) t
              ==> open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) /\
        (!t. t SUBSET s /\ P t ==> Q(IMAGE f t)) /\
        locally P s
        ==> locally Q (IMAGE f s)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[locally] THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``y:real``] THEN
  STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
  UNDISCH_TAC ``f continuous_on s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o  SPEC ``w:real->bool`` o
    REWRITE_RULE [CONTINUOUS_ON_OPEN]) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?x. x IN s /\ ((f:real->real) x = y)`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``{x | x IN s /\ (f:real->real) x IN w}``, ``x:real``]) THEN
  ASM_SIMP_TAC real_ss [GSPECIFICATION, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN MAP_EVERY EXISTS_TAC
   [``IMAGE (f:real->real) u``, ``IMAGE (f:real->real) v``] THEN
  ASM_SIMP_TAC real_ss [] THEN CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* F_sigma and G_delta sets.                                                 *)
(* ------------------------------------------------------------------------- *)

val gdelta = new_definition ("gdelta",
 ``gdelta(s:real->bool) <=>
    ?g. COUNTABLE g /\ (!u. u IN g ==> open u) /\ (BIGINTER g = s)``);

val fsigma = new_definition ("fsigma",
 ``fsigma(s:real->bool) <=>
    ?g. COUNTABLE g /\ (!c. c IN g ==> closed c) /\ (BIGUNION g = s)``);

val GDELTA_COMPLEMENT = store_thm ("GDELTA_COMPLEMENT",
 ``!s. gdelta(univ(:real) DIFF s) <=> fsigma s``,
  GEN_TAC THEN REWRITE_TAC[gdelta, fsigma] THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (\s. univ(:real) DIFF s) g`` THEN
  ASM_SIMP_TAC real_ss [COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  ASM_REWRITE_TAC[GSYM OPEN_CLOSED, GSYM closed_def] THEN
  ONCE_REWRITE_TAC[BIGINTER_BIGUNION, BIGUNION_BIGINTER] THEN
  SIMP_TAC real_ss [SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
  ASM_SIMP_TAC real_ss [SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``,
                  SET_RULE ``{x | x IN s} = s``]);

val FSIGMA_COMPLEMENT = store_thm ("FSIGMA_COMPLEMENT",
 ``!s. fsigma(univ(:real) DIFF s) <=> gdelta s``,
  ONCE_REWRITE_TAC[GSYM GDELTA_COMPLEMENT] THEN
  REWRITE_TAC[SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``]);

val CLOSED_AS_GDELTA = store_thm ("CLOSED_AS_GDELTA",
 ``!s:real->bool. closed s ==> gdelta s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[gdelta] THEN EXISTS_TAC
   ``{ BIGUNION { ball(x:real,inv(&n + &1)) | x IN s} | n IN univ(:num)}`` THEN
  SIMP_TAC real_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, NUM_COUNTABLE] THEN
  SIMP_TAC real_ss [FORALL_IN_IMAGE, OPEN_BIGUNION, OPEN_BALL] THEN
  MATCH_MP_TAC(SET_RULE
   ``(closure s = s) /\ s SUBSET t /\ t SUBSET closure s
     ==> (t = s)``) THEN
  ASM_REWRITE_TAC[CLOSURE_EQ] THEN CONJ_TAC THENL
   [SIMP_TAC real_ss [SUBSET_BIGINTER, FORALL_IN_IMAGE, IN_UNIV] THEN
    X_GEN_TAC ``n:num`` THEN SIMP_TAC real_ss [BIGUNION_IMAGE, SUBSET_DEF, GSPECIFICATION] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN EXISTS_TAC ``x:real`` THEN
    ASM_REWRITE_TAC[CENTRE_IN_BALL, REAL_LT_INV_EQ] THEN
    SIMP_TAC arith_ss [REAL_LT],
    REWRITE_TAC[SUBSET_DEF, CLOSURE_APPROACHABLE, BIGINTER_IMAGE, IN_UNIV] THEN
    X_GEN_TAC ``x:real`` THEN SIMP_TAC real_ss [GSPECIFICATION, BIGUNION_IMAGE] THEN
    DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN  DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o ONCE_REWRITE_RULE [REAL_ARCH_INV]) THEN
    DISCH_THEN(X_CHOOSE_THEN ``n:num`` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``n:num``) THEN REWRITE_TAC[IN_BALL] THEN
    DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
    POP_ASSUM MP_TAC THEN MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LT_TRANS) THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
        REAL_LT_TRANS)) THEN
    MATCH_MP_TAC REAL_LT_INV2 THEN
    SIMP_TAC arith_ss [REAL_OF_NUM_ADD, REAL_LT] THEN ASM_ARITH_TAC]);

(* ------------------------------------------------------------------------- *)
(* Local compactness.                                                        *)
(* ------------------------------------------------------------------------- *)

val LOCALLY_COMPACT = store_thm ("LOCALLY_COMPACT",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s ==> ?u v. x IN u /\ u SUBSET v /\ v SUBSET s /\
                             open_in (subtopology euclidean s) u /\
                             compact v``,
  GEN_TAC THEN REWRITE_TAC[locally] THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN FIRST_X_ASSUM
     (MP_TAC o SPECL [``s INTER ball(x:real,&1)``, ``x:real``]) THEN
    ASM_SIMP_TAC real_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
    ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_LT_01] THEN
    MESON_TAC[SUBSET_INTER],
    MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN
    REWRITE_TAC[CONJ_EQ_IMP] THEN GEN_REWR_TAC LAND_CONV [OPEN_IN_OPEN] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[IN_INTER] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC real_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN
    UNDISCH_TAC ``open t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(s INTER ball(x:real,e)) INTER u`` THEN
    EXISTS_TAC ``cball(x:real,e) INTER v`` THEN
    ASM_SIMP_TAC real_ss [OPEN_IN_INTER, OPEN_IN_OPEN_INTER, OPEN_BALL, CENTRE_IN_BALL,
                 COMPACT_INTER, COMPACT_CBALL, IN_INTER] THEN
    MP_TAC(ISPECL [``x:real``, ``e:real``] BALL_SUBSET_CBALL) THEN
    ASM_SET_TAC[]]);

val LOCALLY_COMPACT_ALT = store_thm ("LOCALLY_COMPACT_ALT",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s
            ==> ?u. x IN u /\
                    open_in (subtopology euclidean s) u /\
                    compact(closure u) /\ closure u SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  METIS_TAC[CLOSURE_SUBSET, SUBSET_TRANS, CLOSURE_MINIMAL,
            COMPACT_CLOSURE, BOUNDED_SUBSET, COMPACT_EQ_BOUNDED_CLOSED]);

val LOCALLY_COMPACT_INTER_CBALL = store_thm ("LOCALLY_COMPACT_INTER_CBALL",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s ==> ?e. &0 < e /\ closed(cball(x,e) INTER s)``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT, OPEN_IN_CONTAINS_CBALL] THEN
  EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_SIMP_TAC real_ss [LEFT_IMP_EXISTS_THM] THENL
  [ MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN
    ASM_REWRITE_TAC[] THEN
    SUBGOAL_THEN ``cball(x:real,e) INTER s = cball (x,e) INTER v``
    SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    ASM_SIMP_TAC real_ss [COMPACT_CBALL, COMPACT_INTER, COMPACT_IMP_CLOSED],

    X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
    EXISTS_TAC ``ball(x:real,e) INTER s`` THEN
    EXISTS_TAC ``cball(x:real,e) INTER s`` THEN
    REWRITE_TAC[GSYM OPEN_IN_CONTAINS_CBALL] THEN
    ASM_SIMP_TAC real_ss [IN_INTER, CENTRE_IN_BALL, INTER_SUBSET] THEN
    ASM_SIMP_TAC real_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTER, BOUNDED_CBALL] THEN
    ONCE_REWRITE_TAC[INTER_COMM] THEN
    SIMP_TAC real_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
    REWRITE_TAC [SUBSET_DEF, IN_INTER] THEN GEN_TAC THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    METIS_TAC[SUBSET_DEF, BALL_SUBSET_CBALL]]);

val LOCALLY_COMPACT_INTER_CBALLS = store_thm ("LOCALLY_COMPACT_INTER_CBALLS",
 ``!s:real->bool.
      locally compact s <=>
      !x. x IN s ==> ?e. &0 < e /\ !d. d <= e ==> closed(cball(x,d) INTER s)``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL] THEN
  EQ_TAC THENL [ALL_TAC, METIS_TAC[REAL_LE_REFL]] THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  GEN_TAC THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``cball(x:real,d) INTER s = cball(x,d) INTER cball(x,e) INTER s``
  SUBST1_TAC THENL
  [ REWRITE_TAC[INTER_ASSOC, GSYM CBALL_MIN_INTER] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
    BINOP_TAC THEN REWRITE_TAC[min_def] THEN PROVE_TAC [],
    ASM_SIMP_TAC real_ss [GSYM INTER_ASSOC, CLOSED_INTER, CLOSED_CBALL] ]);

val LOCALLY_COMPACT_COMPACT = store_thm ("LOCALLY_COMPACT_COMPACT",
 ``!s:real->bool.
        locally compact s <=>
        !k. k SUBSET s /\ compact k
            ==> ?u v. k SUBSET u /\
                      u SUBSET v /\
                      v SUBSET s /\
                      open_in (subtopology euclidean s) u /\
                      compact v``,
  GEN_TAC THEN GEN_REWR_TAC LAND_CONV [LOCALLY_COMPACT] THEN EQ_TAC THEN
  REPEAT STRIP_TAC THENL
   [ALL_TAC, METIS_TAC[SING_SUBSET, COMPACT_SING]] THEN
  UNDISCH_TAC ``!x. x IN s ==>
        ?u v. x IN u /\ u SUBSET v /\ v SUBSET s /\
          open_in (subtopology euclidean s) u /\ compact v`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->real->bool``, ``v:real->real->bool``] THEN
  DISCH_TAC THEN UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE
   [COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\x:real. k INTER u x) k``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, BIGUNION_IMAGE] THEN
  KNOW_TAC ``(!(x :real).
    x IN (k :real -> bool) ==>
    open_in (subtopology euclidean k)
      (k INTER (u :real -> real -> bool) x)) /\
    k SUBSET {y | ?(x :real). x IN k /\ y IN k INTER u x}`` THENL
   [CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC OPEN_IN_SUBTOPOLOGY_INTER_SUBSET THEN
    EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC OPEN_IN_INTER THEN REWRITE_TAC[OPEN_IN_REFL] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
    SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, BIGUNION_IMAGE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``BIGUNION(IMAGE (u:real->real->bool) t)`` THEN
    EXISTS_TAC ``BIGUNION(IMAGE (v:real->real->bool) t)`` THEN
    REPEAT CONJ_TAC THENL
     [ALL_TAC, ALL_TAC, ALL_TAC, MATCH_MP_TAC OPEN_IN_BIGUNION,
      MATCH_MP_TAC COMPACT_BIGUNION THEN ASM_SIMP_TAC std_ss [IMAGE_FINITE]] THEN
    ASM_SET_TAC[]]);

val LOCALLY_COMPACT_COMPACT_ALT = store_thm ("LOCALLY_COMPACT_COMPACT_ALT",
 ``!s:real->bool.
        locally compact s <=>
        !k. k SUBSET s /\ compact k
            ==> ?u. k SUBSET u /\
                    open_in (subtopology euclidean s) u /\
                    compact(closure u) /\ closure u SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_COMPACT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``k:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  METIS_TAC[CLOSURE_SUBSET, SUBSET_TRANS, CLOSURE_MINIMAL,
            COMPACT_CLOSURE, BOUNDED_SUBSET, COMPACT_EQ_BOUNDED_CLOSED]);

val LOCALLY_COMPACT_COMPACT_SUBOPEN = store_thm ("LOCALLY_COMPACT_COMPACT_SUBOPEN",
 ``!s:real->bool.
        locally compact s <=>
        !k t. k SUBSET s /\ compact k /\ open t /\ k SUBSET t
              ==> ?u v. k SUBSET u /\ u SUBSET v /\ u SUBSET t /\ v SUBSET s /\
                        open_in (subtopology euclidean s) u /\
                        compact v``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_COMPACT] THEN
  EQ_TAC THEN DISCH_TAC THEN REPEAT STRIP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``u INTER t:real->bool``, ``closure(u INTER t:real->bool)``] THEN
    REWRITE_TAC[CLOSURE_SUBSET, INTER_SUBSET] THEN REPEAT CONJ_TAC THENL
     [ASM_SET_TAC[],
      MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``closure(u:real->bool)`` THEN
      SIMP_TAC std_ss [SUBSET_CLOSURE, INTER_SUBSET] THEN
      MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``v:real->bool`` THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
      ASM_SIMP_TAC std_ss [OPEN_IN_INTER_OPEN],
      REWRITE_TAC[COMPACT_CLOSURE] THEN
      ASM_MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET, SUBSET_TRANS,
                    COMPACT_IMP_BOUNDED]],
    FIRST_X_ASSUM(MP_TAC o SPECL [``k:real->bool``, ``univ(:real)``]) THEN
    ASM_REWRITE_TAC[OPEN_UNIV, SUBSET_UNIV]]);

val OPEN_IMP_LOCALLY_COMPACT = store_thm ("OPEN_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. open s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN FIRST_ASSUM
   (MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  MAP_EVERY EXISTS_TAC [``ball(x:real,e)``, ``cball(x:real,e)``] THEN
  ASM_REWRITE_TAC[BALL_SUBSET_CBALL, CENTRE_IN_BALL, COMPACT_CBALL] THEN
  MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN ASM_REWRITE_TAC[OPEN_BALL] THEN
  MATCH_MP_TAC SUBSET_TRANS THEN METIS_TAC [BALL_SUBSET_CBALL]);

val CLOSED_IMP_LOCALLY_COMPACT = store_thm ("CLOSED_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. closed s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN MAP_EVERY EXISTS_TAC
   [``s INTER ball(x:real,&1)``, ``s INTER cball(x:real,&1)``] THEN
  ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, INTER_SUBSET, REAL_LT_01] THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_INTER_COMPACT, COMPACT_CBALL] THEN
  MP_TAC(ISPECL [``x:real``, ``&1:real``] BALL_SUBSET_CBALL) THEN ASM_SET_TAC[]);

val IS_INTERVAL_IMP_LOCALLY_COMPACT = store_thm ("IS_INTERVAL_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. is_interval s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``x:real``]
   INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``d:real``] THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [``s INTER ball(x:real,d)``, ``interval[a:real,b]``] THEN
  ASM_SIMP_TAC std_ss [COMPACT_INTERVAL, OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
  ASM_REWRITE_TAC[CENTRE_IN_BALL, IN_INTER] THEN ASM_SET_TAC[]);

val LOCALLY_COMPACT_UNIV = store_thm ("LOCALLY_COMPACT_UNIV",
 ``locally compact univ(:real)``,
  SIMP_TAC std_ss [OPEN_IMP_LOCALLY_COMPACT, OPEN_UNIV]);

val LOCALLY_COMPACT_INTER = store_thm ("LOCALLY_COMPACT_INTER",
 ``!s t:real->bool.
        locally compact s /\ locally compact t
        ==> locally compact (s INTER t)``,
  MATCH_MP_TAC LOCALLY_INTER THEN REWRITE_TAC[COMPACT_INTER]);

val LOCALLY_COMPACT_OPEN_IN = store_thm ("LOCALLY_COMPACT_OPEN_IN",
 ``!s t:real->bool.
        open_in (subtopology euclidean s) t /\ locally compact s
        ==> locally compact t``,
  REWRITE_TAC[OPEN_IN_OPEN] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [LOCALLY_COMPACT_INTER, OPEN_IMP_LOCALLY_COMPACT]);

val LOCALLY_COMPACT_CLOSED_IN = store_thm ("LOCALLY_COMPACT_CLOSED_IN",
 ``!s t:real->bool.
        closed_in (subtopology euclidean s) t /\ locally compact s
        ==> locally compact t``,
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [LOCALLY_COMPACT_INTER, CLOSED_IMP_LOCALLY_COMPACT]);

val LOCALLY_COMPACT_DELETE = store_thm ("LOCALLY_COMPACT_DELETE",
 ``!s a:real. locally compact s ==> locally compact (s DELETE a)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LOCALLY_COMPACT_OPEN_IN THEN
  EXISTS_TAC ``s:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DELETE, OPEN_IN_REFL]);

val HOMEOMORPHIC_LOCAL_COMPACTNESS = store_thm ("HOMEOMORPHIC_LOCAL_COMPACTNESS",
 ``!s t:real->bool.
        s homeomorphic t ==> (locally compact s <=> locally compact t)``,
  MATCH_MP_TAC HOMEOMORPHIC_LOCALLY THEN
  REWRITE_TAC[HOMEOMORPHIC_COMPACTNESS]);

val LOCALLY_COMPACT_TRANSLATION_EQ = store_thm ("LOCALLY_COMPACT_TRANSLATION_EQ",
 ``!a:real s. locally compact (IMAGE (\x. a + x) s) <=>
                locally compact s``,
  MATCH_MP_TAC LOCALLY_TRANSLATION THEN
  REWRITE_TAC[COMPACT_TRANSLATION_EQ]);

val LOCALLY_CLOSED = store_thm ("LOCALLY_CLOSED",
 ``!s:real->bool. locally closed s <=> locally compact s``,
  GEN_TAC THEN EQ_TAC THENL
   [ALL_TAC, MESON_TAC[LOCALLY_MONO, COMPACT_IMP_CLOSED]] THEN
  REWRITE_TAC[locally] THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real->bool``, ``x:real``]) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN
  EXISTS_TAC ``u INTER ball(x:real,&1)`` THEN
  EXISTS_TAC ``v INTER cball(x:real,&1)`` THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_INTER_OPEN, OPEN_BALL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_INTER_COMPACT, COMPACT_CBALL] THEN
  ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_LT_01] THEN
  MP_TAC(ISPEC ``x:real`` BALL_SUBSET_CBALL) THEN ASM_SET_TAC[]);

val LOCALLY_COMPACT_OPEN_UNION = store_thm ("LOCALLY_COMPACT_OPEN_UNION",
 ``!s t:real->bool.
        locally compact s /\ locally compact t /\
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t
        ==> locally compact (s UNION t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL, IN_UNION] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN STRIP_TAC THENL
   [UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
    DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    UNDISCH_TAC ``open_in (subtopology euclidean (s UNION t)) s`` THEN DISCH_TAC THEN
    FIRST_ASSUM (MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL]),
    UNDISCH_TAC ``!x. x IN t ==> ?e. 0 < e /\ closed (cball (x,e) INTER t)`` THEN
    DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    UNDISCH_TAC ``open_in (subtopology euclidean (s UNION t)) t`` THEN DISCH_TAC THEN
    FIRST_ASSUM (MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL])] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
  DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN
  UNDISCH_TAC `` !x. x IN t ==> ?e. 0 < e /\ closed (cball (x,e) INTER t)`` THEN
  DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [] THENL
  [DISCH_TAC THEN DISCH_THEN (X_CHOOSE_TAC ``e:real``),
   DISCH_THEN (X_CHOOSE_TAC ``e:real``) THEN DISCH_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  REWRITE_TAC[CBALL_MIN_INTER, INTER_ASSOC] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP (SET_RULE
   ``u INTER st SUBSET s ==> s SUBSET st ==> (u INTER st = u INTER s)``)) THEN
  REWRITE_TAC[SUBSET_UNION] THEN
  ONCE_REWRITE_TAC [SET_RULE ``a INTER b INTER c = b INTER (a INTER c)``] THEN
  DISCH_THEN SUBST1_TAC THEN
  ONCE_REWRITE_TAC [SET_RULE ``a INTER (b INTER c) = b INTER (a INTER c)``] THEN
  METIS_TAC[CLOSED_INTER, CLOSED_CBALL, INTER_ACI]);

val LOCALLY_COMPACT_CLOSED_UNION = store_thm ("LOCALLY_COMPACT_CLOSED_UNION",
 ``!s t:real->bool.
        locally compact s /\ locally compact t /\
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t
        ==> locally compact (s UNION t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL, IN_UNION] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN
  DISCH_THEN(STRIP_ASSUME_TAC o MATCH_MP (TAUT
   `p \/ q ==> p /\ q \/ p /\ ~q \/ q /\ ~p`))
  THENL
   [FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC ``d:real`` THEN STRIP_TAC THEN
    X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
    EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
    SIMP_TAC std_ss [SET_RULE ``u INTER (s UNION t) = u INTER s UNION u INTER t``] THEN
    MATCH_MP_TAC CLOSED_UNION THEN REWRITE_TAC[CBALL_MIN_INTER] THEN CONJ_TAC THENL
    [ONCE_REWRITE_TAC [SET_RULE ``a INTER b INTER c = b INTER (a INTER c)``],
     REWRITE_TAC [GSYM INTER_ASSOC]] THEN
    METIS_TAC[CLOSED_CBALL, CLOSED_INTER, INTER_ACI],
    UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    UNDISCH_TAC ``closed_in (subtopology euclidean (s UNION t)) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [closed_in]),
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    UNDISCH_TAC ``closed_in (subtopology euclidean (s UNION t)) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [closed_in])] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL]) THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, IN_DIFF, IN_UNION] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THENL
   [SUBGOAL_THEN ``cball (x:real,min d e) INTER (s UNION t) =
                  cball(x,d) INTER cball (x,e) INTER s`` SUBST1_TAC
    THENL [REWRITE_TAC[CBALL_MIN_INTER] THEN ASM_SET_TAC[], ALL_TAC],
    SUBGOAL_THEN ``cball (x:real,min d e) INTER (s UNION t) =
                  cball(x,d) INTER cball (x,e) INTER t`` SUBST1_TAC
    THENL [REWRITE_TAC[CBALL_MIN_INTER] THEN ASM_SET_TAC[], ALL_TAC]] THEN
  ASM_MESON_TAC[GSYM INTER_ASSOC, CLOSED_INTER, CLOSED_CBALL]);

val OPEN_IN_LOCALLY_COMPACT = store_thm ("OPEN_IN_LOCALLY_COMPACT",
 ``!s t:real->bool.
        locally compact s
        ==> (open_in (subtopology euclidean s) t <=>
             t SUBSET s /\
             !k. compact k /\ k SUBSET s
                 ==> open_in (subtopology euclidean k) (k INTER t))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THENL
   [ASM_MESON_TAC[OPEN_IN_IMP_SUBSET],
    UNDISCH_TAC ``open_in (subtopology euclidean s) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``t':real->bool``) THEN
    EXISTS_TAC ``t':real->bool`` THEN ASM_SET_TAC[],
    ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
    X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN
    KNOW_TAC ``a IN s:real->bool`` THENL
    [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN EXISTS_TAC ``t INTER u:real->bool`` THEN
    ASM_REWRITE_TAC[IN_INTER, INTER_SUBSET] THEN
    MATCH_MP_TAC OPEN_IN_TRANS THEN EXISTS_TAC ``u:real->bool`` THEN
    ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``closure u:real->bool``) THEN
    KNOW_TAC ``compact (closure u) /\ closure u SUBSET s`` THENL
     [SUBGOAL_THEN ``(closure u:real->bool) SUBSET v`` MP_TAC THENL
       [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
        REWRITE_TAC[COMPACT_CLOSURE] THEN
        ASM_MESON_TAC[SUBSET_TRANS, BOUNDED_SUBSET, COMPACT_IMP_BOUNDED]],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
      REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``t':real->bool``) THEN
      EXISTS_TAC ``t':real->bool`` THEN ASM_REWRITE_TAC [] THEN
      MP_TAC(ISPEC ``u:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]]]);

val LOCALLY_COMPACT_PROPER_IMAGE_EQ = store_thm ("LOCALLY_COMPACT_PROPER_IMAGE_EQ",
 ``!f:real->real s.
        f continuous_on s /\
        (!k. k SUBSET (IMAGE f s) /\ compact k
             ==> compact {x | x IN s /\ f x IN k})
        ==> (locally compact s <=> locally compact (IMAGE f s))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``,
                 ``IMAGE (f:real->real) s``] PROPER_MAP) THEN
  ASM_REWRITE_TAC[SUBSET_REFL] THEN STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [REWRITE_TAC[LOCALLY_COMPACT_ALT] THEN X_GEN_TAC ``y:real`` THEN
    DISCH_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``y:real``) THEN
    ASM_REWRITE_TAC[] THEN UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT_COMPACT_ALT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``{x | x IN s /\ ((f:real->real) x = y)}``) THEN
    ONCE_REWRITE_TAC [METIS [] ``(f x = y) = (\x. (f x = y)) x``] THEN
    ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
    DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN
     ``?v. open_in (subtopology euclidean (IMAGE f s)) v /\
          y IN v /\
          {x | x IN s /\ (f:real->real) x IN v} SUBSET u``
    MP_TAC THENL
     [GEN_REWR_TAC (BINDER_CONV o RAND_CONV o LAND_CONV)
       [GSYM SING_SUBSET] THEN
      MATCH_MP_TAC CLOSED_MAP_OPEN_SUPERSET_PREIMAGE THEN
      ASM_REWRITE_TAC[SING_SUBSET, IN_SING],
      DISCH_THEN (X_CHOOSE_TAC ``v:real->bool``) THEN EXISTS_TAC ``v:real->bool`` THEN
      POP_ASSUM MP_TAC THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
      SUBGOAL_THEN ``closure v SUBSET IMAGE (f:real->real) (closure u)``
      ASSUME_TAC THENL
       [MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``closure(IMAGE (f:real->real) u)`` THEN
        CONJ_TAC THENL
         [MATCH_MP_TAC SUBSET_CLOSURE THEN
          REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET)) THEN
          ASM_SET_TAC[],
          MATCH_MP_TAC CLOSURE_MINIMAL THEN
          SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
          MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
          MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
          ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]],
        CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
        REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
          BOUNDED_SUBSET)) THEN
        MATCH_MP_TAC COMPACT_IMP_BOUNDED THEN
        MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
        ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]],
    REWRITE_TAC[LOCALLY_COMPACT_ALT] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``locally compact (IMAGE (f :real -> real) (s :real -> bool))`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT_ALT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
    ASM_SIMP_TAC std_ss [FUN_IN_IMAGE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``closure v:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
    EXISTS_TAC ``{x | x IN s /\ (f:real->real) x IN v}`` THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN CONJ_TAC THENL
     [MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
      ASM_MESON_TAC[SUBSET_REFL],
      ALL_TAC] THEN
    SUBGOAL_THEN
     ``closure {x | x IN s /\ f x IN v} SUBSET
       {x | x IN s /\ (f:real->real) x IN closure v}``
    ASSUME_TAC THENL
     [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED] THEN
      MP_TAC(ISPEC ``v:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
      CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
      SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
      METIS_TAC[COMPACT_IMP_BOUNDED, BOUNDED_SUBSET]]]);

val LOCALLY_COMPACT_PROPER_IMAGE = store_thm ("LOCALLY_COMPACT_PROPER_IMAGE",
 ``!f:real->real s.
        f continuous_on s /\
        (!k. k SUBSET (IMAGE f s) /\ compact k
             ==> compact {x | x IN s /\ f x IN k}) /\
        locally compact s
        ==> locally compact (IMAGE f s)``,
  METIS_TAC[LOCALLY_COMPACT_PROPER_IMAGE_EQ]);

val MUMFORD_LEMMA = store_thm ("MUMFORD_LEMMA",
 ``!f:real->real s t y.
        f continuous_on s /\ IMAGE f s SUBSET t /\ locally compact s /\
        y IN t /\ compact {x | x IN s /\ (f x = y)}
        ==> ?u v. open_in (subtopology euclidean s) u /\
                  open_in (subtopology euclidean t) v /\
                  {x | x IN s /\ (f x = y)} SUBSET u /\ y IN v /\
                  IMAGE f u SUBSET v /\
                  (!k. k SUBSET v /\ compact k
                       ==> compact {x | x IN u /\ f x IN k})``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``{x | x IN s /\ ((f:real->real) x = y)}`` o
   REWRITE_RULE [LOCALLY_COMPACT_COMPACT]) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN
  SUBGOAL_THEN ``(closure u:real->bool) SUBSET v`` ASSUME_TAC THENL
   [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
    ALL_TAC] THEN
  SUBGOAL_THEN ``compact(closure u:real->bool)`` ASSUME_TAC THENL
   [ASM_REWRITE_TAC[COMPACT_CLOSURE] THEN
    ASM_MESON_TAC[BOUNDED_SUBSET, COMPACT_IMP_BOUNDED],
    ALL_TAC] THEN
  MATCH_MP_TAC(TAUT `(~p ==> F) ==> p`) THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``!b. open_in (subtopology euclidean t) b /\ y IN b
        ==> u INTER {x | x IN s /\ (f:real->real) x IN b} PSUBSET
            closure u INTER {x | x IN s /\ (f:real->real) x IN b}``
  MP_TAC THENL
   [REPEAT STRIP_TAC THEN REWRITE_TAC[PSUBSET_DEF] THEN
    SIMP_TAC std_ss [CLOSURE_SUBSET,
             SET_RULE ``s SUBSET t ==> s INTER u SUBSET t INTER u``] THEN
    MATCH_MP_TAC(MESON[] ``!P. ~P s /\ P t ==> ~(s = t)``) THEN
    EXISTS_TAC
     ``\a. !k. k SUBSET b /\ compact k
              ==> compact {x | x IN a /\ (f:real->real) x IN k}`` THEN
    SIMP_TAC std_ss [] THEN CONJ_TAC THENL
     [KNOW_TAC ``(open_in (subtopology euclidean s) (u INTER {x | x IN s /\ f x IN b})
                  ==> {x | x IN s /\ (f x = y)} SUBSET u INTER {x | x IN s /\ f x IN b}
                  ==> IMAGE f (u INTER {x | x IN s /\ f x IN b}) SUBSET b
                  ==> ~(!k. k SUBSET b /\ compact k
                  ==> compact
                    {x | x IN u INTER {x | x IN s /\ f x IN b} /\ f x IN k}))
                  ==> ~(!k. k SUBSET b /\ compact k
                     ==> compact
                     {x | x IN u INTER {x | x IN s /\ f x IN b} /\ f x IN k})`` THENL
       [ALL_TAC, METIS_TAC []] THEN
       KNOW_TAC ``open_in (subtopology euclidean s)
                  (u INTER {x | x IN s /\ (f:real->real) x IN b})`` THENL
       [MATCH_MP_TAC OPEN_IN_INTER THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN ASM_SET_TAC[],
        ASM_SET_TAC[]],
      X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
      SUBGOAL_THEN
       ``{x | x IN closure u INTER {x | x IN s /\ f x IN b} /\ f x IN k} =
        v INTER {x | x IN closure u /\ (f:real->real) x IN k}``
      SUBST1_TAC THENL [ASM_SET_TAC[], MATCH_MP_TAC COMPACT_INTER_CLOSED] THEN
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED, CLOSED_CLOSURE] THEN
      ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_TRANS]],
    DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC
     ``t INTER ball(y:real,inv(&n + &1))``) THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL, IN_INTER, CENTRE_IN_BALL] THEN
    ASM_REWRITE_TAC[REAL_LT_INV_EQ,
     METIS [REAL_LT, REAL_OF_NUM_ADD, GSYM ADD1, LESS_0] ``&0 < &n + &1:real``] THEN
    KNOW_TAC ``~(!n. ?x. x IN closure u /\
           ~(x IN u) /\
           x IN {x | x IN s /\ f x IN t /\ f x IN ball (y,inv (&n + &1))})`` THENL
    [ALL_TAC,
     METIS_TAC [CLOSURE_SUBSET, REAL_OF_NUM_ADD, SET_RULE
     ``u SUBSET u'
      ==> (u INTER t PSUBSET u' INTER t <=>
           ?x. x IN u' /\ ~(x IN u) /\ x IN t)``]] THEN
    KNOW_TAC ``~(?x. (!n. x n IN closure u) /\
       (!n. ~(x n IN u)) /\
       (!n. x n IN s) /\
       (!n. f (x n) IN t) /\
       (!n. dist (y,f (x n)) < inv (&n + &1)))`` THENL
    [ALL_TAC,
     SIMP_TAC std_ss [SKOLEM_THM, GSPECIFICATION, IN_BALL, FORALL_AND_THM] THEN
     METIS_TAC [SKOLEM_THM]] THEN
    DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPEC ``closure u:real->bool`` compact) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``x:num->real``) THEN
    ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN
    CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
    SUBGOAL_THEN ``(f:real->real) l = y`` ASSUME_TAC THENL
     [MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
      EXISTS_TAC ``(f:real->real) o x o (r:num->num)`` THEN
      ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN CONJ_TAC THENL
       [SUBGOAL_THEN ``(f:real->real) continuous_on closure u`` MP_TAC THENL
         [ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_TRANS], ALL_TAC] THEN
        REWRITE_TAC[CONTINUOUS_ON_SEQUENTIALLY] THEN
        DISCH_THEN MATCH_MP_TAC THEN ASM_SIMP_TAC std_ss [o_THM],
        REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC LIM_SUBSEQUENCE THEN
        ASM_SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
        CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
        X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
        MP_TAC(SPEC ``e:real`` REAL_ARCH_INV) THEN
        ASM_REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN
        EXISTS_TAC ``N:num`` THEN X_GEN_TAC ``n:num`` THEN
        DISCH_TAC THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
        MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``inv(&n + &1:real)`` THEN
        ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
        EXISTS_TAC ``inv(&N:real)`` THEN ASM_REWRITE_TAC[] THEN
        MATCH_MP_TAC REAL_LT_INV2 THEN
        ASM_SIMP_TAC arith_ss [REAL_OF_NUM_ADD, REAL_LT]],
      UNDISCH_TAC ``open_in (subtopology euclidean s) u`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [open_in]) THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC o SPEC ``l:real``)) THEN
      SIMP_TAC std_ss [NOT_IMP, NOT_EXISTS_THM] THEN
      CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``e:real`` THEN
      CCONTR_TAC THEN FULL_SIMP_TAC std_ss []] THEN
      UNDISCH_TAC ``(((x :num -> real) o (r :num -> num) --> (l :real))
          sequentially :bool)`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
      DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(X_CHOOSE_THEN ``n:num`` (MP_TAC o SPEC ``n:num``)) THEN
      ASM_SIMP_TAC std_ss [LESS_EQ_REFL, o_THM] THEN ASM_SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Locally compact sets are closed in an open set and are homeomorphic       *)
(* to an absolutely closed set if we have one more dimension to play with.   *)
(* ------------------------------------------------------------------------- *)

val LOCALLY_COMPACT_OPEN_INTER_CLOSURE = store_thm ("LOCALLY_COMPACT_OPEN_INTER_CLOSURE",
 ``!s:real->bool. locally compact s ==> ?t. open t /\ (s = t INTER closure s)``,
  GEN_TAC THEN SIMP_TAC std_ss [LOCALLY_COMPACT, OPEN_IN_OPEN, CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(x IN s INTER t /\ s INTER t SUBSET v /\
                                v SUBSET s /\ open t /\ compact v) =
                         (\v t. x IN s INTER t /\ s INTER t SUBSET v /\
                                v SUBSET s /\ open t /\ compact v) v t``] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC, TAUT `p /\ (x = y) /\ q <=> (x = y) /\ p /\ q`] THEN
  ONCE_REWRITE_TAC[MESON[] ``(?v t. P v t) <=> (?t v. P v t)``] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->real->bool``, ``v:real->real->bool``] THEN
  DISCH_TAC THEN EXISTS_TAC ``BIGUNION (IMAGE (u:real->real->bool) s)`` THEN
  ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, OPEN_BIGUNION, FORALL_IN_IMAGE] THEN
  REWRITE_TAC[INTER_BIGUNION] THEN MATCH_MP_TAC EQ_TRANS THEN EXISTS_TAC
   ``BIGUNION {v INTER s | v | v IN IMAGE (u:real->real->bool) s}`` THEN
  CONJ_TAC THENL
   [SIMP_TAC std_ss [BIGUNION_GSPEC, EXISTS_IN_IMAGE] THEN ASM_SET_TAC[], ALL_TAC] THEN
  AP_TERM_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``v INTER s = (\v. v INTER s:real->bool) v``] THEN
  MATCH_MP_TAC(SET_RULE ``(!x. x IN s ==> (f(g x) = f'(g x)))
    ==> ({f x | x IN IMAGE g s} = {f' x | x IN IMAGE g s})``) THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [GSYM SUBSET_ANTISYM_EQ] THEN CONJ_TAC THENL
   [MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
  REWRITE_TAC[SUBSET_INTER, INTER_SUBSET] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``closure((u:real->real->bool) x INTER s)`` THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER_CLOSURE_SUBSET] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``(v:real->real->bool) x`` THEN
  ASM_SIMP_TAC std_ss [] THEN MATCH_MP_TAC CLOSURE_MINIMAL THEN
  ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED] THEN ASM_SET_TAC[]]);

val LOCALLY_COMPACT_CLOSED_IN_OPEN = store_thm ("LOCALLY_COMPACT_CLOSED_IN_OPEN",
 ``!s:real->bool.
    locally compact s ==> ?t. open t /\ closed_in (subtopology euclidean t) s``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LOCALLY_COMPACT_OPEN_INTER_CLOSURE) THEN
  STRIP_TAC THEN EXISTS_TAC ``t:real->bool`` THEN ASM_SIMP_TAC std_ss [] THEN
  FIRST_X_ASSUM SUBST1_TAC THEN
  SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, CLOSED_CLOSURE]);

val LOCALLY_COMPACT_CLOSED_INTER_OPEN = store_thm ("LOCALLY_COMPACT_CLOSED_INTER_OPEN",
 ``!s:real->bool.
        locally compact s <=> ?t u. closed t /\ open u /\ (s = t INTER u)``,
  MESON_TAC[CLOSED_IMP_LOCALLY_COMPACT, OPEN_IMP_LOCALLY_COMPACT,
            LOCALLY_COMPACT_INTER, INTER_COMM, CLOSED_CLOSURE,
            LOCALLY_COMPACT_OPEN_INTER_CLOSURE]);

(* ------------------------------------------------------------------------- *)
(* Forms of the Baire propery of dense sets.                                 *)
(* ------------------------------------------------------------------------- *)

val BAIRE = store_thm ("BAIRE",
 ``!g s:real->bool.
        locally compact s /\ COUNTABLE g /\
        (!t. t IN g
             ==> open_in (subtopology euclidean s) t /\ s SUBSET closure t)
        ==> s SUBSET closure(BIGINTER g)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``g:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGINTER_EMPTY, CLOSURE_UNIV, SUBSET_UNIV] THEN
  MP_TAC(ISPEC ``g:(real->bool)->bool`` COUNTABLE_AS_IMAGE) THEN
  ASM_REWRITE_TAC[] THEN
  MAP_EVERY (C UNDISCH_THEN (K ALL_TAC))
   [``COUNTABLE(g:(real->bool)->bool)``,
    ``~(g:(real->bool)->bool = {})``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:num->real->bool`` SUBST_ALL_TAC) THEN
  RULE_ASSUM_TAC(SIMP_RULE std_ss [FORALL_IN_IMAGE, IN_UNIV]) THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_NONEMPTY_OPEN_INTER] THEN
  X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``v:real->bool`` THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [``\n:num u:real->bool.
        open_in (subtopology euclidean s) u /\ ~(u = {}) /\ u SUBSET v``,
    ``\n:num u v:real->bool.
       ?c. compact c /\ v SUBSET c /\ c SUBSET u /\ c SUBSET (g n)``]
   DEPENDENT_CHOICE) THEN
  SIMP_TAC std_ss [] THEN
  KNOW_TAC ``(?(a :real -> bool).
    open_in (subtopology euclidean (s :real -> bool)) a /\
    a <> ({} :real -> bool) /\ a SUBSET (v :real -> bool)) /\
 (!(n :num) (x :real -> bool).
    open_in (subtopology euclidean s) x /\ x <> ({} :real -> bool) /\
    x SUBSET v ==>
    ?(y :real -> bool).
      (open_in (subtopology euclidean s) y /\ y <> ({} :real -> bool) /\
       y SUBSET v) /\
      ?(c :real -> bool).
        compact c /\ y SUBSET c /\ c SUBSET x /\
        c SUBSET (g :num -> real -> bool) n)`` THENL
   [CONJ_TAC THENL
     [EXISTS_TAC ``s INTER v:real->bool`` THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER] THEN ASM_SET_TAC[],
      ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [``n:num``, ``w:real->bool``] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(STRIP_ASSUME_TAC o SPEC ``n:num``) THEN
    SUBGOAL_THEN ``?b:real. b IN w /\ b IN g(n:num)``
    STRIP_ASSUME_TAC THENL
     [UNDISCH_TAC ``open_in (subtopology euclidean s) (w:real->bool)`` THEN
      SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC ``t:real->bool`` THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[IN_INTER] THEN
      UNDISCH_TAC ``s SUBSET closure((g:num->real->bool) n)`` THEN
      REWRITE_TAC[SUBSET_DEF, CLOSURE_NONEMPTY_OPEN_INTER] THEN
      FIRST_X_ASSUM(X_CHOOSE_TAC ``x:real`` o
        REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
      KNOW_TAC ``x:real IN s`` THENL [ASM_SET_TAC[], DISCH_TAC THEN
       ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      DISCH_THEN(MP_TAC o SPEC ``t:real->bool``) THEN
      KNOW_TAC ``x:real IN t /\ open t`` THENL
      [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN SET_TAC[],
      UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC o REWRITE_RULE [locally]) THEN
      DISCH_THEN(MP_TAC o SPECL
       [``w INTER (g:num->real->bool) n``, ``b:real``]) THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_INTER, OPEN_IN_REFL, IN_INTER] THEN
      SIMP_TAC std_ss [GSYM RIGHT_EXISTS_AND_THM] THEN
      STRIP_TAC THEN MAP_EVERY EXISTS_TAC [``u:real->bool``,``v':real->bool``] THEN
      ASM_SET_TAC[]],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    SIMP_TAC std_ss [SKOLEM_THM, GSYM RIGHT_EXISTS_AND_THM, LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:num->real->bool``, ``c:num->real->bool``] THEN
    SIMP_TAC std_ss [FORALL_AND_THM] THEN STRIP_TAC THEN
    MATCH_MP_TAC(SET_RULE ``!s. s SUBSET t /\ ~(s = {}) ==> ~(t = {})``) THEN
    EXISTS_TAC ``BIGINTER {c n:real->bool | n IN univ(:num)}`` THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC COMPACT_NEST THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    ONCE_REWRITE_TAC [METIS [] ``(c n SUBSET c m) = (\m n. c n SUBSET c m) m n``] THEN
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM_SET_TAC[]]);

val BAIRE_ALT = store_thm ("BAIRE_ALT",
 ``!g s:real->bool.
        locally compact s /\ ~(s = {}) /\ COUNTABLE g /\ (BIGUNION g = s)
        ==> ?t u. t IN g /\ open_in (subtopology euclidean s) u /\
                  u SUBSET (closure t)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
  [``IMAGE (\t:real->bool. s DIFF closure t) g``, ``s:real->bool``] BAIRE) THEN
  ASM_SIMP_TAC std_ss [COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  MATCH_MP_TAC(TAUT `~q /\ (~r ==> p) ==> (p ==> q) ==> r`) THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC(SET_RULE
     ``~(s = {}) /\ ((t = {}) ==> (closure t = {})) /\ (t = {})
      ==> ~(s SUBSET closure t)``) THEN
    ASM_SIMP_TAC std_ss [CLOSURE_EMPTY] THEN
    MATCH_MP_TAC(SET_RULE ``i SUBSET s /\ (s DIFF i = s) ==> (i = {})``) THEN
    CONJ_TAC THENL [SIMP_TAC std_ss [BIGINTER_IMAGE] THEN ASM_SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[DIFF_BIGINTER] THEN
    REWRITE_TAC[SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
    SIMP_TAC std_ss [SET_RULE ``s DIFF (s DIFF t) = s INTER t``] THEN
    REWRITE_TAC[SET_RULE ``{s INTER closure t | t IN g} =
                          {s INTER t | t IN IMAGE closure g}``] THEN
    SIMP_TAC std_ss [GSYM INTER_BIGUNION, SET_RULE ``(s INTER t = s) <=> s SUBSET t``] THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    GEN_REWR_TAC (LAND_CONV o RAND_CONV) [GSYM IMAGE_ID] THEN
    MATCH_MP_TAC BIGUNION_MONO_IMAGE THEN SIMP_TAC std_ss [CLOSURE_SUBSET],
    SIMP_TAC std_ss [NOT_EXISTS_THM] THEN STRIP_TAC THEN
    X_GEN_TAC ``t:real->bool`` THEN REPEAT STRIP_TAC THENL
     [ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s DIFF (s INTER t)``] THEN
      MATCH_MP_TAC OPEN_IN_DIFF THEN
      ASM_SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, CLOSED_CLOSURE, OPEN_IN_REFL],
      REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      REWRITE_TAC[CLOSURE_APPROACHABLE] THEN
      X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPECL
       [``t:real->bool``, ``s INTER ball(x:real,e)``]) THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL, SUBSET_DEF, IN_INTER, IN_BALL,
                   IN_DIFF] THEN
      METIS_TAC[DIST_SYM]]]);

val NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED = store_thm ("NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED",
 ``!g:(real->bool)->bool.
        COUNTABLE g /\ (!s. s IN g ==> closed s /\ (interior s = {}))
        ==> (interior(BIGUNION g) = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{univ(:real) DIFF s | s IN g}``, ``univ(:real)``]
        BAIRE) THEN
  SIMP_TAC std_ss [LOCALLY_COMPACT_UNIV, GSYM OPEN_IN, SUBTOPOLOGY_UNIV] THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [GSYM closed_def, SET_RULE
   ``UNIV SUBSET s <=> (UNIV DIFF s = {})``] THEN
  SIMP_TAC std_ss[GSYM INTERIOR_COMPLEMENT] THEN
  SIMP_TAC std_ss [IMAGE_DEF, GSYM BIGUNION_BIGINTER] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``]);

val NOWHERE_DENSE_COUNTABLE_BIGUNION = store_thm ("NOWHERE_DENSE_COUNTABLE_BIGUNION",
 ``!g:(real->bool)->bool.
        COUNTABLE g /\ (!s. s IN g ==> (interior(closure s) = {}))
        ==> (interior(BIGUNION g) = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``IMAGE closure (g:(real->bool)->bool)``
        NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED) THEN
  ASM_SIMP_TAC std_ss [COUNTABLE_IMAGE, FORALL_IN_IMAGE, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (t = {}) ==> (s = {})``) THEN
  MATCH_MP_TAC SUBSET_INTERIOR THEN MATCH_MP_TAC BIGUNION_MONO THEN
  SIMP_TAC std_ss [EXISTS_IN_IMAGE] THEN MESON_TAC[CLOSURE_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* Partitions of unity subordinate to locally finite open coverings.         *)
(* ------------------------------------------------------------------------- *)

val SUBORDINATE_PARTITION_OF_UNITY = store_thm ("SUBORDINATE_PARTITION_OF_UNITY",
 ``!c s. s SUBSET BIGUNION c /\ (!u. u IN c ==> open u) /\
         (!x. x IN s
              ==> ?v. open v /\ x IN v /\
                      FINITE {u | u IN c /\ ~(u INTER v = {})})
         ==> ?f:(real->bool)->real->real.
                      (!u. u IN c
                           ==> f u continuous_on s /\
                               !x. x IN s ==> &0 <= f u x) /\
                      (!x u. u IN c /\ x IN s /\ ~(x IN u) ==> (f u x = &0)) /\
                      (!x. x IN s ==> (sum c (\u. f u x) = &1)) /\
                      (!x. x IN s
                           ==> ?n. open n /\ x IN n /\
                                   FINITE {u | u IN c /\
                                           ~(!x. x IN n ==> (f u x = &0))})``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``?u:real->bool. u IN c /\ s SUBSET u`` THENL
   [FIRST_X_ASSUM(CHOOSE_THEN STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``\v:real->bool x:real. if v = u then &1 else &0:real`` THEN
    SIMP_TAC arith_ss [COND_RAND, COND_RATOR, o_DEF, REAL_POS, REAL_OF_NUM_EQ,
                METIS [] ``(if p then q else T) <=> p ==> q``] THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CONST, COND_ID, SUM_DELTA] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    EXISTS_TAC ``ball(x:real,&1)`` THEN
    REWRITE_TAC[OPEN_BALL, CENTRE_IN_BALL, REAL_LT_01] THEN
    MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``{u:real->bool}`` THEN
    SIMP_TAC std_ss [FINITE_SING, SUBSET_DEF, GSPECIFICATION, IN_SING] THEN
    X_GEN_TAC ``v:real->bool`` THEN
    ASM_CASES_TAC ``v:real->bool = u`` THEN ASM_REWRITE_TAC[],
    ALL_TAC] THEN
  EXISTS_TAC ``\u:real->bool x:real.
        if x IN s
        then setdist({x},s DIFF u) / sum c (\v. setdist({x},s DIFF v))
        else &0`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  SIMP_TAC std_ss [SUM_POS_LE, SETDIST_POS_LE, REAL_LE_DIV] THEN
  SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF, real_div, REAL_MUL_LZERO] THEN
  SIMP_TAC std_ss [SUM_RMUL] THEN REWRITE_TAC[GSYM real_div] THEN
  MATCH_MP_TAC(TAUT `r /\ p /\ q ==> p /\ q /\ r`) THEN CONJ_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``n:real->bool``) THEN EXISTS_TAC ``n:real->bool`` THEN
    POP_ASSUM MP_TAC THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_FINITE_I) THEN
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real->bool`` THEN
    ASM_CASES_TAC ``(u:real->bool) IN c`` THENL [ALL_TAC, METIS_TAC []] THEN
    ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN X_GEN_TAC ``y:real`` THEN CCONTR_TAC THEN
    FULL_SIMP_TAC std_ss [] THEN POP_ASSUM MP_TAC THEN
    REWRITE_TAC[real_div, REAL_ENTIRE] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
    ASM_CASES_TAC ``(y:real) IN u`` THEN
    ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF, REAL_MUL_LZERO] THEN
    ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN
   ``!v x:real. v IN c /\ x IN s /\ x IN v ==> &0 < setdist({x},s DIFF v)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN
    SIMP_TAC std_ss [SETDIST_POS_LE, REAL_ARITH ``&0 < x <=> &0 <= x /\ ~(x = &0:real)``] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``s DIFF v:real->bool``, ``x:real``]
        SETDIST_EQ_0_CLOSED_IN) THEN
    ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, GSYM OPEN_CLOSED] THEN
    DISCH_THEN SUBST1_TAC THEN ASM_REWRITE_TAC[] THEN
    ASM_REWRITE_TAC[IN_INTER, IN_DIFF, IN_UNION] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  SUBGOAL_THEN
   ``!x:real. x IN s ==> &0 < sum c (\v. setdist ({x},s DIFF v))``
  ASSUME_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    ONCE_REWRITE_TAC[GSYM SUM_SUPPORT] THEN
    REWRITE_TAC[support, NEUTRAL_REAL_ADD] THEN
    MATCH_MP_TAC SUM_POS_LT THEN SIMP_TAC std_ss [SETDIST_POS_LE] THEN
    CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(CHOOSE_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_FINITE_I) THEN
      SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real->bool`` THEN
      ASM_CASES_TAC ``(x:real) IN u`` THEN
      ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF] THEN ASM_SET_TAC[],
      UNDISCH_TAC `` s SUBSET BIGUNION c:real->bool`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN REWRITE_TAC[IN_BIGUNION] THEN
      ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_THEN (X_CHOOSE_TAC ``t:real->bool``) THEN
      EXISTS_TAC ``t:real->bool`` THEN METIS_TAC[REAL_LT_IMP_NE]],
    ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE, REAL_DIV_REFL, o_DEF] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  MATCH_MP_TAC CONTINUOUS_ON_EQ THEN
  EXISTS_TAC ``\x:real.
        setdist({x},s DIFF u) / sum c (\v. setdist({x},s DIFF v))`` THEN
  SIMP_TAC std_ss [] THEN REWRITE_TAC[real_div] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(\x. setdist ({x},s DIFF u) *
   inv (sum c (\v. setdist ({x},s DIFF v)))) =
     (\x. (\x. setdist ({x},s DIFF u)) x *
   (\x. inv (sum c (\v. setdist ({x},s DIFF v)))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SETDIST, o_DEF] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(\x. inv (sum c (\v. setdist ({x},s DIFF v)))) =
     (\x. inv ((\x. sum c (\v. setdist ({x},s DIFF v))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE, CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``x:real`` th) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``n:real->bool`` STRIP_ASSUME_TAC)) THEN
  MATCH_MP_TAC CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN THEN
  MAP_EVERY EXISTS_TAC
   [``\x:real. sum {v | v IN c /\ ~(v INTER n = {})}
                         (\v. setdist({x},s DIFF v))``,
    ``s INTER n:real->bool``] THEN
  ASM_SIMP_TAC std_ss [IN_INTER, OPEN_IN_OPEN_INTER] THEN CONJ_TAC THENL
   [X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    CONV_TAC SYM_CONV THEN MATCH_MP_TAC SUM_EQ_SUPERSET THEN
    ASM_REWRITE_TAC[SUBSET_RESTRICT] THEN STRIP_TAC THENL
    [ASM_SET_TAC [], ALL_TAC] THEN X_GEN_TAC ``v:real->bool`` THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_TAC THEN
    MATCH_MP_TAC SETDIST_SING_IN_SET THEN ASM_SET_TAC[],
    ONCE_REWRITE_TAC [METIS []
     ``(\x. sum {v | v IN c /\ v INTER n <> {}}
       (\v. setdist ({x},s DIFF v))) =
       (\x. sum {v | v IN c /\ v INTER n <> {}}
       (\v. (\v x. setdist ({x},s DIFF v)) v x))``] THEN
    MATCH_MP_TAC CONTINUOUS_SUM THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_AT_SETDIST, CONTINUOUS_AT_WITHIN]]);

val _ = export_theory();

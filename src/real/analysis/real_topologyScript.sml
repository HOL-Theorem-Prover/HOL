(* ========================================================================= *)
(*                                                                           *)
(*                Elementary Topology in Euclidean Space (R^1)               *)
(*                                                                           *)
(*        (c) Copyright, John Harrison 1998-2015                             *)
(*        (c) Copyright, Valentina Bruno 2010                                *)
(*        (c) Copyright, Marco Maggesi 2014-2015                             *)
(*        (c) Copyright 2015,                                                *)
(*                       Muhammad Qasim,                                     *)
(*                       Osman Hasan,                                        *)
(*                       Hardware Verification Group,                        *)
(*                       Concordia University                                *)
(*            Contact:  <m_qasi@ece.concordia.ca>                            *)
(*                                                                           *)
(*    Note: This theory was ported from HOL Light                            *)
(*                                                                           *)
(* ========================================================================= *)

open HolKernel Parse boolLib bossLib;

open numTheory numLib unwindLib tautLib prim_recTheory
     combinTheory quotientTheory arithmeticTheory realTheory real_sigmaTheory
     jrhUtils pairTheory boolTheory pred_setTheory optionTheory
     sumTheory InductiveDefinition listTheory mesonLib
     realLib topologyTheory metricTheory netsTheory;

open wellorderTheory cardinalTheory permutesTheory iterateTheory hurdUtils;

val _ = new_theory "real_topology";

val std_ss' = std_ss -* ["lift_disj_eq", "lift_imp_disj"];

fun METIS ths tm = prove(tm,METIS_TAC ths);

val DISC_RW_KILL = DISCH_TAC THEN ONCE_ASM_REWRITE_TAC [] THEN
                   POP_ASSUM K_TAC;

fun ASSERT_TAC tm = SUBGOAL_THEN tm STRIP_ASSUME_TAC;
val ASM_ARITH_TAC = REPEAT (POP_ASSUM MP_TAC) THEN ARITH_TAC;

(* Minimal hol-light compatibility layer *)
val ASM_REAL_ARITH_TAC = REAL_ASM_ARITH_TAC; (* realLib *)
val IMP_CONJ           = CONJ_EQ_IMP;        (* cardinalTheory *)
val FINITE_SUBSET      = SUBSET_FINITE_I;    (* pred_setTheory *)
val SUM_ABS            = SUM_ABS';           (* iterateTheory *)
val SUM_ABS_LE         = SUM_ABS_LE';        (* iterateTheory *)
val SUM_EQ             = SUM_EQ';            (* iterateTheory *)
val SUM_LE             = SUM_LE';            (* iterateTheory *)

Overload "*_c"[local,inferior] = “pred_set$CROSS”;
val _ = temp_set_fixity "*_c" (Infixl 600)

(* experimental overloads *)
Overload uncountable           = “\s. ~countable s”
Overload UNCOUNTABLE[inferior] = “uncountable”

(* ------------------------------------------------------------------------- *)

val EXISTS_IN_INSERT = store_thm ("EXISTS_IN_INSERT",
 ``!P a s. (?x. x IN (a INSERT s) /\ P x) <=> P a \/ ?x. x IN s /\ P x``,
  REWRITE_TAC[IN_INSERT] THEN MESON_TAC[]);

val DEPENDENT_CHOICE_FIXED = store_thm ("DEPENDENT_CHOICE_FIXED",
 ``!P R a:'a. P 0 a /\ (!n x. P n x ==> ?y. P (SUC n) y /\ R n x y) ==>
          ?f. (f 0 = a) /\ (!n. P n (f n)) /\ (!n. R n (f n) (f(SUC n)))``,
  REPEAT STRIP_TAC THEN KNOW_TAC ``(?f. (f 0 = (a:'a)) /\
    (!n. f(SUC n) = (@y. P (SUC n) y /\ R n (f n) y)))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``f:num->'a`` THEN ASM_REWRITE_TAC [] THEN
  ONCE_REWRITE_TAC[METIS [] ``(!n. P n (f n)) = (!n. (\n. P n (f n)) n)``] THEN
  GEN_REWR_TAC LAND_CONV
   [MESON[num_CASES] ``(!n. P n) <=> P 0 /\ !n. P(SUC n)``] THEN
  ASM_SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN INDUCT_TAC THEN METIS_TAC[]);

val DEPENDENT_CHOICE = store_thm ("DEPENDENT_CHOICE",
 ``!P R:num->'a->'a->bool. (?a. P 0 a) /\
   (!n x. P n x ==> ?y. P (SUC n) y /\ R n x y) ==>
   ?f. (!n. P n (f n)) /\ (!n. R n (f n) (f(SUC n)))``,
  MESON_TAC[DEPENDENT_CHOICE_FIXED]);

val BIGUNION_MONO_IMAGE = store_thm ("BIGUNION_MONO_IMAGE",
 ``(!x. x IN s ==> f x SUBSET g x) ==>
    BIGUNION(IMAGE f s) SUBSET BIGUNION(IMAGE g s)``,
  SET_TAC[]);
(** proof without SET_TAC
    RW_TAC std_ss [SUBSET_DEF, IN_BIGUNION_IMAGE]
 >> rename1 `y IN s`
 >> Q.EXISTS_TAC `y` >> ASM_REWRITE_TAC []
 >> FIRST_X_ASSUM irule
 >> ASM_REWRITE_TAC []
 *)

val BIGUNION_MONO = store_thm ("BIGUNION_MONO",
 ``(!x. x IN s ==> ?y. y IN t /\ x SUBSET y) ==> BIGUNION s SUBSET BIGUNION t``,
  SET_TAC[]);
(** proof without SET_TAC
    rpt STRIP_TAC
 >> RW_TAC std_ss [SUBSET_DEF, IN_BIGUNION]
 >> rename1 `x IN y`
 >> Q.PAT_X_ASSUM `!x. x IN s ==> P` (MP_TAC o (Q.SPEC `y`))
 >> RW_TAC std_ss [SUBSET_DEF]
 >> rename1 `z IN t`
 >> Q.EXISTS_TAC `z` >> ASM_REWRITE_TAC []
 >> POP_ASSUM MATCH_MP_TAC
 >> ASM_REWRITE_TAC []
 *)

(* ------------------------------------------------------------------------- *)
(* Linear functions.                                                         *)
(* ------------------------------------------------------------------------- *)

val linear = new_definition ("linear",
  ``linear (f:real->real) <=>
        (!x y. f(x + y) = f(x) + f(y)) /\
        (!c x. f(c * x) = c * f(x))``);

(* Courtesy to Thomas Sewell for providing this proof (first) on Slack

   NOTE: The explicit-form of linear functions (linear_repr and linear_alt) does
         NOT hold in higher dimensional spaces, e.g. (f:real['M]->real['N]), cf.
         vec_linear_def in examples/vectorScript.sml (ported from HOL-Light).

         However, the theorem linear_repr is necessary in limTheory to show the
         equivalence between the old and new definitions of "differentiable":

         |- !f x. f differentiable_at x <=> f differentiable (at x)
 *)
Theorem linear_lemma[local]:
  (!c x. f(c * x) = c * f(x)) ==> ?l. f = (\x. l * x)
Proof
  rw []
  \\ qexists_tac `f 1`
  \\ rw [FUN_EQ_THM]
  \\ metis_tac [linear, REAL_MUL_RID]
QED

Theorem linear_repr :
    !f. linear f <=> ?l. f = \x. l * x
Proof
    Q.X_GEN_TAC ‘f’
 >> EQ_TAC
 >> rw [linear, linear_lemma]
 >> REAL_ARITH_TAC
QED

(* In fact, only the part ‘!c x. f(c * x) = c * f(x))’ is primitive.

   This theorem may simplify some theorems below, but it only holds for
   one-dimensional linear functions (I believe). --Chun Tian, 11 nov 2022.
 *)
Theorem linear_alt_cmul :
    !f. linear f <=> !c x. f(c * x) = c * f(x)
Proof
    Q.X_GEN_TAC ‘f’
 >> EQ_TAC >- rw [linear]
 >> rw [linear_repr]
 >> MATCH_MP_TAC linear_lemma >> art []
QED

val LINEAR_SCALING = store_thm ("LINEAR_SCALING",
 ``!c. linear(\x:real. c * x)``,
 SIMP_TAC std_ss [linear] THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_CMUL = store_thm ("LINEAR_COMPOSE_CMUL",
 ``!f c. linear f ==> linear (\x. c * f(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_NEG = store_thm ("LINEAR_COMPOSE_NEG",
 ``!f. linear f ==> linear (\x. -(f(x)))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_ADD = store_thm ("LINEAR_COMPOSE_ADD",
 ``!f g. linear f /\ linear g ==> linear (\x. f(x) + g(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_SUB = store_thm ("LINEAR_COMPOSE_SUB",
 ``!f g. linear f /\ linear g ==> linear (\x. f(x) - g(x))``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE = store_thm ("LINEAR_COMPOSE",
 ``!f g. linear f /\ linear g ==> linear (g o f)``,
  SIMP_TAC std_ss [linear, o_THM]);

val LINEAR_ID = store_thm ("LINEAR_ID",
 ``linear (\x. x)``,
  SIMP_TAC std_ss [linear]);

val LINEAR_ZERO = store_thm ("LINEAR_ZERO",
 ``linear (\x. 0)``,
  SIMP_TAC std_ss [linear] THEN CONJ_TAC THEN REAL_ARITH_TAC);

val LINEAR_NEGATION = store_thm ("LINEAR_NEGATION",
 ``linear (\x. -x)``,
  SIMP_TAC std_ss [linear] THEN REAL_ARITH_TAC);

val LINEAR_COMPOSE_SUM = store_thm ("LINEAR_COMPOSE_SUM",
 ``!f s. FINITE s /\ (!a. a IN s ==> linear(f a))
         ==> linear(\x. sum s (\a. f a x))``,
  GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN GEN_TAC THEN
  KNOW_TAC
    ``((!a. a IN s ==> linear (f a)) ==> linear (\x. sum s (\a. f a x))) =
     (\s. (!a. a IN s ==> linear (f a)) ==> linear (\x. sum s (\a. f a x))) s``
  THENL [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES, LINEAR_ZERO] THEN REPEAT STRIP_TAC THEN
  KNOW_TAC ``(linear (\x. f e x + sum s (\a. f a x))) =
              linear (\x. (\x. f e x) x + (\x. sum s (\a. f a x)) x)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LINEAR_COMPOSE_ADD THEN METIS_TAC [IN_INSERT]);

val LINEAR_MUL_COMPONENT = store_thm ("LINEAR_MUL_COMPONENT",
 ``!f:real->real v.
     linear f ==> linear (\x. f(x) * v)``,
  SIMP_TAC std_ss [linear] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LINEAR_0 = store_thm ("LINEAR_0",
 ``!f. linear f ==> (f(0) = 0)``,
  METIS_TAC [REAL_MUL_LZERO, linear]);

val LINEAR_CMUL = store_thm ("LINEAR_CMUL",
 ``!f c x. linear f ==> (f(c * x) = c * f(x))``,
  SIMP_TAC std_ss [linear]);

val LINEAR_NEG = store_thm ("LINEAR_NEG",
 ``!f x. linear f ==> (f(-x) = -(f x))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [LINEAR_CMUL]);

val LINEAR_ADD = store_thm ("LINEAR_ADD",
 ``!f x y. linear f ==> (f(x + y) = f(x) + f(y))``,
  SIMP_TAC std_ss [linear]);

val LINEAR_SUB = store_thm ("LINEAR_SUB",
 ``!f x y. linear f ==> (f(x - y) = f(x) - f(y))``,
  SIMP_TAC std_ss [real_sub, LINEAR_ADD, LINEAR_NEG]);

val LINEAR_SUM = store_thm ("LINEAR_SUM",
 ``!f g s. linear f /\ FINITE s ==> (f(sum s g) = sum s (f o g))``,
  GEN_TAC THEN GEN_TAC THEN SIMP_TAC std_ss [GSYM AND_IMP_INTRO, RIGHT_FORALL_IMP_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN
  KNOW_TAC ``(f (sum s g) = sum s (f o g)) =
          (\s. (f (sum s g) = sum s (f o g))) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES] THEN FIRST_ASSUM(fn th =>
    SIMP_TAC std_ss [MATCH_MP LINEAR_0 th, MATCH_MP LINEAR_ADD th, o_THM]));

val LINEAR_SUM_MUL = store_thm ("LINEAR_SUM_MUL",
 ``!f s c v.
        linear f /\ FINITE s
        ==> (f(sum s (\i. c i * v i)) = sum s (\i. c(i) * f(v i)))``,
  SIMP_TAC std_ss [LINEAR_SUM, o_DEF, LINEAR_CMUL]);

val lemma = prove (
 ``x = sum {1..1} (\i. x * &i)``,
  REWRITE_TAC [SUM_SING_NUMSEG] THEN BETA_TAC THEN REAL_ARITH_TAC);

val LINEAR_BOUNDED = store_thm ("LINEAR_BOUNDED",
 ``!f:real->real. linear f ==> ?B. !x. abs(f x) <= B * abs(x)``,
  REPEAT STRIP_TAC THEN EXISTS_TAC
   ``sum{1:num..1:num} (\i. abs((f:real->real)(&i)))`` THEN
  GEN_TAC THEN
  GEN_REWR_TAC (LAND_CONV o funpow 2 RAND_CONV) [lemma] THEN
  ASM_SIMP_TAC std_ss [LINEAR_SUM, FINITE_NUMSEG] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN REWRITE_TAC[GSYM SUM_LMUL] THEN
  MATCH_MP_TAC SUM_ABS_LE THEN REWRITE_TAC [FINITE_NUMSEG, IN_NUMSEG] THEN
  BETA_TAC THEN ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN
  ASM_SIMP_TAC std_ss [o_DEF, ABS_MUL, LINEAR_CMUL] THEN
  METIS_TAC [REAL_LE_RMUL, ABS_POS, REAL_LE_LT, REAL_MUL_COMM]);

val LINEAR_BOUNDED_POS = store_thm ("LINEAR_BOUNDED_POS",
 ``!f:real->real. linear f ==> ?B. &0 < B /\ !x. abs(f x) <= B * abs(x)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(X_CHOOSE_TAC ``B:real`` o MATCH_MP LINEAR_BOUNDED) THEN
  EXISTS_TAC ``abs(B) + &1:real`` THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x <= a ==> x <= b:real``) THEN
  MATCH_MP_TAC REAL_LE_RMUL_IMP THEN REWRITE_TAC[ABS_POS] THEN
  REAL_ARITH_TAC);

val SYMMETRIC_LINEAR_IMAGE = store_thm ("SYMMETRIC_LINEAR_IMAGE",
 ``!f s. (!x. x IN s ==> -x IN s) /\ linear f
          ==> !x. x IN (IMAGE f s) ==> -x IN (IMAGE f s)``,
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  SIMP_TAC std_ss [GSYM LINEAR_NEG] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Bilinear functions.                                                       *)
(* ------------------------------------------------------------------------- *)

val bilinear = new_definition ("bilinear",
  ``bilinear f <=> (!x. linear(\y. f x y)) /\ (!y. linear(\x. f x y))``);

val BILINEAR_SWAP = store_thm ("BILINEAR_SWAP",
 ``!op:real->real->real.
        bilinear(\x y. op y x) <=> bilinear op``,
  SIMP_TAC std_ss [bilinear, ETA_AX] THEN METIS_TAC[]);

val BILINEAR_LADD = store_thm ("BILINEAR_LADD",
 ``!h x y z. bilinear h ==> (h (x + y) z = (h x z) + (h y z))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_RADD = store_thm ("BILINEAR_RADD",
 ``!h x y z. bilinear h ==> (h x (y + z) = (h x y) + (h x z))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_LMUL = store_thm ("BILINEAR_LMUL",
 ``!h c x y. bilinear h ==> (h (c * x) y = c * (h x y))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_RMUL = store_thm ("BILINEAR_RMUL",
 ``!h c x y. bilinear h ==> (h x (c * y) = c * (h x y))``,
  SIMP_TAC std_ss [bilinear, linear]);

val BILINEAR_LNEG = store_thm ("BILINEAR_LNEG",
 ``!h x y. bilinear h ==> (h (-x) y = -(h x y))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [BILINEAR_LMUL]);

val BILINEAR_RNEG = store_thm ("BILINEAR_RNEG",
 ``!h x y. bilinear h ==> (h x (-y) = -(h x y))``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN SIMP_TAC std_ss [BILINEAR_RMUL]);

val BILINEAR_LZERO = store_thm ("BILINEAR_LZERO",
 ``!h x. bilinear h ==> (h (0) x = 0)``,
  ONCE_REWRITE_TAC[REAL_ARITH ``(x = 0:real) <=> (x + x = x)``] THEN
  SIMP_TAC std_ss [GSYM BILINEAR_LADD, REAL_ADD_LID]);

val BILINEAR_RZERO = store_thm ("BILINEAR_RZERO",
 ``!h x. bilinear h ==> (h x (0) = 0)``,
  ONCE_REWRITE_TAC[REAL_ARITH ``(x = 0:real) <=> (x + x = x)``] THEN
  SIMP_TAC std_ss [GSYM BILINEAR_RADD, REAL_ADD_LID]);

val BILINEAR_LSUB = store_thm ("BILINEAR_LSUB",
 ``!h x y z. bilinear h ==> (h (x - y) z = (h x z) - (h y z))``,
  SIMP_TAC std_ss [real_sub, BILINEAR_LNEG, BILINEAR_LADD]);

val BILINEAR_RSUB = store_thm ("BILINEAR_RSUB",
 ``!h x y z. bilinear h ==> (h x (y - z) = (h x y) - (h x z))``,
  SIMP_TAC std_ss [real_sub, BILINEAR_RNEG, BILINEAR_RADD]);

val lemma = prove (
 ``!s t. s CROSS t = {(x,y) | x IN s /\ y IN t}``,
  REWRITE_TAC [CROSS_DEF] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD]);

val BILINEAR_SUM = store_thm ("BILINEAR_SUM",
 ``!h:real->real->real.
       bilinear h /\ FINITE s /\ FINITE t
       ==> (h (sum s f) (sum t g) = sum (s CROSS t) (\(i,j). h (f i) (g j)))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [bilinear] THEN
  KNOW_TAC ``(!x. linear (\y. h:real->real->real x y)) = (!x. linear (h x))`` THENL
  [METIS_TAC [ETA_AX], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `(a /\ b) /\ c /\ d <=> (a /\ d) /\ (b /\ c)`] THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  KNOW_TAC ``((!y. linear (\x. h:real->real->real x y)) /\ FINITE s) =
             ((!y. linear (\x. h x y) /\ FINITE s))`` THENL
  [SIMP_TAC std_ss [LEFT_AND_FORALL_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o GEN_ALL o MATCH_MP LINEAR_SUM o SPEC_ALL) THEN
  SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [LINEAR_SUM, o_DEF, SUM_SUM_PRODUCT] THEN
  SIMP_TAC std_ss [lemma]);

val lemma = prove (
 ``!x. x = sum {1:num..1:num} (\i. x * &i)``,
  REWRITE_TAC [SUM_SING_NUMSEG] THEN BETA_TAC THEN REAL_ARITH_TAC);

val BILINEAR_BOUNDED = store_thm ("BILINEAR_BOUNDED",
 ``!h:real->real->real.
        bilinear h ==> ?B. !x y. abs(h x y) <= B * abs(x) * abs(y)``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``sum ({1:num..1:num} CROSS {1:num..1:num})
                  (\ (i,j). abs((h:real->real->real)
                                (&i) (&j)))`` THEN
  REPEAT GEN_TAC THEN GEN_REWR_TAC
   (LAND_CONV o RAND_CONV o BINOP_CONV) [lemma] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_SUM, FINITE_NUMSEG] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = b * c * a:real``] THEN
  REWRITE_TAC[GSYM SUM_LMUL] THEN MATCH_MP_TAC SUM_ABS_LE THEN
  SIMP_TAC std_ss [FINITE_CROSS, FINITE_NUMSEG, FORALL_PROD, IN_CROSS] THEN
  REWRITE_TAC[IN_NUMSEG] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [BILINEAR_LMUL, ABS_MUL] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RMUL, ABS_MUL, REAL_MUL_ASSOC] THEN
  METIS_TAC [REAL_LE_LT]);

val BILINEAR_BOUNDED_POS = store_thm ("BILINEAR_BOUNDED_POS",
 ``!h. bilinear h
       ==> ?B. &0 < B /\ !x y. abs(h x y) <= B * abs(x) * abs(y)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(X_CHOOSE_TAC ``B:real`` o MATCH_MP BILINEAR_BOUNDED) THEN
  EXISTS_TAC ``abs(B) + &1:real`` THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  REPEAT GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPECL [`x:real`, `y:real`]) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x <= a ==> x <= b:real``) THEN
  REPEAT(MATCH_MP_TAC REAL_LE_RMUL_IMP THEN
         SIMP_TAC std_ss [ABS_POS, REAL_LE_MUL]) THEN
  REAL_ARITH_TAC);

val BILINEAR_SUM_PARTIAL_SUC = store_thm ("BILINEAR_SUM_PARTIAL_SUC",
 ``!f g h:real->real->real m n.
        bilinear h
        ==> (sum {m..n} (\k. h (f k) (g(k + 1) - g(k))) =
                if m <= n then h (f(n + 1)) (g(n + 1)) - h (f m) (g m) -
                               sum {m..n} (\k. h (f(k + 1) - f(k)) (g(k + 1)))
                else 0)``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  GEN_TAC THEN INDUCT_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, NOT_LESS_EQ] THEN
  ASM_REWRITE_TAC[SUM_CLAUSES_NUMSEG] THENL
   [COND_CASES_TAC THEN ASM_SIMP_TAC arith_ss [] THENL
     [ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC,
      FULL_SIMP_TAC std_ss [bilinear, linear]], FULL_SIMP_TAC std_ss [bilinear, linear],
  POP_ASSUM MP_TAC THEN REWRITE_TAC [LE] THEN
  DISCH_THEN(DISJ_CASES_THEN2 SUBST_ALL_TAC ASSUME_TAC) THENL [ALL_TAC, ASM_REWRITE_TAC []] THEN
  ASM_SIMP_TAC std_ss [GSYM NOT_LESS, SUM_TRIV_NUMSEG, ARITH_PROVE ``n < SUC n``] THEN
  ASM_SIMP_TAC std_ss [GSYM ADD1, ADD_CLAUSES] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC,
  ALL_TAC] THEN POP_ASSUM MP_TAC THEN REWRITE_TAC [LE] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  ASM_SIMP_TAC std_ss [GSYM NOT_LESS, SUM_TRIV_NUMSEG, ARITH_PROVE ``n < SUC n``] THEN
  ASM_SIMP_TAC std_ss [GSYM ADD1, ADD_CLAUSES] THEN
  ASM_SIMP_TAC std_ss [BILINEAR_RSUB, BILINEAR_LSUB] THEN REAL_ARITH_TAC);

val BILINEAR_SUM_PARTIAL_PRE = store_thm ("BILINEAR_SUM_PARTIAL_PRE",
 ``!f g h:real->real->real m n.
        bilinear h
        ==> (sum {m..n} (\k. h (f k) (g(k) - g(k - 1))) =
                if m <= n then h (f(n + 1)) (g(n)) - h (f m) (g(m - 1)) -
                               sum {m..n} (\k. h (f(k + 1) - f(k)) (g(k)))
                else 0)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o ISPECL [``f:num->real``, ``\k. (g:num->real)(k - 1)``,
                 ``m:num``, ``n:num``] o MATCH_MP BILINEAR_SUM_PARTIAL_SUC) THEN
  BETA_TAC THEN REWRITE_TAC[ADD_SUB] THEN DISCH_THEN SUBST1_TAC THEN
  COND_CASES_TAC THEN REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* A bit of linear algebra.                                                  *)
(* ------------------------------------------------------------------------- *)

val subspace = new_definition ("subspace",
 ``subspace s <=>
        (0:real) IN s /\
        (!x y. x IN s /\ y IN s ==> (x + y) IN s) /\
        (!c x. x IN s ==> (c * x) IN s)``);

val span = new_definition ("span",
  ``span s = subspace hull s``);

val dependent = new_definition ("dependent",
 ``dependent s <=> ?a. a IN s /\ a IN span(s DELETE a)``);

val independent = new_definition ("independent",
 ``independent s <=> ~(dependent s)``);

(* ------------------------------------------------------------------------- *)
(* Closure properties of subspaces.                                          *)
(* ------------------------------------------------------------------------- *)

val SUBSPACE_UNIV = store_thm ("SUBSPACE_UNIV",
 ``subspace(UNIV:real->bool)``,
  REWRITE_TAC[subspace, IN_UNIV]);

val SUBSPACE_IMP_NONEMPTY = store_thm ("SUBSPACE_IMP_NONEMPTY",
 ``!s. subspace s ==> ~(s = {})``,
  REWRITE_TAC[subspace] THEN SET_TAC[]);

val SUBSPACE_0 = store_thm ("SUBSPACE_0",
 ``subspace s ==> (0:real) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_ADD = store_thm ("SUBSPACE_ADD",
 ``!x y s. subspace s /\ x IN s /\ y IN s ==> (x + y) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_MUL = store_thm ("SUBSPACE_MUL",
 ``!x c s. subspace s /\ x IN s ==> (c * x) IN s``,
  SIMP_TAC std_ss [subspace]);

val SUBSPACE_NEG = store_thm ("SUBSPACE_NEG",
 ``!x s. subspace s /\ x IN s ==> (-x) IN s``,
  METIS_TAC [REAL_ARITH ``-x = -(&1) * x:real``, SUBSPACE_MUL]);

val SUBSPACE_SUB = store_thm ("SUBSPACE_SUB",
 ``!x y s. subspace s /\ x IN s /\ y IN s ==> (x - y) IN s``,
  SIMP_TAC std_ss [real_sub, SUBSPACE_ADD, SUBSPACE_NEG]);

val SUBSPACE_SUM = store_thm ("SUBSPACE_SUM",
 ``!s f t. subspace s /\ FINITE t /\ (!x. x IN t ==> f(x) IN s)
           ==> (sum t f) IN s``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!t. ((!x. x IN t ==> f x IN s) ==> sum t f IN s) =
                               (\t. (!x. x IN t ==> f x IN s) ==> sum t f IN s) t``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  ASM_SIMP_TAC std_ss [SUM_CLAUSES, SUBSPACE_0, IN_INSERT, SUBSPACE_ADD]);

val SUBSPACE_LINEAR_IMAGE = store_thm ("SUBSPACE_LINEAR_IMAGE",
 ``!f s. linear f /\ subspace s ==> subspace(IMAGE f s)``,
  SIMP_TAC std_ss [subspace, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN REWRITE_TAC[IN_IMAGE] THEN
  METIS_TAC [linear, LINEAR_0]);

val SUBSPACE_LINEAR_PREIMAGE = store_thm ("SUBSPACE_LINEAR_PREIMAGE",
 ``!f s. linear f /\ subspace s ==> subspace {x | f(x) IN s}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  METIS_TAC [linear, LINEAR_0]);

val SUBSPACE_TRIVIAL = store_thm ("SUBSPACE_TRIVIAL",
 ``subspace {0}``,
  SIMP_TAC std_ss [subspace, IN_SING] THEN CONJ_TAC THEN REAL_ARITH_TAC);

val SUBSPACE_INTER = store_thm ("SUBSPACE_INTER",
 ``!s t. subspace s /\ subspace t ==> subspace (s INTER t)``,
  REWRITE_TAC[subspace, IN_INTER] THEN METIS_TAC []);

val SUBSPACE_BIGINTER = store_thm ("SUBSPACE_BIGINTER",
 ``!f. (!s. s IN f ==> subspace s) ==> subspace(BIGINTER f)``,
  SIMP_TAC std_ss [subspace, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, IN_BIGINTER]);

val LINEAR_INJECTIVE_0_SUBSPACE = store_thm ("LINEAR_INJECTIVE_0_SUBSPACE",
 ``!f:real->real s.
        linear f /\ subspace s
         ==> ((!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) <=>
              (!x. x IN s /\ (f x = 0) ==> (x = 0)))``,
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_SUB_0] THEN
  ASM_SIMP_TAC std_ss [GSYM LINEAR_SUB] THEN
  METIS_TAC [REAL_SUB_RZERO, SUBSPACE_SUB, SUBSPACE_0]);

val SUBSPACE_UNION_CHAIN = store_thm ("SUBSPACE_UNION_CHAIN",
 ``!s t:real->bool.
        subspace s /\ subspace t /\ subspace(s UNION t)
         ==> s SUBSET t \/ t SUBSET s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC [SET_RULE
   ``s SUBSET t \/ t SUBSET s <=>
    ~(?x y. x IN s /\ ~(x IN t) /\ y IN t /\ ~(y IN s))``] THEN
  STRIP_TAC THEN SUBGOAL_THEN ``(x + y:real) IN (s UNION t)`` MP_TAC THENL
   [MATCH_MP_TAC SUBSPACE_ADD THEN ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
    REWRITE_TAC[IN_UNION, DE_MORGAN_THM] THEN
    METIS_TAC [SUBSPACE_SUB, REAL_ARITH
     ``((x + y) - x:real = y) /\ ((x + y) - y:real = x)``]]);

(* ------------------------------------------------------------------------- *)
(* Lemmas.                                                                   *)
(* ------------------------------------------------------------------------- *)

val SPAN_SPAN = store_thm ("SPAN_SPAN",
 ``!s. span(span s) = span s``,
  REWRITE_TAC[span, HULL_HULL]);

val SPAN_MONO = store_thm ("SPAN_MONO",
 ``!s t. s SUBSET t ==> span s SUBSET span t``,
  REWRITE_TAC[span, HULL_MONO]);

val SUBSPACE_SPAN = store_thm ("SUBSPACE_SPAN",
 ``!s. subspace(span s)``,
  GEN_TAC THEN REWRITE_TAC[span] THEN MATCH_MP_TAC P_HULL THEN
  SIMP_TAC std_ss [subspace, IN_BIGINTER]);

val SPAN_CLAUSES = store_thm ("SPAN_CLAUSES",
 ``(!a s. a IN s ==> a IN span s) /\
   ((0) IN span s) /\
   (!x y s. x IN span s /\ y IN span s ==> (x + y) IN span s) /\
   (!x c s. x IN span s ==> (c * x) IN span s)``,
  MESON_TAC[span, HULL_SUBSET, SUBSET_DEF, SUBSPACE_SPAN, subspace]);

val SPAN_INDUCT = store_thm ("SPAN_INDUCT",
 ``!s h. (!x. x IN s ==> x IN h) /\ subspace h ==> !x. x IN span(s) ==> h(x)``,
  REWRITE_TAC[span] THEN MESON_TAC[SUBSET_DEF, HULL_MINIMAL, IN_DEF]);

val SPAN_EMPTY = store_thm ("SPAN_EMPTY",
 ``span {} = {0}``,
  REWRITE_TAC[span] THEN MATCH_MP_TAC HULL_UNIQUE THEN
  SIMP_TAC std_ss [subspace, SUBSET_DEF, IN_SING, NOT_IN_EMPTY] THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val INDEPENDENT_EMPTY = store_thm ("INDEPENDENT_EMPTY",
 ``independent {}``,
  REWRITE_TAC[independent, dependent, NOT_IN_EMPTY]);

val INDEPENDENT_NONZERO = store_thm ("INDEPENDENT_NONZERO",
 ``!s. independent s ==> ~(0 IN s)``,
  REWRITE_TAC[independent, dependent] THEN MESON_TAC[SPAN_CLAUSES]);

val INDEPENDENT_MONO = store_thm ("INDEPENDENT_MONO",
 ``!s t. independent t /\ s SUBSET t ==> independent s``,
  REWRITE_TAC[independent, dependent] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_DELETE]);

val DEPENDENT_MONO = store_thm ("DEPENDENT_MONO",
 ``!s t:real->bool. dependent s /\ s SUBSET t ==> dependent t``,
  ONCE_REWRITE_TAC[TAUT `p /\ q ==> r <=> ~r /\ q ==> ~p`] THEN
  REWRITE_TAC[GSYM independent, INDEPENDENT_MONO]);

val SPAN_SUBSPACE = store_thm ("SPAN_SUBSPACE",
 ``!b s. b SUBSET s /\ s SUBSET (span b) /\ subspace s ==> (span b = s)``,
  MESON_TAC[SUBSET_ANTISYM, span, HULL_MINIMAL]);

val SPAN_INDUCT_ALT = store_thm ("SPAN_INDUCT_ALT",
 ``!s h. h(0) /\
         (!c x y. x IN s /\ h(y) ==> h(c * x + y))
          ==> !x:real. x IN span(s) ==> h(x)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o prove_nonschematic_inductive_relations_exist bool_monoset o concl) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``!x:real. x IN span(s) ==> g(x)``
   (fn th => METIS_TAC [th]) THEN
  MATCH_MP_TAC SPAN_INDUCT THEN SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  SIMP_TAC std_ss [IN_DEF, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(g x ==> g (c * x)) = (\c x:real. g x ==> g (c * x)) c x``] THEN
  ONCE_REWRITE_TAC[SWAP_FORALL_THM] THEN SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN
  REPEAT CONJ_TAC THENL
  [METIS_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   METIS_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   ONCE_REWRITE_TAC [METIS [] ``!x. (!y. g y ==> g (x + y)) =
                              (\x. !y. g y ==> g (x + y)) (x:real)``] THEN
   FIRST_X_ASSUM MATCH_MP_TAC THEN
   SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_ASSOC] THEN
   ASM_MESON_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO],
   ONCE_REWRITE_TAC [METIS [] ``(!x. g (x * y)) =
                            (\y.!x. g (x * y)) (y:real)``] THEN
   FIRST_X_ASSUM MATCH_MP_TAC THEN
   SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_ASSOC] THEN
   ASM_MESON_TAC [IN_DEF, REAL_ADD_LID, REAL_ADD_ASSOC, REAL_ADD_SYM,
                REAL_MUL_LID, REAL_MUL_RZERO]]);

(* ------------------------------------------------------------------------- *)
(* Individual closure properties.                                            *)
(* ------------------------------------------------------------------------- *)

val SPAN_SUPERSET = store_thm ("SPAN_SUPERSET",
 ``!x. x IN s ==> x IN span s``,
  MESON_TAC[SPAN_CLAUSES]);

val SPAN_INC = store_thm ("SPAN_INC",
 ``!s. s SUBSET span s``,
  REWRITE_TAC[SUBSET_DEF, SPAN_SUPERSET]);

val SPAN_UNION_SUBSET = store_thm ("SPAN_UNION_SUBSET",
 ``!s t. span s UNION span t SUBSET span(s UNION t)``,
  REWRITE_TAC[span, HULL_UNION_SUBSET]);

val SPAN_UNIV = store_thm ("SPAN_UNIV",
 ``span univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [SPAN_INC, SET_RULE ``UNIV SUBSET s ==> (s = UNIV)``]);

val SPAN_0 = store_thm ("SPAN_0",
 ``(0) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_0]);

val SPAN_ADD = store_thm ("SPAN_ADD",
 ``!x y s. x IN span s /\ y IN span s ==> (x + y) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_ADD]);

val SPAN_MUL = store_thm ("SPAN_MUL",
 ``!x c s. x IN span s ==> (c * x) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_MUL]);

val SPAN_MUL_EQ = store_thm ("SPAN_MUL_EQ",
 ``!x:real c s. ~(c = &0) ==> ((c * x) IN span s <=> x IN span s)``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN ASM_SIMP_TAC std_ss [SPAN_MUL] THEN
  SUBGOAL_THEN ``(inv(c) * c * x:real) IN span s`` MP_TAC THENL
   [REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN ASM_SIMP_TAC std_ss [SPAN_MUL],
    ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID]]);

val SPAN_NEG = store_thm ("SPAN_NEG",
 ``!x s. x IN span s ==> (-x) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_NEG]);

val SPAN_NEG_EQ = store_thm ("SPAN_NEG_EQ",
 ``!x s. -x IN span s <=> x IN span s``,
  MESON_TAC[SPAN_NEG, REAL_NEG_NEG]);

val SPAN_SUB = store_thm ("SPAN_SUB",
 ``!x y s. x IN span s /\ y IN span s ==> (x - y) IN span s``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_SUB]);

val SPAN_SUM = store_thm ("SPAN_SUM",
 ``!s f t. FINITE t /\ (!x. x IN t ==> f(x) IN span(s))
           ==> (sum t f) IN span(s)``,
  MESON_TAC[SUBSPACE_SPAN, SUBSPACE_SUM]);

val SPAN_ADD_EQ = store_thm ("SPAN_ADD_EQ",
 ``!s x y. x IN span s ==> ((x + y) IN span s <=> y IN span s)``,
  MESON_TAC[SPAN_ADD, SPAN_SUB, REAL_ARITH ``(x + y) - x:real = y``]);

val SPAN_EQ_SELF = store_thm ("SPAN_EQ_SELF",
 ``!s. (span s = s) <=> subspace s``,
  GEN_TAC THEN EQ_TAC THENL [MESON_TAC[SUBSPACE_SPAN], ALL_TAC] THEN
  DISCH_TAC THEN MATCH_MP_TAC SPAN_SUBSPACE THEN
  ASM_REWRITE_TAC[SUBSET_REFL, SPAN_INC]);

val SPAN_SUBSET_SUBSPACE = store_thm ("SPAN_SUBSET_SUBSPACE",
 ``!s t:real->bool. s SUBSET t /\ subspace t ==> span s SUBSET t``,
  MESON_TAC[SPAN_MONO, SPAN_EQ_SELF]);

val SURJECTIVE_IMAGE_EQ = store_thm ("SURJECTIVE_IMAGE_EQ",
 ``!s t. (!y. y IN t ==> ?x. f x = y) /\ (!x. (f x) IN t <=> x IN s)
         ==> (IMAGE f s = t)``,
  SET_TAC[]);

val SUBSPACE_TRANSLATION_SELF = store_thm ("SUBSPACE_TRANSLATION_SELF",
 ``!s a. subspace s /\ a IN s ==> (IMAGE (\x. a + x) s = s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SURJECTIVE_IMAGE_EQ THEN
  FIRST_ASSUM(SUBST1_TAC o SYM o REWRITE_RULE [GSYM SPAN_EQ_SELF]) THEN
  ASM_SIMP_TAC std_ss [SPAN_ADD_EQ, SPAN_CLAUSES] THEN
  REWRITE_TAC[REAL_ARITH ``(a + x:real = y) <=> (x = y - a)``, EXISTS_REFL]);

val SUBSPACE_TRANSLATION_SELF_EQ = store_thm ("SUBSPACE_TRANSLATION_SELF_EQ",
 ``!s a:real. subspace s ==> ((IMAGE (\x. a + x) s = s) <=> a IN s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_TRANSLATION_SELF] THEN
  DISCH_THEN(MP_TAC o AP_TERM ``\s. (a:real) IN s``) THEN
  SIMP_TAC std_ss [] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  REWRITE_TAC[IN_IMAGE] THEN EXISTS_TAC ``0:real`` THEN
  ASM_MESON_TAC[subspace, REAL_ADD_RID]);

val SUBSPACE_SUMS = store_thm ("SUBSPACE_SUMS",
 ``!s t. subspace s /\ subspace t
         ==> subspace {x + y | x IN s /\ y IN t}``,
  SIMP_TAC std_ss [subspace, FORALL_IN_GSPEC, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN REPEAT STRIP_TAC THENL
   [ASM_MESON_TAC[REAL_ADD_LID],
    ONCE_REWRITE_TAC[REAL_ARITH
     ``(x + y) + (x' + y'):real = (x + x') + (y + y')``] THEN
    ASM_MESON_TAC[],
    REWRITE_TAC[REAL_ADD_LDISTRIB] THEN ASM_MESON_TAC[]]);

val SPAN_UNION = store_thm ("SPAN_UNION",
 ``!s t. span(s UNION t) = {x + y:real | x IN span s /\ y IN span t}``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [MATCH_MP_TAC SPAN_SUBSET_SUBSPACE THEN
    SIMP_TAC std_ss [SUBSPACE_SUMS, SUBSPACE_SPAN] THEN
    SIMP_TAC std_ss [SUBSET_DEF, IN_UNION, GSPECIFICATION, EXISTS_PROD] THEN
    X_GEN_TAC ``x:real`` THEN STRIP_TAC THENL
     [MAP_EVERY EXISTS_TAC [``x:real``, ``0:real``] THEN
      ASM_SIMP_TAC std_ss [SPAN_SUPERSET, SPAN_0, REAL_ADD_RID],
      MAP_EVERY EXISTS_TAC [``0:real``, ``x:real``] THEN
      ASM_SIMP_TAC std_ss [SPAN_SUPERSET, SPAN_0, REAL_ADD_LID]],
    SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_GSPEC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SPAN_ADD THEN
    ASM_MESON_TAC[SPAN_MONO, SUBSET_UNION, SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* Equality in Cauchy-Schwarz and triangle inequalities.                     *)
(* ------------------------------------------------------------------------- *)

val ABS_CAUCHY_SCHWARZ_EQ = store_thm
  ("ABS_CAUCHY_SCHWARZ_EQ",
 ``!x:real y. (x * y = abs(x) * abs(y)) <=> (abs(x) * y = abs(y) * x)``,
   REPEAT GEN_TAC THEN ASM_CASES_TAC ``0 <= x:real`` THEN
  (ASM_CASES_TAC ``0 <= y:real``) THEN ASM_REWRITE_TAC [abs] THENL
  [ASM_REAL_ARITH_TAC, ALL_TAC, ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  ((MP_TAC o SPECL [``x:real``,``y:real``]) REAL_LT_TOTAL THEN STRIP_TAC THEN
  TRY (ASM_REAL_ARITH_TAC)) THEN COND_CASES_TAC THEN EQ_TAC THEN
  TRY (ASM_REAL_ARITH_TAC));

val ABS_CAUCHY_SCHWARZ_ABS_EQ = store_thm
  ("ABS_CAUCHY_SCHWARZ_ABS_EQ",
 ``!x:real y. (abs(x * y) = abs(x) * abs(y)) <=>
                (abs(x) * y = abs(y) * x) \/ (abs(x) * y = -abs(y) * x)``,
  SIMP_TAC std_ss [REAL_ARITH ``&0 <= a ==> ((abs x = a) <=> (x = a) \/ (-x = a:real))``,
           REAL_LE_MUL, ABS_POS, REAL_MUL_RNEG] THEN
  REAL_ARITH_TAC);

val REAL_EQ_LINV = store_thm
  ("REAL_EQ_LINV", ``!x. (-x = (x :real)) <=> (x = 0)``,
    GEN_TAC
 >> REWRITE_TAC [SYM (Q.SPECL [`x`, `-x`, `x`] REAL_EQ_LADD)]
 >> REWRITE_TAC [REAL_ADD_RINV, REAL_DOUBLE]
 >> RW_TAC real_ss [REAL_ENTIRE]);

val REAL_EQ_RINV = store_thm
  ("REAL_EQ_RINV", ``!x. ((x :real) = -x) <=> (x = 0)``,
    GEN_TAC
 >> REWRITE_TAC [SYM (Q.SPECL [`x`, `x`, `-x`] REAL_EQ_LADD)]
 >> REWRITE_TAC [REAL_ADD_RINV, REAL_DOUBLE]
 >> RW_TAC real_ss [REAL_ENTIRE]);

(* this proof is too advanced in realScript *)
val ABS_TRIANGLE_EQ = store_thm ("ABS_TRIANGLE_EQ",
  ``!x y:real. (abs(x + y) = abs(x) + abs(y)) <=> (abs(x) * y = abs(y) * x)``,
    rpt GEN_TAC
 >> ASM_CASES_TAC ``0 <= x:real``
 >> ASM_CASES_TAC ``0 <= y:real``
 >> ASM_REWRITE_TAC [abs]
 >- ( `0 <= x + y` by PROVE_TAC [REAL_LE_ADD] \\
      ASM_SIMP_TAC bool_ss [] >> REAL_ARITH_TAC )
 >| [ (* goal 1 (of 3) *)
      Cases_on `0 <= x + y`
      >- ( ASM_SIMP_TAC bool_ss [REAL_EQ_LADD, Once REAL_MUL_SYM] \\
           EQ_TAC >- PROVE_TAC [] \\
           REWRITE_TAC [REAL_EQ_RMUL] \\
           STRIP_TAC >> FULL_SIMP_TAC bool_ss [REAL_ADD_LID] ) \\
      ASM_SIMP_TAC bool_ss [REAL_NEG_ADD, REAL_EQ_RADD, Once REAL_MUL_SYM] \\
      `(-x = x) = (x = 0)` by PROVE_TAC [REAL_EQ_LINV] \\
      POP_ASSUM (REWRITE_TAC o wrap) \\
      REWRITE_TAC [REAL_EQ_RMUL] \\
      EQ_TAC >- PROVE_TAC [] \\
      STRIP_TAC \\
      `y = 0` by PROVE_TAC [REAL_EQ_RINV] \\
      FULL_SIMP_TAC bool_ss [REAL_ADD_RID],
      (* goal 2 (of 3) *)
      Cases_on `0 <= x + y`
      >- ( ASM_SIMP_TAC bool_ss [REAL_EQ_RADD, Once REAL_MUL_SYM] \\
           EQ_TAC >- PROVE_TAC [] \\
           REWRITE_TAC [REAL_EQ_LMUL] \\
           reverse STRIP_TAC >- ( MATCH_MP_TAC EQ_SYM >> ASM_REWRITE_TAC [] ) \\
           REWRITE_TAC [REAL_EQ_RINV] \\
           FULL_SIMP_TAC bool_ss [REAL_ADD_RID] ) \\
      FULL_SIMP_TAC bool_ss [REAL_NEG_ADD] \\
      REWRITE_TAC [REAL_EQ_LADD, REAL_EQ_LINV, Once REAL_MUL_SYM] \\
      EQ_TAC >- RW_TAC real_ss [] \\
      REWRITE_TAC [REAL_EQ_LMUL, REAL_EQ_LINV] >> STRIP_TAC \\
      FULL_SIMP_TAC bool_ss [REAL_ADD_LID],
      (* goal 3 (of 3) *)
      Know `~(0 <= x + y)`
      >- (FULL_SIMP_TAC bool_ss [REAL_NOT_LE] \\
          PROVE_TAC [REAL_LT_ADD2, REAL_ADD_RID]) \\
      DISCH_TAC >> ASM_SIMP_TAC bool_ss [] \\
      REWRITE_TAC [REAL_NEG_ADD] \\
      PROVE_TAC [REAL_NEG_RMUL, REAL_MUL_SYM] ]);

val DIST_TRIANGLE_EQ = store_thm ("DIST_TRIANGLE_EQ",
 ``!x y z:real. (dist(x,z) = dist(x,y) + dist(y,z)) <=>
                (abs (x - y) * (y - z) = abs (y - z) * (x - y))``,
  REWRITE_TAC[GSYM ABS_TRIANGLE_EQ, dist] THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Collinearity.                                                             *)
(* ------------------------------------------------------------------------- *)

val _ = hide "collinear";

val collinear = new_definition ("collinear",
 ``collinear s <=> ?u. !x y:real. x IN s /\ y IN s ==> ?c. x - y = c * u``);

val COLLINEAR_SUBSET = store_thm ("COLLINEAR_SUBSET",
 ``!s t. collinear t /\ s SUBSET t ==> collinear s``,
  REWRITE_TAC[collinear] THEN SET_TAC[]);

val COLLINEAR_EMPTY = store_thm ("COLLINEAR_EMPTY",
 ``collinear {}``,
  REWRITE_TAC[collinear, NOT_IN_EMPTY]);

val COLLINEAR_SING = store_thm ("COLLINEAR_SING",
 ``!x:real. collinear {x}``,
  SIMP_TAC std_ss [collinear, IN_SING, REAL_SUB_REFL] THEN
  METIS_TAC [REAL_MUL_LZERO]);

val COLLINEAR_2 = store_thm ("COLLINEAR_2",
 ``!x y:real. collinear {x;y}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[collinear, IN_INSERT, NOT_IN_EMPTY] THEN
  EXISTS_TAC ``x - y:real`` THEN REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THENL
   [EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1:real``,
    EXISTS_TAC ``- &1:real``, EXISTS_TAC ``&0:real``] THEN
  REAL_ARITH_TAC);

val COLLINEAR_SMALL = store_thm ("COLLINEAR_SMALL",
 ``!s. FINITE s /\ CARD s <= 2 ==> collinear s``,
  REWRITE_TAC[ARITH_PROVE ``s <= 2 <=> (s = 0) \/ (s = 1) \/ (s = 2:num)``] THEN
  REWRITE_TAC[LEFT_AND_OVER_OR, GSYM HAS_SIZE] THEN
  REWRITE_TAC [ONE, TWO, HAS_SIZE_CLAUSES] THEN
  REPEAT STRIP_TAC THEN
  ASM_REWRITE_TAC[COLLINEAR_EMPTY, COLLINEAR_SING, COLLINEAR_2]);

val COLLINEAR_3 = store_thm ("COLLINEAR_3",
 ``!x y z. collinear {x;y;z} <=> collinear {0;x - y;z - y}``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [collinear, FORALL_IN_INSERT, CONJ_EQ_IMP,
                   RIGHT_FORALL_IMP_THM, NOT_IN_EMPTY] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  METIS_TAC [REAL_ARITH ``x - y = (x - y) - 0:real``,
             REAL_ARITH ``y - x = 0 - (x - y:real)``,
             REAL_ARITH ``x - z:real = (x - y) - (z - y)``]);

val COLLINEAR_LEMMA = store_thm ("COLLINEAR_LEMMA",
 ``!x y:real. collinear {0;x;y} <=>
                   (x = 0) \/ (y = 0) \/ ?c. y = c * x``,
  REPEAT GEN_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``x:real = 0``, ``y:real = 0``] THEN
  TRY(ONCE_REWRITE_TAC [INSERT_COMM] THEN
      ASM_REWRITE_TAC[INSERT_INSERT, COLLINEAR_SING, COLLINEAR_2] THEN NO_TAC) THEN
  ASM_REWRITE_TAC[collinear] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``u:real``
     (fn th => MP_TAC(SPECL [``x:real``, ``0:real``] th) THEN
                MP_TAC(SPECL [``y:real``, ``0:real``] th))) THEN
    REWRITE_TAC[IN_INSERT, REAL_SUB_RZERO] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` SUBST_ALL_TAC) THEN
    DISCH_THEN(X_CHOOSE_THEN ``d:real`` SUBST_ALL_TAC) THEN
    EXISTS_TAC ``e / d:real`` THEN REWRITE_TAC[REAL_MUL_ASSOC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[REAL_ENTIRE, DE_MORGAN_THM]) THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL],
    STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[IN_INSERT, NOT_IN_EMPTY] THEN REPEAT STRIP_TAC THEN
    ASM_REWRITE_TAC[] THENL
     [EXISTS_TAC ``&0:real``, EXISTS_TAC ``- &1:real``, EXISTS_TAC ``-c:real``,
      EXISTS_TAC ``&1:real``, EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1 - c:real``,
      EXISTS_TAC ``c:real``, EXISTS_TAC ``c - &1:real``, EXISTS_TAC ``&0:real``] THEN
    REAL_ARITH_TAC]);

val COLLINEAR_LEMMA_ALT = store_thm ("COLLINEAR_LEMMA_ALT",
 ``!x y. collinear {0;x;y} <=> (x = 0) \/ ?c. y = c * x``,
  REWRITE_TAC[COLLINEAR_LEMMA] THEN METIS_TAC [REAL_MUL_LZERO]);

val ABS_CAUCHY_SCHWARZ_EQUAL = store_thm ("ABS_CAUCHY_SCHWARZ_EQUAL",
 ``!x y:real. (abs(x * y) = abs(x) * abs(y)) <=> collinear {0;x;y}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[ABS_CAUCHY_SCHWARZ_ABS_EQ] THEN
  MAP_EVERY ASM_CASES_TAC [``x:real = 0``, ``y:real = 0``] THEN
  TRY(ONCE_ASM_REWRITE_TAC [INSERT_COMM] THEN
      ASM_REWRITE_TAC[INSERT_INSERT, COLLINEAR_SING, COLLINEAR_2, ABS_0,
                      REAL_MUL_LZERO, REAL_MUL_RZERO] THEN NO_TAC) THEN
  ASM_REWRITE_TAC[COLLINEAR_LEMMA] THEN EQ_TAC THENL
   [STRIP_TAC THENL
     [EXISTS_TAC ``y / x:real``, EXISTS_TAC ``y / x:real``] THEN
    ASM_SIMP_TAC std_ss [REAL_DIV_RMUL],
    ASM_REAL_ARITH_TAC]);

val MUL_CAUCHY_SCHWARZ_EQUAL = store_thm ("MUL_CAUCHY_SCHWARZ_EQUAL",
 ``!x y:real.
        ((x * y) pow 2 = (x * x) * (y * y)) <=>
        collinear {0;x;y}``,
  REWRITE_TAC[GSYM ABS_CAUCHY_SCHWARZ_EQUAL] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(REAL_ARITH
   ``&0 <= y /\ ((u:real = v) <=> (x = abs y)) ==> ((u = v) <=> (x = y:real))``) THEN
  SIMP_TAC std_ss [ABS_POS, REAL_LE_MUL] THEN
  REWRITE_TAC[REAL_EQ_SQUARE_ABS] THEN REWRITE_TAC[POW_MUL, GSYM POW_2] THEN
  REWRITE_TAC [POW_2] THEN REAL_ARITH_TAC);

val COLLINEAR_3_EXPAND = store_thm ("COLLINEAR_3_EXPAND",
 ``!a b c:real. collinear{a;b;c} <=> ((a = c) \/ ?u. b = u * a + (&1 - u) * c)``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``{a;b;c} = {a;c;b}``] THEN
  ONCE_REWRITE_TAC[COLLINEAR_3] THEN
  REWRITE_TAC[COLLINEAR_LEMMA, REAL_SUB_0] THEN
  ASM_CASES_TAC ``a:real = c`` THEN ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC ``b:real = c`` THEN
  ASM_REWRITE_TAC[REAL_ARITH ``u * c + (&1 - u) * c = c:real``] THENL
   [EXISTS_TAC ``&0:real`` THEN REAL_ARITH_TAC,
     AP_TERM_TAC THEN ABS_TAC THEN REAL_ARITH_TAC]);

val COLLINEAR_TRIPLES = store_thm ("COLLINEAR_TRIPLES",
 ``!s a b:real.
        ~(a = b)
        ==> (collinear(a INSERT b INSERT s) <=>
             !x. x IN s ==> collinear{a;b;x})``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP
     (REWRITE_RULE[CONJ_EQ_IMP] COLLINEAR_SUBSET)) THEN
    ASM_SET_TAC[],
    ONCE_REWRITE_TAC[SET_RULE ``{a;b;x} = {a;x;b}``] THEN
    ASM_REWRITE_TAC[COLLINEAR_3_EXPAND] THEN DISCH_TAC THEN
    SUBGOAL_THEN
     ``!x:real. x IN (a INSERT b INSERT s) ==> ?u. x = u * a + (&1 - u) * b``
    MP_TAC THENL
     [ASM_SIMP_TAC real_ss [FORALL_IN_INSERT] THEN CONJ_TAC THENL
       [EXISTS_TAC ``&1:real`` THEN REAL_ARITH_TAC,
        EXISTS_TAC ``&0:real`` THEN REAL_ARITH_TAC],
      POP_ASSUM_LIST(K ALL_TAC) THEN DISCH_TAC THEN
      REWRITE_TAC[collinear] THEN EXISTS_TAC ``b - a:real`` THEN
      MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
      FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``x:real`` th) THEN MP_TAC(SPEC
        ``y:real`` th)) THEN
      ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
      ASM_REWRITE_TAC[REAL_ARITH
       ``(u * a + (&1 - u) * b) - (v * a + (&1 - v) * b):real =
         (v - u) * (b - a)``] THEN
      METIS_TAC []]]);

val COLLINEAR_4_3 = store_thm ("COLLINEAR_4_3",
 ``!a b c d:real.
        ~(a = b)
        ==> (collinear {a;b;c;d} <=> collinear{a;b;c} /\ collinear{a;b;d})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{c:real;d}``, ``a:real``, ``b:real``]
    COLLINEAR_TRIPLES) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN SUBST1_TAC THEN
  SIMP_TAC real_ss [FORALL_IN_INSERT, NOT_IN_EMPTY]);

val COLLINEAR_3_TRANS = store_thm ("COLLINEAR_3_TRANS",
 ``!a b c d:real.
        collinear{a;b;c} /\ collinear{b;c;d} /\ ~(b = c) ==> collinear{a;b;d}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC COLLINEAR_SUBSET THEN
  EXISTS_TAC ``{b:real;c;a;d}`` THEN ASM_SIMP_TAC std_ss [COLLINEAR_4_3] THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[]] THEN
  ONCE_ASM_REWRITE_TAC [SET_RULE ``{b;c;a} = {a;b;c}``] THEN METIS_TAC []);

(* ------------------------------------------------------------------------- *)
(* Between-ness.                                                             *)
(* ------------------------------------------------------------------------- *)

val between = new_definition ("between",
 ``between x (a,b) <=> (dist(a,b) = dist(a,x) + dist(x,b))``);

val BETWEEN_REFL = store_thm ("BETWEEN_REFL",
 ``!a b. between a (a,b) /\ between b (a,b) /\ between a (a,a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_REFL_EQ = store_thm ("BETWEEN_REFL_EQ",
 ``!a x. between x (a,a) <=> (x = a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_SYM = store_thm ("BETWEEN_SYM",
 ``!a b x. between x (a,b) <=> between x (b,a)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_ANTISYM = store_thm ("BETWEEN_ANTISYM",
 ``!a b c. between a (b,c) /\ between b (a,c) ==> (a = b)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_TRANS = store_thm ("BETWEEN_TRANS",
 ``!a b c d. between a (b,c) /\ between d (a,c) ==> between d (b,c)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_TRANS_2 = store_thm ("BETWEEN_TRANS_2",
 ``!a b c d. between a (b,c) /\ between d (a,b) ==> between a (c,d)``,
  REWRITE_TAC[between, dist] THEN REAL_ARITH_TAC);

val BETWEEN_ABS = store_thm ("BETWEEN_ABS",
 ``!a b x:real.
     between x (a,b) <=> (abs(x - a) * (b - x) = abs(b - x) * (x - a))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[between, DIST_TRIANGLE_EQ] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [ABS_SUB] THEN REAL_ARITH_TAC);

val BETWEEN_IMP_COLLINEAR = store_thm ("BETWEEN_IMP_COLLINEAR",
 ``!a b x:real. between x (a,b) ==> collinear {a;x;b}``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``x:real = a`` THENL
  [ONCE_REWRITE_TAC[COLLINEAR_3, BETWEEN_ABS] THEN
   DISCH_TAC THEN ASM_REWRITE_TAC[COLLINEAR_LEMMA, REAL_SUB_REFL] THEN
   ASM_REAL_ARITH_TAC,
   ONCE_REWRITE_TAC[COLLINEAR_3, BETWEEN_ABS] THEN
   DISCH_TAC THEN ASM_REWRITE_TAC[COLLINEAR_LEMMA] THEN
   DISJ2_TAC THEN DISJ2_TAC THEN EXISTS_TAC ``(b - x) / (a - x:real)`` THEN
   RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH
                   ``(x <> a) = ((a - x) <> 0:real)``]) THEN
   ASM_SIMP_TAC real_ss [REAL_DIV_RMUL]]);

val COLLINEAR_BETWEEN_CASES = store_thm ("COLLINEAR_BETWEEN_CASES",
 ``!a b c:real.
        collinear {a;b;c} <=>
        between a (b,c) \/ between b (c,a) \/ between c (a,b)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[COLLINEAR_3_EXPAND] THEN
    ASM_CASES_TAC ``c:real = a`` THEN ASM_REWRITE_TAC[BETWEEN_REFL] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[between, dist] THEN
    ASM_REAL_ARITH_TAC,
    DISCH_THEN(REPEAT_TCL DISJ_CASES_THEN (MP_TAC o MATCH_MP
      BETWEEN_IMP_COLLINEAR)) THEN
    METIS_TAC[INSERT_COMM]]);

val COLLINEAR_DIST_BETWEEN = store_thm ("COLLINEAR_DIST_BETWEEN",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)
           ==> between x (a,b)``,
  SIMP_TAC std_ss [COLLINEAR_BETWEEN_CASES, between, dist] THEN REAL_ARITH_TAC);

val COLLINEAR_1 = store_thm ("COLLINEAR_1",
 ``!s:real->bool. collinear s``,
  GEN_TAC THEN MATCH_MP_TAC COLLINEAR_SUBSET THEN
  EXISTS_TAC ``(0:real) INSERT (1:real) INSERT s`` THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[]] THEN
  W(MP_TAC o PART_MATCH (lhs o rand) COLLINEAR_TRIPLES o snd) THEN
  REWRITE_TAC[REAL_ARITH ``0 <> 1:real``] THEN DISCH_THEN SUBST1_TAC THEN
  REWRITE_TAC[COLLINEAR_BETWEEN_CASES] THEN
  REWRITE_TAC[between, dist, ABS_N] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Midpoint between two points.                                              *)
(* ------------------------------------------------------------------------- *)

val midpoint = new_definition ("midpoint",
 ``midpoint(a,b) = inv(&2:real) * (a + b)``);

Theorem MIDPOINT_REFL: !x. midpoint(x,x) = x
Proof
  REWRITE_TAC[midpoint, REAL_DOUBLE, REAL_MUL_ASSOC] THEN
  SIMP_TAC std_ss [REAL_MUL_LINV, REAL_ARITH ``2 <> 0:real``] THEN
  REAL_ARITH_TAC
QED

val MIDPOINT_SYM = store_thm ("MIDPOINT_SYM",
 ``!a b. midpoint(a,b) = midpoint(b,a)``,
  METIS_TAC[midpoint, REAL_ADD_SYM]);

val DIST_MIDPOINT = store_thm ("DIST_MIDPOINT",
 ``!a b. (dist(a,midpoint(a,b)) = dist(a,b) / &2) /\
         (dist(b,midpoint(a,b)) = dist(a,b) / &2) /\
         (dist(midpoint(a,b),a) = dist(a,b) / &2) /\
         (dist(midpoint(a,b),b) = dist(a,b) / &2)``,
  REWRITE_TAC[midpoint, dist] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ONCE_REWRITE_TAC [GSYM ABS_N] THEN
  REWRITE_TAC [GSYM ABS_MUL, REAL_SUB_RDISTRIB] THEN REWRITE_TAC [ABS_N] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = a * c * b:real``] THEN
  SIMP_TAC std_ss [REAL_MUL_LINV, REAL_ARITH ``2 <> 0:real``] THEN
  REAL_ARITH_TAC);

val MIDPOINT_EQ_ENDPOINT = store_thm ("MIDPOINT_EQ_ENDPOINT",
 ``!a b. ((midpoint(a,b) = a) <=> (a = b)) /\
         ((midpoint(a,b) = b) <=> (a = b)) /\
         ((a = midpoint(a,b)) <=> (a = b)) /\
         ((b = midpoint(a,b)) <=> (a = b))``,
  REWRITE_TAC[midpoint] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss
    [REAL_EQ_RDIV_EQ, REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val BETWEEN_MIDPOINT = store_thm ("BETWEEN_MIDPOINT",
 ``!a b. between (midpoint(a,b)) (a,b) /\ between (midpoint(a,b)) (b,a)``,
  REWRITE_TAC[between, midpoint] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [dist, GSYM real_div] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a / 2 - b = a / 2 - b * 1:real``] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``b - a / 2 = b * 1 - a / 2:real``] THEN
  REWRITE_TAC [
    METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``] ``1 = 2/2:real``] THEN
  REWRITE_TAC [real_div, REAL_MUL_ASSOC, real_sub] THEN
  REWRITE_TAC [REAL_ARITH ``-(a * b) = -a * b:real``] THEN
  REWRITE_TAC [GSYM real_div] THEN SIMP_TAC std_ss [REAL_DIV_ADD] THEN
  REWRITE_TAC [real_div, ABS_MUL] THEN
  SIMP_TAC std_ss [ABS_N, ABS_INV, REAL_ARITH ``2 <> 0:real``] THEN
  REWRITE_TAC [GSYM REAL_ADD_RDISTRIB] THEN REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val MIDPOINT_LINEAR_IMAGE = store_thm ("MIDPOINT_LINEAR_IMAGE",
 ``!f a b. linear f ==> (midpoint(f a,f b) = f(midpoint(a,b)))``,
  SIMP_TAC std_ss [midpoint, LINEAR_ADD, LINEAR_CMUL]);

val COLLINEAR_MIDPOINT = store_thm ("COLLINEAR_MIDPOINT",
 ``!a b. collinear{a;midpoint(a,b);b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[COLLINEAR_3_EXPAND, midpoint] THEN
  DISJ2_TAC THEN REWRITE_TAC [REAL_ARITH ``u * a + (1 - u) * b =
                                           a * u - b * u + b:real``] THEN
  EXISTS_TAC ``inv &2:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_MUL_SYM] THEN
  REWRITE_TAC [REAL_ADD_RDISTRIB] THEN
  GEN_REWR_TAC (RAND_CONV o RAND_CONV) [GSYM REAL_HALF] THEN
  REWRITE_TAC [GSYM real_div] THEN REAL_ARITH_TAC);

Theorem MIDPOINT_COLLINEAR:
   !a b c:real.
     a <> c ==>
     ((b = midpoint(a,c)) <=> collinear{a;b;c} /\ (dist(a,b) = dist(b,c)))
Proof
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `(a ==> b) /\ (b ==> (a <=> c)) ==> (a <=> b /\ c)`) THEN
  SIMP_TAC std_ss [COLLINEAR_MIDPOINT] THEN
  ASM_REWRITE_TAC[COLLINEAR_3_EXPAND] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[midpoint, dist] THEN
  REWRITE_TAC
   [REAL_ARITH ``a - (u * a + (&1 - u) * c) = (&1 - u) * (a - c:real)``,
    REAL_ARITH ``(u * a + (&1 - u) * c) - c = u * (a - c:real)``] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC std_ss [REAL_EQ_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC
QED

(* ------------------------------------------------------------------------ *)
(*  MISC                                                                    *)
(* ------------------------------------------------------------------------ *)

val SPAN_BREAKDOWN = store_thm ("SPAN_BREAKDOWN",
 ``!b s a:real. b IN s /\ a IN span s ==> ?k. (a - k * b) IN span(s DELETE b)``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC [METIS []
   ``(?k:real. a - k * b IN span (s DELETE b)) =
     (\a. ?k. a - k * b IN span (s DELETE b)) a``] THEN
  MATCH_MP_TAC SPAN_INDUCT THEN
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN CONJ_TAC THENL
   [GEN_TAC THEN DISCH_TAC THEN ASM_CASES_TAC ``x:real = b``, ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IN_DEF] THENL
  [EXISTS_TAC ``1:real`` THEN SIMP_TAC real_ss [] THEN
   ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN REWRITE_TAC [SPAN_CLAUSES],
   EXISTS_TAC ``0:real`` THEN SIMP_TAC real_ss [] THEN
   ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN MATCH_MP_TAC SPAN_SUPERSET THEN
   ASM_SET_TAC [],
   ALL_TAC] THEN REPEAT CONJ_TAC THENL
   [EXISTS_TAC ``0:real`` THEN SIMP_TAC real_ss [] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN REWRITE_TAC [SPAN_CLAUSES],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``k + k':real`` THEN
    ONCE_REWRITE_TAC [REAL_ARITH
     ``(x + y - (k + k') * b) = ((x - k * b) + (y - k' * b:real))``] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM SPECIFICATION]) THEN
    METIS_TAC [SPAN_ADD],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``c * k:real`` THEN
    ONCE_REWRITE_TAC [
      REAL_ARITH ``(c * x - (c * k) * y = c * (x - k * y:real))``] THEN
    ONCE_REWRITE_TAC [GSYM SPECIFICATION] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM SPECIFICATION]) THEN
    METIS_TAC [SPAN_CLAUSES]]);

val IN_SPAN_INSERT = store_thm ("IN_SPAN_INSERT",
 ``!a b:real s. a IN span(b INSERT s) /\ ~(a IN span s)
   ==> b IN span(a INSERT s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``b:real``, ``(b:real) INSERT s``, ``a:real``]
    SPAN_BREAKDOWN) THEN ASM_REWRITE_TAC[IN_INSERT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` MP_TAC) THEN
  ASM_CASES_TAC ``k = &0:real`` THEN
  ASM_REWRITE_TAC[REAL_ARITH ``a - &0 * b = a:real``, DELETE_INSERT] THENL
   [ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, DELETE_SUBSET], ALL_TAC] THEN
  DISCH_THEN(MP_TAC o SPEC ``inv(k:real)`` o MATCH_MP SPAN_MUL) THEN
  ASM_SIMP_TAC real_ss [REAL_SUB_LDISTRIB, REAL_MUL_ASSOC, REAL_MUL_LINV] THEN
  DISCH_TAC THEN SUBST1_TAC(REAL_ARITH
   ``b:real = inv(k) * a - (inv(k) * a - b)``) THEN
  MATCH_MP_TAC SPAN_SUB THEN
  FULL_SIMP_TAC std_ss [SPAN_CLAUSES, IN_INSERT, SUBSET_DEF, IN_DELETE,
                        SPAN_MONO] THEN
  POP_ASSUM MP_TAC THEN ABBREV_TAC ``y = inv k * a - b:real`` THEN
  SPEC_TAC (``y:real``, ``y:real``) THEN REWRITE_TAC [GSYM SUBSET_DEF] THEN
  MATCH_MP_TAC SPAN_MONO THEN ASM_SET_TAC []);

val INDEPENDENT_INSERT = store_thm ("INDEPENDENT_INSERT",
 ``!a:real s. independent(a INSERT s) <=>
    if a IN s then independent s else independent s /\ ~(a IN span s)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(a:real) IN s`` THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``x IN s ==> (x INSERT s = s)``] THEN
  EQ_TAC THENL
   [DISCH_TAC THEN CONJ_TAC THENL
     [ASM_MESON_TAC[INDEPENDENT_MONO, SUBSET_DEF, IN_INSERT],
      POP_ASSUM MP_TAC THEN REWRITE_TAC[independent, dependent] THEN
      ASM_MESON_TAC[IN_INSERT, SET_RULE
        ``~(a IN s) ==> ((a INSERT s) DELETE a = s)``]],
    ALL_TAC] THEN
  SIMP_TAC std_ss [independent, dependent, NOT_EXISTS_THM] THEN
  STRIP_TAC THEN X_GEN_TAC ``b:real`` THEN
  REWRITE_TAC[IN_INSERT] THEN ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [
    SET_RULE ``~(a IN s) ==> ((a INSERT s) DELETE a = s)``] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``~(a IN s) /\ ~(b = a)
     ==> ((a INSERT s) DELETE b = a INSERT (s DELETE b))``] THEN
  ASM_MESON_TAC[IN_SPAN_INSERT, SET_RULE
    ``b IN s ==> (b INSERT (s DELETE b) = s)``]);

val INDEPENDENT_SING = store_thm ("INDEPENDENT_SING",
 ``!x. independent {x} <=> ~(x = 0)``,
  REWRITE_TAC[INDEPENDENT_INSERT, NOT_IN_EMPTY, SPAN_EMPTY] THEN
  REWRITE_TAC[INDEPENDENT_EMPTY] THEN SET_TAC[]);

val INDEPENDENT_STDBASIS = store_thm ("INDEPENDENT_STDBASIS",
 ``independent {i:real | 1 <= i /\ i <= 1}``,
 REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
 REWRITE_TAC [INDEPENDENT_SING] THEN REAL_ARITH_TAC);

val SPANNING_SUBSET_INDEPENDENT = store_thm ("SPANNING_SUBSET_INDEPENDENT",
 ``!s t:real->bool.
        t SUBSET s /\ independent s /\ s SUBSET span(t) ==> (s = t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[SUBSET_DEF] THEN
  X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``independent s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [independent]) THEN
  SIMP_TAC std_ss [dependent, NOT_EXISTS_THM] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_DELETE]);

val IN_SPAN_DELETE = store_thm ("IN_SPAN_DELETE",
 ``!a b s.
         a IN span s /\ ~(a IN span (s DELETE b))
         ==> b IN span (a INSERT (s DELETE b))``,
  ASM_MESON_TAC[IN_SPAN_INSERT, SPAN_MONO, SUBSET_DEF, IN_INSERT, IN_DELETE]);

val SPAN_TRANS = store_thm ("SPAN_TRANS",
 ``!x y:real s. x IN span(s) /\ y IN span(x INSERT s) ==> y IN span(s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``x:real``, ``(x:real) INSERT s``, ``y:real``]
         SPAN_BREAKDOWN) THEN
  ASM_SIMP_TAC std_ss [IN_INSERT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  SUBST1_TAC(REAL_ARITH ``y:real = (y - k * x) + k * x``) THEN
  MATCH_MP_TAC SPAN_ADD THEN ASM_SIMP_TAC std_ss [SPAN_MUL] THEN
  ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_INSERT, IN_DELETE]);

val EXCHANGE_LEMMA = store_thm ("EXCHANGE_LEMMA",
 ``!s t:real->bool.
        FINITE t /\ independent s /\ s SUBSET span t
        ==> ?t'. t' HAS_SIZE (CARD t) /\
                 s SUBSET t' /\ t' SUBSET (s UNION t) /\ s SUBSET (span t')``,
  REPEAT GEN_TAC THEN
  completeInduct_on `CARD(t DIFF s :real->bool)` THEN
  GEN_TAC THEN GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM K_TAC THEN
  KNOW_TAC ``(!m. m < CARD (t:real->bool DIFF s) ==>
    !t:real->bool s:real->bool. (m = CARD (t DIFF s)) ==>
      FINITE t /\ independent s /\ s SUBSET span t ==>
      ?t'. t' HAS_SIZE CARD t /\ s SUBSET t' /\ t' SUBSET s UNION t /\
        s SUBSET span t') ==>
    (!t'':real->bool s':real->bool. (CARD (t'' DIFF s') < CARD (t DIFF s)) ==>
      FINITE t'' /\ independent s' /\ s' SUBSET span t'' ==>
      ?t'. t' HAS_SIZE CARD t'' /\ s' SUBSET t' /\ t' SUBSET s' UNION t'' /\
        s' SUBSET span t')`` THENL
  [METIS_TAC [], ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC] THEN
  ASM_CASES_TAC ``(s:real->bool) SUBSET t`` THENL
   [ASM_MESON_TAC[HAS_SIZE, SUBSET_UNION], ALL_TAC] THEN
  ASM_CASES_TAC ``t SUBSET (s:real->bool)`` THENL
   [ASM_MESON_TAC[SPANNING_SUBSET_INDEPENDENT, HAS_SIZE], ALL_TAC] THEN
  STRIP_TAC THEN UNDISCH_TAC ``~(t SUBSET s:real->bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``s SUBSET span(t DELETE (b:real))`` THENL
   [FIRST_X_ASSUM(MP_TAC o
     SPECL [``t DELETE (b:real)``, ``s:real->bool``]) THEN
    ASM_REWRITE_TAC[SET_RULE ``s DELETE a DIFF t = (s DIFF t) DELETE a``] THEN
    ASM_SIMP_TAC arith_ss [CARD_DELETE, FINITE_DIFF, IN_DIFF, FINITE_DELETE,
                 CARD_EQ_0, ARITH_PROVE ``n - 1 < n <=> ~(n = 0:num)``] THEN
    KNOW_TAC ``t DIFF s <> {}:real->bool`` THENL
     [UNDISCH_TAC ``~((s:real->bool) SUBSET t)`` THEN ASM_SET_TAC[],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(b:real) INSERT u`` THEN
    ASM_SIMP_TAC std_ss [SUBSET_INSERT, INSERT_SUBSET, IN_UNION] THEN
    CONJ_TAC THENL
     [UNDISCH_TAC ``(u:real->bool) HAS_SIZE CARD(t:real->bool) - 1`` THEN
      SIMP_TAC std_ss [HAS_SIZE, FINITE_EMPTY, FINITE_INSERT, CARD_EMPTY,
                       CARD_INSERT] THEN
      STRIP_TAC THEN COND_CASES_TAC THENL
       [ASM_MESON_TAC[SUBSET_DEF, IN_UNION, IN_DELETE], ALL_TAC] THEN
      ASM_MESON_TAC[ARITH_PROVE ``~(n = 0) ==> (SUC(n - 1) = n)``,
                    CARD_EQ_0, MEMBER_NOT_EMPTY], ALL_TAC] THEN
    CONJ_TAC THENL
     [UNDISCH_TAC ``u SUBSET s UNION (t DELETE (b:real))`` THEN SET_TAC[],
      ASM_MESON_TAC[SUBSET_DEF, SPAN_MONO, IN_INSERT]],
    ALL_TAC] THEN
  UNDISCH_TAC ``~(s SUBSET span (t DELETE (b:real)))`` THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [SUBSET_DEF] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``~(a:real = b)`` ASSUME_TAC THENL
    [ASM_MESON_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``~((a:real) IN t)`` ASSUME_TAC THENL
   [ASM_MESON_TAC[IN_DELETE, SPAN_CLAUSES], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``(a:real) INSERT (t DELETE b)``, ``s:real->bool``]) THEN
  KNOW_TAC ``CARD ((a INSERT t DELETE b) DIFF s) < CARD (t DIFF s:real->bool)``
  THENL
   [ASM_SIMP_TAC std_ss [SET_RULE
     ``a IN s ==> ((a INSERT (t DELETE b)) DIFF s = (t DIFF s) DELETE b)``] THEN
    KNOW_TAC ``(b:real) IN (t DIFF s)``
      THENL [METIS_TAC [IN_DIFF], DISCH_TAC] THEN
    KNOW_TAC ``FINITE (t DIFF s:real->bool)``
      THENL [METIS_TAC [FINITE_DIFF], ALL_TAC] THEN
    SIMP_TAC std_ss [CARD_DELETE] THEN ASM_REWRITE_TAC [] THEN DISCH_TAC THEN
    ASM_SIMP_TAC std_ss [ARITH_PROVE ``n - 1 < n <=> ~(n = 0:num)``, CARD_EQ_0,
                 FINITE_DIFF] THEN
    UNDISCH_TAC ``~((s:real->bool) SUBSET t)`` THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  KNOW_TAC ``FINITE ((a:real) INSERT t DELETE b) /\
             s SUBSET span (a INSERT t DELETE b)`` THENL
   [ASM_SIMP_TAC std_ss [FINITE_EMPTY, FINITE_INSERT, FINITE_DELETE] THEN
    REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN
    DISCH_TAC THEN MATCH_MP_TAC SPAN_TRANS THEN EXISTS_TAC ``b:real`` THEN
    ASM_MESON_TAC[IN_SPAN_DELETE, SUBSET_DEF, SPAN_MONO,
                  SET_RULE ``t SUBSET (b INSERT (a INSERT (t DELETE b)))``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN
  EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  ASM_SIMP_TAC std_ss [HAS_SIZE, CARD_EMPTY, CARD_INSERT, CARD_DELETE,
                       FINITE_DELETE,
                       IN_DELETE, ARITH_PROVE ``(SUC(n - 1) = n) <=> ~(n = 0)``,
                       CARD_EQ_0] THEN
  UNDISCH_TAC ``(b:real) IN t`` THEN ASM_SET_TAC[]);

val CARD_STDBASIS = store_thm ("CARD_STDBASIS",
 ``CARD {1:real} = 1``,
   MESON_TAC[CARD_SING]);

val INDEPENDENT_SPAN_BOUND = store_thm ("INDEPENDENT_SPAN_BOUND",
 ``!s t. FINITE t /\ independent s /\ s SUBSET span(t)
         ==> FINITE s /\ CARD(s) <= CARD(t)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP EXCHANGE_LEMMA) THEN
  ASM_MESON_TAC[HAS_SIZE, CARD_SUBSET, SUBSET_FINITE_I]);

val INDEPENDENT_BOUND = store_thm ("INDEPENDENT_BOUND",
 ``!s:real->bool.
        independent s ==> FINITE s /\ CARD(s) <= 1:num``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[GSYM CARD_STDBASIS] THEN
  MATCH_MP_TAC INDEPENDENT_SPAN_BOUND THEN
  KNOW_TAC ``span {1} = univ(:real)`` THENL
  [SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
   SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
   REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
   FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_REWRITE_TAC[FINITE_SING, SUBSET_UNIV]);

val MAXIMAL_INDEPENDENT_SUBSET_EXTEND = store_thm ("MAXIMAL_INDEPENDENT_SUBSET_EXTEND",
 ``!s v:real->bool. s SUBSET v /\ independent s ==> ?b. s SUBSET b /\ b SUBSET v /\
   independent b /\ v SUBSET (span b)``,
  REPEAT GEN_TAC THEN
  completeInduct_on ` 1n - CARD(s:real->bool)` THEN
  GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN POP_ASSUM K_TAC THEN
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``v SUBSET (span(s:real->bool))`` THENL
   [ASM_MESON_TAC[SUBSET_REFL], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  KNOW_TAC ``(!(m :num). m <  1n - CARD (s :real -> bool) ==>
        !(s :real -> bool). (m =  1n - CARD s) ==>
          s SUBSET (v :real -> bool) /\ independent s ==>
          ?(b :real -> bool).
            s SUBSET b /\ b SUBSET v /\ independent b /\ v SUBSET span b) ==>
        !s'. (1 - CARD s' < 1 - CARD s) ==> s' SUBSET v /\ independent s' ==>
          ?b. s' SUBSET b /\ b SUBSET v /\ independent b /\ v SUBSET span b`` THENL
  [METIS_TAC [], ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) INSERT s``) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  KNOW_TAC ``1 - CARD (a INSERT s) < 1 - CARD s /\ a INSERT s SUBSET v /\
              independent (a INSERT s:real->bool)`` THENL
   [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
             MESON_TAC[INSERT_SUBSET]] THEN
  SUBGOAL_THEN ``independent ((a:real) INSERT s)`` ASSUME_TAC THENL
   [ASM_REWRITE_TAC[INDEPENDENT_INSERT, COND_ID], ALL_TAC] THEN
  ASM_REWRITE_TAC[INSERT_SUBSET] THEN
  MATCH_MP_TAC(ARITH_PROVE ``(b = a + 1) /\ b <= n ==> n - b < n - a:num``) THEN
  ASM_SIMP_TAC std_ss [CARD_EMPTY, CARD_INSERT, INDEPENDENT_BOUND] THEN
  METIS_TAC[SPAN_SUPERSET, ADD1]);

val MAXIMAL_INDEPENDENT_SUBSET = store_thm ("MAXIMAL_INDEPENDENT_SUBSET",
 ``!v:real->bool. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b)``,
  MP_TAC(SPEC ``EMPTY:real->bool`` MAXIMAL_INDEPENDENT_SUBSET_EXTEND) THEN
  REWRITE_TAC[EMPTY_SUBSET, INDEPENDENT_EMPTY]);

val SPAN_BREAKDOWN_EQ = store_thm ("SPAN_BREAKDOWN_EQ",
 ``!a:real s. (x IN span(a INSERT s) <=> (?k. (x - k * a) IN span s))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_THEN(MP_TAC o CONJ(SET_RULE ``(a:real) IN (a INSERT s)``)) THEN
    DISCH_THEN(MP_TAC o MATCH_MP SPAN_BREAKDOWN) THEN
    DISCH_THEN (X_CHOOSE_TAC ``k:real``) THEN EXISTS_TAC ``k:real`` THEN
    POP_ASSUM MP_TAC THEN SPEC_TAC(``x - k * a:real``,``y:real``) THEN
    REWRITE_TAC[GSYM SUBSET_DEF] THEN MATCH_MP_TAC SPAN_MONO THEN SET_TAC[],
    DISCH_THEN(X_CHOOSE_TAC ``k:real``) THEN
    SUBST1_TAC(REAL_ARITH ``x = (x - k * a) + k * a:real``) THEN
    MATCH_MP_TAC SPAN_ADD THEN
    ASM_MESON_TAC[SPAN_MONO, SUBSET_DEF, IN_INSERT, SPAN_CLAUSES]]);

val LINEAR_INDEPENDENT_EXTEND_LEMMA = store_thm ("LINEAR_INDEPENDENT_EXTEND_LEMMA",
 ``!f b. FINITE b ==> independent b ==>
    ?g:real->real. (!x y. x IN span b /\ y IN span b ==>
     (g(x + y) = g(x) + g(y))) /\ (!x c. x IN span b ==>
     (g(c * x) = c * g(x))) /\ (!x. x IN b ==> (g x = f x))``,
  GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS []
   ``!b. (independent b ==>
  ?g. (!x y. x IN span b /\ y IN span b ==> (g (x + y) = g x + g y)) /\
    (!x c. x IN span b ==> (g (c * x) = c * g x)) /\
    !x. x IN b ==> (g x = f x)) =
    (\b. independent b ==>
  ?g. (!x y. x IN span b /\ y IN span b ==> (g (x + y) = g x + g y)) /\
    (!x c. x IN span b ==> (g (c * x) = c * g x)) /\
    !x. x IN b ==> (g x = f x)) b``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[NOT_IN_EMPTY, INDEPENDENT_INSERT] THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN EXISTS_TAC ``(\x. 0):real->real`` THEN
    SIMP_TAC std_ss [SPAN_EMPTY] THEN REPEAT STRIP_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``b:real->bool``, ``a:real``] THEN
  REWRITE_TAC [AND_IMP_INTRO] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
  REWRITE_TAC [CONJ_EQ_IMP] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  DISCH_TAC THEN DISCH_TAC THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  DISCH_THEN (CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  ABBREV_TAC ``h = \z:real. @k. (z - k * a) IN span b`` THEN
  SUBGOAL_THEN ``!z:real. z IN span(a INSERT b)
                    ==> (z - h(z) * a) IN span(b) /\
                        !k. (z - k * a) IN span(b) ==> (k = h(z))``
  MP_TAC THENL
   [GEN_TAC THEN DISCH_TAC THEN
    MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN CONJ_TAC THENL
     [EXPAND_TAC "h" THEN CONV_TAC SELECT_CONV THEN
      ASM_MESON_TAC[SPAN_BREAKDOWN_EQ],
      ALL_TAC] THEN
    SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, AND_IMP_INTRO] THEN GEN_TAC THEN
    DISCH_THEN(MP_TAC o MATCH_MP SPAN_SUB) THEN
    REWRITE_TAC[REAL_ARITH ``(z - a * v) - (z - b * v) = (b - a) * v:real``] THEN
    ASM_CASES_TAC ``k = (h:real->real) z`` THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(MP_TAC o SPEC ``inv(k - (h:real->real) z)`` o
               MATCH_MP SPAN_MUL) THEN
    ASM_SIMP_TAC real_ss [REAL_MUL_LINV, REAL_MUL_ASSOC, REAL_SUB_0],
    ALL_TAC] THEN
  SIMP_TAC std_ss [TAUT `(a ==> b /\ c) <=> (a ==> b) /\ (a ==> c)`] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, AND_IMP_INTRO] THEN
  DISCH_THEN (MP_TAC o SIMP_RULE std_ss [FORALL_AND_THM]) THEN STRIP_TAC THEN
  EXISTS_TAC ``\z:real. h(z) * (f:real->real)(a) + g(z - h(z) * a)`` THEN
  ONCE_REWRITE_TAC [CONJ_SYM] THEN REPEAT CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``(h:real->real)(x + y) = h(x) + h(y)`` ASSUME_TAC THENL
     [CONV_TAC SYM_CONV THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      REWRITE_TAC[REAL_ARITH
       ``(x + y) - (k + l) * a = (x - k * a) + (y - l * a:real)``] THEN
      CONJ_TAC THEN MATCH_MP_TAC SPAN_ADD THEN ASM_REWRITE_TAC[] THEN
      ASM_SIMP_TAC std_ss [],
      ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
       ``(x + y) - (k + l) * a = (x - k * a) + (y - l * a:real)``] THEN
    ASM_SIMP_TAC std_ss [] THEN REAL_ARITH_TAC,
    MAP_EVERY X_GEN_TAC [``x:real``, ``c:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``(h:real->real)(c * x) = c * h(x)`` ASSUME_TAC THENL
     [CONV_TAC SYM_CONV THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
      REWRITE_TAC[REAL_ARITH
       ``c * x - (c * k) * a = c * (x - k * a:real)``] THEN
      CONJ_TAC THEN MATCH_MP_TAC SPAN_MUL THEN ASM_REWRITE_TAC[] THEN
      ASM_SIMP_TAC std_ss [],
      ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
       ``c * x - (c * k) * a = c * (x - k * a:real)``] THEN
    ASM_SIMP_TAC std_ss [] THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  X_GEN_TAC ``x:real`` THEN SIMP_TAC std_ss [IN_INSERT] THEN
  DISCH_THEN(DISJ_CASES_THEN2 SUBST_ALL_TAC ASSUME_TAC) THENL
   [SUBGOAL_THEN ``&1:real = h(a:real)`` (SUBST1_TAC o SYM) THENL
     [FIRST_X_ASSUM MATCH_MP_TAC, ALL_TAC] THEN
    REWRITE_TAC[REAL_ARITH ``a - &1 * a = 0:real``, SPAN_0] THENL
     [ASM_MESON_TAC[SPAN_SUPERSET, SUBSET_DEF, IN_INSERT], ALL_TAC] THEN
    UNDISCH_TAC ``!x y:real. x IN span b /\ y IN span b ==>
                        ((g:real->real) (x + y) = g x + g y)`` THEN
    DISCH_TAC THEN SIMP_TAC std_ss [] THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``0:real``, ``0:real``]) THEN
    SIMP_TAC real_ss [SPAN_0, REAL_ADD_LID] THEN
    REWRITE_TAC[REAL_ARITH ``(a = a + a) <=> (a = 0:real)``] THEN
    DISCH_THEN SUBST1_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  SUBGOAL_THEN ``&0:real = h(x:real)`` (SUBST1_TAC o SYM) THENL
   [FIRST_X_ASSUM MATCH_MP_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [REAL_ADD_LID, REAL_MUL_LZERO, REAL_SUB_RZERO] THEN
  ASM_MESON_TAC[SUBSET_DEF, IN_INSERT, SPAN_SUPERSET]);

val LINEAR_INDEPENDENT_EXTEND = store_thm ("LINEAR_INDEPENDENT_EXTEND",
 ``!f b. independent b ==> ?g:real->real. linear g /\ (!x. x IN b ==> (g x = f x))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``b:real->bool``, ``univ(:real)``]
           MAXIMAL_INDEPENDENT_SUBSET_EXTEND) THEN
  ASM_SIMP_TAC std_ss [SUBSET_UNIV, UNIV_SUBSET] THEN
  REWRITE_TAC[EXTENSION, IN_UNIV] THEN
  DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``f:real->real``, ``c:real->bool``]
    LINEAR_INDEPENDENT_EXTEND_LEMMA) THEN
  ASM_SIMP_TAC std_ss [INDEPENDENT_BOUND, linear] THEN
  ASM_MESON_TAC[SUBSET_DEF]);

val SUBSPACE_KERNEL = store_thm ("SUBSPACE_KERNEL",
 ``!f. linear f ==> subspace {x | f(x) = 0}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION] THEN
  SIMP_TAC std_ss [LINEAR_ADD, LINEAR_CMUL, REAL_ADD_LID, REAL_MUL_RZERO] THEN
  MESON_TAC[LINEAR_0]);

val LINEAR_EQ_0_SPAN = store_thm ("LINEAR_EQ_0_SPAN",
 ``!f:real->real b. linear f /\ (!x. x IN b ==> (f(x) = 0))
   ==> !x. x IN span(b) ==> (f(x) = 0)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN RULE_ASSUM_TAC(SIMP_RULE std_ss [IN_DEF]) THEN
  ONCE_REWRITE_TAC [METIS [] ``(f x = 0) = (\x. (f:real->real) x = 0) x``] THEN
  MATCH_MP_TAC SPAN_INDUCT THEN ASM_SIMP_TAC std_ss [IN_DEF] THEN
  MP_TAC(ISPEC ``f:real->real`` SUBSPACE_KERNEL) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_DEF]);

val LINEAR_EQ_0 = store_thm ("LINEAR_EQ_0",
 ``!f b s. linear f /\ s SUBSET (span b) /\
   (!x. x IN b ==> (f(x) = 0)) ==> !x. x IN s ==> (f(x) = 0)``,
  MESON_TAC[LINEAR_EQ_0_SPAN, SUBSET_DEF]);

val LINEAR_EQ = store_thm ("LINEAR_EQ",
 ``!f g b s. linear f /\ linear g /\ s SUBSET (span b) /\
    (!x. x IN b ==> (f(x) = g(x))) ==> !x. x IN s ==> (f(x) = g(x))``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(f x - g x = 0) = ((\x. (f:real->real) x - g x) x = 0)``] THEN
  MATCH_MP_TAC LINEAR_EQ_0 THEN SIMP_TAC std_ss [] THEN METIS_TAC[LINEAR_COMPOSE_SUB]);

val LINEAR_EQ_STDBASIS = store_thm ("LINEAR_EQ_STDBASIS",
 ``!f:real->real g. linear f /\ linear g /\
   (!i. 1 <= i /\ i <= 1 ==> (f i = g i)) ==> (f = g)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!x. x IN UNIV ==> ((f:real->real) x = g x)``
   (fn th => MP_TAC th THEN SIMP_TAC std_ss [FUN_EQ_THM, IN_UNIV]) THEN
  MATCH_MP_TAC LINEAR_EQ THEN
  EXISTS_TAC ``{i :real | 1 <= i /\ i <= 1}`` THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL, GSPECIFICATION] THEN
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
  KNOW_TAC ``span {1} = univ(:real)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [SUBSET_REFL]] THEN
  SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
  SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC []);

val LINEAR_INJECTIVE_LEFT_INVERSE = store_thm ("LINEAR_INJECTIVE_LEFT_INVERSE",
 ``!f:real->real. linear f /\ (!x y. (f x = f y) ==> (x = y))
                  ==> ?g. linear g /\ (g o f = (\x. x))``,
  REWRITE_TAC[INJECTIVE_LEFT_INVERSE] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``?h. linear(h:real->real) /\
                    !x. x IN IMAGE (f:real->real) {i | 1 <= i /\ i <= 1}
                  ==> (h x = g x)`` MP_TAC THENL
  [MATCH_MP_TAC LINEAR_INDEPENDENT_EXTEND THEN
   SIMP_TAC std_ss [REAL_LE_ANTISYM, GSPEC_EQ2, IMAGE_SING] THEN
   SIMP_TAC std_ss [INDEPENDENT_SING] THEN
   KNOW_TAC ``?g. !x. g ((f:real->real) x) = x`` THENL
   [METIS_TAC [], REWRITE_TAC [GSYM INJECTIVE_LEFT_INVERSE] THEN DISCH_TAC] THEN
   FULL_SIMP_TAC std_ss [linear] THEN KNOW_TAC ``0 = (f:real->real) 0`` THENL
   [UNDISCH_TAC ``!c x. (f:real->real) (c * x) = c * f x`` THEN
    DISCH_THEN (MP_TAC o SPECL [``0:real``, ``0:real``]) >> rw [],
    DISCH_TAC THEN ONCE_ASM_REWRITE_TAC []] THEN DISCH_TAC THEN
   UNDISCH_TAC ``!x y. ((f:real->real) x = f y) ==> (x = y)`` THEN
   DISCH_THEN (MP_TAC o SPECL [``1:real``,``0:real``]) THEN
   POP_ASSUM MP_TAC THEN rw [],
   DISCH_THEN (X_CHOOSE_TAC ``h:real->real``) THEN EXISTS_TAC ``h:real->real`` THEN
   POP_ASSUM MP_TAC THEN
   ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, GSPECIFICATION] THEN STRIP_TAC THEN
   ASM_REWRITE_TAC[] THEN MATCH_MP_TAC LINEAR_EQ_STDBASIS THEN
   ASM_SIMP_TAC std_ss [LINEAR_ID, LINEAR_COMPOSE, LINEAR_ID, o_THM] THEN
   ASM_MESON_TAC[]]);

val dim = new_definition ("dim",
  ``dim v = @n. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b) /\
                   b HAS_SIZE n``);

val BASIS_EXISTS = store_thm ("BASIS_EXISTS",
 ``!v. ?b. b SUBSET v /\ independent b /\ v SUBSET (span b) /\ b HAS_SIZE (dim v)``,
  GEN_TAC THEN REWRITE_TAC[dim] THEN CONV_TAC SELECT_CONV THEN
  MESON_TAC[MAXIMAL_INDEPENDENT_SUBSET, HAS_SIZE, INDEPENDENT_BOUND]);

val INDEPENDENT_CARD_LE_DIM = store_thm ("INDEPENDENT_CARD_LE_DIM",
 ``!v b:real->bool. b SUBSET v /\ independent b ==> FINITE b /\ CARD(b) <= dim v``,
  METIS_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, HAS_SIZE, SUBSET_TRANS]);

val CARD_GE_DIM_INDEPENDENT = store_thm ("CARD_GE_DIM_INDEPENDENT",
 ``!v b:real->bool. b SUBSET v /\ independent b /\ dim v <= CARD(b)
        ==> v SUBSET (span b)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!a:real. ~(a IN v /\ ~(a IN span b))`` MP_TAC THENL
   [ALL_TAC, SET_TAC[]] THEN
  X_GEN_TAC ``a:real`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``independent((a:real) INSERT b)`` ASSUME_TAC THENL
   [METIS_TAC[INDEPENDENT_INSERT], ALL_TAC] THEN
  MP_TAC(ISPECL [``v:real->bool``, ``(a:real) INSERT b``]
                INDEPENDENT_CARD_LE_DIM) THEN
  ASM_SIMP_TAC std_ss [INSERT_SUBSET, CARD_EMPTY, CARD_INSERT, INDEPENDENT_BOUND] THEN
  METIS_TAC[SPAN_SUPERSET, SUBSET_DEF, ARITH_PROVE
    ``x <= y ==> ~(SUC y <= x)``]);

val SPAN_EXPLICIT = store_thm ("SPAN_EXPLICIT",
 ``!(p:real -> bool). span p =
    {y | ?s u. FINITE s /\ s SUBSET p /\ (sum s (\v. u v * v) = y)}``,
  GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [ALL_TAC,
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN
    REPEAT STRIP_TAC THEN FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    MATCH_MP_TAC SPAN_SUM THEN ASM_REWRITE_TAC[] THEN
    ASM_MESON_TAC[SPAN_SUPERSET, SPAN_MUL]] THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(?s u. FINITE s /\ (!x. x IN s ==> x IN p) /\ (sum s (\v. u v * v) = x)) =
     (\x. ?s u. FINITE s /\ (!x. x IN s ==> x IN p) /\ (sum s (\v. u v * v) = x)) x``] THEN
  MATCH_MP_TAC SPAN_INDUCT_ALT THEN SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [EXISTS_TAC ``{}:real->bool`` THEN
    SIMP_TAC std_ss [FINITE_EMPTY, FINITE_INSERT, SUM_CLAUSES,
     EMPTY_SUBSET, NOT_IN_EMPTY], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``c:real``, ``x:real``, ``y:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``] THEN
  STRIP_TAC THEN EXISTS_TAC ``(x:real) INSERT s`` THEN
  EXISTS_TAC ``\y. if y = x then (if x IN s then (u:real->real) y + c else c)
                  else u y`` THEN
  ASM_SIMP_TAC std_ss [FINITE_INSERT, IN_INSERT, SUM_CLAUSES] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL
   [FIRST_X_ASSUM(SUBST1_TAC o MATCH_MP (SET_RULE
     ``x IN s ==> (s = x INSERT (s DELETE x))``)) THEN
    ASM_SIMP_TAC std_ss [SUM_CLAUSES, FINITE_INSERT, FINITE_DELETE, IN_DELETE] THEN
    MATCH_MP_TAC(REAL_ARITH
      ``(y = z) ==> ((c + d) * x + y = d * x + (c * x + z:real))``),
    AP_TERM_TAC] THEN
  MATCH_MP_TAC SUM_EQ THEN METIS_TAC[IN_DELETE]);

val DEPENDENT_EXPLICIT = store_thm ("DEPENDENT_EXPLICIT",
 ``!p. dependent (p:real -> bool) <=>
       ?s u. FINITE s /\ s SUBSET p /\ (?v. v IN s /\ ~(u v = &0)) /\
             (sum s (\v. u v * v) = 0)``,
  GEN_TAC THEN SIMP_TAC std_ss [dependent, SPAN_EXPLICIT, GSPECIFICATION] THEN
  SIMP_TAC std_ss [GSYM RIGHT_EXISTS_AND_THM, GSYM LEFT_EXISTS_AND_THM] THEN
  EQ_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THENL
   [MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``] THEN
    STRIP_TAC THEN ABBREV_TAC ``a = sum s (\v. (u:real->real) v * v)`` THEN
    MAP_EVERY EXISTS_TAC
     [``(a:real) INSERT s``,
      ``\y. if y = a then - &1 else (u:real->real) y``,
      ``a:real``] THEN
    ASM_REWRITE_TAC[IN_INSERT, INSERT_SUBSET, FINITE_INSERT] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC real_ss []] THEN
    ASM_SIMP_TAC std_ss [SUM_CLAUSES] THEN
    COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[REAL_ARITH ``(-&1 * a + s = 0) <=> (a = s:real)``] THEN
    FIRST_X_ASSUM(fn th => GEN_REWR_TAC LAND_CONV [SYM th]) THEN
    MATCH_MP_TAC SUM_EQ THEN ASM_SET_TAC[],
    MAP_EVERY X_GEN_TAC [``s:real->bool``, ``u:real->real``, ``a:real``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s DELETE (a:real)``,
      ``\i. -((u:real->real) i) / (u (a:real))``] THEN
    ASM_SIMP_TAC std_ss [SUM_DELETE, FINITE_DELETE] THEN
    KNOW_TAC ``sum s (\v. -u v / (u:real->real) a * v) - -u a / u a * a = a`` THENL
    [REWRITE_TAC[real_div] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
     REWRITE_TAC [REAL_MUL_ASSOC] THEN SIMP_TAC real_ss [SUM_RMUL, SUM_NEG'] THEN
     RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN ASM_REWRITE_TAC [] THEN
     ASM_SIMP_TAC real_ss [REAL_MUL_LNEG, GSYM REAL_MUL_ASSOC,
                           REAL_MUL_RNEG, REAL_MUL_RZERO] THEN
     ASM_SIMP_TAC real_ss [REAL_MUL_RINV], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    ASM_SET_TAC []]);

Theorem INDEPENDENT_INJECTIVE_IMAGE_GEN :
   !(f:real->real) s. independent s /\ linear f /\
     (!x y. x IN span s /\ y IN span s /\ (f(x) = f(y)) ==> (x = y))
    ==> independent (IMAGE f s)
Proof
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss' [independent, DEPENDENT_EXPLICIT] THEN
  REWRITE_TAC[CONJ_ASSOC, FINITE_SUBSET_IMAGE] THEN DISCH_TAC THEN
  KNOW_TAC ``(?s':real->bool u:real->real. (FINITE s' /\ s' SUBSET s) /\
      (?v. v IN IMAGE f s' /\ ~(u v = &0)) /\
      (sum (IMAGE f s') (\v. u v * v) = 0))`` THENL
  [METIS_TAC [], POP_ASSUM K_TAC] THEN
  SIMP_TAC std_ss [EXISTS_IN_IMAGE, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``t:real->bool``, ``u:real->real``] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MAP_EVERY EXISTS_TAC
   [``t:real->bool``, ``(u:real->real) o (f:real->real)``] THEN
  ASM_REWRITE_TAC[o_THM] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN REPEAT CONJ_TAC THENL
   [MATCH_MP_TAC SPAN_SUM THEN ASM_SIMP_TAC std_ss [] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SPAN_MUL THEN
    MATCH_MP_TAC SPAN_SUPERSET THEN ASM_SET_TAC[],
    REWRITE_TAC[SPAN_0],
    ASM_SIMP_TAC std_ss [LINEAR_SUM] THEN
    FIRST_ASSUM(SUBST1_TAC o MATCH_MP LINEAR_0) THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN CONV_TAC SYM_CONV THEN
    W(MP_TAC o PART_MATCH (lhs o rand) SUM_IMAGE o lhand o snd) THEN
    ASM_SIMP_TAC std_ss [o_DEF] THEN ASM_SIMP_TAC std_ss [LINEAR_CMUL] THEN
    DISCH_THEN MATCH_MP_TAC THEN ASM_MESON_TAC[SPAN_SUPERSET, SUBSET_DEF]]
QED

val INDEPENDENT_INJECTIVE_IMAGE = store_thm ("INDEPENDENT_INJECTIVE_IMAGE",
 ``!f:real->real s. independent s /\ linear f /\
     (!x y. (f(x) = f(y)) ==> (x = y)) ==> independent (IMAGE f s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INDEPENDENT_INJECTIVE_IMAGE_GEN THEN
  ASM_MESON_TAC[]);

Theorem SPAN_LINEAR_IMAGE :
    !f:real->real s. linear f ==> (span(IMAGE f s) = IMAGE f (span s))
Proof
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  X_GEN_TAC ``x:real`` THEN EQ_TAC THENL
   [ONCE_REWRITE_TAC [METIS [] ``x IN IMAGE f (span s) <=>
                            (\x. x IN IMAGE f (span s)) x``] THEN
    SPEC_TAC(``x:real``, ``x:real``) THEN MATCH_MP_TAC SPAN_INDUCT THEN
    SIMP_TAC std_ss [SET_RULE ``(\x. x IN s) = s``] THEN
    ASM_SIMP_TAC std_ss [SUBSPACE_SPAN, SUBSPACE_LINEAR_IMAGE] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN REWRITE_TAC[IN_IMAGE] THEN
    MESON_TAC[SPAN_SUPERSET, SUBSET_DEF],
    SPEC_TAC(``x:real``, ``x:real``) THEN SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
    ONCE_REWRITE_TAC [METIS [] ``f x IN span (IMAGE f s) <=>
                            (\x. f x IN span (IMAGE f s)) x``] THEN
    MATCH_MP_TAC SPAN_INDUCT THEN
    SIMP_TAC std_ss [SET_RULE ``(\x. f x IN span(s)) = {x | f(x) IN span s}``] THEN
    ASM_SIMP_TAC std_ss [SUBSPACE_LINEAR_PREIMAGE, SUBSPACE_SPAN] THEN
    SIMP_TAC std_ss [GSPECIFICATION] THEN
    MESON_TAC[SPAN_SUPERSET, SUBSET_DEF, IN_IMAGE]]
QED

(* ------------------------------------------------------------------------- *)
(* An injective map real->real is also surjective.                       *)
(* ------------------------------------------------------------------------- *)

val LINEAR_INJECTIVE_IMP_SURJECTIVE = store_thm ("LINEAR_INJECTIVE_IMP_SURJECTIVE",
 ``!f:real->real. linear f /\ (!x y. (f(x) = f(y)) ==> (x = y))
                 ==> !y. ?x. f(x) = y``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``univ(:real)`` BASIS_EXISTS) THEN
  REWRITE_TAC[SUBSET_UNIV, HAS_SIZE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``UNIV SUBSET span(IMAGE (f:real->real) b)`` MP_TAC THENL
   [MATCH_MP_TAC CARD_GE_DIM_INDEPENDENT THEN
    ASM_MESON_TAC[INDEPENDENT_INJECTIVE_IMAGE, LESS_EQ_REFL,
                  SUBSET_UNIV, CARD_IMAGE_INJ],
    ASM_SIMP_TAC std_ss [SPAN_LINEAR_IMAGE] THEN
    ASM_MESON_TAC[SUBSET_DEF, IN_IMAGE, IN_UNIV]]);

(* ------------------------------------------------------------------------- *)
(* Left-invertible linear transformation has a lower bound.                  *)
(* ------------------------------------------------------------------------- *)

val LINEAR_INVERTIBLE_BOUNDED_BELOW_POS = store_thm ("LINEAR_INVERTIBLE_BOUNDED_BELOW_POS",
 ``!f:real->real g. linear f /\ linear g /\ (g o f = I)
   ==> ?B. &0 < B /\ !x. B * abs(x) <= abs(f x)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``g:real->real`` LINEAR_BOUNDED_POS) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``inv B:real`` THEN ASM_SIMP_TAC real_ss [REAL_LT_INV_EQ] THEN
  X_GEN_TAC ``x:real`` THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``inv(B) * abs(((g:real->real) o (f:real->real)) x)`` THEN
  CONJ_TAC THENL [ASM_SIMP_TAC real_ss [I_THM, REAL_LE_REFL], ALL_TAC] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC real_ss [o_THM, REAL_LE_LDIV_EQ] THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_REWRITE_TAC[]);

val LINEAR_INVERTIBLE_BOUNDED_BELOW = store_thm ("LINEAR_INVERTIBLE_BOUNDED_BELOW",
 ``!f:real->real g. linear f /\ linear g /\ (g o f = I) ==>
   ?B. !x. B * abs(x) <= abs(f x)``,
  MESON_TAC[LINEAR_INVERTIBLE_BOUNDED_BELOW_POS]);

val LINEAR_INJECTIVE_BOUNDED_BELOW_POS = store_thm ("LINEAR_INJECTIVE_BOUNDED_BELOW_POS",
 ``!f:real->real. linear f /\ (!x y. (f x = f y) ==> (x = y))
    ==> ?B. &0 < B /\ !x. abs(x) * B <= abs(f x)``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  MATCH_MP_TAC LINEAR_INVERTIBLE_BOUNDED_BELOW_POS THEN
  METIS_TAC[LINEAR_INJECTIVE_LEFT_INVERSE, I_THM]);

(* ------------------------------------------------------------------------- *)
(* Consequences of independence or spanning for cardinality.                 *)
(* ------------------------------------------------------------------------- *)

val SPAN_CARD_GE_DIM = store_thm ("SPAN_CARD_GE_DIM",
 ``!v b:real->bool. v SUBSET (span b) /\ FINITE b ==> dim(v) <= CARD(b)``,
  METIS_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, HAS_SIZE, SUBSET_TRANS]);

val BASIS_CARD_EQ_DIM = store_thm ("BASIS_CARD_EQ_DIM",
 ``!v b. b SUBSET v /\ v SUBSET (span b) /\ independent b
   ==> FINITE b /\ (CARD b = dim v)``,
  METIS_TAC[LESS_EQUAL_ANTISYM, INDEPENDENT_CARD_LE_DIM, SPAN_CARD_GE_DIM]);

val BASIS_HAS_SIZE_DIM = store_thm ("BASIS_HAS_SIZE_DIM",
 ``!v b. independent b /\ (span b = v) ==> b HAS_SIZE (dim v)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HAS_SIZE] THEN
  MATCH_MP_TAC BASIS_CARD_EQ_DIM THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN REWRITE_TAC[SPAN_INC]);

val DIM_UNIQUE = store_thm ("DIM_UNIQUE",
 ``!v b. b SUBSET v /\ v SUBSET (span b) /\ independent b /\ b HAS_SIZE n
        ==> (dim v = n)``,
  MESON_TAC[BASIS_CARD_EQ_DIM, HAS_SIZE]);

val DIM_LE_CARD = store_thm ("DIM_LE_CARD",
 ``!s. FINITE s ==> dim s <= CARD s``,
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC SPAN_CARD_GE_DIM THEN
  ASM_REWRITE_TAC[SPAN_INC, SUBSET_REFL]);

(* ------------------------------------------------------------------------- *)
(* Standard bases are a spanning set, and obviously finite.                  *)
(* ------------------------------------------------------------------------- *)

val SPAN_STDBASIS = store_thm ("SPAN_STDBASIS",
 ``span {i :real | 1 <= i /\ i <= 1} = UNIV``,
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2] THEN
  SIMP_TAC std_ss [EXTENSION, span, hull, IN_BIGINTER, IN_UNIV] THEN
  SIMP_TAC std_ss [SING_SUBSET, GSPECIFICATION, subspace] THEN
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_RID] THEN
  FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC []);

val HAS_SIZE_STDBASIS = store_thm ("HAS_SIZE_STDBASIS",
 ``{i :real | 1 <= i /\ i <= 1} HAS_SIZE 1``,
  REWRITE_TAC [REAL_LE_ANTISYM, GSPEC_EQ2, HAS_SIZE] THEN
  REWRITE_TAC [FINITE_SING, CARD_SING]);

(* ------------------------------------------------------------------------- *)
(* More lemmas about dimension.                                              *)
(* ------------------------------------------------------------------------- *)

val DIM_UNIV = store_thm ("DIM_UNIV",
 ``dim univ(:real) = 1:num``,
  MATCH_MP_TAC DIM_UNIQUE THEN EXISTS_TAC ``{i :real | &1 <= i /\ i <= &1}`` THEN
  REWRITE_TAC[SUBSET_UNIV, SPAN_STDBASIS, HAS_SIZE_STDBASIS, INDEPENDENT_STDBASIS]);

val DIM_SUBSET = store_thm ("DIM_SUBSET",
 ``!s t:real->bool. s SUBSET t ==> dim(s) <= dim(t)``,
  MESON_TAC[BASIS_EXISTS, INDEPENDENT_SPAN_BOUND, SUBSET_DEF, HAS_SIZE]);

val DIM_SUBSET_UNIV = store_thm ("DIM_SUBSET_UNIV",
 ``!s:real->bool. dim(s) <=  1n``,
  GEN_TAC THEN REWRITE_TAC[GSYM DIM_UNIV] THEN
  MATCH_MP_TAC DIM_SUBSET THEN REWRITE_TAC[SUBSET_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Open and closed sets                                                      *)
(* ------------------------------------------------------------------------- *)

(* new definition *)
Definition euclidean_def :
    euclidean = mtop mr1
End

(* new definition *)
Definition euclidean_open_def :
    Open = open_in euclidean
End
Overload "open" = “Open”

(* old definition as an equivalent theorem *)
Theorem open_def :
    !s. Open s <=> !x. x IN s ==> ?e. &0 < e /\ !x'. dist(x',x) < e ==> x' IN s
Proof
    rw [euclidean_def, MTOP_OPEN, euclidean_open_def, dist_def, IN_APP,
        Once METRIC_SYM]
QED

(* old definition as an equivalent theorem *)
Theorem euclidean :
    euclidean = topology open
Proof
    rw [euclidean_def, mtop]
 >> AP_TERM_TAC (* eliminated ‘topology’ *)
 >> rw [FUN_EQ_THM, open_def, dist_def, IN_APP, Once METRIC_SYM]
QED

fun convert thm =
    REWRITE_RULE [GSYM euclidean_open_def] (Q.ISPEC ‘euclidean’ thm);

(* |- open {} *)
Theorem OPEN_EMPTY = convert OPEN_IN_EMPTY

val OPEN_UNIV = store_thm ("OPEN_UNIV",
 ``open univ(:real)``,
  REWRITE_TAC[open_def, IN_UNIV] THEN MESON_TAC[REAL_LT_01]);

(* |- !s t. open s /\ open t ==> open (s INTER t) *)
Theorem OPEN_INTER = convert OPEN_IN_INTER

(* NOTE: added top quantifier for ‘f’ *)
Theorem OPEN_BIGUNION :
    !f. (!s. s IN f ==> open s) ==> open (BIGUNION f)
Proof
    REWRITE_TAC [open_def, IN_BIGUNION] >> MESON_TAC []
QED

val OPEN_EXISTS_IN = store_thm ("OPEN_EXISTS_IN",
 ``!P Q:'a->real->bool.
        (!a. P a ==> open {x | Q a x}) ==> open {x | ?a. P a /\ Q a x}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``open(BIGUNION {{x | Q (a:'a) (x:real)} | P a})`` MP_TAC THENL
   [MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN
    METIS_TAC [], MATCH_MP_TAC (TAUT `(a <=> b) ==> a ==> b`) THEN AP_TERM_TAC THEN
    SIMP_TAC std_ss [EXTENSION, IN_BIGUNION, GSPECIFICATION] THEN
    SET_TAC[]]);

val OPEN_EXISTS = store_thm ("OPEN_EXISTS",
 ``!Q:'a->real->bool. (!a. open {x | Q a x}) ==> open {x | ?a. Q a x}``,
  MP_TAC(ISPEC ``\x:'a. T`` OPEN_EXISTS_IN) THEN REWRITE_TAC[]);

Theorem OPEN_IN :
    !s. open s <=> open_in euclidean s
Proof
    rw [euclidean_open_def]
QED

val TOPSPACE_EUCLIDEAN = store_thm ("TOPSPACE_EUCLIDEAN",
 ``topspace euclidean = univ(:real)``,
  SIMP_TAC std_ss [topspace, EXTENSION, IN_UNIV, IN_BIGUNION, GSPECIFICATION] THEN
  MESON_TAC[OPEN_UNIV, IN_UNIV, OPEN_IN]);

val TOPSPACE_EUCLIDEAN_SUBTOPOLOGY = store_thm ("TOPSPACE_EUCLIDEAN_SUBTOPOLOGY",
 ``!s. topspace (subtopology euclidean s) = s``,
  REWRITE_TAC[TOPSPACE_EUCLIDEAN, TOPSPACE_SUBTOPOLOGY, INTER_UNIV]);

val OPEN_IN_REFL = store_thm ("OPEN_IN_REFL",
 ``!s:real->bool. open_in (subtopology euclidean s) s``,
  REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV]);

(* new definition *)
Definition euclidean_closed_def :
    Closed = closed_in euclidean
End
Overload closed = “Closed”

(* old definition as an equivalent theorem *)
Theorem closed_def :
    !s. Closed s <=> open (UNIV DIFF s)
Proof
    rw [euclidean_closed_def, closed_in, euclidean_open_def, TOPSPACE_EUCLIDEAN]
QED

val CLOSED_IN_REFL = store_thm ("CLOSED_IN_REFL",
 ``!s:real->bool. closed_in (subtopology euclidean s) s``,
  REWRITE_TAC[CLOSED_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV]);

Theorem CLOSED_IN :
    !s. closed s <=> closed_in euclidean s
Proof
    rw [euclidean_closed_def]
QED

(* |- !s t. open s /\ open t ==> open (s UNION t) *)
Theorem OPEN_UNION = convert OPEN_IN_UNION

Theorem OPEN_SUB_OPEN :
    !s. open s <=> !x. x IN s ==> ?t. open t /\ x IN t /\ t SUBSET s
Proof
    rw [euclidean_open_def, Once OPEN_SUBOPEN, IN_APP]
 >> METIS_TAC []
QED

val CLOSED_EMPTY = store_thm ("CLOSED_EMPTY",
 ``closed {}``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_EMPTY]);

val CLOSED_UNIV = store_thm ("CLOSED_UNIV",
 ``closed(UNIV:real->bool)``,
  REWRITE_TAC[CLOSED_IN, GSYM TOPSPACE_EUCLIDEAN, CLOSED_IN_TOPSPACE]);

val CLOSED_UNION = store_thm ("CLOSED_UNION",
 ``!s t. closed s /\ closed t ==> closed(s UNION t)``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_UNION]);

val CLOSED_INTER = store_thm ("CLOSED_INTER",
 ``!s t. closed s /\ closed t ==> closed(s INTER t)``,
  REWRITE_TAC[CLOSED_IN, CLOSED_IN_INTER]);

val CLOSED_BIGINTER = store_thm ("CLOSED_BIGINTER",
 ``!f. (!s:real->bool. s IN f ==> closed s) ==> closed(BIGINTER f)``,
  REWRITE_TAC[CLOSED_IN] THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_BIGINTER, BIGINTER_EMPTY] THEN
  REWRITE_TAC[GSYM TOPSPACE_EUCLIDEAN, CLOSED_IN_TOPSPACE]);

val CLOSED_FORALL_IN = store_thm ("CLOSED_FORALL_IN",
 ``!P Q:'a->real->bool.
        (!a. P a ==> closed {x | Q a x}) ==> closed {x | !a. P a ==> Q a x}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``closed(BIGINTER {{x | Q (a:'a) (x:real)} | P a})`` MP_TAC THENL
   [MATCH_MP_TAC CLOSED_BIGINTER THEN ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC],
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SIMP_TAC std_ss [BIGINTER_GSPEC] THEN
    SET_TAC[]]);

val CLOSED_FORALL = store_thm ("CLOSED_FORALL",
 ``!Q:'a->real->bool. (!a. closed {x | Q a x}) ==> closed {x | !a. Q a x}``,
  MP_TAC(ISPEC ``\x:'a. T`` CLOSED_FORALL_IN) THEN REWRITE_TAC[]);

val OPEN_CLOSED = store_thm ("OPEN_CLOSED",
 ``!s:real->bool. open s <=> closed(UNIV DIFF s)``,
  SIMP_TAC std_ss [OPEN_IN, CLOSED_IN, TOPSPACE_EUCLIDEAN, SUBSET_UNIV,
           OPEN_IN_CLOSED_IN_EQ]);

val OPEN_DIFF = store_thm ("OPEN_DIFF",
 ``!s t. open s /\ closed t ==> open(s DIFF t)``,
  REWRITE_TAC[OPEN_IN, CLOSED_IN, OPEN_IN_DIFF]);

val CLOSED_DIFF = store_thm ("CLOSED_DIFF",
 ``!s t. closed s /\ open t ==> closed(s DIFF t)``,
  REWRITE_TAC[OPEN_IN, CLOSED_IN, CLOSED_IN_DIFF]);

val OPEN_BIGINTER = store_thm ("OPEN_BIGINTER",
  ``!s. FINITE s /\ (!t. t IN s ==> open t) ==> (open (BIGINTER s))``,
  REWRITE_TAC [GSYM AND_IMP_INTRO] THEN GEN_TAC THEN
  KNOW_TAC `` (!t. t IN s ==> open t) ==> open (BIGINTER s) <=>
         (\x. (!t. t IN x ==> open t) ==> open (BIGINTER x)) s`` THENL
  [SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
   MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
   REWRITE_TAC [BIGINTER_INSERT, BIGINTER_EMPTY, OPEN_UNIV,
   IN_INSERT] THEN MESON_TAC [OPEN_INTER]);

val CLOSED_BIGUNION = store_thm ("CLOSED_BIGUNION",
 ``!s. FINITE s /\ (!t. t IN s ==> closed t) ==> closed(BIGUNION s)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s. ((!t. t IN s ==> closed t) ==> closed(BIGUNION s)) <=>
             (\s. (!t. t IN s ==> closed t) ==> closed(BIGUNION s)) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_INSERT, BIGUNION_EMPTY, CLOSED_EMPTY, IN_INSERT] THEN
  MESON_TAC[CLOSED_UNION]);

(* ------------------------------------------------------------------------- *)
(* Open and closed balls.                                                    *)
(* ------------------------------------------------------------------------- *)

(* new definition based on metricTheory *)
Definition ball_def :
    ball = metric$B(mr1)
End

(* old definition now becomes a theorem *)
Theorem ball :
    !x e. ball(x,e) = { y | dist(x,y) < e}
Proof
    RW_TAC std_ss [ball_def, dist_def, metricTheory.ball,
                   Once EXTENSION, GSPECIFICATION]
 >> rw [IN_APP]
QED

val cball = new_definition ("cball",
  ``cball(x,e) = { y | dist(x,y) <= e}``);

val sphere = new_definition ("sphere",
  ``sphere(x,e) = { y | dist(x,y) = e}``);

val IN_BALL = store_thm ("IN_BALL",
 ``!x y e. y IN ball(x,e) <=> dist(x,y) < e``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [ball, GSPECIFICATION]);

val IN_CBALL = store_thm ("IN_CBALL",
 ``!x y e. y IN cball(x,e) <=> dist(x,y) <= e``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [cball, GSPECIFICATION]);

val IN_SPHERE = store_thm ("IN_SPHERE",
 ``!x y e. y IN sphere(x,e) <=> (dist(x,y) = e)``,
  REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [sphere, GSPECIFICATION]);

val IN_BALL_0 = store_thm ("IN_BALL_0",
 ``!x e. x IN ball(0,e) <=> abs(x) < e``,
  REWRITE_TAC [IN_BALL, dist, REAL_SUB_LZERO, ABS_NEG]);

val IN_CBALL_0 = store_thm ("IN_CBALL_0",
 ``!x e. x IN cball(0,e) <=> abs(x) <= e``,
  REWRITE_TAC[IN_CBALL, dist, REAL_SUB_LZERO, ABS_NEG]);

val IN_SPHERE_0 = store_thm ("IN_SPHERE_0",
 ``!x e. x IN sphere(0,e) <=> (abs(x) = e)``,
  REWRITE_TAC[IN_SPHERE, dist, REAL_SUB_LZERO, ABS_NEG]);

val BALL_TRIVIAL = store_thm ("BALL_TRIVIAL",
 ``!x. ball(x,&0) = {}``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_SING, NOT_IN_EMPTY, dist] THEN REAL_ARITH_TAC);

val CBALL_TRIVIAL = store_thm ("CBALL_TRIVIAL",
 ``!x. cball(x,&0) = {x}``,
  REWRITE_TAC[EXTENSION, IN_CBALL, IN_SING, NOT_IN_EMPTY, dist] THEN REAL_ARITH_TAC);

val CENTRE_IN_CBALL = store_thm ("CENTRE_IN_CBALL",
 ``!x e. x IN cball(x,e) <=> &0 <= e``,
  MESON_TAC[IN_CBALL, DIST_REFL]);

val BALL_SUBSET_CBALL = store_thm ("BALL_SUBSET_CBALL",
 ``!x e. ball(x,e) SUBSET cball(x,e)``,
  REWRITE_TAC[IN_BALL, IN_CBALL, SUBSET_DEF] THEN REAL_ARITH_TAC);

val SPHERE_SUBSET_CBALL = store_thm ("SPHERE_SUBSET_CBALL",
 ``!x e. sphere(x,e) SUBSET cball(x,e)``,
  REWRITE_TAC[IN_SPHERE, IN_CBALL, SUBSET_DEF] THEN REAL_ARITH_TAC);

val SUBSET_BALL = store_thm ("SUBSET_BALL",
 ``!x d e. d <= e ==> ball(x,d) SUBSET ball(x,e)``,
  REWRITE_TAC[SUBSET_DEF, IN_BALL] THEN MESON_TAC[REAL_LTE_TRANS]);

val SUBSET_CBALL = store_thm ("SUBSET_CBALL",
 ``!x d e. d <= e ==> cball(x,d) SUBSET cball(x,e)``,
  REWRITE_TAC[SUBSET_DEF, IN_CBALL] THEN MESON_TAC[REAL_LE_TRANS]);

val BALL_MAX_UNION = store_thm ("BALL_MAX_UNION",
  ``!a r s. ball(a,max r s) = ball(a,r) UNION ball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_BALL, IN_UNION, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LT_MAX]);

val BALL_MIN_INTER = store_thm ("BALL_MIN_INTER",
  ``!a r s. ball(a,min r s) = ball(a,r) INTER ball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_BALL, IN_INTER, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LT_MIN]);

val CBALL_MAX_UNION = store_thm ("CBALL_MAX_UNION",
  ``!a r s. cball(a,max r s) = cball(a,r) UNION cball(a,s)``,
    rpt GEN_TAC
 >> REWRITE_TAC [IN_CBALL, IN_UNION, EXTENSION, dist]
 >> GEN_TAC >> Q.ABBREV_TAC `b = abs (a - x)`
 >> REWRITE_TAC [REAL_LE_MAX]);

val CBALL_MIN_INTER = store_thm ("CBALL_MIN_INTER",
  ``!x d e. cball(x,min d e) = cball(x,d) INTER cball(x,e)``,
    rpt GEN_TAC
 >> REWRITE_TAC [EXTENSION, IN_INTER, IN_CBALL, dist]
 >> Q.X_GEN_TAC `a` >> Q.ABBREV_TAC `b = abs (x - a)`
 >> REWRITE_TAC [REAL_LE_MIN]);

val BALL_TRANSLATION = store_thm ("BALL_TRANSLATION",
 ``!a x r. ball(a + x,r) = IMAGE (\y. a + y) (ball(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_BALL, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val CBALL_TRANSLATION = store_thm ("CBALL_TRANSLATION",
 ``!a x r. cball(a + x,r) = IMAGE (\y. a + y) (cball(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_CBALL, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val SPHERE_TRANSLATION = store_thm ("SPHERE_TRANSLATION",
 ``!a x r. sphere(a + x,r) = IMAGE (\y. a + y) (sphere(x,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC [EXTENSION, IN_SPHERE, IN_IMAGE, dist] THEN
  GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x' - a:real`` THEN
  RW_TAC std_ss [REAL_SUB_ADD2] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``x - (x' - a) = a + x - x':real``],
  RW_TAC std_ss [] THEN
  METIS_TAC [REAL_ARITH ``a - (b + c) = a - b - c:real``, REAL_ADD_SUB]]);

val BALL_LINEAR_IMAGE = store_thm ("BALL_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (ball(f x,r) = IMAGE f (ball(x,r)))``,
  REWRITE_TAC[ball] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val CBALL_LINEAR_IMAGE = store_thm ("CBALL_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (cball(f x,r) = IMAGE f (cball(x,r)))``,
  REWRITE_TAC[cball] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val SPHERE_LINEAR_IMAGE = store_thm ("SPHERE_LINEAR_IMAGE",
 ``!f:real->real x r.
        linear f /\ (!y. ?x. f x = y) /\ (!x. abs(f x) = abs x)
        ==> (sphere(f x,r) = IMAGE f (sphere(x,r)))``,
  REWRITE_TAC[sphere] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [UNDISCH_TAC ``!y. ?x. (f:real->real) x = y`` THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SPEC ``x':real``) THEN STRIP_TAC THEN
   EXISTS_TAC ``x'':real`` THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x. abs ((f:real->real) x) = abs x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPEC ``x - x'':real``) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SPECL [``x:real``, ``-x'':real``]) THEN
   REWRITE_TAC [GSYM real_sub] THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-x = -1 * x:real``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SPECL [``-1:real``,``x'':real``]) THEN ASM_REAL_ARITH_TAC,
   ASM_REWRITE_TAC [real_sub] THEN REWRITE_TAC [REAL_ARITH ``-(f:real->real) x = -1 * f x``] THEN
   UNDISCH_TAC ``!c x. f (c * x) = c * (f:real->real) x`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``-1:real``,``x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ARITH ``-1 * x:real = -x``] THEN
   UNDISCH_TAC ``!x y. (f:real->real) (x + y) = f x + f y`` THEN
   DISCH_THEN (MP_TAC o SYM o SPECL [``x:real``, ``-x'':real``]) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [GSYM real_sub]]);

val BALL_SCALING = store_thm ("BALL_SCALING",
 ``!c. &0 < c ==> !x r. ball(c * x,c * r) = IMAGE (\x. c * x) (ball(x,r))``,
  REWRITE_TAC [IMAGE_DEF, IN_BALL] THEN BETA_TAC THEN
  SIMP_TAC std_ss [ball, EXTENSION, GSPECIFICATION, dist] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL [DISCH_TAC THEN
  EXISTS_TAC ``x' / c:real`` THEN
  FULL_SIMP_TAC std_ss [REAL_DIV_LMUL, REAL_POS_NZ] THEN
  KNOW_TAC `` abs (x - x' / c) < r <=> abs c * abs (x - x' / c) < c * r:real`` THENL
  [FULL_SIMP_TAC std_ss [abs, REAL_LT_IMP_LE, REAL_LT_LMUL], ALL_TAC] THEN
  DISC_RW_KILL THEN REWRITE_TAC [GSYM ABS_MUL] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_DIV_LMUL, REAL_POS_NZ],
  STRIP_TAC THEN FULL_SIMP_TAC std_ss [GSYM dist, DIST_MUL, abs,
                 REAL_LT_IMP_LE, REAL_LT_LMUL]]);

val CBALL_SCALING = store_thm ("CBALL_SCALING",
 ``!c. &0 < c ==> !x r. cball(c * x,c * r) = IMAGE (\x. c * x) (cball(x,r))``,
  REWRITE_TAC [IMAGE_DEF, IN_CBALL] THEN BETA_TAC THEN
  SIMP_TAC std_ss [cball, EXTENSION, GSPECIFICATION, dist] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL [DISCH_TAC THEN
  EXISTS_TAC ``x' / c:real`` THEN
  FULL_SIMP_TAC std_ss [REAL_DIV_LMUL, REAL_POS_NZ] THEN
  KNOW_TAC `` abs (x - x' / c) <= r <=> abs c * abs (x - x' / c) <= c * r:real`` THENL
  [FULL_SIMP_TAC std_ss [abs, REAL_LT_IMP_LE, REAL_LE_LMUL], ALL_TAC] THEN
  DISC_RW_KILL THEN REWRITE_TAC [GSYM ABS_MUL] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_DIV_LMUL, REAL_POS_NZ],
  STRIP_TAC THEN FULL_SIMP_TAC std_ss [GSYM dist, DIST_MUL, abs,
                 REAL_LT_IMP_LE, REAL_LE_LMUL]]);

val CBALL_DIFF_BALL = store_thm ("CBALL_DIFF_BALL",
 ``!a r. cball(a,r) DIFF ball(a,r) = sphere(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_DIFF, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val BALL_UNION_SPHERE = store_thm ("BALL_UNION_SPHERE",
 ``!a r. ball(a,r) UNION sphere(a,r) = cball(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_UNION, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val SPHERE_UNION_BALL = store_thm ("SPHERE_UNION_BALL",
 ``!a r. sphere(a,r) UNION ball(a,r)  = cball(a,r)``,
  SIMP_TAC std_ss [ball, cball, sphere, EXTENSION, IN_UNION, GSPECIFICATION] THEN
  REAL_ARITH_TAC);

val CBALL_DIFF_SPHERE = store_thm ("CBALL_DIFF_SPHERE",
 ``!a r. cball(a,r) DIFF sphere(a,r) = ball(a,r)``,
  REWRITE_TAC[EXTENSION, IN_DIFF, IN_SPHERE, IN_BALL, IN_CBALL] THEN
  REAL_ARITH_TAC);

val OPEN_BALL = store_thm ("OPEN_BALL",
 ``!x e. open(ball(x,e))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_def, ball] THEN
  FULL_SIMP_TAC std_ss [GSPECIFICATION] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  MESON_TAC [REAL_SUB_LT, REAL_LT_SUB_LADD, REAL_ADD_SYM, REAL_LET_TRANS,
  DIST_TRIANGLE_ALT]);

val CENTRE_IN_BALL = store_thm ("CENTRE_IN_BALL",
 ``!x e. x IN ball(x,e) <=> &0 < e``,
  MESON_TAC[IN_BALL, DIST_REFL]);

val OPEN_CONTAINS_BALL = store_thm ("OPEN_CONTAINS_BALL",
 ``!s. open s <=> !x. x IN s ==> ?e. &0 < e /\ ball(x,e) SUBSET s``,
  REWRITE_TAC[open_def, SUBSET_DEF, IN_BALL] THEN SIMP_TAC std_ss [DIST_SYM]);

val OPEN_CONTAINS_BALL_EQ = store_thm ("OPEN_CONTAINS_BALL_EQ",
 ``!s. open s ==> (!x. x IN s <=> ?e. &0 < e /\ ball(x,e) SUBSET s)``,
  MESON_TAC[OPEN_CONTAINS_BALL, SUBSET_DEF, CENTRE_IN_BALL]);

val BALL_EQ_EMPTY = store_thm ("BALL_EQ_EMPTY",
 ``!x e. (ball(x,e) = {}) <=> e <= &0``,
  REWRITE_TAC[EXTENSION, IN_BALL, NOT_IN_EMPTY, REAL_NOT_LT] THEN
  MESON_TAC[DIST_POS_LE, REAL_LE_TRANS, DIST_REFL]);

val BALL_EMPTY = store_thm ("BALL_EMPTY",
 ``!x e. e <= &0 ==> (ball(x,e) = {})``,
  REWRITE_TAC[BALL_EQ_EMPTY]);

val OPEN_CONTAINS_CBALL = store_thm ("OPEN_CONTAINS_CBALL",
 ``!s. open s <=> !x. x IN s ==> ?e. &0 < e /\ cball(x,e) SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[OPEN_CONTAINS_BALL] THEN EQ_TAC THENL
   [ALL_TAC, ASM_MESON_TAC[SUBSET_TRANS, BALL_SUBSET_CBALL]] THEN
   KNOW_TAC ``!x. (x IN s ==> ?e. 0 < e /\ cball (x,e) SUBSET s) =
         (\x:real. x IN s ==> ?e. 0 < e /\ cball (x,e) SUBSET s) x`` THENL
   [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
   KNOW_TAC ``!x. (x IN s ==> ?e. 0 < e /\ ball (x,e) SUBSET s) =
         (\x:real. x IN s ==> ?e. 0 < e /\ ball (x,e) SUBSET s) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC MONO_ALL THEN GEN_TAC THEN BETA_TAC THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e / &2:real`` THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  SUBGOAL_THEN ``e / &2 < e:real`` (fn th => ASM_MESON_TAC[th, REAL_LET_TRANS]) THEN
  UNDISCH_TAC ``0 < e:real`` THEN SIMP_TAC arith_ss [REAL_LT_HALF2]);

val OPEN_CONTAINS_CBALL_EQ = store_thm ("OPEN_CONTAINS_CBALL_EQ",
 ``!s. open s ==> (!x. x IN s <=> ?e. &0 < e /\ cball(x,e) SUBSET s)``,
  MESON_TAC[OPEN_CONTAINS_CBALL, SUBSET_DEF, REAL_LT_IMP_LE, CENTRE_IN_CBALL]);

val SPHERE_EQ_EMPTY = store_thm ("SPHERE_EQ_EMPTY",
 ``!a:real r. (sphere(a,r) = {}) <=> r < &0``,
  SIMP_TAC std_ss [sphere, EXTENSION, GSPECIFICATION, NOT_IN_EMPTY] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [REAL_NOT_LT] THEN
  UNDISCH_TAC ``!x. dist (a,x) <> r`` THEN
  FULL_SIMP_TAC std_ss [REAL_LE_LT, dist] THENL
  [EXISTS_TAC ``a - r:real`` THEN POP_ASSUM MP_TAC THEN
  REAL_ARITH_TAC, EXISTS_TAC ``a:real`` THEN
  METIS_TAC [REAL_SUB_REFL, EQ_SYM_EQ, ABS_0]], DISCH_TAC THEN
  ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN CCONTR_TAC THEN
  UNDISCH_TAC ``r < 0:real`` THEN FULL_SIMP_TAC std_ss [REAL_NOT_LT, DIST_POS_LE]]);

val SPHERE_EMPTY = store_thm ("SPHERE_EMPTY",
 ``!a:real r. r < &0 ==> (sphere(a,r) = {})``,
  REWRITE_TAC[SPHERE_EQ_EMPTY]);

val NEGATIONS_BALL = store_thm ("NEGATIONS_BALL",
 ``!r. IMAGE (\x:real. -x) (ball(0:real,r)) = ball(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_BALL_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

val NEGATIONS_CBALL = store_thm ("NEGATIONS_CBALL",
 ``!r. IMAGE (\x. -x) (cball(0:real,r)) = cball(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_CBALL_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

val NEGATIONS_SPHERE = store_thm ("NEGATIONS_SPHERE",
 ``!r. IMAGE (\x. -x) (sphere(0:real,r)) = sphere(0,r)``,
  GEN_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_SPHERE_0] THEN
  GEN_TAC THEN EQ_TAC THENL [METIS_TAC [ABS_NEG], DISCH_TAC THEN
  EXISTS_TAC ``-x:real`` THEN
  FULL_SIMP_TAC std_ss [ABS_NEG, REAL_NEG_NEG]]);

(* ------------------------------------------------------------------------- *)
(* Basic "localization" results are handy for connectedness.                 *)
(* ------------------------------------------------------------------------- *)

val OPEN_IN_OPEN = store_thm ("OPEN_IN_OPEN",
 ``!s:real->bool u.
        open_in (subtopology euclidean u) s <=> ?t. open t /\ (s = u INTER t)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY, GSYM OPEN_IN] THEN
  SIMP_TAC std_ss [INTER_ACI]);

val OPEN_IN_INTER_OPEN = store_thm ("OPEN_IN_INTER_OPEN",
 ``!s t u:real->bool.
        open_in (subtopology euclidean u) s /\ open t
        ==> open_in (subtopology euclidean u) (s INTER t)``,
  SIMP_TAC std_ss [OPEN_IN_OPEN] THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[INTER_ASSOC, OPEN_INTER]);

val OPEN_IN_OPEN_INTER = store_thm ("OPEN_IN_OPEN_INTER",
 ``!u s. open s ==> open_in (subtopology euclidean u) (u INTER s)``,
  REWRITE_TAC[OPEN_IN_OPEN] THEN MESON_TAC[]);

val OPEN_OPEN_IN_TRANS = store_thm ("OPEN_OPEN_IN_TRANS",
 ``!s t. open s /\ open t /\ t SUBSET s
         ==> open_in (subtopology euclidean s) t``,
  MESON_TAC[OPEN_IN_OPEN_INTER, SET_RULE ``(t:real->bool) SUBSET s ==> (t = s INTER t)``]);

val OPEN_SUBSET = store_thm ("OPEN_SUBSET",
 ``!s t:real->bool.
        s SUBSET t /\ open s ==> open_in (subtopology euclidean t) s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[OPEN_IN_OPEN] THEN
  EXISTS_TAC ``s:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CLOSED_IN_CLOSED = store_thm ("CLOSED_IN_CLOSED",
 ``!s:real->bool u.
    closed_in (subtopology euclidean u) s <=> ?t. closed t /\ (s = u INTER t)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [CLOSED_IN_SUBTOPOLOGY, GSYM CLOSED_IN] THEN
  SIMP_TAC std_ss [INTER_ACI]);

val CLOSED_SUBSET_EQ = store_thm ("CLOSED_SUBSET_EQ",
 ``!u s:real->bool.
        closed s ==> (closed_in (subtopology euclidean u) s <=> s SUBSET u)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
    REWRITE_TAC[CLOSED_IN_CLOSED] THEN EXISTS_TAC ``s:real->bool`` THEN
    REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CLOSED_IN_INTER_CLOSED = store_thm ("CLOSED_IN_INTER_CLOSED",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\ closed t
        ==> closed_in (subtopology euclidean u) (s INTER t)``,
  SIMP_TAC std_ss [CLOSED_IN_CLOSED] THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[INTER_ASSOC, CLOSED_INTER]);

val CLOSED_IN_CLOSED_INTER = store_thm ("CLOSED_IN_CLOSED_INTER",
 ``!u s. closed s ==> closed_in (subtopology euclidean u) (u INTER s)``,
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN MESON_TAC[]);

val CLOSED_SUBSET = store_thm ("CLOSED_SUBSET",
 ``!s t:real->bool.
        s SUBSET t /\ closed s ==> closed_in (subtopology euclidean t) s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``s:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val OPEN_IN_SUBSET_TRANS = store_thm ("OPEN_IN_SUBSET_TRANS",
 ``!s t u:real->bool.
        open_in (subtopology euclidean u) s /\ s SUBSET t /\ t SUBSET u
        ==> open_in (subtopology euclidean t) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_EXISTS_AND_THM] THEN
  SET_TAC[]);

val CLOSED_IN_SUBSET_TRANS = store_thm ("CLOSED_IN_SUBSET_TRANS",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\ s SUBSET t /\ t SUBSET u
        ==> closed_in (subtopology euclidean t) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [CLOSED_IN_CLOSED] THEN
  REPEAT STRIP_TAC THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val open_in = store_thm ("open_in",
 ``!u s:real->bool.
        open_in (subtopology euclidean u) s <=>
          s SUBSET u /\
          !x. x IN s ==> ?e. &0 < e /\
                             !x'. x' IN u /\ dist(x',x) < e ==> x' IN s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY, GSYM OPEN_IN] THEN EQ_TAC THENL
   [REWRITE_TAC[open_def] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[INTER_SUBSET, IN_INTER],
    ALL_TAC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN DISCH_TAC THEN
  FULL_SIMP_TAC std_ss [GSYM RIGHT_EXISTS_IMP_THM] THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN DISCH_THEN(X_CHOOSE_TAC ``d:real->real``) THEN
  EXISTS_TAC ``BIGUNION {b | ?x:real. (b = ball(x,d x)) /\ x IN s}`` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC OPEN_BIGUNION THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN METIS_TAC [LEFT_EXISTS_IMP_THM, OPEN_BALL],
    GEN_REWR_TAC I [EXTENSION] THEN
    SIMP_TAC std_ss [IN_INTER, IN_BIGUNION, GSPECIFICATION] THEN
    ASM_MESON_TAC[SUBSET_DEF, DIST_REFL, DIST_SYM, IN_BALL]]);

val OPEN_IN_CONTAINS_BALL = store_thm ("OPEN_IN_CONTAINS_BALL",
 ``!s t:real->bool.
        open_in (subtopology euclidean t) s <=>
        s SUBSET t /\
        !x. x IN s ==> ?e. &0 < e /\ ball(x,e) INTER t SUBSET s``,
  SIMP_TAC std_ss [open_in, INTER_DEF, SUBSET_DEF, GSPECIFICATION, IN_BALL] THEN
  MESON_TAC[DIST_SYM]);

val OPEN_IN_CONTAINS_CBALL = store_thm ("OPEN_IN_CONTAINS_CBALL",
 ``!s t:real->bool.
        open_in (subtopology euclidean t) s <=>
        s SUBSET t /\
        !x. x IN s ==> ?e. &0 < e /\ cball(x,e) INTER t SUBSET s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_CONTAINS_BALL] THEN
  AP_TERM_TAC THEN REWRITE_TAC[IN_BALL, IN_INTER, SUBSET_DEF, IN_CBALL] THEN
  MESON_TAC[METIS [REAL_LT_HALF1, REAL_LT_HALF2, REAL_LET_TRANS]
    ``&0 < e:real ==> &0 < e / &2 /\ (x <= e / &2 ==> x < e)``,
            REAL_LT_IMP_LE]);

(* ------------------------------------------------------------------------- *)
(* These "transitivity" results are handy too.                               *)
(* ------------------------------------------------------------------------- *)

val OPEN_IN_TRANS = store_thm ("OPEN_IN_TRANS",
 ``!s t u. open_in (subtopology euclidean t) s /\
           open_in (subtopology euclidean u) t
           ==> open_in (subtopology euclidean u) s``,
  ASM_MESON_TAC[OPEN_IN_OPEN, OPEN_IN, OPEN_INTER, INTER_ASSOC]);

val OPEN_IN_TRANS_EQ = store_thm ("OPEN_IN_TRANS_EQ",
 ``!s t:real->bool.
        (!u. open_in (subtopology euclidean t) u
             ==> open_in (subtopology euclidean s) t)
        <=> open_in (subtopology euclidean s) t``,
  MESON_TAC[OPEN_IN_TRANS, OPEN_IN_REFL]);

val OPEN_IN_OPEN_TRANS = store_thm ("OPEN_IN_OPEN_TRANS",
 ``!s t. open_in (subtopology euclidean t) s /\ open t ==> open s``,
  REWRITE_TAC[ONCE_REWRITE_RULE[GSYM SUBTOPOLOGY_UNIV] OPEN_IN] THEN
  REWRITE_TAC[OPEN_IN_TRANS]);

val CLOSED_IN_TRANS = store_thm ("CLOSED_IN_TRANS",
 ``!s t u. closed_in (subtopology euclidean t) s /\
           closed_in (subtopology euclidean u) t
           ==> closed_in (subtopology euclidean u) s``,
  ASM_MESON_TAC[CLOSED_IN_CLOSED, CLOSED_IN, CLOSED_INTER, INTER_ASSOC]);

val CLOSED_IN_TRANS_EQ = store_thm ("CLOSED_IN_TRANS_EQ",
 ``!s t:real->bool.
        (!u. closed_in (subtopology euclidean t) u
             ==> closed_in (subtopology euclidean s) t)
        <=> closed_in (subtopology euclidean s) t``,
  MESON_TAC[CLOSED_IN_TRANS, CLOSED_IN_REFL]);

val CLOSED_IN_CLOSED_TRANS = store_thm ("CLOSED_IN_CLOSED_TRANS",
 ``!s t. closed_in (subtopology euclidean t) s /\ closed t ==> closed s``,
  REWRITE_TAC[ONCE_REWRITE_RULE[GSYM SUBTOPOLOGY_UNIV] CLOSED_IN] THEN
  REWRITE_TAC[CLOSED_IN_TRANS]);

val OPEN_IN_SUBTOPOLOGY_INTER_SUBSET = store_thm ("OPEN_IN_SUBTOPOLOGY_INTER_SUBSET",
 ``!s u v. open_in (subtopology euclidean u) (u INTER s) /\ v SUBSET u
           ==> open_in (subtopology euclidean v) (v INTER s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [OPEN_IN_OPEN, GSYM LEFT_EXISTS_AND_THM] THEN
  STRIP_TAC THEN EXISTS_TAC ``t:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val OPEN_IN_OPEN_EQ = store_thm ("OPEN_IN_OPEN_EQ",
 ``!s t. open s
         ==> (open_in (subtopology euclidean s) t <=> open t /\ t SUBSET s)``,
  MESON_TAC[OPEN_OPEN_IN_TRANS, OPEN_IN_OPEN_TRANS, open_in]);

val CLOSED_IN_CLOSED_EQ = store_thm ("CLOSED_IN_CLOSED_EQ",
 ``!s t. closed s
         ==> (closed_in (subtopology euclidean s) t <=>
              closed t /\ t SUBSET s)``,
  MESON_TAC[CLOSED_SUBSET, CLOSED_IN_CLOSED_TRANS, closed_in,
            TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]);

(* ------------------------------------------------------------------------- *)
(* Line segments, with open/closed overloading of (a,b) and [a,b].           *)
(* ------------------------------------------------------------------------- *)

val closed_segment = new_definition ("closed_segment",
  ``closed_segment (l:(real#real)list) =
   {((&1:real) - u) * FST(HD l) + u * SND(HD l) | &0 <= u /\ u <= &1}``);

val open_segment = new_definition ("open_segment",
 ``open_segment(a,b) = closed_segment[a,b] DIFF {a;b}``);

val OPEN_SEGMENT_ALT = store_thm ("OPEN_SEGMENT_ALT",
 ``!a b:real.
        ~(a = b)
        ==> (open_segment(a,b) = {(&1 - u) * a + u * b | &0 < u /\ u < &1:real})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[open_segment, closed_segment, FST, SND, HD] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_INSERT, NOT_IN_EMPTY, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
  AP_TERM_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM] THEN
  X_GEN_TAC ``u:real`` THEN ASM_CASES_TAC ``x:real = (&1 - u) * a + u * b`` THEN
  ASM_REWRITE_TAC[REAL_LE_LT,
    REAL_ARITH ``((&1 - u) * a + u * b = a) <=> (u * (b - a) = 0:real)``,
    REAL_ARITH ``((&1 - u) * a + u * b = b) <=> ((&1 - u) * (b - a) = 0:real)``,
    REAL_ENTIRE, REAL_SUB_0] THEN UNDISCH_TAC ``a <> b:real`` THEN DISCH_TAC THEN
        POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN DISCH_TAC THEN
        ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC);

val _ = overload_on ("segment", ``open_segment``);
val _ = overload_on ("segment", ``closed_segment``);

val segment = store_thm ("segment",
 ``(segment[a,b] = {(&1 - u) * a + u * b | &0 <= u /\ u <= &1:real}) /\
   (segment(a,b) = segment[a,b] DIFF {a;b:real})``,
  REWRITE_TAC[open_segment, closed_segment, HD]);

val SEGMENT_REFL = store_thm ("SEGMENT_REFL",
 ``(!a. segment[a,a] = {a}) /\
   (!a. segment(a,a) = {})``,
  REWRITE_TAC[segment, REAL_ARITH ``(&1 - u) * a + u * a = a:real``] THEN
  CONJ_TAC THENL [ALL_TAC, SET_TAC[REAL_POS]] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION] THEN REPEAT GEN_TAC THEN
  EQ_TAC THEN REWRITE_TAC [IN_SING] THENL [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN EXISTS_TAC ``1:real`` THEN REAL_ARITH_TAC);

val IN_SEGMENT = store_thm ("IN_SEGMENT",
 ``!a b x:real.
        ((x IN segment[a,b] <=>
         ?u. &0 <= u /\ u <= &1 /\ (x = (&1 - u) * a + u * b:real))) /\
        ((x IN segment(a,b) <=>
         ~(a = b) /\ ?u. &0 < u /\ u < &1 /\ (x = (&1 - u) * a + u * b:real)))``,
  REPEAT STRIP_TAC THENL
   [SIMP_TAC std_ss [segment, GSPECIFICATION, CONJ_ASSOC], ALL_TAC] THEN
  ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, NOT_IN_EMPTY] THEN
  ASM_SIMP_TAC std_ss [OPEN_SEGMENT_ALT, GSPECIFICATION, CONJ_ASSOC] THEN METIS_TAC []);

val SEGMENT_SYM = store_thm ("SEGMENT_SYM",
 ``(!a b:real. segment[a,b] = segment[b,a]) /\
   (!a b:real. segment(a,b) = segment(b,a))``,
  MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN
  SIMP_TAC std_ss [open_segment] THEN
  CONJ_TAC THENL [ALL_TAC, SIMP_TAC std_ss [INSERT_COMM, INSERT_INSERT]] THEN
  REWRITE_TAC[EXTENSION, IN_SEGMENT] THEN REPEAT GEN_TAC THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_TAC ``u:real``) THEN EXISTS_TAC ``&1 - u:real`` THEN
  ASM_REWRITE_TAC[] THEN
  REPEAT CONJ_TAC THEN TRY ASM_ARITH_TAC THEN ASM_REAL_ARITH_TAC);

val ENDS_IN_SEGMENT = store_thm ("ENDS_IN_SEGMENT",
 ``!a b. a IN segment[a,b] /\ b IN segment[a,b]``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [segment, GSPECIFICATION] THENL
   [EXISTS_TAC ``&0:real``, EXISTS_TAC ``&1:real``] THEN
  (CONJ_TAC THENL [REAL_ARITH_TAC, REAL_ARITH_TAC]));

val ENDS_NOT_IN_SEGMENT =  store_thm ("ENDS_NOT_IN_SEGMENT",
 ``!a b. ~(a IN segment(a,b)) /\ ~(b IN segment(a,b))``,
  REWRITE_TAC[open_segment] THEN SET_TAC[]);

val SEGMENT_CLOSED_OPEN = store_thm ("SEGMENT_CLOSED_OPEN",
 ``!a b. segment[a,b] = segment(a,b) UNION {a;b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_segment] THEN MATCH_MP_TAC(SET_RULE
   ``a IN s /\ b IN s ==> (s = (s DIFF {a;b}) UNION {a;b})``) THEN
  REWRITE_TAC[ENDS_IN_SEGMENT]);

val SEGMENT_OPEN_SUBSET_CLOSED = store_thm ("SEGMENT_OPEN_SUBSET_CLOSED",
 ``!a b. segment(a,b) SUBSET segment[a,b]``,
  REWRITE_TAC[CONJUNCT2(SPEC_ALL segment)] THEN SET_TAC[]);

val MIDPOINT_IN_SEGMENT = store_thm ("MIDPOINT_IN_SEGMENT",
 ``(!a b:real. midpoint(a,b) IN segment[a,b]) /\
   (!a b:real. midpoint(a,b) IN segment(a,b) <=> ~(a = b))``,
  REWRITE_TAC[IN_SEGMENT] THEN REPEAT STRIP_TAC THENL
   [ALL_TAC, ASM_CASES_TAC ``a:real = b`` THEN ASM_REWRITE_TAC[]] THEN
  EXISTS_TAC ``&1 / &2:real`` THEN REWRITE_TAC[midpoint] THEN
  REWRITE_TAC [REAL_HALF_BETWEEN] THEN
  REWRITE_TAC [METIS [REAL_HALF_DOUBLE, REAL_EQ_SUB_RADD]
   ``1 - 1 / 2 = 1 / 2:real``] THEN REWRITE_TAC [GSYM REAL_LDISTRIB] THEN
   REWRITE_TAC [REAL_INV_1OVER]);

val BETWEEN_IN_SEGMENT = store_thm ("BETWEEN_IN_SEGMENT",
 ``!x a b:real. between x (a,b) <=> x IN segment[a,b]``,
  REPEAT GEN_TAC THEN REWRITE_TAC[between] THEN
  ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, IN_SING] THENL
  [REWRITE_TAC [dist] THEN REAL_ARITH_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [segment, GSPECIFICATION] THEN EQ_TAC THENL
   [DISCH_THEN(ASSUME_TAC o SYM) THEN
    EXISTS_TAC ``dist(a:real,x) / dist(a,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ, DIST_POS_LT] THEN CONJ_TAC
    THENL [FIRST_ASSUM(SUBST1_TAC o SYM) THEN
    ASM_REWRITE_TAC [dist] THEN REWRITE_TAC [REAL_SUB_RDISTRIB, REAL_MUL_LID] THEN
        ONCE_REWRITE_TAC [REAL_ARITH ``(x = a - y + z) = (y - z = a - x:real)``] THEN
        REWRITE_TAC [GSYM REAL_SUB_LDISTRIB] THEN KNOW_TAC ``(a - b:real) <> 0`` THENL
        [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN ASM_SIMP_TAC std_ss [GSYM ABS_DIV] THEN
        Cases_on `0 < a - b:real` THENL
        [ASM_SIMP_TAC std_ss [GSYM REAL_EQ_RDIV_EQ] THEN REWRITE_TAC [ABS_REFL] THEN
         ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_MUL_LZERO] THEN
         FULL_SIMP_TAC std_ss [dist] THEN ASM_REAL_ARITH_TAC,
         FULL_SIMP_TAC std_ss [REAL_NOT_LT, REAL_LE_LT] THENL
         [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
         POP_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_LT_NEG] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-0 = 0:real) /\ (-(a - b) = (b - a:real))``] THEN
         DISCH_TAC THEN ONCE_REWRITE_TAC [REAL_ARITH ``((a - b) = -(b - a:real))``] THEN
         ONCE_ASM_REWRITE_TAC [REAL_ARITH ``a * -b = -a * b:real``] THEN
         ASM_SIMP_TAC std_ss [GSYM REAL_EQ_RDIV_EQ] THEN REWRITE_TAC [real_div] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-a * b = -(a * b:real))``] THEN
         REWRITE_TAC [REAL_EQ_NEG] THEN KNOW_TAC ``(b - a:real) <> 0`` THENL
         [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN ASM_SIMP_TAC std_ss [GSYM REAL_NEG_INV] THEN
         ONCE_REWRITE_TAC [REAL_ARITH ``(-(a * b) = (a * -b:real))``] THEN
         FULL_SIMP_TAC std_ss [REAL_NEG_NEG, dist] THEN
         REWRITE_TAC [ABS_REFL, GSYM real_div] THEN
         ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_MUL_LZERO] THEN
         ASM_REAL_ARITH_TAC], ALL_TAC] THEN FULL_SIMP_TAC std_ss [dist] THEN
         ASM_REAL_ARITH_TAC, ALL_TAC] THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[dist] THEN
    SIMP_TAC std_ss [REAL_ARITH ``a - ((&1 - u) * a + u * b) = u * (a - b:real)``,
                REAL_ARITH ``((&1 - u) * a + u * b) - b = (&1 - u) * (a - b:real)``,
                ABS_MUL, GSYM REAL_ADD_RDISTRIB] THEN
        FULL_SIMP_TAC std_ss [REAL_ARITH ``u <= 1 <=> 0 <= 1 - u:real``, GSYM ABS_REFL] THEN
        REAL_ARITH_TAC);

val REAL_CONVEX_BOUND_LE = store_thm ("REAL_CONVEX_BOUND_LE",
 ``!x y a u v. x <= a /\ y <= a /\ &0 <= u /\ &0 <= v /\ (u + v = &1:real)
   ==> u * x + v * y <= a:real``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``(u + v) * a:real`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SIMP_TAC std_ss [REAL_LE_REFL, REAL_MUL_LID]] THEN
  ASM_SIMP_TAC std_ss [REAL_ADD_RDISTRIB] THEN MATCH_MP_TAC REAL_LE_ADD2 THEN
  UNDISCH_TAC ``0 <= v:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN
  STRIP_TAC THEN UNDISCH_TAC ``0 <= u:real`` THEN
  GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN DISCH_TAC THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [REAL_LE_LT, REAL_MUL_LZERO]);

val IN_SEGMENT_COMPONENT = store_thm ("IN_SEGMENT_COMPONENT",
 ``!a b x:real i. x IN segment[a,b]
        ==> min (a) (b) <= x /\ x <= max (a) (b)``,
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IN_SEGMENT]) THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``t:real`` STRIP_ASSUME_TAC) THEN
  ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [REAL_ARITH ``c <= u * a + t * b <=> u * -a + t * -b <= -c:real``] THEN
  MATCH_MP_TAC REAL_CONVEX_BOUND_LE THEN
  RW_TAC real_ss [] THEN
  ASM_REAL_ARITH_TAC);

val SEGMENT_TRANSLATION = store_thm ("SEGMENT_TRANSLATION",
 ``(!c a b. segment[c + a,c + b] = IMAGE (\x. c + x) (segment[a,b])) /\
   (!c a b. segment(c + a,c + b) = IMAGE (\x. c + x) (segment(a,b)))``,
  SIMP_TAC std_ss [EXTENSION, IN_SEGMENT, IN_IMAGE] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(&1 - u) * (c + a) + u * (c + b) =
                            c + (&1 - u) * a + u * b:real``] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(c + a:real = c + b) <=> (a = b)``] THEN
  CONJ_TAC THEN
  (REPEAT GEN_TAC THEN EQ_TAC THENL
   [REPEAT STRIP_TAC THEN EXISTS_TAC ``(1 - u) * a + u * b:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_ADD_ASSOC] THEN EXISTS_TAC ``u:real`` THEN
        ASM_SIMP_TAC std_ss [],
        REPEAT STRIP_TAC THEN EXISTS_TAC ``u:real`` THEN
        ASM_SIMP_TAC std_ss [REAL_ADD_ASSOC]]));

val CLOSED_SEGMENT_LINEAR_IMAGE = store_thm ("CLOSED_SEGMENT_LINEAR_IMAGE",
 ``!f a b. linear f
           ==> (segment[f a,f b] = IMAGE f (segment[a,b]))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[EXTENSION, IN_IMAGE, IN_SEGMENT] THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_CMUL th)]) THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_ADD th)]) THEN
  MESON_TAC[]);

val OPEN_SEGMENT_LINEAR_IMAGE = store_thm ("OPEN_SEGMENT_LINEAR_IMAGE",
 ``!f:real->real a b.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (segment(f a,f b) = IMAGE f (segment(a,b)))``,
  REWRITE_TAC[open_segment, closed_segment, FST, SND, HD] THEN
  SIMP_TAC std_ss [linear, IN_IMAGE, dist, EXTENSION, GSPECIFICATION, IN_DIFF] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [EXISTS_TAC ``(1 - u) * a + u * b:real`` THEN
   CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
   CONJ_TAC THENL [EXISTS_TAC ``u:real`` THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
   ASM_SET_TAC [],
   CONJ_TAC THENL [EXISTS_TAC ``u:real`` THEN METIS_TAC [], ALL_TAC] THEN
   ASM_SET_TAC []]);

val IN_OPEN_SEGMENT = store_thm ("IN_OPEN_SEGMENT",
 ``!a b x:real.
        x IN segment(a,b) <=> x IN segment[a,b] /\ ~(x = a) /\ ~(x = b)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_segment, IN_DIFF] THEN SET_TAC[]);

val IN_OPEN_SEGMENT_ALT = store_thm ("IN_OPEN_SEGMENT_ALT",
 ``!a b x:real.
        x IN segment(a,b) <=>
        x IN segment[a,b] /\ ~(x = a) /\ ~(x = b) /\ ~(a = b)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = b`` THEN
  ASM_REWRITE_TAC[SEGMENT_REFL, IN_SING, NOT_IN_EMPTY] THEN
  ASM_MESON_TAC[IN_OPEN_SEGMENT]);

val COLLINEAR_DIST_IN_CLOSED_SEGMENT = store_thm ("COLLINEAR_DIST_IN_CLOSED_SEGMENT",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)
           ==> x IN segment[a,b]``,
  REWRITE_TAC[GSYM BETWEEN_IN_SEGMENT, COLLINEAR_DIST_BETWEEN]);

val COLLINEAR_DIST_IN_OPEN_SEGMENT = store_thm ("COLLINEAR_DIST_IN_OPEN_SEGMENT",
 ``!a b x. collinear {x;a;b} /\
           dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b)
           ==> x IN segment(a,b)``,
  REWRITE_TAC[IN_OPEN_SEGMENT] THEN
  METIS_TAC[COLLINEAR_DIST_IN_CLOSED_SEGMENT, REAL_LT_LE, DIST_SYM]);

val DIST_IN_OPEN_CLOSED_SEGMENT = store_thm ("DIST_IN_OPEN_CLOSED_SEGMENT",
 ``(!a b x:real.
    x IN segment[a,b] ==> dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b)) /\
   (!a b x:real.
    x IN segment(a,b) ==> dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b))``,
  SIMP_TAC std_ss [IN_SEGMENT, GSYM RIGHT_EXISTS_AND_THM, LEFT_IMP_EXISTS_THM, dist,
           REAL_ARITH
    ``(((&1 - u) * a + u * b) - a:real = u * (b - a)) /\
      (((&1 - u) * a + u * b) - b = -(&1 - u) * (b - a))``] THEN
  REWRITE_TAC[ABS_MUL, ABS_NEG] THEN ONCE_REWRITE_TAC [ABS_SUB] THEN CONJ_TAC THEN
  REPEAT GEN_TAC THEN STRIP_TAC THENL
   [ONCE_REWRITE_TAC [REAL_ARITH
     ``x * y <= abs (b - a) <=> x * y <= abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ARITH ``x * y <= y <=> x * y <= &1 * y:real``] THEN
    CONJ_TAC THEN MATCH_MP_TAC REAL_LE_RMUL_IMP THEN
    REWRITE_TAC[ABS_POS] THEN ASM_REAL_ARITH_TAC,
    ONCE_REWRITE_TAC [REAL_ARITH
     ``x * y < abs (b - a) <=> x * y < abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ARITH ``x * y < y <=> x * y < &1 * y:real``] THEN
    CONJ_TAC THEN MATCH_MP_TAC REAL_LT_RMUL_IMP THEN
    ASM_REAL_ARITH_TAC]);

val DIST_IN_CLOSED_SEGMENT = store_thm ("DIST_IN_CLOSED_SEGMENT",
  ``(!a b x:real.
    x IN segment[a,b] ==> dist(x,a) <= dist(a,b) /\ dist(x,b) <= dist(a,b))``,
  REWRITE_TAC [DIST_IN_OPEN_CLOSED_SEGMENT]);

val DIST_IN_OPEN_SEGMENT = store_thm ("DIST_IN_OPEN_SEGMENT",
  ``(!a b x:real.
    x IN segment(a,b) ==> dist(x,a) < dist(a,b) /\ dist(x,b) < dist(a,b))``,
  REWRITE_TAC [DIST_IN_OPEN_CLOSED_SEGMENT]);

(* ------------------------------------------------------------------------- *)
(* Connectedness.                                                            *)
(* ------------------------------------------------------------------------- *)

val connected = new_definition ("connected",
  ``connected s <=>
      ~(?e1 e2. open e1 /\ open e2 /\ s SUBSET (e1 UNION e2) /\
                (e1 INTER e2 INTER s = {}) /\
                ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))``);

val CONNECTED_CLOSED = store_thm ("CONNECTED_CLOSED",
 ``!s:real->bool.
        connected s <=>
        ~(?e1 e2. closed e1 /\ closed e2 /\ s SUBSET (e1 UNION e2) /\
                  (e1 INTER e2 INTER s = {}) /\
                  ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))``,
  GEN_TAC THEN REWRITE_TAC[connected] THEN AP_TERM_TAC THEN
  EQ_TAC THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC [``univ(:real) DIFF e1``, ``univ(:real) DIFF e2``] THEN
  ASM_REWRITE_TAC[GSYM closed_def, GSYM OPEN_CLOSED] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CONNECTED_OPEN_IN = store_thm ("CONNECTED_OPEN_IN",
 ``!s. connected s <=>
           ~(?e1 e2.
                 open_in (subtopology euclidean s) e1 /\
                 open_in (subtopology euclidean s) e2 /\
                 s SUBSET e1 UNION e2 /\
                 (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\
                 ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[connected, OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SET_TAC[]);

val CONNECTED_OPEN_IN_EQ = store_thm ("CONNECTED_OPEN_IN_EQ",
 ``!s. connected s <=>
           ~(?e1 e2.
                 open_in (subtopology euclidean s) e1 /\
                 open_in (subtopology euclidean s) e2 /\
                 (e1 UNION e2 = s) /\ (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\ ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_OPEN_IN] THEN
  AP_TERM_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[OPEN_IN_CLOSED_IN_EQ,
   TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]) THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CONNECTED_CLOSED_IN = store_thm ("CONNECTED_CLOSED_IN",
 ``!s. connected s <=>
           ~(?e1 e2.
                 closed_in (subtopology euclidean s) e1 /\
                 closed_in (subtopology euclidean s) e2 /\
                 s SUBSET e1 UNION e2 /\
                 (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\
                 ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_CLOSED, CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SET_TAC[]);

val CONNECTED_CLOSED_IN_EQ = store_thm ("CONNECTED_CLOSED_IN_EQ",
 ``!s. connected s <=>
           ~(?e1 e2.
                 closed_in (subtopology euclidean s) e1 /\
                 closed_in (subtopology euclidean s) e2 /\
                 (e1 UNION e2 = s) /\ (e1 INTER e2 = {}) /\
                 ~(e1 = {}) /\ ~(e2 = {}))``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_CLOSED_IN] THEN
  AP_TERM_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[SUBSET_REFL] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY]) THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val EXISTS_DIFF = store_thm ("EXISTS_DIFF",
 ``(?s:'a->bool. P(UNIV DIFF s)) <=> (?s. P s)``,
  MESON_TAC[prove(``UNIV DIFF (UNIV DIFF s) = s``,SET_TAC[])]);

val CONNECTED_CLOPEN = store_thm ("CONNECTED_CLOPEN",
 ``!s. connected s <=>
        !t. open_in (subtopology euclidean s) t /\
            closed_in (subtopology euclidean s) t ==> (t = {}) \/ (t = s)``,
  GEN_TAC THEN REWRITE_TAC[connected, OPEN_IN_OPEN, CLOSED_IN_CLOSED] THEN
  REWRITE_TAC [METIS [GSYM EXISTS_DIFF] ``!e1. (?e2. open e2) <=>
                              ?e2. open (univ(:real) DIFF e2)``] THEN
  KNOW_TAC ``(?e1 e2. open e1 /\ open e2 /\ s SUBSET e1 UNION e2 /\
        (e1 INTER e2 INTER s = {}) /\ e1 INTER s <> {} /\
        e2 INTER s <> {}) <=>
             (?e1 e2. open e1 /\ open (univ(:real) DIFF e2) /\
                    s SUBSET e1 UNION (univ(:real) DIFF e2) /\
        (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
        (univ(:real) DIFF e2) INTER s <> {})`` THENL
  [EQ_TAC THENL [STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
   ASM_SIMP_TAC std_ss [EXISTS_DIFF] THEN METIS_TAC [],
   METIS_TAC [GSYM EXISTS_DIFF]], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `(~a <=> b) <=> (a <=> ~b)`] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, GSYM CONJ_ASSOC, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c /\ d <=> b /\ a /\ c /\ d`] THEN
  KNOW_TAC ``(?t. (?t'. closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
             (?t t'. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [GSYM closed_def] THEN
  KNOW_TAC ``((?e1 e2. closed e2 /\ open e1 /\ s SUBSET e1 UNION (univ(:real) DIFF e2) /\
       (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
       (univ(:real) DIFF e2) INTER s <> {}) <=> ?t t'. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
            ((?e2 e1. closed e2 /\ open e1 /\ s SUBSET e1 UNION (univ(:real) DIFF e2) /\
       (e1 INTER (univ(:real) DIFF e2) INTER s = {}) /\ e1 INTER s <> {} /\
       (univ(:real) DIFF e2) INTER s <> {}) <=> ?t' t. (closed t' /\ (t = s INTER t')) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN AP_TERM_TAC THEN ABS_TAC THEN
  KNOW_TAC ``(?t. (closed e2 /\ (t = s INTER e2)) /\
      (?t'. open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s) <=>
             (?t' t.(closed e2 /\ (t = s INTER e2)) /\
      (open t' /\ (t = s INTER t')) /\ t <> {} /\ t <> s)`` THENL
  [METIS_TAC [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN AP_TERM_TAC THEN ABS_TAC THEN
  REWRITE_TAC[TAUT `(a /\ b) /\ (c /\ d) /\ e <=> a /\ c /\ b /\ d /\ e`] THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  AP_TERM_TAC THEN AP_TERM_TAC THEN SET_TAC[]);

val CONNECTED_CLOSED_SET = store_thm ("CONNECTED_CLOSED_SET",
 ``!s:real->bool.
        closed s
        ==> (connected s <=>
             ~(?e1 e2. closed e1 /\ closed e2 /\ ~(e1 = {}) /\ ~(e2 = {}) /\
                       (e1 UNION e2 = s) /\ (e1 INTER e2 = {})))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC [CONNECTED_CLOSED, GSYM MONO_NOT_EQ] THEN
    STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
    EXISTS_TAC ``e2:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    SIMP_TAC std_ss [] THEN SET_TAC[],
    REWRITE_TAC [CONNECTED_CLOSED_IN, GSYM MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [PULL_EXISTS] THEN
    SIMP_TAC std_ss [CLOSED_IN_CLOSED, LEFT_IMP_EXISTS_THM, GSYM AND_IMP_INTRO] THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s INTER u:real->bool``, ``s INTER v:real->bool``] THEN
    ASM_SIMP_TAC std_ss [CLOSED_INTER] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

val CONNECTED_OPEN_SET = store_thm ("CONNECTED_OPEN_SET",
 ``!s:real->bool.
        open s
        ==> (connected s <=>
             ~(?e1 e2. open e1 /\ open e2 /\ ~(e1 = {}) /\ ~(e2 = {}) /\
                       (e1 UNION e2 = s) /\ (e1 INTER e2 = {})))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[connected, GSYM MONO_NOT_EQ] THEN
    STRIP_TAC THEN EXISTS_TAC ``e1:real->bool`` THEN
    EXISTS_TAC ``e2:real->bool`` THEN REPEAT (POP_ASSUM MP_TAC) THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    SIMP_TAC std_ss [] THEN SET_TAC[],
    REWRITE_TAC [CONNECTED_OPEN_IN, GSYM MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [PULL_EXISTS] THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_IMP_EXISTS_THM, GSYM AND_IMP_INTRO] THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``s INTER u:real->bool``, ``s INTER v:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_INTER] THEN REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]]);

Theorem CONNECTED_IFF_CONNECTABLE_POINTS :
   !(s:real->bool).
        connected s <=>
        !a b. a IN s /\ b IN s
              ==> ?t. connected t /\ t SUBSET s /\ a IN t /\ b IN t
Proof
  GEN_TAC THEN EQ_TAC THENL [MESON_TAC[SUBSET_REFL], DISCH_TAC] THEN
  SIMP_TAC std_ss' [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
                    ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
                      ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))``] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``a:real``) (X_CHOOSE_TAC ``b:real``)) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``a:real``, ``b:real``]) THEN
  ASM_REWRITE_TAC[connected] THEN
  DISCH_THEN(CHOOSE_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC)) THEN
  REWRITE_TAC[] THEN
  MAP_EVERY EXISTS_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  ASM_SET_TAC[]
QED

val CONNECTED_EMPTY = store_thm ("CONNECTED_EMPTY",
 ``connected {}``,
  REWRITE_TAC[connected, INTER_EMPTY]);

val CONNECTED_SING = store_thm ("CONNECTED_SING",
 ``!a. connected{a}``,
  REWRITE_TAC[connected] THEN SET_TAC[]);

val CONNECTED_REAL_LEMMA = store_thm ("CONNECTED_REAL_LEMMA",
 ``!f:real->real a b e1 e2.
        a <= b /\ f(a) IN e1 /\ f(b) IN e2 /\
        (!e x. a <= x /\ x <= b /\ &0 < e
               ==> ?d. &0 < d /\
                       !y. abs(y - x) < d ==> dist(f(y),f(x)) < e) /\
        (!y. y IN e1 ==> ?e. &0 < e /\ !y'. dist(y',y) < e ==> y' IN e1) /\
        (!y. y IN e2 ==> ?e. &0 < e /\ !y'. dist(y',y) < e ==> y' IN e2) /\
        ~(?x. a <= x /\ x <= b /\ f(x) IN e1 /\ f(x) IN e2)
        ==> ?x. a <= x /\ x <= b /\ ~(f(x) IN e1) /\ ~(f(x) IN e2)``,
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``\c. !x:real. a <= x /\ x <= c ==> (f(x):real) IN e1``
              REAL_COMPLETE) THEN
  SIMP_TAC std_ss [] THEN
  KNOW_TAC ``(?x:real. !x'. a <= x' /\ x' <= x ==> (f x'):real IN e1) /\
     (?M. !x. (!x'. a <= x' /\ x' <= x ==> f x' IN e1) ==> x <= M)`` THENL
  [METIS_TAC[REAL_LT_IMP_LE, REAL_LE_TOTAL, REAL_LE_ANTISYM],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN ``a <= x /\ x <= b:real`` STRIP_ASSUME_TAC THENL
  [METIS_TAC[REAL_LT_IMP_LE, REAL_LE_TOTAL, REAL_LE_ANTISYM], ALL_TAC] THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN ``!z:real. a <= z /\ z < x ==> (f(z):real) IN e1`` ASSUME_TAC THENL
   [METIS_TAC[REAL_NOT_LT, REAL_LT_IMP_LE], ALL_TAC] THEN
  REPEAT STRIP_TAC THENL
   [SUBGOAL_THEN
     ``?d:real. &0 < d /\ !y. abs(y - x) < d ==> (f(y):real) IN e1``
    STRIP_ASSUME_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    METIS_TAC[REAL_ARITH ``z <= x + e /\ e < d ==> z < x \/ abs(z - x) < d:real``,
                  REAL_ARITH ``&0 < e ==> ~(x + e <= x:real)``, REAL_DOWN],
    SUBGOAL_THEN
     ``?d:real. &0 < d /\ !y. abs(y - x) < d ==> (f(y):real) IN e2``
    STRIP_ASSUME_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    MP_TAC(SPECL [``x - a:real``, ``d:real``] REAL_DOWN2) THEN
    KNOW_TAC ``0 < x - a:real /\ 0 < d:real`` THENL
     [METIS_TAC[REAL_LT_LE, REAL_SUB_LT], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    METIS_TAC[REAL_ARITH ``e < x - a ==> a <= x - e:real``,
                  REAL_ARITH ``&0 < e /\ x <= b ==> x - e <= b:real``,
      REAL_ARITH ``&0 < e /\ e < d ==> x - e < x /\ abs((x - e) - x) < d:real``]]);

Theorem CONNECTED_SEGMENT :
   (!a b:real. connected(segment[a,b])) /\
   (!a b:real. connected(segment(a,b)))
Proof
  CONJ_TAC THEN REPEAT GEN_TAC THENL
 [ (* goal 1 (of 2): connected(segment[a,b]) *)
  ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [SEGMENT_REFL, CONNECTED_EMPTY, CONNECTED_SING] THEN
  ASM_SIMP_TAC std_ss' [connected, OPEN_SEGMENT_ALT, CONJUNCT1 segment,
               NOT_EXISTS_THM] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
   ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
     ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))`` ] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  PURE_ONCE_REWRITE_TAC[INTER_COMM] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REWRITE_TAC [IN_INTER] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, LEFT_IMP_EXISTS_THM] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``e2:real->bool``, ``e1:real->bool``, ``v:real``, ``u:real``] THEN
  KNOW_TAC ``!(u :real) (v :real). (\u v. !(e1 :real -> bool) (e2 :real -> bool).
      (e1 INTER e2 INTER
       {((1 :real) - u) * (a :real) + u * (b :real) |
        (0 :real) <= u /\ u <= (1 :real)} =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b |
       (0 :real) <= u /\ u <= (1 :real)} SUBSET e1 UNION e2 /\
      (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) <= u /\ u <= (1 :real) /\
      ((1 :real) - u) * a + u * b IN e1 ==>
      ~((0 :real) <= v) \/ ~(v <= (1 :real)) \/
      ((1 :real) - v) * a + v * b NOTIN e2) u v`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN BETA_TAC THEN
    GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV)
        [UNION_COMM, INTER_COMM] THEN
   KNOW_TAC ``(!(e1 :real -> bool) (e2 :real -> bool).
       (e1 INTER e2 INTER
        {((1 :real) - u) * (a :real) + u * (b :real) |
         (0 :real) <= u /\ u <= (1 :real)} =
        ({} :real -> bool)) /\
       {((1 :real) - u) * a + u * b |
        (0 :real) <= u /\ u <= (1 :real)} SUBSET e1 UNION e2 /\
       (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
       (0 :real) <= (u :real) /\ u <= (1 :real) /\
       ((1 :real) - u) * a + u * b IN e1 ==>
       ~((0 :real) <= (v :real)) \/ ~(v <= (1 :real)) \/
       ((1 :real) - v) * a + v * b NOTIN e2) <=>
    !(e2 :real -> bool) (e1 :real -> bool).
      ({((1 :real) - u) * a + u * b |
        (0 :real) <= u /\ u <= (1 :real)} INTER (e1 INTER e2) =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b |
       (0 :real) <= u /\ u <= (1 :real)} SUBSET e2 UNION e1 /\
      (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) <= v /\ v <= (1 :real) /\
      ((1 :real) - v) * a + v * b IN e1 ==>
      ~((0 :real) <= u) \/ ~(u <= (1 :real)) \/
      ((1 :real) - u) * a + u * b NOTIN e2`` THENL
        [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    SIMP_TAC std_ss [UNION_ACI, INTER_ACI] THEN METIS_TAC[],
    ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL
   [``\u. (&1 - u) * a + u * b:real``, ``u:real``, ``v:real``,
    ``e1:real->bool``, ``e2:real->bool``]
    CONNECTED_REAL_LEMMA) THEN BETA_TAC THEN
  ASM_REWRITE_TAC [GSYM open_def, REAL_POS, NOT_IMP] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``e:real``, ``x:real``] THEN STRIP_TAC THEN
    EXISTS_TAC ``e / dist(a:real,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, GSYM DIST_NZ] THEN
    GEN_TAC THEN REWRITE_TAC[dist] THEN STRIP_TAC THEN
    ASM_SIMP_TAC std_ss [ABS_MUL, GSYM REAL_LT_RDIV_EQ, GSYM ABS_NZ, REAL_SUB_0,
                 ABS_NEG, REAL_ARITH
     ``((&1 - y') * a + y' * b) - ((&1 - x') * a + x' * b):real =
       -((y' - x') * (a - b))``],
    RULE_ASSUM_TAC(SIMP_RULE std_ss [EXTENSION, IN_INTER, GSPECIFICATION,
                                SUBSET_DEF, IN_UNION, NOT_IN_EMPTY]) THEN
    METIS_TAC[REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]],

  (* goal 2 (of 2): connected(segment(a,b)) *)
  ASM_CASES_TAC ``b:real = a`` THEN
  ASM_SIMP_TAC std_ss [SEGMENT_REFL, CONNECTED_EMPTY, CONNECTED_SING] THEN
  ASM_SIMP_TAC std_ss' [connected, OPEN_SEGMENT_ALT, CONJUNCT1 segment,
               NOT_EXISTS_THM] THEN
  REWRITE_TAC [METIS [DE_MORGAN_THM]
   ``~a \/ ~b \/ ~c \/ (d <> e) \/ (f = g) \/ (h = i) <=>
     ~(a /\ b /\ c /\ (d = e) /\ (f <> g) /\ (h <> i))`` ] THEN
  MAP_EVERY X_GEN_TAC [``e1:real->bool``, ``e2:real->bool``] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  PURE_ONCE_REWRITE_TAC[INTER_COMM] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REWRITE_TAC [IN_INTER] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [EXISTS_IN_GSPEC]) THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, LEFT_IMP_EXISTS_THM] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``e2:real->bool``, ``e1:real->bool``, ``v:real``, ``u:real``] THEN
  KNOW_TAC ``!(u :real) (v :real). (\u v. !(e1 :real -> bool) (e2 :real -> bool).
      (e1 INTER e2 INTER
       {((1 :real) - u) * (a :real) + u * (b :real) |
        (0 :real) < u /\ u < (1 :real)} =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
      e1 UNION e2 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) < u /\ u < (1 :real) /\
      ((1 :real) - u) * a + u * b IN e1 ==>
      ~((0 :real) < v) \/ ~(v < (1 :real)) \/
      ((1 :real) - v) * a + v * b NOTIN e2) u v`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC REAL_WLOG_LE THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN BETA_TAC THEN
    GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV)
        [UNION_COMM, INTER_COMM] THEN
   KNOW_TAC `` (!(e1 :real -> bool) (e2 :real -> bool).
       (e1 INTER e2 INTER
        {((1 :real) - u) * (a :real) + u * (b :real) |
         (0 :real) < u /\ u < (1 :real)} =
        ({} :real -> bool)) /\
       {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
       e1 UNION e2 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
       (0 :real) < (u :real) /\ u < (1 :real) /\
       ((1 :real) - u) * a + u * b IN e1 ==>
       ~((0 :real) < (v :real)) \/ ~(v < (1 :real)) \/
       ((1 :real) - v) * a + v * b NOTIN e2) <=>
    !(e2 :real -> bool) (e1 :real -> bool).
      ({((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} INTER
       (e1 INTER e2) =
       ({} :real -> bool)) /\
      {((1 :real) - u) * a + u * b | (0 :real) < u /\ u < (1 :real)} SUBSET
      e2 UNION e1 /\ (open e2 :bool) /\ (open e1 :bool) /\ b <> a ==>
      (0 :real) < v /\ v < (1 :real) /\
      ((1 :real) - v) * a + v * b IN e1 ==>
      ~((0 :real) < u) \/ ~(u < (1 :real)) \/
      ((1 :real) - u) * a + u * b NOTIN e2`` THENL
        [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    SIMP_TAC std_ss [UNION_ACI, INTER_ACI] THEN METIS_TAC[],
    ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL
   [``\u. (&1 - u) * a + u * b:real``, ``u:real``, ``v:real``,
    ``e1:real->bool``, ``e2:real->bool``]
    CONNECTED_REAL_LEMMA) THEN BETA_TAC THEN
  ASM_REWRITE_TAC [GSYM open_def, REAL_POS, NOT_IMP] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [MAP_EVERY X_GEN_TAC [``e:real``, ``x:real``] THEN STRIP_TAC THEN
    EXISTS_TAC ``e / dist(a:real,b)`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, GSYM DIST_NZ] THEN
    GEN_TAC THEN REWRITE_TAC[dist] THEN STRIP_TAC THEN
    ASM_SIMP_TAC std_ss [ABS_MUL, GSYM REAL_LT_RDIV_EQ, GSYM ABS_NZ, REAL_SUB_0,
                 ABS_NEG, REAL_ARITH
     ``((&1 - y') * a + y' * b) - ((&1 - x') * a + x' * b):real =
       -((y' - x') * (a - b))``],
    RULE_ASSUM_TAC(SIMP_RULE std_ss [EXTENSION, IN_INTER, GSPECIFICATION,
                                SUBSET_DEF, IN_UNION, NOT_IN_EMPTY]) THEN
    METIS_TAC[REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]] ]
QED

val CONNECTED_UNIV = store_thm ("CONNECTED_UNIV",
 ``connected univ(:real)``,
  ONCE_REWRITE_TAC[CONNECTED_IFF_CONNECTABLE_POINTS] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN
  REWRITE_TAC[IN_UNIV, SUBSET_UNIV] THEN
  EXISTS_TAC ``segment[a:real,b]`` THEN
  ASM_SIMP_TAC std_ss [CONNECTED_SEGMENT, ENDS_IN_SEGMENT]);

val CLOPEN = store_thm ("CLOPEN",
 ``!s. closed s /\ open s <=> (s = {}) \/ (s = univ(:real))``,
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY, OPEN_EMPTY, CLOSED_UNIV, OPEN_UNIV] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONNECTED_CLOPEN] CONNECTED_UNIV) THEN
  ASM_REWRITE_TAC[SUBTOPOLOGY_UNIV, GSYM OPEN_IN, GSYM CLOSED_IN]);

val CONNECTED_BIGUNION = store_thm ("CONNECTED_BIGUNION",
 ``!P:(real->bool)->bool.
        (!s. s IN P ==> connected s) /\ ~(BIGINTER P = {})
        ==> connected(BIGUNION P)``,
  GEN_TAC THEN REWRITE_TAC[connected] THEN STRIP_TAC THEN
  CCONTR_TAC THEN POP_ASSUM (MP_TAC o REWRITE_RULE [REAL_NEG_NEG]) THEN
  STRIP_TAC THEN UNDISCH_TAC ``~(BIGINTER P :real->bool = {})`` THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_BIGINTER] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``(a:real) IN e1 \/ a IN e2`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[],
    UNDISCH_TAC ``~(e2 INTER BIGUNION P:real->bool = {})``,
    UNDISCH_TAC ``~(e1 INTER BIGUNION P:real->bool = {})``] THEN
  PURE_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER, IN_BIGUNION] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real``
   (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!t:real->bool. t IN P ==> a IN t`` THEN
  DISCH_THEN(MP_TAC o SPEC ``s:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``s:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM (MP_TAC o SPECL [``e1:real->bool``, ``e2:real->bool``]) THEN
  ASM_SET_TAC[]);

val CONNECTED_UNION = store_thm ("CONNECTED_UNION",
 ``!s t:real->bool.
        connected s /\ connected t /\ ~(s INTER t = {})
        ==> connected (s UNION t)``,
  REWRITE_TAC[GSYM BIGUNION_2, GSYM BIGINTER_2] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN
  ASM_SET_TAC[]);

val CONNECTED_DIFF_OPEN_FROM_CLOSED = store_thm ("CONNECTED_DIFF_OPEN_FROM_CLOSED",
 ``!s t u:real->bool.
        s SUBSET t /\ t SUBSET u /\
        open s /\ closed t /\ connected u /\ connected(t DIFF s)
        ==> connected(u DIFF s)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``v:real->bool``, ``w:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``connected(t DIFF s:real->bool)`` THEN SIMP_TAC std_ss [connected] THEN
  MAP_EVERY EXISTS_TAC [``v:real->bool``, ``w:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC  THENL [ASM_SET_TAC [], ALL_TAC] THEN
  CONJ_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t)) [``v:real->bool``, ``w:real->bool``] THEN
  KNOW_TAC ``(!v:real->bool w:real->bool.
      ~(w INTER (u DIFF s) = {}) /\ ~(v INTER (u DIFF s) = {}) /\
      (v INTER w INTER (u DIFF s) = {}) /\ u DIFF s SUBSET v UNION w /\
      open w /\ open v /\ connected u /\ closed t /\ open s /\
      t SUBSET u /\ s SUBSET t
      ==> ~(v INTER (u DIFF s) = {}) /\ ~(w INTER (u DIFF s) = {}) /\
          (w INTER v INTER (u DIFF s) = {}) /\ u DIFF s SUBSET w UNION v /\
          open v /\ open w /\ connected u /\ closed t /\ open s /\
          t SUBSET u /\ s SUBSET t) /\
 (!w v. (~(w INTER (u DIFF s) = {}) /\ ~(v INTER (u DIFF s) = {}) /\
       (v INTER w INTER (u DIFF s) = {}) /\ u DIFF s SUBSET v UNION w /\
       open w /\ open v /\ connected u /\ closed t /\ open s /\
       t SUBSET u /\ s SUBSET t) /\ (w INTER (t DIFF s) = {})
      ==> F)`` THENL
  [CONJ_TAC THENL [SIMP_TAC std_ss [CONJ_ACI, INTER_ACI, UNION_ACI], ALL_TAC] THEN
  REPEAT STRIP_TAC THEN UNDISCH_TAC ``connected u`` THEN
  GEN_REWR_TAC LAND_CONV [connected] THEN SIMP_TAC std_ss [] THEN
  MAP_EVERY EXISTS_TAC [``v UNION s:real->bool``, ``w DIFF t:real->bool``] THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION, OPEN_DIFF] THEN ASM_SET_TAC[], METIS_TAC []]);

val CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE = store_thm
  ("CONNECTED_DISJOINT_BIGUNION_OPEN_UNIQUE",
 ``!f:(real->bool)->bool f'.
         pairwise DISJOINT f /\ pairwise DISJOINT f' /\
        (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
        (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
        (BIGUNION f = BIGUNION f')
        ==> (f = f')``,
  GEN_REWR_TAC (funpow 2 BINDER_CONV o RAND_CONV) [EXTENSION] THEN
  KNOW_TAC ``(!f f'.
      pairwise DISJOINT f /\ pairwise DISJOINT f' /\
      (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
      (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
      (BIGUNION f = BIGUNION f')
      ==> pairwise DISJOINT f' /\ pairwise DISJOINT f /\
          (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
          (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
          (BIGUNION f' = BIGUNION f)) /\
 (!f f' x. (pairwise DISJOINT f /\ pairwise DISJOINT f' /\
       (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
       (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
       (BIGUNION f = BIGUNION f')) /\ x IN f ==> x IN f')`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  GEN_TAC THEN GEN_TAC THEN X_GEN_TAC ``s:real->bool`` THEN STRIP_TAC THEN
  SUBGOAL_THEN
   ``?t a:real. t IN f' /\ a IN s /\ a IN t`` STRIP_ASSUME_TAC
  THENL [ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``s:real->bool = t`` (fn th => ASM_REWRITE_TAC[th]) THEN
  REWRITE_TAC[EXTENSION] THEN POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
  MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``s:real->bool``, ``t:real->bool``,
    ``f:(real->bool)->bool``, ``f':(real->bool)->bool``] THEN
  KNOW_TAC ``(!f f' s t.
      a IN t /\ a IN s /\ t IN f' /\ s IN f /\
      (BIGUNION f = BIGUNION f') /\
      (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
      (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
      pairwise DISJOINT f' /\ pairwise DISJOINT f
      ==> a IN s /\ a IN t /\ s IN f /\ t IN f' /\
          (BIGUNION f' = BIGUNION f) /\
          (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
          (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
          pairwise DISJOINT f /\ pairwise DISJOINT f') /\
 (!f f' s t x.
      (a IN t /\ a IN s /\ t IN f' /\ s IN f /\
       (BIGUNION f = BIGUNION f') /\
       (!s. s IN f' ==> open s /\ connected s /\ ~(s = {})) /\
       (!s. s IN f ==> open s /\ connected s /\ ~(s = {})) /\
       pairwise DISJOINT f' /\ pairwise DISJOINT f) /\
      x IN s ==> x IN t)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN
  X_GEN_TAC ``b:real`` THEN STRIP_TAC THEN
  UNDISCH_TAC
   ``!s:real->bool. s IN f ==> open s /\ connected s /\ ~(s = {})`` THEN
  DISCH_THEN(MP_TAC o SPEC ``s:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN ASM_CASES_TAC ``(b:real) IN t`` THEN
  ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``connected(s:real->bool)`` THEN
  REWRITE_TAC[connected] THEN
  MAP_EVERY EXISTS_TAC
   [``t:real->bool``, ``BIGUNION(f' DELETE (t:real->bool))``] THEN
  REPEAT STRIP_TAC THENL
   [ASM_SIMP_TAC std_ss [],
    MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SIMP_TAC std_ss [IN_DELETE],
    REWRITE_TAC[GSYM BIGUNION_INSERT] THEN ASM_SET_TAC[],
    MATCH_MP_TAC(SET_RULE ``(t INTER u = {}) ==> (t INTER u INTER s = {})``) THEN
    SIMP_TAC std_ss [INTER_BIGUNION, EMPTY_BIGUNION, FORALL_IN_GSPEC] THEN
    REWRITE_TAC [IN_DELETE, GSYM DISJOINT_DEF] THEN ASM_MESON_TAC[pairwise],
    ASM_SET_TAC[], ASM_SET_TAC[]]);

val CONNECTED_FROM_CLOSED_UNION_AND_INTER = store_thm ("CONNECTED_FROM_CLOSED_UNION_AND_INTER",
 ``!s t:real->bool.
        closed s /\ closed t /\ connected(s UNION t) /\ connected(s INTER t)
        ==> connected s /\ connected t``,
  KNOW_TAC ``(!s t. closed s /\ closed t /\
       connected (s UNION t) /\ connected (s INTER t)
      ==> closed t /\ closed s /\ connected (t UNION s) /\
          connected (t INTER s)) /\
 (!s t. closed s /\ closed t /\ connected (s UNION t) /\
        connected (s INTER t) ==> connected s)`` THENL
  [ALL_TAC, MESON_TAC []] THEN
  CONJ_TAC THENL [SIMP_TAC std_ss [UNION_COMM, INTER_COMM], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_CLOSED_SET] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  ASM_CASES_TAC
   ``~(s INTER t SUBSET (u:real->bool)) /\ ~(s INTER t SUBSET v)``
  THENL
   [UNDISCH_TAC ``connected(s INTER t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CLOSED] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC [],
    POP_ASSUM (MP_TAC o REWRITE_RULE [DE_MORGAN_THM]) THEN
    STRIP_TAC THEN UNDISCH_TAC ``connected(s UNION t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CLOSED] THENL
     [MAP_EVERY EXISTS_TAC [``t UNION u:real->bool``, ``v:real->bool``] THEN
      ASM_SIMP_TAC std_ss [CLOSED_UNION] THEN ASM_SET_TAC[],
      MAP_EVERY EXISTS_TAC [``t UNION v:real->bool``, ``u:real->bool``] THEN
      ASM_SIMP_TAC std_ss [CLOSED_UNION] THEN ASM_SET_TAC[]]]);

val CONNECTED_FROM_OPEN_UNION_AND_INTER = store_thm ("CONNECTED_FROM_OPEN_UNION_AND_INTER",
 ``!s t:real->bool.
        open s /\ open t /\ connected(s UNION t) /\ connected(s INTER t)
        ==> connected s /\ connected t``,

  KNOW_TAC ``(!s t.
      open s /\ open t /\ connected (s UNION t) /\ connected (s INTER t)
      ==> open t /\ open s /\ connected (t UNION s) /\ connected (t INTER s)) /\
 (!s t.
      open s /\ open t /\ connected (s UNION t) /\ connected (s INTER t)
      ==> connected s)`` THENL
  [ALL_TAC, MESON_TAC []] THEN
  CONJ_TAC THENL [SIMP_TAC std_ss [UNION_COMM, INTER_COMM], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_OPEN_SET] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN ASM_CASES_TAC
   ``~(s INTER t SUBSET (u:real->bool)) /\ ~(s INTER t SUBSET v)``
  THENL
   [UNDISCH_TAC ``connected(s INTER t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [connected] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
    POP_ASSUM (MP_TAC o REWRITE_RULE [DE_MORGAN_THM]) THEN
    STRIP_TAC THEN UNDISCH_TAC ``connected(s UNION t:real->bool)`` THEN
    ASM_SIMP_TAC std_ss [connected] THENL
     [MAP_EVERY EXISTS_TAC [``t UNION u:real->bool``, ``v:real->bool``] THEN
      ASM_SIMP_TAC std_ss [OPEN_UNION] THEN ASM_SET_TAC[],
      MAP_EVERY EXISTS_TAC [``t UNION v:real->bool``, ``u:real->bool``] THEN
      ASM_SIMP_TAC std_ss [OPEN_UNION] THEN ASM_SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Sort of induction principle for connected sets.                           *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_INDUCTION = store_thm ("CONNECTED_INDUCTION",
 ``!P Q s:real->bool. connected s /\
     (!t a. open_in (subtopology euclidean s) t /\ a IN t
     ==> ?z. z IN t /\ P z) /\ (!a. a IN s
       ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
       !x y. x IN t /\ y IN t /\ P x /\ P y /\ Q x ==> Q y)
          ==> !a b. a IN s /\ b IN s /\ P a /\ P b /\ Q a ==> Q b``,
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC I [TAUT `p <=> ~ ~p`] THEN DISCH_TAC THEN
  UNDISCH_TAC ``connected s`` THEN GEN_REWR_TAC LAND_CONV [CONNECTED_OPEN_IN] THEN
  REWRITE_TAC[] THEN MAP_EVERY EXISTS_TAC
  [``{b:real | ?t. open_in (subtopology euclidean s) t /\
                   b IN t /\ !x. x IN t /\ P x ==> Q x}``,
   ``{b:real | ?t. open_in (subtopology euclidean s) t /\
                 b IN t /\ !x. x IN t /\ P x ==> ~(Q x)}``]   THEN
  REPEAT CONJ_TAC THENL
  [ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
   X_GEN_TAC ``c:real`` THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
   ASM_SET_TAC[],
   ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
   X_GEN_TAC ``c:real`` THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNION] THEN
   X_GEN_TAC ``c:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``c:real``) THEN ASM_SET_TAC[],
   KNOW_TAC ``!x. ~((?t. open_in (subtopology euclidean s) t /\
            x IN t /\ (!x. x IN t /\ P x ==> Q x)) /\
       (?t. open_in (subtopology euclidean s) t /\ x IN t /\
            (!x. x IN t /\ P x ==> ~Q x)))`` THENL
   [ALL_TAC, SIMP_TAC std_ss [EXTENSION, IN_INTER, NOT_IN_EMPTY, GSPECIFICATION]] THEN
   X_GEN_TAC ``c:real`` THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC)) THEN
   FIRST_X_ASSUM(MP_TAC o SPECL [``t INTER u:real->bool``, ``c:real``]) THEN
   ASM_SIMP_TAC std_ss [OPEN_IN_INTER] THEN ASM_SET_TAC[],
   ASM_SET_TAC[], ASM_SET_TAC[]]);

val CONNECTED_EQUIVALENCE_RELATION_GEN = store_thm ("CONNECTED_EQUIVALENCE_RELATION_GEN",
 ``!P R s:real->bool. connected s /\ (!x y. R x y ==> R y x) /\
     (!x y z. R x y /\ R y z ==> R x z) /\
     (!t a. open_in (subtopology euclidean s) t /\ a IN t
    ==> ?z. z IN t /\ P z) /\ (!a. a IN s
      ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x y. x IN t /\ y IN t /\ P x /\ P y ==> R x y)
        ==> !a b. a IN s /\ b IN s /\ P a /\ P b ==> R a b``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN
  ``!a:real. a IN s /\ P a
  ==> !b c. b IN s /\ c IN s /\ P b /\ P c /\ R a b ==> R a c``
  MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[]] THEN
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC CONNECTED_INDUCTION THEN
  ASM_REWRITE_TAC [] THEN
  X_GEN_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `b:real`) THEN
  METIS_TAC[]);

val CONNECTED_INDUCTION_SIMPLE = store_thm ("CONNECTED_INDUCTION_SIMPLE",
 ``!P s:real->bool. connected s /\
    (!a. a IN s
    ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x y. x IN t /\ y IN t /\ P x ==> P y)
      ==> !a b. a IN s /\ b IN s /\ P a ==> P b``,
  MP_TAC(ISPEC ``\x:real. T`` CONNECTED_INDUCTION) THEN
  REWRITE_TAC[] THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``Q:real->bool``, ``s:real->bool``] THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`Q:real->bool`, `s:real->bool`]) THEN
  METIS_TAC[]);

val CONNECTED_EQUIVALENCE_RELATION = store_thm ("CONNECTED_EQUIVALENCE_RELATION",
 ``!R s:real->bool. connected s /\
     (!x y. R x y ==> R y x) /\
     (!x y z. R x y /\ R y z ==> R x z) /\
     (!a. a IN s
     ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
      !x. x IN t ==> R a x)
      ==> !a b. a IN s /\ b IN s ==> R a b``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN
  ``!a:real. a IN s ==> !b c. b IN s /\ c IN s /\ R a b ==> R a c``
  MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[]] THEN
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC CONNECTED_INDUCTION_SIMPLE THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Limit points.                                                             *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "limit_point_of" (Infix(NONASSOC, 450));

(* ‘limpt’ is defined in topologyTheory *)
Definition limit_point_of_def :
    x limit_point_of s <=> limpt(euclidean) x s
End

Theorem limit_point_of :
    !x s. x limit_point_of s <=>
          !t. x IN t /\ Open t ==> ?y. ~(y = x) /\ y IN s /\ y IN t
Proof
    rw [limit_point_of_def, limpt, neigh, TOPSPACE_EUCLIDEAN, GSYM OPEN_IN, IN_APP]
 >> EQ_TAC >> rw []
 >- (Q.PAT_X_ASSUM ‘!N. _ ==> ?y. x <> y /\ s y /\ N y’ (MP_TAC o (Q.SPEC ‘t’)) \\
     Know ‘?P. Open P /\ P SUBSET t /\ P x’
     >- (Q.EXISTS_TAC ‘t’ >> rw []) >> rw [] \\
     Q.EXISTS_TAC ‘y’ >> rw [])
 >> Q.PAT_X_ASSUM ‘!t. t x /\ Open t ==> _’ (MP_TAC o (Q.SPEC ‘P’))
 >> rw []
 >> Q.EXISTS_TAC ‘y’ >> fs [SUBSET_DEF, IN_APP]
QED

val LIMPT_SUBSET = store_thm ("LIMPT_SUBSET",
 ``!x s t. x limit_point_of s /\ s SUBSET t ==> x limit_point_of t``,
  REWRITE_TAC[limit_point_of, SUBSET_DEF] THEN MESON_TAC[]);

val LIMPT_APPROACHABLE = store_thm ("LIMPT_APPROACHABLE",
 ``!x s. x limit_point_of s <=>
                !e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ dist(x',x) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[limit_point_of] THEN
  MESON_TAC[open_def, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL, IN_BALL]);

val lemma = prove (
 ``&0 < d:real ==> x <= d / &2 ==> x < d``,
 SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LT] THEN REAL_ARITH_TAC);

val APPROACHABLE_LT_LE = store_thm ("APPROACHABLE_LT_LE",
 ``!P f. (?d:real. &0 < d /\ !x. f(x) < d ==> P x) =
         (?d:real. &0 < d /\ !x. f(x) <= d ==> P x)``,
  MESON_TAC[REAL_LT_IMP_LE, lemma, REAL_LT_HALF1]);

val LIMPT_APPROACHABLE_LE = store_thm ("LIMPT_APPROACHABLE_LE",
 ``!x s. x limit_point_of s <=>
                !e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ dist(x',x) <= e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  MATCH_MP_TAC(TAUT `(~a <=> ~b) ==> (a <=> b)`) THEN
  KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e) <=>
            (\e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e)) e`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) <= e) <=>
            (\e. (0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) <= e)) e `` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [NOT_FORALL_THM] THEN BETA_TAC THEN REWRITE_TAC [NOT_IMP] THEN
  KNOW_TAC ``!x'' x'. ( x'' IN s /\ x'' <> x /\ dist (x'',x) < x') <=>
            (\x''. x'' IN s /\ x'' <> x /\ dist (x'',x) < x') x''`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!x'' x'. ( x'' IN s /\ x'' <> x /\ dist (x'',x) <= x') <=>
            (\x''. x'' IN s /\ x'' <> x /\ dist (x'',x) <= x') x''`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  REWRITE_TAC [NOT_EXISTS_THM] THEN BETA_TAC THEN
  SIMP_TAC std_ss [TAUT `~(a /\ b /\ c) <=> c ==> ~(a /\ b)`, APPROACHABLE_LT_LE]);

val REAL_CHOOSE_SIZE = store_thm ("REAL_CHOOSE_SIZE",
 ``!c. &0 <= c ==> (?x. abs x = c:real)``,
  METIS_TAC [ABS_REFL]);

val LIMPT_UNIV = store_thm ("LIMPT_UNIV",
 ``!x:real. x limit_point_of UNIV``,
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNIV] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?c:real. abs(c) = e / &2`` CHOOSE_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_CHOOSE_SIZE, REAL_LT_HALF1, REAL_LT_IMP_LE],
    ALL_TAC] THEN
  EXISTS_TAC ``x + c:real`` THEN
  REWRITE_TAC[dist, REAL_ADD_RID_UNIQ] THEN ASM_REWRITE_TAC[REAL_ADD_SUB] THEN
  ASM_REWRITE_TAC [REAL_LT_HALF2] THEN KNOW_TAC ``0 < abs c:real`` THENL
  [ASM_SIMP_TAC std_ss [REAL_LT_HALF1], METIS_TAC [ABS_NZ]]);

val CLOSED_LIMPT = store_thm ("CLOSED_LIMPT",
 ``!s. closed s <=> !x. x limit_point_of s ==> x IN s``,
  REWRITE_TAC[closed_def] THEN ONCE_REWRITE_TAC[OPEN_SUB_OPEN] THEN
  REWRITE_TAC[limit_point_of, IN_DIFF, IN_UNIV, SUBSET_DEF] THEN MESON_TAC[]);

val LIMPT_EMPTY = store_thm ("LIMPT_EMPTY",
 ``!x. ~(x limit_point_of {})``,
  REWRITE_TAC[LIMPT_APPROACHABLE, NOT_IN_EMPTY] THEN MESON_TAC[REAL_LT_01]);

val NO_LIMIT_POINT_IMP_CLOSED = store_thm ("NO_LIMIT_POINT_IMP_CLOSED",
 ``!s. ~(?x. x limit_point_of s) ==> closed s``,
  MESON_TAC[CLOSED_LIMPT]);

val CLOSED_POSITIVE_ORTHANT = store_thm ("CLOSED_POSITIVE_ORTHANT",
 ``closed {x:real | &0 <= x}``,
  REWRITE_TAC[CLOSED_LIMPT, LIMPT_APPROACHABLE] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``-(x:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RNEG, REAL_ADD_LID, NOT_EXISTS_THM] THEN
  X_GEN_TAC ``y:real`` THEN ONCE_REWRITE_TAC [METIS []``(a = b) <=> ~(a <> b:real)``] THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM] THEN
  MATCH_MP_TAC(TAUT `(a ==> ~c) ==> ~(a /\ b /\ c)`) THEN DISCH_TAC THEN
  MATCH_MP_TAC(REAL_ARITH ``!b. abs x <= b /\ b <= a ==> ~(a + x < &0:real)``) THEN
  EXISTS_TAC ``abs(y - x :real)`` THEN ASM_SIMP_TAC std_ss [dist, REAL_LE_REFL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``x < &0 /\ &0 <= y:real ==> abs(x) <= abs(y - x)``]);

val FINITE_SET_AVOID = store_thm ("FINITE_SET_AVOID",
 ``!a:real s. FINITE s
   ==> ?d. &0 < d /\ !x. x IN s /\ ~(x = a) ==> d <= dist(a,x)``,
  GEN_TAC THEN
  KNOW_TAC ``!s. (?d. 0 < d /\ !x:real. x IN s /\ x <> a ==> d <= dist (a,x)) <=>
             (\s. ?d. 0 < d /\ !x:real. x IN s /\ x <> a ==> d <= dist (a,x)) s `` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[NOT_IN_EMPTY] THEN
  CONJ_TAC THENL [MESON_TAC[REAL_LT_01], ALL_TAC] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``x:real``] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN DISCH_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``x:real = a`` THEN REWRITE_TAC[IN_INSERT] THENL
  [ASM_MESON_TAC[], ALL_TAC] THEN
  EXISTS_TAC ``min d (dist(a:real,x))`` THEN
  ASM_REWRITE_TAC[REAL_LT_MIN, GSYM DIST_NZ, REAL_MIN_LE] THEN
  ASM_MESON_TAC[REAL_LE_REFL]);

val LIMIT_POINT_FINITE = store_thm ("LIMIT_POINT_FINITE",
 ``!s a. FINITE s ==> ~(a limit_point_of s)``,
  REWRITE_TAC[LIMPT_APPROACHABLE, GSYM REAL_NOT_LE] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM, REAL_NOT_LE,
   REAL_NOT_LT, TAUT `~(a /\ b /\ c) <=> a /\ b ==> ~c`] THEN
  MESON_TAC[FINITE_SET_AVOID, DIST_SYM]);

val LIMPT_SING = store_thm ("LIMPT_SING",
 ``!x y:real. ~(x limit_point_of {y})``,
  SIMP_TAC std_ss [LIMIT_POINT_FINITE, FINITE_SING]);

val LIMIT_POINT_UNION = store_thm ("LIMIT_POINT_UNION",
 ``!s t x:real. x limit_point_of (s UNION t) <=>
                x limit_point_of s \/ x limit_point_of t``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
  [ALL_TAC, MESON_TAC[LIMPT_SUBSET, SUBSET_UNION]] THEN
  REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNION] THEN DISCH_TAC THEN
  MATCH_MP_TAC(TAUT `(~a ==> b) ==> a \/ b`) THEN
  KNOW_TAC ``!e. &0 < e /\ ~(?x'. x' IN s /\ ~(x' = x) /\ dist (x',x) < e)
     ==> (!e. &0 < e ==> (?x'. x' IN t /\ ~(x' = x) /\ dist (x',x) < e))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [NOT_FORALL_THM, LEFT_IMP_EXISTS_THM, NOT_IMP]] THEN
  X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min d e:real``) THEN ASM_MESON_TAC[REAL_LT_MIN]);

val LIMPT_INSERT = store_thm ("LIMPT_INSERT",
 ``!s x y:real. x limit_point_of (y INSERT s) <=> x limit_point_of s``,
  ONCE_REWRITE_TAC[SET_RULE ``y:real INSERT s = {y} UNION s``] THEN
  REWRITE_TAC[LIMIT_POINT_UNION] THEN
  SIMP_TAC std_ss [FINITE_SING, LIMIT_POINT_FINITE]);

val LIMPT_OF_LIMPTS = store_thm ("LIMPT_OF_LIMPTS",
 ``!x:real s. x limit_point_of {y | y limit_point_of s}
          ==> x limit_point_of s``,
  SIMP_TAC std_ss [LIMPT_APPROACHABLE, GSPECIFICATION] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  DISCH_THEN (X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``dist(y:real,x)``) THEN
  ASM_SIMP_TAC std_ss [DIST_POS_LT] THEN
  DISCH_THEN (X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``z:real`` THEN
  ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL
  [FIRST_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o LAND_CONV) [DIST_SYM] THEN
   REWRITE_TAC [dist] THEN REAL_ARITH_TAC, ALL_TAC] THEN
  FULL_SIMP_TAC std_ss [dist, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

val CLOSED_LIMPTS = store_thm ("CLOSED_LIMPTS",
 ``!s. closed {x:real | x limit_point_of s}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, GSPECIFICATION, LIMPT_OF_LIMPTS]);

val DISCRETE_IMP_CLOSED = store_thm ("DISCRETE_IMP_CLOSED",
 ``!s:real->bool e. &0 < e /\
    (!x y. x IN s /\ y IN s /\ abs(y - x) < e ==> (y = x))
    ==> closed s``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``!x:real. ~(x limit_point_of s)``
  (fn th => MESON_TAC[th, CLOSED_LIMPT]) THEN
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  REWRITE_TAC[REAL_LT_HALF1, ASSUME ``&0 < e:real``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min (e / &2) (dist(x:real,y))``) THEN
  ASM_REWRITE_TAC [REAL_LT_MIN, REAL_LT_HALF1] THEN
  KNOW_TAC ``0 < dist(x,y:real)`` THENL
  [ASM_SIMP_TAC std_ss [DIST_POS_LT], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``y:real``, ``z:real``]) THEN
  ASM_SIMP_TAC arith_ss [GSYM dist] THEN CONJ_TAC THENL
  [MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist(z,x) + dist(x,y:real)`` THEN
   METIS_TAC [DIST_TRIANGLE, GSYM REAL_HALF_DOUBLE, REAL_LT_ADD2, DIST_SYM],
   REPEAT (POP_ASSUM MP_TAC) THEN REWRITE_TAC [dist, DIST_NZ] THEN
   REAL_ARITH_TAC]);

val LIMPT_OF_UNIV = store_thm ("LIMPT_OF_UNIV",
 ``!x. x limit_point_of univ(:real)``,
  GEN_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE, IN_UNIV] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``0 <= e / 2:real`` THENL
  [METIS_TAC [REAL_LT_HALF1, REAL_LE_LT], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN STRIP_TAC THEN EXISTS_TAC ``y:real`` THEN
  CONJ_TAC THENL [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN
  ASM_REWRITE_TAC [DIST_NZ, REAL_LT_HALF1], MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``e / 2:real`` THEN METIS_TAC [REAL_LT_HALF2, REAL_LE_LT, DIST_SYM]]);

val LIMPT_OF_OPEN_IN = store_thm ("LIMPT_OF_OPEN_IN",
 ``!s t x:real. open_in (subtopology euclidean s) t /\
                x limit_point_of s /\ x IN t
                ==> x limit_point_of t``,
  REWRITE_TAC[open_in, SUBSET_DEF, LIMPT_APPROACHABLE] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!x. x IN t ==>
    ?e. 0 < e /\ !x'. x' IN s /\ dist (x',x) < e ==> x' IN t`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``min d e / &2:real``) THEN
  KNOW_TAC ``0 < min d e / 2:real`` THENL [REWRITE_TAC [min_def] THEN
  METIS_TAC [REAL_LT_HALF1], ALL_TAC] THEN DISCH_TAC THEN
  ASM_REWRITE_TAC [] THEN STRIP_TAC THEN EXISTS_TAC ``x':real`` THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN TRY (FIRST_X_ASSUM MATCH_MP_TAC) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``min d e / 2:real`` THEN ASM_REWRITE_TAC [] THEN
  MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
  METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2]);

val LIMPT_OF_OPEN = store_thm ("LIMPT_OF_OPEN",
 ``!s x:real. open s /\ x IN s ==> x limit_point_of s``,
  REWRITE_TAC[OPEN_IN] THEN ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN
  MESON_TAC[LIMPT_OF_OPEN_IN, LIMPT_OF_UNIV]);

val OPEN_IN_SING = store_thm ("OPEN_IN_SING",
 ``!s a. open_in (subtopology euclidean s) {a} <=>
   a IN s /\ ~(a limit_point_of s)``,
  REWRITE_TAC[open_in, LIMPT_APPROACHABLE, SING_SUBSET, IN_SING] THEN
  METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Interior of a set.                                                        *)
(* ------------------------------------------------------------------------- *)

val interior = new_definition ("interior",
  ``interior s = {x | ?t. open t /\ x IN t /\ t SUBSET s}``);

val INTERIOR_EQ = store_thm ("INTERIOR_EQ",
 ``!s. (interior s = s) <=> open s``,
  GEN_TAC THEN REWRITE_TAC[EXTENSION, interior] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN GEN_REWR_TAC RAND_CONV [OPEN_SUB_OPEN]
  THEN MESON_TAC[SUBSET_DEF]);

val INTERIOR_OPEN = store_thm ("INTERIOR_OPEN",
 ``!s. open s ==> (interior s = s)``,
  MESON_TAC[INTERIOR_EQ]);

val INTERIOR_EMPTY = store_thm ("INTERIOR_EMPTY",
 ``interior {} = {}``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_EMPTY]);

val INTERIOR_UNIV = store_thm ("INTERIOR_UNIV",
 ``interior univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_UNIV]);

val OPEN_INTERIOR = store_thm ("OPEN_INTERIOR",
 ``!s. open(interior s)``,
  GEN_TAC THEN REWRITE_TAC[interior] THEN GEN_REWR_TAC I [OPEN_SUB_OPEN] THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_INTERIOR = store_thm ("INTERIOR_INTERIOR",
 ``!s. interior(interior s) = interior s``,
  MESON_TAC[INTERIOR_EQ, OPEN_INTERIOR]);

val INTERIOR_SUBSET = store_thm ("INTERIOR_SUBSET",
 ``!s. (interior s) SUBSET s``,
  SIMP_TAC std_ss [SUBSET_DEF, interior, GSPECIFICATION] THEN MESON_TAC[]);

val SUBSET_INTERIOR_EQ = store_thm ("SUBSET_INTERIOR_EQ",
 ``!s:real->bool. s SUBSET interior s <=> open s``,
  REWRITE_TAC[GSYM INTERIOR_EQ,
  SET_RULE ``!(s:real->bool) t. (s = t) <=> s SUBSET t /\ t SUBSET s``,
  INTERIOR_SUBSET]);

val SUBSET_INTERIOR = store_thm ("SUBSET_INTERIOR",
 ``!s t. s SUBSET t ==> (interior s) SUBSET (interior t)``,
  SIMP_TAC std_ss [interior, SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_MAXIMAL = store_thm ("INTERIOR_MAXIMAL",
 ``!s t. t SUBSET s /\ open t ==> t SUBSET (interior s)``,
  SIMP_TAC std_ss[interior, SUBSET_DEF, GSPECIFICATION] THEN MESON_TAC[]);

val INTERIOR_MAXIMAL_EQ = store_thm ("INTERIOR_MAXIMAL_EQ",
 ``!s t:real->bool. open s ==> (s SUBSET interior t <=> s SUBSET t)``,
  MESON_TAC[INTERIOR_MAXIMAL, SUBSET_TRANS, INTERIOR_SUBSET]);

val INTERIOR_UNIQUE = store_thm ("INTERIOR_UNIQUE",
 ``!s t. t SUBSET s /\ open t /\ (!t'. t' SUBSET s /\ open t' ==> t' SUBSET t)
         ==> (interior s = t)``,
  MESON_TAC[SUBSET_ANTISYM, INTERIOR_MAXIMAL, INTERIOR_SUBSET, OPEN_INTERIOR]);

val IN_INTERIOR = store_thm ("IN_INTERIOR",
 ``!x s. x IN interior s <=> ?e. &0 < e /\ ball(x,e) SUBSET s``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[OPEN_CONTAINS_BALL, SUBSET_TRANS, CENTRE_IN_BALL, OPEN_BALL]);

val OPEN_SUBSET_INTERIOR = store_thm ("OPEN_SUBSET_INTERIOR",
 ``!s t. open s ==> (s SUBSET interior t <=> s SUBSET t)``,
  MESON_TAC[INTERIOR_MAXIMAL, INTERIOR_SUBSET, SUBSET_TRANS]);

val INTERIOR_INTER = store_thm ("INTERIOR_INTER",
 ``!s t:real->bool. interior(s INTER t) = interior s INTER interior t``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [REWRITE_TAC[SUBSET_INTER] THEN CONJ_TAC THEN
    MATCH_MP_TAC SUBSET_INTERIOR THEN REWRITE_TAC[INTER_SUBSET],
    MATCH_MP_TAC INTERIOR_MAXIMAL THEN SIMP_TAC std_ss [OPEN_INTER, OPEN_INTERIOR] THEN
    MATCH_MP_TAC(SET_RULE
      ``s SUBSET s' /\ t SUBSET t' ==> s INTER t SUBSET s' INTER t'``) THEN
    REWRITE_TAC[INTERIOR_SUBSET]]);

val INTERIOR_FINITE_BIGINTER = store_thm ("INTERIOR_FINITE_BIGINTER",
 ``!s:(real->bool)->bool.
        FINITE s ==> (interior(BIGINTER s) = BIGINTER(IMAGE interior s))``,
  GEN_TAC THEN KNOW_TAC ``(interior (BIGINTER s) = BIGINTER (IMAGE interior s)) =
  (\s:(real->bool)->bool. (interior (BIGINTER s) = BIGINTER (IMAGE interior s))) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGINTER_EMPTY, BIGINTER_INSERT, INTERIOR_UNIV, IMAGE_EMPTY,
  IMAGE_INSERT] THEN SIMP_TAC std_ss [INTERIOR_INTER]);

val INTERIOR_BIGINTER_SUBSET = store_thm ("INTERIOR_BIGINTER_SUBSET",
 ``!f. interior(BIGINTER f) SUBSET BIGINTER (IMAGE interior f)``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERIOR, IN_BIGINTER, FORALL_IN_IMAGE] THEN
  MESON_TAC[]);

val UNION_INTERIOR_SUBSET = store_thm ("UNION_INTERIOR_SUBSET",
 ``!s t:real->bool.
        interior s UNION interior t SUBSET interior(s UNION t)``,
  SIMP_TAC std_ss [INTERIOR_MAXIMAL_EQ, OPEN_UNION, OPEN_INTERIOR] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(SET_RULE
   ``s SUBSET s' /\ t SUBSET t' ==> (s UNION t) SUBSET (s' UNION t')``) THEN
  REWRITE_TAC[INTERIOR_SUBSET]);

val INTERIOR_EQ_EMPTY = store_thm ("INTERIOR_EQ_EMPTY",
 ``!s:real->bool. (interior s = {}) <=> !t. open t /\ t SUBSET s ==> (t = {})``,
  MESON_TAC[INTERIOR_MAXIMAL_EQ, SUBSET_EMPTY,
            OPEN_INTERIOR, INTERIOR_SUBSET]);

val INTERIOR_EQ_EMPTY_ALT = store_thm ("INTERIOR_EQ_EMPTY_ALT",
 ``!s:real->bool. (interior s = {}) <=>
  !t. open t /\ ~(t = {}) ==> ~(t DIFF s = {})``,
  GEN_TAC THEN REWRITE_TAC[INTERIOR_EQ_EMPTY] THEN SET_TAC[]);

val INTERIOR_LIMIT_POINT = store_thm ("INTERIOR_LIMIT_POINT",
 ``!s x:real. x IN interior s ==> x limit_point_of s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [IN_INTERIOR, GSPECIFICATION, SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[LIMPT_APPROACHABLE] THEN X_GEN_TAC ``d:real`` THEN
  DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``min d e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``0 <= min d e / 2:real`` THENL
  [METIS_TAC [min_def, REAL_LE_LT, REAL_LT_HALF1], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  EXISTS_TAC ``y:real`` THEN REPEAT CONJ_TAC THENL
  [FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
   METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2],
   CONV_TAC (RAND_CONV SYM_CONV) THEN REWRITE_TAC[DIST_NZ] THEN
   ASM_REWRITE_TAC [] THEN METIS_TAC [min_def, REAL_LE_LT, REAL_LT_HALF1],
   ONCE_REWRITE_TAC[DIST_SYM] THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d e:real`` THEN
   METIS_TAC [REAL_MIN_LE1, min_def, REAL_LT_HALF2]]);

val INTERIOR_SING = store_thm ("INTERIOR_SING",
  ``!a:real. interior {a} = {}``,
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN
  MESON_TAC[INTERIOR_LIMIT_POINT, LIMPT_SING]);

val INTERIOR_CLOSED_UNION_EMPTY_INTERIOR = store_thm ("INTERIOR_CLOSED_UNION_EMPTY_INTERIOR",
 ``!s t:real->bool. closed(s) /\ (interior(t) = {})
                ==> (interior(s UNION t) = interior(s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, SUBSET_UNION] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTERIOR, IN_INTER, IN_UNION] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN
  ASM_REWRITE_TAC[] THEN X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``(y:real) limit_point_of s``
   (fn th => ASM_MESON_TAC[CLOSED_LIMPT, th]) THEN
  REWRITE_TAC[IN_INTERIOR, NOT_IN_EMPTY, LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?z:real. ~(z IN t) /\ ~(z = y) /\ dist(z,y) < d /\ dist(x,z) < e``
   (fn th => ASM_MESON_TAC[th, IN_BALL]) THEN
  UNDISCH_TAC ``y IN ball (x,e)`` THEN REWRITE_TAC [IN_BALL] THEN
  DISCH_TAC THEN UNDISCH_TAC ``interior t = {}`` THEN
  GEN_REWR_TAC LAND_CONV [EXTENSION] THEN
  KNOW_TAC ``(!x e. ~(&0 < e /\ ball (x,e) SUBSET t))
   ==> (?z. ~(z IN t) /\ ~(z = y) /\ dist (z,y) < d /\ dist (x,z) < e)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [IN_INTERIOR, NOT_IN_EMPTY, NOT_EXISTS_THM]] THEN
  ABBREV_TAC ``k = min d (e - dist(x:real,y))`` THEN
  SUBGOAL_THEN ``&0 < k:real`` ASSUME_TAC THENL
  [METIS_TAC [min_def, REAL_SUB_LT], ALL_TAC] THEN
  SUBGOAL_THEN ``?w:real. dist(y,w) = k / &2`` CHOOSE_TAC THENL
  [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_HALF, REAL_LT_IMP_LE], ALL_TAC] THEN
  DISCH_THEN(MP_TAC o SPECL [``w:real``, ``k / &4:real``]) THEN
  ASM_SIMP_TAC arith_ss [SUBSET_DEF, NOT_FORALL_THM, REAL_LT_DIV, REAL_LT,
  NOT_IMP, IN_BALL] THEN DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN
  EXISTS_TAC ``z:real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN REPEAT CONJ_TAC THENL
  [CCONTR_TAC THEN FULL_SIMP_TAC std_ss [DIST_SYM] THEN
   UNDISCH_TAC `` dist (w,y) < k / 4`` THEN ASM_REWRITE_TAC [REAL_NOT_LT, REAL_LE_LT] THEN
   DISJ1_TAC THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD],
   MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (z, w) + dist (w, y:real)`` THEN
   REWRITE_TAC [DIST_TRIANGLE] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``min d (e - dist (x,y))`` THEN
   ASM_REWRITE_TAC [REAL_MIN_LE1] THEN
   GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN REWRITE_TAC [REAL_LT_RADD] THEN
   MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``k / 4:real`` THEN
   ASM_REWRITE_TAC [] THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD],
   Cases_on `d <= (e - dist (x,y))` THENL
   [ALL_TAC, FULL_SIMP_TAC std_ss [min_def] THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``(a - b = c) = (a = c + b:real)``] THEN
    ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``dist (x, y) + dist (y, z:real)`` THEN
    REWRITE_TAC [DIST_TRIANGLE, REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``dist (y,w) + dist (w, z:real)`` THEN ASM_REWRITE_TAC [DIST_TRIANGLE] THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN REWRITE_TAC [REAL_LT_LADD] THEN
    MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``k / 4:real`` THEN
    ASM_REWRITE_TAC [] THEN KNOW_TAC ``k < k / 2 * 4:real`` THENL
    [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
    REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
    SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
    ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
    GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD]] THEN
   FULL_SIMP_TAC std_ss [min_def, REAL_LE_SUB_LADD] THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``d + dist (x,y)`` THEN
   ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN
   MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (x, y) + dist (y, z:real)`` THEN
   REWRITE_TAC [DIST_TRIANGLE, REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
   EXISTS_TAC ``dist (y,w) + dist (w, z:real)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
   ASM_REWRITE_TAC [] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
   ASM_REWRITE_TAC [REAL_LT_LADD] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
   EXISTS_TAC ``k / 4:real`` THEN ASM_REWRITE_TAC [] THEN
   KNOW_TAC ``k < k / 2 * 4:real`` THENL
   [ALL_TAC, SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``0 < 4:real``]] THEN
   REWRITE_TAC [REAL_ARITH ``4 = 2 * 2:real``, REAL_MUL_ASSOC] THEN
   SIMP_TAC arith_ss [REAL_DIV_RMUL, REAL_ARITH ``2 <> 0:real``] THEN
   ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM REAL_DOUBLE] THEN
   ONCE_REWRITE_TAC [REAL_ARITH``a = a + 0:real``] THEN
   GEN_REWR_TAC RAND_CONV [REAL_ADD_RID] THEN ASM_REWRITE_TAC [REAL_LT_LADD]]);

val INTERIOR_UNION_EQ_EMPTY = store_thm ("INTERIOR_UNION_EQ_EMPTY",
 ``!s t:real->bool. closed s \/ closed t
        ==> ((interior(s UNION t) = {}) <=>
             (interior s = {}) /\ (interior t = {}))``,
REPEAT GEN_TAC THEN DISCH_TAC THEN EQ_TAC THENL
[ASM_MESON_TAC[SUBSET_UNION, SUBSET_INTERIOR, SUBSET_EMPTY],
 ASM_MESON_TAC[UNION_COMM, INTERIOR_CLOSED_UNION_EMPTY_INTERIOR]]);

val INTERIOR_UNIONS_OPEN_SUBSETS = store_thm ("INTERIOR_UNIONS_OPEN_SUBSETS",
 ``!s:real->bool. BIGUNION {t | open t /\ t SUBSET s} = interior s``,
  GEN_TAC THEN CONV_TAC SYM_CONV THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  SIMP_TAC std_ss [OPEN_BIGUNION, GSPECIFICATION] THEN SET_TAC[]);

val REAL_ARCH_RDIV_EQ_0 = store_thm ("REAL_ARCH_RDIV_EQ_0",
 ``!x c:real. &0 <= x /\ &0 <= c /\ (!m. 0 < m ==> &m * x <= c) ==> (x = &0)``,
  SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, GSYM REAL_NOT_LT] THEN REPEAT STRIP_TAC THEN
  POP_ASSUM (STRIP_ASSUME_TAC o SPEC ``c:real`` o MATCH_MP REAL_ARCH) THEN
  ASM_CASES_TAC ``n=0:num`` THENL
   [POP_ASSUM SUBST_ALL_TAC THEN
    RULE_ASSUM_TAC (REWRITE_RULE [REAL_MUL_LZERO]) THEN
    ASM_MESON_TAC [REAL_LET_ANTISYM],
    ASM_MESON_TAC [REAL_LET_ANTISYM, REAL_MUL_SYM, LT_NZ]]);

(* ------------------------------------------------------------------------- *)
(* Closure of a set.                                                         *)
(* ------------------------------------------------------------------------- *)

val closure = new_definition ("closure",
  ``closure s = s UNION {x | x limit_point_of s}``);

val CLOSURE_APPROACHABLE = store_thm ("CLOSURE_APPROACHABLE",
 ``!x s. x IN closure(s) <=> !e. &0 < e ==> ?y. y IN s /\ dist(y,x) < e``,
  SIMP_TAC std_ss [closure, LIMPT_APPROACHABLE, IN_UNION, GSPECIFICATION] THEN
  MESON_TAC[DIST_REFL]);

val CLOSURE_NONEMPTY_OPEN_INTER = store_thm ("CLOSURE_NONEMPTY_OPEN_INTER",
 ``!s x:real. x IN closure s <=> !t. x IN t /\ open t ==> ~(s INTER t = {})``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION] THEN
  REWRITE_TAC[limit_point_of] THEN SET_TAC[]);

val CLOSURE_INTERIOR = store_thm ("CLOSURE_INTERIOR",
 ``!s:real->bool. closure s = UNIV DIFF (interior (UNIV DIFF s))``,
  SIMP_TAC std_ss [EXTENSION, closure, IN_UNION, IN_DIFF, IN_UNIV, interior,
              GSPECIFICATION, limit_point_of, SUBSET_DEF] THEN
  MESON_TAC[]);

val INTERIOR_CLOSURE = store_thm ("INTERIOR_CLOSURE",
 ``!s:real->bool. interior s = UNIV DIFF (closure (UNIV DIFF s))``,
  REWRITE_TAC[CLOSURE_INTERIOR, SET_RULE ``!s t. UNIV DIFF (UNIV DIFF t) = t``]);

val CLOSED_CLOSURE = store_thm ("CLOSED_CLOSURE",
 ``!s. closed(closure s)``,
  REWRITE_TAC[closed_def, CLOSURE_INTERIOR, SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``,
              OPEN_INTERIOR]);

val CLOSURE_HULL = store_thm ("CLOSURE_HULL",
 ``!s. closure s = closed hull s``,
  GEN_TAC THEN MATCH_MP_TAC(GSYM HULL_UNIQUE) THEN
  REWRITE_TAC[CLOSED_CLOSURE, SUBSET_DEF] THEN
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, CLOSED_LIMPT] THEN
  MESON_TAC[limit_point_of]);

val CLOSURE_EQ = store_thm ("CLOSURE_EQ",
 ``!s. (closure s = s) <=> closed s``,
  SIMP_TAC std_ss [CLOSURE_HULL, HULL_EQ, CLOSED_BIGINTER]);

val CLOSURE_CLOSED = store_thm ("CLOSURE_CLOSED",
 ``!s. closed s ==> (closure s = s)``,
  MESON_TAC[CLOSURE_EQ]);

val CLOSURE_CLOSURE = store_thm ("CLOSURE_CLOSURE",
 ``!s. closure(closure s) = closure s``,
  REWRITE_TAC[CLOSURE_HULL, HULL_HULL]);

val CLOSURE_SUBSET = store_thm ("CLOSURE_SUBSET",
 ``!s. s SUBSET (closure s)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_SUBSET]);

val SUBSET_CLOSURE = store_thm ("SUBSET_CLOSURE",
 ``!s t. s SUBSET t ==> (closure s) SUBSET (closure t)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_MONO]);

val CLOSURE_UNION = store_thm ("CLOSURE_UNION",
 ``!s t:real->bool. closure(s UNION t) = closure s UNION closure t``,
  REWRITE_TAC[LIMIT_POINT_UNION, closure] THEN SET_TAC[]);

val CLOSURE_INTER_SUBSET = store_thm ("CLOSURE_INTER_SUBSET",
 ``!s t. closure(s INTER t) SUBSET closure(s) INTER closure(t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SUBSET_INTER] THEN
  CONJ_TAC THEN MATCH_MP_TAC SUBSET_CLOSURE THEN SET_TAC[]);

val CLOSURE_BIGINTER_SUBSET = store_thm ("CLOSURE_BIGINTER_SUBSET",
 ``!f. closure(BIGINTER f) SUBSET BIGINTER (IMAGE closure f)``,
  REWRITE_TAC[SET_RULE ``s SUBSET BIGINTER f <=> !t. t IN f ==> s SUBSET t``] THEN
  REWRITE_TAC[FORALL_IN_IMAGE] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SUBSET_CLOSURE THEN ASM_SET_TAC[]);

val CLOSURE_MINIMAL = store_thm ("CLOSURE_MINIMAL",
 ``!s t. s SUBSET t /\ closed t ==> (closure s) SUBSET t``,
  REWRITE_TAC[HULL_MINIMAL, CLOSURE_HULL]);

val CLOSURE_MINIMAL_EQ = store_thm ("CLOSURE_MINIMAL_EQ",
 ``!s t:real->bool. closed t ==> (closure s SUBSET t <=> s SUBSET t)``,
  MESON_TAC[SUBSET_TRANS, CLOSURE_SUBSET, CLOSURE_MINIMAL]);

val CLOSURE_UNIQUE = store_thm ("CLOSURE_UNIQUE",
 ``!s t. s SUBSET t /\ closed t /\
  (!t'. s SUBSET t' /\ closed t' ==> t SUBSET t')
   ==> (closure s = t)``,
  REWRITE_TAC[CLOSURE_HULL, HULL_UNIQUE]);

val CLOSURE_EMPTY = store_thm ("CLOSURE_EMPTY",
 ``closure {} = {}``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_EMPTY]);

val CLOSURE_UNIV = store_thm ("CLOSURE_UNIV",
 ``closure univ(:real) = univ(:real)``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_UNIV]);

val CLOSURE_BIGUNION = store_thm ("CLOSURE_BIGUNION",
 ``!f. FINITE f ==> (closure(BIGUNION f) = BIGUNION {closure s | s IN f})``,
  KNOW_TAC ``!f. (closure(BIGUNION f) = BIGUNION {closure s | s IN f}) =
             (\f. closure(BIGUNION f) = BIGUNION {closure s | s IN f}) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [BIGUNION_EMPTY, BIGUNION_INSERT, SET_RULE ``{f x | x IN {}} = {}``,
  SET_RULE ``{f x | x IN a INSERT s} = (f a) INSERT {f x | x IN s}``] THEN
  SIMP_TAC std_ss [CLOSURE_EMPTY, CLOSURE_UNION]);

val CLOSURE_EQ_EMPTY = store_thm ("CLOSURE_EQ_EMPTY",
 ``!s. (closure s = {}) <=> (s = {})``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CLOSURE_EMPTY] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (t = {}) ==> (s = {})``) THEN
  REWRITE_TAC[CLOSURE_SUBSET]);

val CLOSURE_SUBSET_EQ = store_thm ("CLOSURE_SUBSET_EQ",
 ``!s:real->bool. closure s SUBSET s <=> closed s``,
  GEN_TAC THEN REWRITE_TAC[GSYM CLOSURE_EQ] THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[]);

val OPEN_INTER_CLOSURE_EQ_EMPTY = store_thm ("OPEN_INTER_CLOSURE_EQ_EMPTY",
 ``!s t:real->bool.
        open s ==> ((s INTER (closure t) = {}) <=> (s INTER t = {}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [MP_TAC(ISPEC ``t:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[], ALL_TAC] THEN
  DISCH_TAC THEN REWRITE_TAC[CLOSURE_INTERIOR] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (s INTER (UNIV DIFF t) = {})``) THEN
  ASM_SIMP_TAC std_ss [OPEN_SUBSET_INTERIOR] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN SET_TAC[]);

val CLOSURE_OPEN_IN_INTER_CLOSURE = store_thm ("CLOSURE_OPEN_IN_INTER_CLOSURE",
 ``!s t u:real->bool.
     open_in (subtopology euclidean u) s /\ t SUBSET u
     ==> (closure(s INTER closure t) = closure(s INTER t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, SUBSET_CLOSURE, SET_RULE
  ``t SUBSET u ==> s INTER t SUBSET s INTER u``] THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_APPROACHABLE] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, IN_INTER, CLOSURE_APPROACHABLE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN
  REWRITE_TAC [open_in] THEN REWRITE_TAC[SUBSET_DEF] THEN
  DISCH_THEN(CONJUNCTS_THEN(MP_TAC o SPEC ``y:real``)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?y'. y' IN t /\ dist (y',y) < e`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``min d (e / &2:real)``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, REAL_LT_MIN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  POP_ASSUM MP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist(z,y) + dist(y,x)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LT_ADD2 THEN ASM_REWRITE_TAC []);

val CLOSURE_OPEN_INTER_CLOSURE = store_thm ("CLOSURE_OPEN_INTER_CLOSURE",
 ``!s t:real->bool.
   open s ==> (closure(s INTER closure t) = closure(s INTER t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSURE_OPEN_IN_INTER_CLOSURE THEN
  EXISTS_TAC ``univ(:real)`` THEN
  ASM_REWRITE_TAC[SUBSET_UNIV, GSYM OPEN_IN, SUBTOPOLOGY_UNIV]);

val OPEN_INTER_CLOSURE_SUBSET = store_thm ("OPEN_INTER_CLOSURE_SUBSET",
 ``!s t:real->bool.
        open s ==> (s INTER (closure t)) SUBSET closure(s INTER t)``,
  REPEAT STRIP_TAC THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_INTER, closure, IN_UNION, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  DISJ2_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``open s`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``x limit_point_of t`` THEN REWRITE_TAC [LIMPT_APPROACHABLE] THEN
  DISCH_THEN(MP_TAC o SPEC ``min d e:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_MIN, IN_INTER] THEN STRIP_TAC THEN
  EXISTS_TAC ``x':real`` THEN ASM_MESON_TAC[]);

val CLOSURE_OPEN_INTER_SUPERSET = store_thm ("CLOSURE_OPEN_INTER_SUPERSET",
 ``!s t:real->bool.
        open s /\ s SUBSET closure t ==> (closure(s INTER t) = closure s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, INTER_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN REWRITE_TAC[CLOSED_CLOSURE] THEN
  W(MP_TAC o PART_MATCH (rand o rand) OPEN_INTER_CLOSURE_SUBSET o rand o snd) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] SUBSET_TRANS) THEN
  ASM_SET_TAC[]);

val CLOSURE_COMPLEMENT = store_thm ("CLOSURE_COMPLEMENT",
 ``!s:real->bool. closure(UNIV DIFF s) = UNIV DIFF interior(s)``,
  REWRITE_TAC[SET_RULE ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_CLOSURE]);

val INTERIOR_COMPLEMENT = store_thm ("INTERIOR_COMPLEMENT",
 ``!s:real->bool. interior(UNIV DIFF s) = UNIV DIFF closure(s)``,
  REWRITE_TAC[SET_RULE ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``] THEN
  REWRITE_TAC[GSYM CLOSURE_INTERIOR]);

val CONNECTED_INTERMEDIATE_CLOSURE = store_thm ("CONNECTED_INTERMEDIATE_CLOSURE",
 ``!s t:real->bool.
   connected s /\ s SUBSET t /\ t SUBSET closure s ==> connected t``,
  REPEAT GEN_TAC THEN
  KNOW_TAC ``(!e1 e2.
      ~(open e1 /\ open e2 /\
        s SUBSET e1 UNION e2 /\ (e1 INTER e2 INTER s = {}) /\
        ~(e1 INTER s = {}) /\ ~(e2 INTER s = {}))) /\
        s SUBSET t /\ t SUBSET closure s
 ==> (!e1 e2.
          ~(open e1 /\ open e2 /\
            t SUBSET e1 UNION e2 /\ (e1 INTER e2 INTER t = {}) /\
            ~(e1 INTER t = {}) /\ ~(e2 INTER t = {})))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [connected, NOT_EXISTS_THM]] THEN
  STRIP_TAC THEN MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPECL [``u:real->bool``, ``v:real->bool``]) THEN
  ASM_REWRITE_TAC[] THEN ASSUME_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[GSYM DE_MORGAN_THM] THEN STRIP_TAC THENL
  [SUBGOAL_THEN ``(closure s) SUBSET (univ(:real) DIFF u)`` MP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_REWRITE_TAC[GSYM OPEN_CLOSED], ALL_TAC],
  SUBGOAL_THEN ``(closure s) SUBSET (univ(:real) DIFF v)`` MP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_REWRITE_TAC[GSYM OPEN_CLOSED],
   ALL_TAC]] THEN ASM_SET_TAC[]);

val CONNECTED_CLOSURE = store_thm ("CONNECTED_CLOSURE",
 ``!s:real->bool. connected s ==> connected(closure s)``,
  MESON_TAC[CONNECTED_INTERMEDIATE_CLOSURE, CLOSURE_SUBSET, SUBSET_REFL]);

val CONNECTED_UNION_STRONG = store_thm ("CONNECTED_UNION_STRONG",
 ``!s t:real->bool.
    connected s /\ connected t /\ ~(closure s INTER t = {})
    ==> connected(s UNION t)``,
  REPEAT STRIP_TAC THEN
  POP_ASSUM (MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``p:real``) THEN
  SUBGOAL_THEN ``s UNION t = ((p:real) INSERT s) UNION t`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC CONNECTED_UNION THEN ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
  [MATCH_MP_TAC CONNECTED_INTERMEDIATE_CLOSURE THEN
   EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
   MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
   ASM_SET_TAC[]]);

val INTERIOR_DIFF = store_thm ("INTERIOR_DIFF",
 ``!s t. interior(s DIFF t) = interior(s) DIFF closure(t)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  REWRITE_TAC[INTERIOR_INTER, CLOSURE_INTERIOR] THEN SET_TAC[]);

val LIMPT_OF_CLOSURE = store_thm ("LIMPT_OF_CLOSURE",
 ``!x:real s. x limit_point_of closure s <=> x limit_point_of s``,
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, LIMIT_POINT_UNION] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT `(q ==> p) ==> (p \/ q <=> p)`) THEN
  REWRITE_TAC[LIMPT_OF_LIMPTS]);

val CLOSED_IN_LIMPT = store_thm ("CLOSED_IN_LIMPT",
 ``!s t. closed_in (subtopology euclidean t) s <=>
    s SUBSET t /\ !x:real. x limit_point_of s /\ x IN t ==> x IN s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN EQ_TAC THENL
  [DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [IN_INTER] THEN
  ASM_MESON_TAC[CLOSED_LIMPT, LIMPT_SUBSET, INTER_SUBSET],
  STRIP_TAC THEN EXISTS_TAC ``closure s :real->bool`` THEN
  REWRITE_TAC[CLOSED_CLOSURE] THEN REWRITE_TAC[closure] THEN
  ASM_SET_TAC[]]);

val CLOSED_IN_INTER_CLOSURE = store_thm ("CLOSED_IN_INTER_CLOSURE",
 ``!s t:real->bool.
    closed_in (subtopology euclidean s) t <=> (s INTER closure t = t)``,
  REWRITE_TAC[closure, CLOSED_IN_LIMPT] THEN SET_TAC[]);

val INTERIOR_CLOSURE_IDEMP = store_thm ("INTERIOR_CLOSURE_IDEMP",
 ``!s:real->bool.
    interior(closure(interior(closure s))) = interior(closure s)``,
  GEN_TAC THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  ASM_MESON_TAC[OPEN_INTERIOR, CLOSURE_SUBSET, CLOSURE_CLOSURE, SUBSET_TRANS,
                OPEN_SUBSET_INTERIOR, SUBSET_CLOSURE, INTERIOR_SUBSET]);

val CLOSURE_INTERIOR_IDEMP = store_thm ("CLOSURE_INTERIOR_IDEMP",
 ``!s:real->bool.
    closure(interior(closure(interior s))) = closure(interior s)``,
  GEN_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = t) <=> (UNIV DIFF s = UNIV DIFF t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_COMPLEMENT, GSYM CLOSURE_COMPLEMENT] THEN
  REWRITE_TAC[INTERIOR_CLOSURE_IDEMP]);

val NOWHERE_DENSE_UNION = store_thm ("NOWHERE_DENSE_UNION",
 ``!s t:real->bool.
   (interior(closure(s UNION t)) = {}) <=>
   (interior(closure s) = {}) /\ (interior(closure t) = {})``,
  SIMP_TAC std_ss [CLOSURE_UNION, INTERIOR_UNION_EQ_EMPTY, CLOSED_CLOSURE]);

val NOWHERE_DENSE = store_thm ("NOWHERE_DENSE",
 ``!s:real->bool. (interior(closure s) = {}) <=>
              !t. open t /\ ~(t = {})
          ==> ?u. open u /\ ~(u = {}) /\ u SUBSET t /\ (u INTER s = {})``,
  GEN_TAC THEN REWRITE_TAC[INTERIOR_EQ_EMPTY_ALT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THENL
  [EXISTS_TAC ``t DIFF closure s:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, CLOSED_CLOSURE] THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN SET_TAC[],
  FIRST_X_ASSUM(MP_TAC o SPEC ``t:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``u:real->bool``, ``s:real->bool``]
  OPEN_INTER_CLOSURE_EQ_EMPTY) THEN ASM_SET_TAC[]]);

val INTERIOR_CLOSURE_INTER_OPEN = store_thm ("INTERIOR_CLOSURE_INTER_OPEN",
 ``!s t:real->bool. open s /\ open t
        ==> (interior(closure(s INTER t)) =
             interior(closure s) INTER interior(closure t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[SET_RULE
  ``(u = s INTER t) <=> s INTER t SUBSET u /\ u SUBSET s /\ u SUBSET t``] THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, SUBSET_CLOSURE, INTER_SUBSET] THEN
  MATCH_MP_TAC INTERIOR_MAXIMAL THEN SIMP_TAC std_ss [OPEN_INTER, OPEN_INTERIOR] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET t <=> (s INTER (UNIV DIFF t) = {})``,
   GSYM INTERIOR_COMPLEMENT] THEN
  REWRITE_TAC[GSYM INTERIOR_INTER] THEN
  REWRITE_TAC[INTERIOR_EQ_EMPTY] THEN
  X_GEN_TAC ``u:real->bool`` THEN STRIP_TAC THEN
  MP_TAC(ISPECL [``u INTER s:real->bool``, ``t:real->bool``]
   OPEN_INTER_CLOSURE_EQ_EMPTY) THEN
  MP_TAC(ISPECL [``u:real->bool``, ``s:real->bool``]
   OPEN_INTER_CLOSURE_EQ_EMPTY) THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER] THEN ASM_SET_TAC[]);

val CLOSURE_INTERIOR_UNION_CLOSED = store_thm ("CLOSURE_INTERIOR_UNION_CLOSED",
 ``!s t:real->bool. closed s /\ closed t
        ==> (closure (interior (s UNION t)) =
             closure (interior s) UNION closure(interior t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[closed_def] THEN
  DISCH_THEN(MP_TAC o MATCH_MP INTERIOR_CLOSURE_INTER_OPEN) THEN
  REWRITE_TAC[CLOSURE_COMPLEMENT, INTERIOR_COMPLEMENT,
  SET_RULE ``(UNIV DIFF s) INTER (UNIV DIFF t) = UNIV DIFF (s UNION t)``] THEN
  SET_TAC[]);

val REGULAR_OPEN_INTER = store_thm ("REGULAR_OPEN_INTER",
 ``!s t:real->bool.
    (interior(closure s) = s) /\ (interior(closure t) = t)
     ==> (interior(closure(s INTER t)) = s INTER t)``,
  MESON_TAC[INTERIOR_CLOSURE_INTER_OPEN, OPEN_INTERIOR]);

val REGULAR_CLOSED_UNION = store_thm ("REGULAR_CLOSED_UNION",
 ``!s t:real->bool.
  (closure(interior s) = s) /\ (closure(interior t) = t)
   ==> (closure(interior(s UNION t)) = s UNION t)``,
  MESON_TAC[CLOSURE_INTERIOR_UNION_CLOSED, CLOSED_CLOSURE]);

val REGULAR_CLOSED_BIGUNION = store_thm ("REGULAR_CLOSED_BIGUNION",
 ``!f:(real->bool)->bool.
    FINITE f /\ (!t. t IN f ==> (closure(interior t) = t))
    ==> (closure(interior(BIGUNION f)) = BIGUNION f)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!f. ((!t. t IN f ==> (closure(interior t) = t))
         ==> (closure(interior(BIGUNION f)) = BIGUNION f)) =
           (\f. (!t. t IN f ==> (closure(interior t) = t))
         ==> (closure(interior(BIGUNION f)) = BIGUNION f)) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_INSERT, BIGUNION_EMPTY, INTERIOR_EMPTY, CLOSURE_EMPTY] THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, REGULAR_CLOSED_UNION]);

val DIFF_CLOSURE_SUBSET = store_thm ("DIFF_CLOSURE_SUBSET",
 ``!s t:real->bool. closure(s) DIFF closure t SUBSET closure(s DIFF t)``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``univ(:real) DIFF closure t``, ``s:real->bool``]
   OPEN_INTER_CLOSURE_SUBSET) THEN
  REWRITE_TAC[SET_RULE ``(UNIV DIFF t) INTER s = s DIFF t``] THEN
  REWRITE_TAC[GSYM closed_def, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_TRANS) THEN
  MATCH_MP_TAC SUBSET_CLOSURE THEN
  MATCH_MP_TAC(SET_RULE ``t SUBSET u ==> s DIFF u SUBSET s DIFF t``) THEN
  REWRITE_TAC[CLOSURE_SUBSET]);

val DENSE_OPEN_INTER = store_thm ("DENSE_OPEN_INTER",
 ``!s t u:real->bool.
  (open_in (subtopology euclidean u) s /\ t SUBSET u \/
   open_in (subtopology euclidean u) t /\ s SUBSET u)
   ==> (u SUBSET closure (s INTER t) <=>
        u SUBSET closure s /\ u SUBSET closure t)``,
  KNOW_TAC ``((!s t u.
      (u SUBSET closure (s INTER t) <=>
       u SUBSET closure s /\ u SUBSET closure t)
      ==> (u SUBSET closure (t INTER s) <=>
           u SUBSET closure t /\ u SUBSET closure s)) /\
 (!s t u.
      open_in (subtopology euclidean u) s /\ t SUBSET u
      ==> (u SUBSET closure (s INTER t) <=>
           u SUBSET closure s /\ u SUBSET closure t)))`` THENL
  [ALL_TAC, METIS_TAC []] THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [INTER_COMM, CONJ_ACI], ALL_TAC] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN EQ_TAC THENL
  [ASM_MESON_TAC[SUBSET_TRANS, SUBSET_CLOSURE, INTER_SUBSET], ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_APPROACHABLE] THEN DISCH_TAC THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(CONJUNCTS_THEN2 (MP_TAC o SPEC ``x:real``) ASSUME_TAC) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN REWRITE_TAC [open_in] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTER] THEN
  DISCH_THEN(CONJUNCTS_THEN (MP_TAC o SPEC ``y:real``)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN DISCH_TAC THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d (e / &2):real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_LT_MIN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN ASM_SIMP_TAC std_ss [] THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist(z,y) + dist(y,x)`` THEN REWRITE_TAC [DIST_TRIANGLE] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LT_ADD2 THEN ASM_REWRITE_TAC []);

(* ------------------------------------------------------------------------- *)
(* Frontier (aka boundary).                                                  *)
(* ------------------------------------------------------------------------- *)

val frontier = new_definition ("frontier",
  ``frontier s = (closure s) DIFF (interior s)``);

val FRONTIER_CLOSED = store_thm ("FRONTIER_CLOSED",
 ``!s. closed(frontier s)``,
  SIMP_TAC std_ss [frontier, CLOSED_DIFF, CLOSED_CLOSURE, OPEN_INTERIOR]);

val FRONTIER_CLOSURES = store_thm ("FRONTIER_CLOSURES",
 ``!s:real->bool. frontier s = (closure s) INTER (closure(UNIV DIFF s))``,
  REWRITE_TAC[frontier, INTERIOR_CLOSURE,
   SET_RULE ``s DIFF (UNIV DIFF t) = s INTER t``]);

val FRONTIER_STRADDLE = store_thm ("FRONTIER_STRADDLE",
 ``!a:real s.
    a IN frontier s <=> !e. &0 < e ==> (?x. x IN s /\ dist(a,x) < e) /\
    (?x. ~(x IN s) /\ dist(a,x) < e)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[FRONTIER_CLOSURES, IN_INTER] THEN
  SIMP_TAC std_ss [closure, IN_UNION, GSPECIFICATION, limit_point_of,
  IN_UNIV, IN_DIFF] THEN
  ASM_MESON_TAC[IN_BALL, SUBSET_DEF, OPEN_CONTAINS_BALL,
  CENTRE_IN_BALL, OPEN_BALL, DIST_REFL]);

val FRONTIER_SUBSET_CLOSED = store_thm ("FRONTIER_SUBSET_CLOSED",
 ``!s. closed s ==> (frontier s) SUBSET s``,
  METIS_TAC[frontier, CLOSURE_CLOSED, DIFF_SUBSET]);

val FRONTIER_EMPTY = store_thm ("FRONTIER_EMPTY",
 ``frontier {} = {}``,
  REWRITE_TAC[frontier, CLOSURE_EMPTY, EMPTY_DIFF]);

val FRONTIER_UNIV = store_thm ("FRONTIER_UNIV",
 ``frontier univ(:real) = {}``,
  REWRITE_TAC[frontier, CLOSURE_UNIV, INTERIOR_UNIV] THEN SET_TAC[]);

val FRONTIER_SUBSET_EQ = store_thm ("FRONTIER_SUBSET_EQ",
 ``!s:real->bool. (frontier s) SUBSET s <=> closed s``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [FRONTIER_SUBSET_CLOSED] THEN
  REWRITE_TAC[frontier] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (SET_RULE
  ``s DIFF t SUBSET u ==> t SUBSET u ==> s SUBSET u``)) THEN
  REWRITE_TAC[INTERIOR_SUBSET, CLOSURE_SUBSET_EQ]);

val FRONTIER_COMPLEMENT = store_thm ("FRONTIER_COMPLEMENT",
 ``!s:real->bool. frontier(UNIV DIFF s) = frontier s``,
  REWRITE_TAC[frontier, CLOSURE_COMPLEMENT, INTERIOR_COMPLEMENT] THEN
  SET_TAC[]);

val FRONTIER_DISJOINT_EQ = store_thm ("FRONTIER_DISJOINT_EQ",
 ``!s. ((frontier s) INTER s = {}) <=> open s``,
  ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT, OPEN_CLOSED] THEN
  REWRITE_TAC[GSYM FRONTIER_SUBSET_EQ] THEN SET_TAC[]);

val FRONTIER_INTER_SUBSET = store_thm ("FRONTIER_INTER_SUBSET",
 ``!s t. frontier(s INTER t) SUBSET frontier(s) UNION frontier(t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTER] THEN
  MATCH_MP_TAC(SET_RULE ``cst SUBSET cs INTER ct
  ==> cst DIFF (s INTER t) SUBSET (cs DIFF s) UNION (ct DIFF t)``) THEN
  REWRITE_TAC[CLOSURE_INTER_SUBSET]);

val FRONTIER_UNION_SUBSET = store_thm ("FRONTIER_UNION_SUBSET",
 ``!s t:real->bool. frontier(s UNION t) SUBSET frontier s UNION frontier t``,
  ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT] THEN
  REWRITE_TAC[SET_RULE ``u DIFF (s UNION t) = (u DIFF s) INTER (u DIFF t)``] THEN
  REWRITE_TAC[FRONTIER_INTER_SUBSET]);

val FRONTIER_INTERIORS = store_thm ("FRONTIER_INTERIORS",
 ``!s. frontier s = univ(:real) DIFF interior(s) DIFF interior(univ(:real) DIFF s)``,
  REWRITE_TAC[frontier, CLOSURE_INTERIOR] THEN SET_TAC[]);

val FRONTIER_FRONTIER_SUBSET = store_thm ("FRONTIER_FRONTIER_SUBSET",
 ``!s:real->bool. frontier(frontier s) SUBSET frontier s``,
  GEN_TAC THEN GEN_REWR_TAC LAND_CONV [frontier] THEN
  SIMP_TAC std_ss [CLOSURE_CLOSED, FRONTIER_CLOSED] THEN SET_TAC[]);

val INTERIOR_FRONTIER = store_thm ("INTERIOR_FRONTIER",
 ``!s:real->bool.
    interior(frontier s) = interior(closure s) DIFF closure(interior s)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  REWRITE_TAC[GSYM INTERIOR_COMPLEMENT, GSYM INTERIOR_INTER, frontier] THEN
  GEN_TAC THEN AP_TERM_TAC THEN SET_TAC[]);

val INTERIOR_FRONTIER_EMPTY = store_thm ("INTERIOR_FRONTIER_EMPTY",
 ``!s:real->bool. open s \/ closed s ==> (interior(frontier s) = {})``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[INTERIOR_FRONTIER] THEN
  ASM_SIMP_TAC std_ss [CLOSURE_CLOSED, INTERIOR_OPEN] THEN
  REWRITE_TAC[SET_RULE ``(s DIFF t = {}) <=> s SUBSET t``] THEN
  REWRITE_TAC[INTERIOR_SUBSET, CLOSURE_SUBSET]);

val FRONTIER_FRONTIER = store_thm ("FRONTIER_FRONTIER",
 ``!s:real->bool. open s \/ closed s ==> (frontier(frontier s) = frontier s)``,
  GEN_TAC THEN GEN_REWR_TAC (RAND_CONV o LAND_CONV) [frontier] THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [INTERIOR_FRONTIER_EMPTY, CLOSURE_CLOSED, FRONTIER_CLOSED] THEN
  REWRITE_TAC[DIFF_EMPTY]);

val FRONTIER_FRONTIER_FRONTIER = store_thm ("FRONTIER_FRONTIER_FRONTIER",
 ``!s:real->bool. frontier(frontier(frontier s)) = frontier(frontier s)``,
  SIMP_TAC std_ss [FRONTIER_FRONTIER, FRONTIER_CLOSED]);

val lemma = prove (
 ``!s t x. x IN frontier s /\ x IN interior t ==> x IN frontier(s INTER t)``,
  REWRITE_TAC[FRONTIER_STRADDLE, IN_INTER, IN_INTERIOR, SUBSET_DEF, IN_BALL] THEN
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (X_CHOOSE_TAC ``d:real``)) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min d e:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_MIN] THEN ASM_MESON_TAC[]);

val UNION_FRONTIER = store_thm ("UNION_FRONTIER",
 ``!s t:real->bool. frontier(s) UNION frontier(t) =
   frontier(s UNION t) UNION frontier(s INTER t) UNION
   frontier(s) INTER frontier(t)``,
  REWRITE_TAC[SET_EQ_SUBSET, UNION_SUBSET,
   FRONTIER_UNION_SUBSET, FRONTIER_INTER_SUBSET,
   SET_RULE ``s INTER t SUBSET s UNION t``] THEN
  REWRITE_TAC[GSYM UNION_SUBSET] THEN REWRITE_TAC[SUBSET_DEF, IN_UNION] THEN
  KNOW_TAC ``((!s t x. x IN frontier s
      ==> x IN frontier (s UNION t) \/
          x IN frontier (s INTER t) \/
          x IN frontier s INTER frontier t) /\
 (!s t x.
      x IN frontier (s UNION t) \/
      x IN frontier (s INTER t) \/
      x IN frontier s INTER frontier t <=>
      x IN frontier (t UNION s) \/
      x IN frontier (t INTER s) \/
      x IN frontier t INTER frontier s))`` THENL
  [ALL_TAC, METIS_TAC []] THEN CONJ_TAC THENL
  [REPEAT STRIP_TAC, SIMP_TAC std_ss [UNION_COMM, INTER_COMM]] THEN
  ASM_CASES_TAC ``(x:real) IN frontier t`` THEN ASM_REWRITE_TAC[IN_INTER] THEN
  POP_ASSUM MP_TAC THEN GEN_REWR_TAC (LAND_CONV o RAND_CONV o RAND_CONV)
   [FRONTIER_INTERIORS] THEN
  REWRITE_TAC[DE_MORGAN_THM, IN_DIFF, IN_UNIV] THEN
  GEN_REWR_TAC RAND_CONV [DISJ_SYM] THEN MATCH_MP_TAC MONO_OR THEN
  ASM_SIMP_TAC std_ss [lemma] THEN
  POP_ASSUM MP_TAC THEN ONCE_REWRITE_TAC[GSYM FRONTIER_COMPLEMENT] THEN
  SIMP_TAC std_ss [lemma, SET_RULE
  ``UNIV DIFF (s UNION t) = (UNIV DIFF s) INTER (UNIV DIFF t)``]);

val CONNECTED_INTER_FRONTIER = store_thm ("CONNECTED_INTER_FRONTIER",
 ``!s t:real->bool.
    connected s /\ ~(s INTER t = {}) /\ ~(s DIFF t = {})
    ==> ~(s INTER frontier t = {})``,
  REWRITE_TAC[FRONTIER_INTERIORS] THEN REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected s`` THEN REWRITE_TAC [CONNECTED_OPEN_IN] THEN
  MAP_EVERY EXISTS_TAC
   [``s INTER interior t:real->bool``,
    ``s INTER (interior(univ(:real) DIFF t))``] THEN
  SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_INTERIOR] THEN
  MAP_EVERY (MP_TAC o C ISPEC INTERIOR_SUBSET)
   [``t:real->bool``, ``univ(:real) DIFF t``] THEN
  ASM_SET_TAC[]);

val INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER = store_thm ("INTERIOR_CLOSED_EQ_EMPTY_AS_FRONTIER",
 ``!s:real->bool. closed s /\ (interior s = {}) <=>
                ?t. open t /\ (s = frontier t)``,
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [EXISTS_TAC ``univ(:real) DIFF s`` THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, OPEN_UNIV, FRONTIER_COMPLEMENT] THEN
  ASM_SIMP_TAC std_ss [frontier, CLOSURE_CLOSED, DIFF_EMPTY],
  ASM_SIMP_TAC std_ss [FRONTIER_CLOSED, INTERIOR_FRONTIER_EMPTY]]);

val FRONTIER_UNION = store_thm ("FRONTIER_UNION",
 ``!s t:real->bool. (closure s INTER closure t = {})
    ==> (frontier(s UNION t) = frontier(s) UNION frontier(t))``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[FRONTIER_UNION_SUBSET] THEN
  GEN_REWR_TAC RAND_CONV [frontier] THEN
  REWRITE_TAC[CLOSURE_UNION] THEN MATCH_MP_TAC(SET_RULE
  ``(fs SUBSET cs /\ ft SUBSET ct) /\ (k INTER fs = {}) /\ (k INTER ft = {})
    ==> (fs UNION ft) SUBSET (cs UNION ct) DIFF k``) THEN
  CONJ_TAC THENL [REWRITE_TAC[frontier] THEN SET_TAC[], ALL_TAC] THEN
  CONJ_TAC THENL [ALL_TAC,
   ONCE_REWRITE_TAC[UNION_COMM] THEN
   RULE_ASSUM_TAC(ONCE_REWRITE_RULE[INTER_COMM])] THEN
   FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
   ``(s INTER t = {}) ==> s' SUBSET s /\ (s' INTER u INTER (UNIV DIFF t) = {})
     ==> (u INTER s' = {})``)) THEN
  REWRITE_TAC[frontier, DIFF_SUBSET, GSYM INTERIOR_COMPLEMENT] THENL
  [KNOW_TAC ``(closure s DIFF interior s) INTER
                     interior (s UNION t) INTER
            interior (univ(:real) DIFF t) =
              (closure s DIFF interior s) INTER
           interior ((s UNION t) INTER (univ(:real) DIFF t))`` THENL
   [METIS_TAC [INTERIOR_INTER, INTER_ASSOC], ALL_TAC] THEN DISC_RW_KILL,
   KNOW_TAC ``(closure t DIFF interior t) INTER
                    interior (t UNION s) INTER
           interior (univ(:real) DIFF s) =
             (closure t DIFF interior t) INTER
           interior ((t UNION s) INTER (univ(:real) DIFF s))`` THENL
   [METIS_TAC [INTERIOR_INTER, INTER_ASSOC], ALL_TAC] THEN DISC_RW_KILL] THEN
  REWRITE_TAC[SET_RULE ``(s UNION t) INTER (UNIV DIFF t) = s DIFF t``] THEN
  MATCH_MP_TAC(SET_RULE
  ``ti SUBSET si ==> ((c DIFF si) INTER ti = {})``) THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, DIFF_SUBSET]);

val CLOSURE_UNION_FRONTIER = store_thm ("CLOSURE_UNION_FRONTIER",
 ``!s:real->bool. closure s = s UNION frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier] THEN
  MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  SET_TAC[]);

val FRONTIER_INTERIOR_SUBSET = store_thm ("FRONTIER_INTERIOR_SUBSET",
 ``!s:real->bool. frontier(interior s) SUBSET frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTERIOR] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> s DIFF u SUBSET t DIFF u``) THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, INTERIOR_SUBSET]);

val FRONTIER_CLOSURE_SUBSET = store_thm ("FRONTIER_CLOSURE_SUBSET",
 ``!s:real->bool. frontier(closure s) SUBSET frontier s``,
  GEN_TAC THEN REWRITE_TAC[frontier, CLOSURE_CLOSURE] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> u DIFF t SUBSET u DIFF s``) THEN
  SIMP_TAC std_ss [SUBSET_INTERIOR, CLOSURE_SUBSET]);

val SET_DIFF_FRONTIER = store_thm ("SET_DIFF_FRONTIER",
 ``!s:real->bool. s DIFF frontier s = interior s``,
  GEN_TAC THEN REWRITE_TAC[frontier] THEN
  MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN
  MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN
  SET_TAC[]);

val FRONTIER_INTER_SUBSET_INTER = store_thm ("FRONTIER_INTER_SUBSET_INTER",
 ``!s t:real->bool.
   frontier(s INTER t) SUBSET closure s INTER frontier t UNION
   frontier s INTER closure t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[frontier, INTERIOR_INTER] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
   CLOSURE_INTER_SUBSET) THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Identify trivial limits, where we can't approach arbitrarily closely.     *)
(* ------------------------------------------------------------------------- *)

val trivial_limit = new_definition ("trivial_limit",
  ``trivial_limit net <=>
     (!a:'a b. a = b) \/
     ?a:'a b. ~(a = b) /\ !x. ~(netord(net) x a) /\ ~(netord(net) x b)``);

val TRIVIAL_LIMIT_WITHIN = store_thm ("TRIVIAL_LIMIT_WITHIN",
 ``!a:real. trivial_limit (at a within s) <=> ~(a limit_point_of s)``,
  REWRITE_TAC[trivial_limit, LIMPT_APPROACHABLE_LE, WITHIN, AT, DIST_NZ] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(DISJ_CASES_THEN MP_TAC) THENL
     [MESON_TAC[REAL_LT_01, REAL_LT_REFL, REAL_CHOOSE_DIST,
                DIST_REFL, REAL_LT_IMP_LE],
      DISCH_THEN(X_CHOOSE_THEN ``b:real`` (X_CHOOSE_THEN ``c:real``
        STRIP_ASSUME_TAC)) THEN
      SUBGOAL_THEN ``&0 < dist(a,b:real) \/ &0 < dist(a,c:real)`` MP_TAC THEN
      ASM_MESON_TAC[DIST_TRIANGLE, DIST_SYM, GSYM DIST_NZ, GSYM DIST_EQ_0,
                    REAL_ARITH ``x:real <= &0 + &0 ==> ~(&0 < x)``]],
    KNOW_TAC ``!e. (0 < e ==> ?x'. x' IN s /\ 0 < dist (x',a) /\ dist (x',a) <= e) =
           (\e. 0 < e ==> ?x'. x' IN s /\ 0 < dist (x',a) /\ dist (x',a) <= e) e`` THENL
    [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
    REWRITE_TAC[NOT_FORALL_THM] THEN BETA_TAC THEN REWRITE_TAC [NOT_IMP] THEN
    SIMP_TAC std_ss [GSYM LEFT_EXISTS_IMP_THM] THEN
    STRIP_TAC THEN DISJ2_TAC THEN
    EXISTS_TAC ``a:real`` THEN
    SUBGOAL_THEN ``?b:real. dist(a,b) = x`` MP_TAC THENL
     [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_LT_IMP_LE], ALL_TAC] THEN
    STRIP_TAC THEN EXISTS_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
    DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
    ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_NZ, DIST_SYM]]);

val TRIVIAL_LIMIT_AT = store_thm ("TRIVIAL_LIMIT_AT",
 ``!a. ~(trivial_limit (at a))``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN, LIMPT_UNIV]);

val TRIVIAL_LIMIT_AT_INFINITY = store_thm ("TRIVIAL_LIMIT_AT_INFINITY",
 ``~(trivial_limit at_infinity)``,
  REWRITE_TAC[trivial_limit, AT_INFINITY, real_ge] THEN
  MESON_TAC[REAL_LE_REFL, REAL_CHOOSE_SIZE, REAL_LT_01, REAL_LT_LE]);

val TRIVIAL_LIMIT_AT_POSINFINITY = store_thm ("TRIVIAL_LIMIT_AT_POSINFINITY",
 ``~(trivial_limit at_posinfinity)``,
  REWRITE_TAC[trivial_limit, AT_POSINFINITY, DE_MORGAN_THM] THEN
  CONJ_TAC THENL
   [DISCH_THEN(MP_TAC o SPECL [``&0:real``, ``&1:real``]) THEN REAL_ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[DE_MORGAN_THM, NOT_EXISTS_THM, real_ge, REAL_NOT_LE] THEN
  MESON_TAC[REAL_LT_TOTAL, REAL_LT_ANTISYM]);

val TRIVIAL_LIMIT_AT_NEGINFINITY = store_thm ("TRIVIAL_LIMIT_AT_NEGINFINITY",
 ``~(trivial_limit at_neginfinity)``,
  REWRITE_TAC[trivial_limit, AT_NEGINFINITY, DE_MORGAN_THM] THEN
  CONJ_TAC THENL
   [DISCH_THEN(MP_TAC o SPECL [``&0:real``, ``&1:real``]) THEN REAL_ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[DE_MORGAN_THM, NOT_EXISTS_THM, real_ge, REAL_NOT_LE] THEN
  MESON_TAC[REAL_LT_TOTAL, REAL_LT_ANTISYM]);

val TRIVIAL_LIMIT_SEQUENTIALLY = store_thm ("TRIVIAL_LIMIT_SEQUENTIALLY",
 ``~(trivial_limit sequentially)``,
  REWRITE_TAC[trivial_limit, SEQUENTIALLY] THEN
  MESON_TAC[GREATER_EQ, LESS_EQ_REFL, SUC_NOT]);

val LIM_WITHIN_CLOSED_TRIVIAL = store_thm ("LIM_WITHIN_CLOSED_TRIVIAL",
 ``!a s. closed s /\ ~(a IN s) ==> trivial_limit (at a within s)``,
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN] THEN MESON_TAC[CLOSED_LIMPT]);

val NONTRIVIAL_LIMIT_WITHIN = store_thm ("NONTRIVIAL_LIMIT_WITHIN",
 ``!net s. trivial_limit net ==> trivial_limit(net within s)``,
  REWRITE_TAC[trivial_limit, WITHIN] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some property holds "sufficiently close" to the limit point.              *)
(* ------------------------------------------------------------------------- *)

val eventually = new_definition ("eventually",
 ``eventually p net <=>
        trivial_limit net \/
        ?y. (?x. netord net x y) /\ (!x. netord net x y ==> p x)``);

val EVENTUALLY_HAPPENS = store_thm ("EVENTUALLY_HAPPENS",
 ``!net p. eventually p net ==> trivial_limit net \/ ?x. p x``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_WITHIN_LE = store_thm ("EVENTUALLY_WITHIN_LE",
 ``!s a:real p.
     eventually p (at a within s) <=>
        ?d. &0 < d /\ !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) <= d ==> p(x)``,
  REWRITE_TAC[eventually, AT, WITHIN, TRIVIAL_LIMIT_WITHIN] THEN
  REWRITE_TAC[LIMPT_APPROACHABLE_LE, DIST_NZ] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [MESON_TAC[REAL_LTE_TRANS], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC(TAUT `(a ==> b) ==> ~a \/ b`) THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?b:real. dist(a,b) = d`` MP_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_CHOOSE_DIST, REAL_LT_IMP_LE], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``b:real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
  ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_NZ, DIST_SYM]);

val EVENTUALLY_WITHIN = store_thm ("EVENTUALLY_WITHIN",
 ``!s a:real p.
     eventually p (at a within s) <=>
        ?d. &0 < d /\ !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) < d ==> p(x)``,
  REWRITE_TAC[EVENTUALLY_WITHIN_LE] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c ==> d <=> c ==> a /\ b ==> d`] THEN
  SIMP_TAC std_ss [APPROACHABLE_LT_LE]);

val EVENTUALLY_AT = store_thm ("EVENTUALLY_AT",
 ``!a p. eventually p (at a) <=>
         ?d. &0 < d /\ !x. &0 < dist(x,a) /\ dist(x,a) < d ==> p(x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[EVENTUALLY_WITHIN, IN_UNIV]);

val EVENTUALLY_SEQUENTIALLY = store_thm ("EVENTUALLY_SEQUENTIALLY",
 ``!p. eventually p sequentially <=> ?N. !n. N <= n ==> p n``,
  REWRITE_TAC[eventually, SEQUENTIALLY, GREATER_EQ, LESS_EQ_REFL,
    TRIVIAL_LIMIT_SEQUENTIALLY] THEN  MESON_TAC[LESS_EQ_REFL]);

val EVENTUALLY_AT_INFINITY = store_thm ("EVENTUALLY_AT_INFINITY",
 ``!p. eventually p at_infinity <=> ?b. !x. abs(x) >= b ==> p x``,
  SIMP_TAC std_ss [eventually, AT_INFINITY, TRIVIAL_LIMIT_AT_INFINITY] THEN
  REPEAT GEN_TAC THEN EQ_TAC THENL [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
  MESON_TAC[real_ge, REAL_LE_REFL, REAL_CHOOSE_SIZE,
    REAL_ARITH ``&0 <= b:real \/ (!x. x >= &0 ==> x >= b)``]);

val EVENTUALLY_AT_POSINFINITY = store_thm ("EVENTUALLY_AT_POSINFINITY",
 ``!p. eventually p at_posinfinity <=> ?b. !x. x >= b ==> p x``,
  REWRITE_TAC[eventually, TRIVIAL_LIMIT_AT_POSINFINITY, AT_POSINFINITY] THEN
  MESON_TAC[REAL_ARITH ``x >= x``]);

val EVENTUALLY_AT_NEGINFINITY = store_thm ("EVENTUALLY_AT_NEGINFINITY",
 ``!p. eventually p at_neginfinity <=> ?b. !x. x <= b ==> p x``,
  REWRITE_TAC[eventually, TRIVIAL_LIMIT_AT_NEGINFINITY, AT_NEGINFINITY] THEN
  MESON_TAC[REAL_LE_REFL]);

val EVENTUALLY_AT_INFINITY_POS = store_thm ("EVENTUALLY_AT_INFINITY_POS",
 ``!p:real->bool.
        eventually p at_infinity <=> ?b. &0 < b /\ !x. abs x >= b ==> p x``,
  GEN_TAC THEN REWRITE_TAC[EVENTUALLY_AT_INFINITY, real_ge] THEN
  MESON_TAC[REAL_ARITH ``&0 < abs b + &1 /\ (abs b + &1 <= x ==> b <= x:real)``]);

val ALWAYS_EVENTUALLY = store_thm ("ALWAYS_EVENTUALLY",
 ``(!x. p x) ==> eventually p net``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[eventually, trivial_limit] THEN
  MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Combining theorems for "eventually". *)
(* ------------------------------------------------------------------------- *)

val EVENTUALLY_AND = store_thm ("EVENTUALLY_AND",
 ``!net:('a net) p q.
   eventually (\x. p x /\ q x) net <=>
   eventually p net /\ eventually q net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[eventually] THEN
  ASM_CASES_TAC ``trivial_limit(net:('a net))`` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THEN SIMP_TAC std_ss [NET_DILEMMA] THENL [MESON_TAC [], ALL_TAC] THEN
  DISCH_TAC THEN MATCH_MP_TAC NET_DILEMMA THEN METIS_TAC []);

val EVENTUALLY_MONO = store_thm ("EVENTUALLY_MONO",
 ``!net:('a net) p q.
  (!x. p x ==> q x) /\ eventually p net
    ==> eventually q net``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_MP = store_thm ("EVENTUALLY_MP",
 ``!net:('a net) p q.
  eventually (\x. p x ==> q x) net /\ eventually p net
  ==> eventually q net``,
  REWRITE_TAC[GSYM EVENTUALLY_AND] THEN
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_FALSE = store_thm ("EVENTUALLY_FALSE",
 ``!net. eventually (\x. F) net <=> trivial_limit net``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_TRUE = store_thm ("EVENTUALLY_TRUE",
 ``!net. eventually (\x. T) net <=> T``,
  REWRITE_TAC[eventually, trivial_limit] THEN MESON_TAC[]);

val NOT_EVENTUALLY = store_thm ("NOT_EVENTUALLY",
 ``!net p. (!x. ~(p x)) /\ ~(trivial_limit net) ==> ~(eventually p net)``,
  REWRITE_TAC[eventually] THEN MESON_TAC[]);

val EVENTUALLY_FORALL = store_thm ("EVENTUALLY_FORALL",
 ``!net:('a net) p s:'b->bool.
  FINITE s /\ ~(s = {})
  ==> (eventually (\x. !a. a IN s ==> p a x) net <=>
   !a. a IN s ==> eventually (p a) net)``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s:'b->bool. (s <> ({} :'b -> bool) ==>
   (eventually (\(x :'a). !(a :'b). a IN s ==> (p :'b -> 'a -> bool) a x)
   (net :'a net) <=> !(a :'b). a IN s ==> eventually (p a) net)) =
             (\s. s <> ({} :'b -> bool) ==>
   (eventually (\(x :'a). !(a :'b). a IN s ==> (p :'b -> 'a -> bool) a x)
   (net :'a net) <=> !(a :'b). a IN s ==> eventually (p a) net)) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, EVENTUALLY_AND, ETA_AX] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  MAP_EVERY X_GEN_TAC [``t:'b->bool``, ``b:'b``] THEN
  ASM_CASES_TAC ``t:'b->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, EVENTUALLY_TRUE] THEN METIS_TAC []);

val FORALL_EVENTUALLY = store_thm ("FORALL_EVENTUALLY",
 ``!net:('a net) p s:'b->bool.
   FINITE s /\ ~(s = {})
   ==> ((!a. a IN s ==> eventually (p a) net) <=>
   eventually (\x. !a. a IN s ==> p a x) net)``,
  SIMP_TAC std_ss [EVENTUALLY_FORALL]);

(* ------------------------------------------------------------------------- *)
(* Limits, defined as vacuously true when the limit is trivial.              *)
(* ------------------------------------------------------------------------- *)

(* NOTE: This is for (f :'a -> real) (l :real) (net :'a net).
         Now the name "tendsto_real" follows HOL-Light's "realanalysis.ml".
 *)
Definition tendsto_real :
    tendsto_real f l net <=> !e. &0 < e ==> eventually (\x. dist(f(x),l) < e) net
End

Overload "-->" = “tendsto_real”
val _ = set_fixity "-->" (Infixr 750);

val tendsto = tendsto_real;

(* LONG RIGHTWARDS ARROW *)
val _ = Unicode.unicode_version {u = UTF8.chr 0x27F6, tmnm = "-->"};
val _ = TeX_notation {hol = UTF8.chr 0x27F6, TeX = ("\\HOLTokenLongmap{}", 1)};
val _ = TeX_notation {hol = "-->",           TeX = ("\\HOLTokenLongmap{}", 1)};

(* Now the name "reallim" follows HOL-Light's "realanalysis.ml" *)
Definition reallim :
    reallim net f = @l. (f --> l) net
End
Overload lim = “reallim”

(* cf. limTheory.LIM *)
Theorem LIM_DEF : (* was: LIM *)
   !f l net. (f --> l) net <=>
        trivial_limit net \/
        !e. &0 < e ==> ?y. (?x. netord(net) x y) /\
                           !x. netord(net) x y ==> dist(f(x),l) < e
Proof
  REWRITE_TAC[tendsto, eventually] THEN MESON_TAC[]
QED
val LIM = LIM_DEF;

(* ------------------------------------------------------------------------- *)
(* Show that they yield usual definitions in the various cases.              *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_LE = store_thm ("LIM_WITHIN_LE",
 ``!f:real->real l a s.
        (f --> l)(at a within s) <=>
           !e. &0 < e ==> ?d. &0 < d /\
                              !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) <= d
                                   ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN_LE]);

val LIM_WITHIN = store_thm ("LIM_WITHIN",
 ``!f:real->real l a s.
      (f --> l) (at a within s) <=>
        !e. &0 < e
            ==> ?d. &0 < d /\
                    !x. x IN s /\ &0 < dist(x,a) /\ dist(x,a) < d
                    ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN] THEN MESON_TAC[]);

val LIM_AT_LE = store_thm ("LIM_AT_LE",
 ``!f l a. (f --> l) (at a) <=>
           !e. &0 < e
               ==> ?d. &0 < d /\
                       !x. &0 < dist(x,a) /\ dist(x,a) <= d
                           ==> dist (f x,l) < e``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[LIM_WITHIN_LE, IN_UNIV]);

val LIM_AT = store_thm ("LIM_AT",
 ``!f l:real a:real.
      (f --> l) (at a) <=>
              !e. &0 < e
                  ==> ?d. &0 < d /\ !x. &0 < dist(x,a) /\ dist(x,a) < d
                          ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT] THEN MESON_TAC[]);

val LIM_AT_INFINITY = store_thm ("LIM_AT_INFINITY",
 ``!f l. (f --> l) at_infinity <=>
               !e. &0 < e ==> ?b. !x. abs(x) >= b ==> dist(f(x),l) < e``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_AT_INFINITY] THEN MESON_TAC[]);

val LIM_AT_INFINITY_POS = store_thm ("LIM_AT_INFINITY_POS",
 ``!f l. (f --> l) at_infinity <=>
         !e. &0 < e ==> ?b. &0 < b /\ !x. abs x >= b ==> dist(f x,l) < e``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [LIM_AT_INFINITY] THEN
  METIS_TAC[REAL_ARITH ``&0 < abs b + &1 /\ (x >= abs b + &1 ==> x >= b)``]);

val LIM_AT_POSINFINITY = store_thm ("LIM_AT_POSINFINITY",
 ``!f l. (f --> l) at_posinfinity <=>
               !e. &0 < e ==> ?b. !x. x >= b ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT_POSINFINITY] THEN MESON_TAC[]);

val LIM_AT_NEGINFINITY = store_thm ("LIM_AT_NEGINFINITY",
 ``!f l. (f --> l) at_neginfinity <=>
               !e. &0 < e ==> ?b. !x. x <= b ==> dist(f(x),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_AT_NEGINFINITY] THEN MESON_TAC[]);

val LIM_SEQUENTIALLY = store_thm ("LIM_SEQUENTIALLY",
 ``!s l. (s --> l) sequentially <=>
          !e. &0 < e ==> ?N. !n. N <= n ==> dist(s(n),l) < e``,
  REWRITE_TAC[tendsto, EVENTUALLY_SEQUENTIALLY] THEN MESON_TAC[]);

val LIM_EVENTUALLY = store_thm ("LIM_EVENTUALLY",
 ``!net f l. eventually (\x. f x = l) net ==> (f --> l) net``,
  REWRITE_TAC[eventually, LIM] THEN MESON_TAC[DIST_REFL]);

val LIM_POSINFINITY_SEQUENTIALLY = store_thm ("LIM_POSINFINITY_SEQUENTIALLY",
 ``!f l. (f --> l) at_posinfinity ==> ((\n. f(&n)) --> l) sequentially``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[LIM_AT_POSINFINITY, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real``) THEN
  MP_TAC(ISPEC ``B:real`` SIMP_REAL_ARCH) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``N:num`` THEN POP_ASSUM MP_TAC THEN
  REPEAT STRIP_TAC THEN BETA_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM REAL_OF_NUM_LE]) THEN
  METIS_TAC [real_ge, REAL_LE_TRANS]);

val LIM_INFINITY_POSINFINITY = store_thm ("LIM_INFINITY_POSINFINITY",
 ``!f l:real. (f --> l) at_infinity ==> (f --> l) at_posinfinity``,
  SIMP_TAC std_ss [LIM_AT_INFINITY, LIM_AT_POSINFINITY, o_THM] THEN
  METIS_TAC[dist, REAL_ARITH ``x >= b ==> abs(x) >= b:real``]);

(* ------------------------------------------------------------------------- *)
(* The expected monotonicity property.                                       *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_EMPTY = store_thm ("LIM_WITHIN_EMPTY",
 ``!f l x. (f --> l) (at x within {})``,
  REWRITE_TAC[LIM_WITHIN, NOT_IN_EMPTY] THEN MESON_TAC[REAL_LT_01]);

val LIM_WITHIN_SUBSET = store_thm ("LIM_WITHIN_SUBSET",
 ``!f l a s.
    (f --> l) (at a within s) /\ t SUBSET s ==> (f --> l) (at a within t)``,
  REWRITE_TAC[LIM_WITHIN, SUBSET_DEF] THEN MESON_TAC[]);

val LIM_UNION = store_thm ("LIM_UNION",
 ``!f x l s t.
        (f --> l) (at x within s) /\ (f --> l) (at x within t)
        ==> (f --> l) (at x within (s UNION t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM_WITHIN, IN_UNION] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``d1:real``) (X_CHOOSE_TAC ``d2:real``)) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_MESON_TAC[REAL_LT_MIN]);

val LIM_UNION_UNIV = store_thm ("LIM_UNION_UNIV",
 ``!f x l s t.
        (f --> l) (at x within s) /\ (f --> l) (at x within t) /\
        (s UNION t = univ(:real)) ==> (f --> l) (at x)``,
  MESON_TAC[LIM_UNION, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Composition of limits.                                                    *)
(* ------------------------------------------------------------------------- *)

val LIM_COMPOSE_WITHIN = store_thm ("LIM_COMPOSE_WITHIN",
 ``!net f:'a->real g:real->real s y z.
    (f --> y) net /\
    eventually (\w. f w IN s /\ ((f w = y) ==> (g y = z))) net /\
    (g --> z) (at y within s)
    ==> ((g o f) --> z) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[tendsto, CONJ_ASSOC] THEN
  KNOW_TAC ``(!e. (&0 < e ==> eventually (\x. dist ((f:'a->real) x,y) < e) net) /\
             eventually (\w. f w IN s /\ ((f w = y) ==> ((g:real->real) y = z))) net) /\
   (!e. &0 < e ==> eventually (\x. dist (g x,z) < e) (at y within s))
   ==> (!e. &0 < e ==> eventually (\x. dist ((g o f) x,z) < e) net)`` THENL
  [ALL_TAC, SIMP_TAC std_ss [LEFT_AND_FORALL_THM]] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  STRIP_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[EVENTUALLY_WITHIN, GSYM DIST_NZ, o_DEF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!e. (0 < e ==> eventually (\x. dist (f x,y) < e) net) /\
        eventually (\w. f w IN s /\ ((f:'a->real w = y) ==> (g:real->real y = z))) net`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``d:real``) THEN
  ASM_REWRITE_TAC[GSYM EVENTUALLY_AND] THEN BETA_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  ASM_MESON_TAC[DIST_REFL]);

val LIM_COMPOSE_AT = store_thm ("LIM_COMPOSE_AT",
 ``!net f:'a->real g:real->real y z.
    (f --> y) net /\
    eventually (\w. (f w = y) ==> (g y = z)) net /\
    (g --> z) (at y)
    ==> ((g o f) --> z) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``net:('a)net``, ``f:'a->real``, ``g:real->real``,
                 ``univ(:real)``, ``y:real``, ``z:real``]
        LIM_COMPOSE_WITHIN) THEN
  ASM_REWRITE_TAC[IN_UNIV, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Interrelations between restricted and unrestricted limits.                *)
(* ------------------------------------------------------------------------- *)

val LIM_AT_WITHIN = store_thm ("LIM_AT_WITHIN",
 ``!f l a s. (f --> l)(at a) ==> (f --> l)(at a within s)``,
  REWRITE_TAC[LIM_AT, LIM_WITHIN] THEN MESON_TAC[]);

val LIM_WITHIN_OPEN = store_thm ("LIM_WITHIN_OPEN",
 ``!f l a:real s.
     a IN s /\ open s ==> ((f --> l)(at a within s) <=> (f --> l)(at a))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [LIM_AT_WITHIN] THEN
  REWRITE_TAC[LIM_AT, LIM_WITHIN] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
   DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``open s`` THEN GEN_REWR_TAC LAND_CONV [open_def] THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(SPECL [``d1:real``, ``d2:real``] REAL_DOWN2) THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[REAL_LT_TRANS]);

(* ------------------------------------------------------------------------- *)
(* More limit point characterizations.                                       *)
(* ------------------------------------------------------------------------- *)

val TRANSITIVE_STEPWISE_LT_EQ = store_thm ("TRANSITIVE_STEPWISE_LT_EQ",
 ``!R. (!x y z. R x y /\ R y z ==> R x z)
         ==> ((!m n. m < n ==> R m n) <=> (!n. R n (SUC n)))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC std_ss [LESS_THM] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [LT_EXISTS] THEN
  KNOW_TAC ``(!m n. (?d. n = m + SUC d) ==> R m n) =
              (!m d n. (n = m + SUC d) ==> R m (m + SUC d))`` THENL
  [METIS_TAC [LEFT_EXISTS_IMP_THM, SWAP_FORALL_THM], ALL_TAC] THEN
  DISC_RW_KILL THEN GEN_TAC THEN
  SIMP_TAC std_ss [LEFT_FORALL_IMP_THM, EXISTS_REFL, ADD_CLAUSES] THEN
  INDUCT_TAC THEN REWRITE_TAC[ADD_CLAUSES] THEN ASM_MESON_TAC[]);

val TRANSITIVE_STEPWISE_LT = store_thm ("TRANSITIVE_STEPWISE_LT",
 ``!R. (!x y z. R x y /\ R y z ==> R x z) /\ (!n. R n (SUC n))
       ==> !m n. m < n ==> R m n``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(a ==> (c <=> b)) ==> a /\ b ==> c`) THEN
  MATCH_ACCEPT_TAC TRANSITIVE_STEPWISE_LT_EQ);

val LIMPT_SEQUENTIAL_INJ = store_thm ("LIMPT_SEQUENTIAL_INJ",
 ``!x:real s.
      x limit_point_of s <=>
             ?f. (!n. f(n) IN (s DELETE x)) /\
                 (!m n. (f m = f n) <=> (m = n)) /\
                 (f --> x) sequentially``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[LIMPT_APPROACHABLE, LIM_SEQUENTIALLY, IN_DELETE] THEN
  EQ_TAC THENL [ALL_TAC, MESON_TAC[GREATER_EQ, LESS_EQ_REFL]] THEN
  KNOW_TAC ``(!e. 0 < e ==> ?x'. x' IN s /\ x' <> x /\ dist (x',x) < e) =
             (!e. ?x'. &0 < e ==> x' IN s /\ ~(x' = x) /\ dist (x',x) < e)`` THENL
  [SIMP_TAC std_ss [GSYM RIGHT_EXISTS_IMP_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN STRIP_TAC THEN
  KNOW_TAC ``?z. (z 0 = f (&1)) /\
    (!n. z (SUC n):real = f (min (inv(&2 pow (SUC n))) (dist(z n,x))))`` THENL
  [RW_TAC real_ss [num_Axiom], ALL_TAC] THEN STRIP_TAC THEN
  EXISTS_TAC ``z:num->real`` THEN
  SUBGOAL_THEN
   ``!n. z(n) IN s /\ ~(z n:real = x) /\ dist(z n,x) < inv(&2 pow n)``
  ASSUME_TAC THENL
   [INDUCT_TAC THEN ASM_REWRITE_TAC[] THENL [REWRITE_TAC [pow, REAL_INV1] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_01], FIRST_X_ASSUM(MP_TAC o SPEC
     ``min (inv(&2 pow (SUC n))) (dist(z n:real,x))``) THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MIN, REAL_LT_INV_EQ, REAL_POW_LT, DIST_POS_LT,
                         REAL_ARITH ``0:real < 2``]],
    ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
     [KNOW_TAC ``!m:num n. (((z:num->real) m = z n) <=> (m = n)) =
                    (\m n. ((z m = z n) <=> (m = n))) m n`` THENL
     [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
     MATCH_MP_TAC WLOG_LT THEN BETA_TAC THEN SIMP_TAC std_ss [EQ_SYM_EQ] THEN
      SUBGOAL_THEN ``!m n:num. m < n ==> dist(z n:real,x) < dist(z m,x)``
       (fn th => MESON_TAC[th, REAL_LT_REFL, LESS_REFL]) THEN
      KNOW_TAC ``!m n:num.  (dist (z n,x) < dist (z m,x)) =
                     (\m n.  dist (z n,x) < dist (z m,x)) m n`` THENL
      [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
      MATCH_MP_TAC TRANSITIVE_STEPWISE_LT THEN BETA_TAC THEN
      CONJ_TAC THENL [REAL_ARITH_TAC, GEN_TAC THEN ASM_REWRITE_TAC[]] THEN
      FIRST_X_ASSUM(MP_TAC o SPEC
       ``min (inv(&2 pow (SUC n))) (dist(z n:real,x))``) THEN
      ASM_SIMP_TAC std_ss [REAL_LT_MIN, REAL_LT_INV_EQ, REAL_POW_LT,
      REAL_ARITH ``0:real < 2``, DIST_POS_LT],
      X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
      MP_TAC(ISPECL [``inv(&2:real)``, ``e:real``] REAL_ARCH_POW_INV) THEN
      ASM_SIMP_TAC std_ss [REAL_INV_1OVER, REAL_HALF_BETWEEN] THEN
      DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
      FULL_SIMP_TAC std_ss [GSYM REAL_INV_1OVER, REAL_POW_INV] THEN
      X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN MATCH_MP_TAC REAL_LT_TRANS THEN
      EXISTS_TAC ``inv (2:real pow N)`` THEN ASM_REWRITE_TAC [] THEN
      MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``inv(&2:real pow n)`` THEN
      ASM_REWRITE_TAC [] THEN REWRITE_TAC [REAL_INV_1OVER] THEN
      SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_POW_LT, REAL_ARITH ``0 < 2:real``] THEN
      ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN
      REWRITE_TAC [GSYM REAL_INV_1OVER, GSYM real_div] THEN SIMP_TAC std_ss [REAL_LE_RDIV_EQ,
      REAL_POW_LT, REAL_MUL_LID, REAL_ARITH ``0 < 2:real``] THEN
      FULL_SIMP_TAC std_ss [REAL_LE_LT, LESS_OR_EQ] THEN DISJ1_TAC THEN
      MATCH_MP_TAC REAL_POW_MONO_LT THEN ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC]]);

val LIMPT_SEQUENTIAL = store_thm ("LIMPT_SEQUENTIAL",
 ``!x:real s.
      x limit_point_of s <=>
             ?f. (!n. f(n) IN (s DELETE x)) /\ (f --> x) sequentially``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[LIMPT_SEQUENTIAL_INJ] THEN MESON_TAC[],
    REWRITE_TAC[LIMPT_APPROACHABLE, LIM_SEQUENTIALLY, IN_DELETE] THEN
    MESON_TAC[GREATER_EQ, LESS_EQ_REFL]]);

val INFINITE_SUPERSET = store_thm ("INFINITE_SUPERSET",
 ``!s t. INFINITE s /\ s SUBSET t ==> INFINITE t``,
  REWRITE_TAC[] THEN MESON_TAC[SUBSET_FINITE_I]);

val LIMPT_INFINITE_OPEN_BALL_CBALL = store_thm ("LIMPT_INFINITE_OPEN_BALL_CBALL",
 ``(!s x:real.
        x limit_point_of s <=> !t. x IN t /\ open t ==> INFINITE(s INTER t)) /\
   (!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER ball(x,e))) /\
   (!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER cball(x,e)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(q ==> p) /\ (r ==> s) /\ (s ==> q) /\ (p ==> r)
    ==> (p <=> q) /\ (p <=> r) /\ (p <=> s)`) THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[limit_point_of, SET_RULE
     ``(?y. ~(y = x) /\ y IN s /\ y IN t) <=> ~(s INTER t SUBSET {x})``] THEN
    MESON_TAC[SUBSET_FINITE_I, FINITE_SING],
    MESON_TAC[INFINITE_SUPERSET, BALL_SUBSET_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    MESON_TAC[INFINITE_SUPERSET, OPEN_CONTAINS_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    REWRITE_TAC[LIMPT_SEQUENTIAL_INJ, IN_DELETE, FORALL_AND_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``f:num->real`` STRIP_ASSUME_TAC) THEN
    X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``(f --> x) sequentially`` THEN
    GEN_REWR_TAC LAND_CONV [LIM_SEQUENTIALLY] THEN
    DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN
    ASM_REWRITE_TAC[GSYM(ONCE_REWRITE_RULE[DIST_SYM] IN_BALL)] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
    MATCH_MP_TAC INFINITE_SUPERSET THEN
    EXISTS_TAC ``IMAGE (f:num->real) (from N)`` THEN
    ASM_SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_FROM, IN_INTER] THEN
    ASM_MESON_TAC[IMAGE_11_INFINITE, INFINITE_FROM]]);

val LIMPT_INFINITE_OPEN = store_thm ("LIMPT_INFINITE_OPEN",
 ``(!s x:real.
        x limit_point_of s <=> !t. x IN t /\ open t ==> INFINITE(s INTER t))``,
  SIMP_TAC std_ss [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val LIMPT_INFINITE_BALL = store_thm ("LIMPT_INFINITE_BALL",
 ``(!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER ball(x,e)))``,
  METIS_TAC [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val LIMPT_INFINITE_CBALL = store_thm ("LIMPT_INFINITE_CBALL",
 ``(!s x:real.
        x limit_point_of s <=> !e. &0 < e ==> INFINITE(s INTER cball(x,e)))``,
  METIS_TAC [LIMPT_INFINITE_OPEN_BALL_CBALL]);

val INFINITE_OPEN_IN = store_thm ("INFINITE_OPEN_IN",
 ``!u s:real->bool.
      open_in (subtopology euclidean u) s /\ (?x. x IN s /\ x limit_point_of u)
      ==> INFINITE s``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN
  REWRITE_TAC [OPEN_IN_OPEN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``x limit_point_of u`` THEN REWRITE_TAC [LIMPT_INFINITE_OPEN] THEN
  FIRST_X_ASSUM SUBST_ALL_TAC THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Condensation points.                                                      *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "condensation_point_of" (Infix(NONASSOC, 450));

val condensation_point_of = new_definition ("condensation_point_of",
 ``x condensation_point_of s <=>
        !t. x IN t /\ open t ==> ~COUNTABLE(s INTER t)``);

val CONDENSATION_POINT_OF_SUBSET = store_thm ("CONDENSATION_POINT_OF_SUBSET",
 ``!x:real s t.
        x condensation_point_of s /\ s SUBSET t ==> x condensation_point_of t``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  REWRITE_TAC[condensation_point_of] THEN
  DISCH_TAC THEN X_GEN_TAC ``t':real->bool`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `t':real->bool`) THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[GSYM MONO_NOT_EQ] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] COUNTABLE_SUBSET) THEN
  ASM_SET_TAC[]);

val CONDENSATION_POINT_IMP_LIMPT = store_thm ("CONDENSATION_POINT_IMP_LIMPT",
 ``!x s. x condensation_point_of s ==> x limit_point_of s``,
  REWRITE_TAC[condensation_point_of, LIMPT_INFINITE_OPEN] THEN
  MESON_TAC[FINITE_IMP_COUNTABLE]);

val CONDENSATION_POINT_INFINITE_BALL_CBALL = store_thm ("CONDENSATION_POINT_INFINITE_BALL_CBALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER ball(x,e))) /\
   (!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER cball(x,e)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(p ==> q) /\ (q ==> r) /\ (r ==> p)
    ==> (p <=> q) /\ (p <=> r)`) THEN
  REWRITE_TAC[condensation_point_of] THEN REPEAT CONJ_TAC THENL
   [MESON_TAC[OPEN_BALL, CENTRE_IN_BALL],
    MESON_TAC[BALL_SUBSET_CBALL, COUNTABLE_SUBSET,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``],
    MESON_TAC[COUNTABLE_SUBSET, OPEN_CONTAINS_CBALL,
              SET_RULE ``t SUBSET u ==> s INTER t SUBSET s INTER u``]]);

val CONDENSATION_POINT_INFINITE_BALL = store_thm ("CONDENSATION_POINT_INFINITE_BALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER ball(x,e)))``,
  METIS_TAC [CONDENSATION_POINT_INFINITE_BALL_CBALL]);

val CONDENSATION_POINT_INFINITE_CBALL = store_thm ("CONDENSATION_POINT_INFINITE_CBALL",
 ``(!s x:real.
        x condensation_point_of s <=>
        !e. &0 < e ==> ~COUNTABLE(s INTER cball(x,e)))``,
  METIS_TAC [CONDENSATION_POINT_INFINITE_BALL_CBALL]);

(* ------------------------------------------------------------------------- *)
(* Basic arithmetical combining theorems for limits.                         *)
(* ------------------------------------------------------------------------- *)

val LIM_LINEAR = store_thm ("LIM_LINEAR",
 ``!net:('a)net h f l.
        (f --> l) net /\ linear h ==> ((\x. h(f x)) --> h l) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
    MATCH_MP LINEAR_BOUNDED_POS) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!e. 0 < e ==> ?y. (?x. netord net x y) /\
          !x. netord net x y ==> dist (f x,l) < e`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / B:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, dist, GSYM LINEAR_SUB, REAL_LT_RDIV_EQ] THEN
  ASM_MESON_TAC[REAL_LET_TRANS, REAL_MUL_SYM]);

val LIM_CONST = store_thm ("LIM_CONST",
 ``!net a:real. ((\x. a) --> a) net``,
  SIMP_TAC std_ss [LIM, DIST_REFL, trivial_limit] THEN MESON_TAC[]);

val LIM_CMUL = store_thm ("LIM_CMUL",
 ``!f l c. (f --> l) net ==> ((\x. c * f x) --> (c * l)) net``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_LINEAR THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[ETA_AX]
    (MATCH_MP LINEAR_COMPOSE_CMUL LINEAR_ID)] THEN
  REWRITE_TAC [linear] THEN REAL_ARITH_TAC);

val LIM_CMUL_EQ = store_thm ("LIM_CMUL_EQ",
 ``!net f l c.
        ~(c = &0) ==> (((\x. c * f x) --> (c * l)) net <=> (f --> l) net)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [LIM_CMUL] THEN
  DISCH_THEN(MP_TAC o SPEC ``inv c:real`` o MATCH_MP LIM_CMUL) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID, ETA_AX]);

val LIM_NEG = store_thm ("LIM_NEG",
 ``!net f l:real. (f --> l) net ==> ((\x. -(f x)) --> -l) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM, dist] THEN
  SIMP_TAC std_ss [REAL_ARITH ``-x - -y = -(x - y:real)``, ABS_NEG]);

val LIM_NEG_EQ = store_thm ("LIM_NEG_EQ",
 ``!net f l:real. ((\x. -(f x)) --> -l) net <=> (f --> l) net``,
  REPEAT GEN_TAC THEN EQ_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG) THEN
  SIMP_TAC std_ss [REAL_NEG_NEG, ETA_AX]);

val LIM_ADD = store_thm ("LIM_ADD",
 ``!net:('a)net f g l m.
    (f --> l) net /\ (g --> m) net ==> ((\x. f(x) + g(x)) --> (l + m)) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN
  ASM_SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  KNOW_TAC ``!x y. (dist(f x, l) < e / 2:real) =
              (\x. (dist(f x, l) < e / 2:real)) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``!x y. (dist(g x, m) < e / 2:real) =
              (\x. (dist(g x, m) < e / 2:real)) x`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  DISCH_THEN(MP_TAC o MATCH_MP NET_DILEMMA) THEN BETA_TAC THEN
  STRIP_TAC THEN EXISTS_TAC ``c:'a`` THEN CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
  GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x'`) THEN REPEAT STRIP_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``dist (f x', l) + dist (g x', m)`` THEN
  METIS_TAC[REAL_LT_HALF1, REAL_LT_ADD2, DIST_TRIANGLE_ADD, GSYM REAL_HALF_DOUBLE]);

val lemma = prove (
 ``abs(x - y) <= abs(a - b) ==> dist(a,b) < e ==> dist(x,y) < e``,
  REWRITE_TAC [dist] THEN REAL_ARITH_TAC);

val LIM_ABS = store_thm ("LIM_ABS",
 ``!net:('a)net f:'a->real l.
     (f --> l) net
     ==> ((\x. abs(f(x))) --> (abs(l)):real) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit (net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``y:'a`` THEN POP_ASSUM MP_TAC THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  STRIP_TAC THENL [DISCH_TAC THEN EXISTS_TAC ``x:'a`` THEN ASM_REWRITE_TAC [],
   ALL_TAC] THEN DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `x:'a`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  MATCH_MP_TAC lemma THEN BETA_TAC THEN
  REAL_ARITH_TAC);

val LIM_SUB = store_thm ("LIM_SUB",
 ``!net:('a)net f g l m.
    (f --> l) net /\ (g --> m) net ==> ((\x. f(x) - g(x)) --> (l - m)) net``,
  REWRITE_TAC[real_sub] THEN ASM_SIMP_TAC std_ss [LIM_ADD, LIM_NEG]);

val LIM_MAX = store_thm ("LIM_MAX",
 ``!net:('a)net f g l:real m:real.
    (f --> l) net /\ (g --> m) net
    ==> ((\x. max (f(x)) (g(x)))
         --> (max (l) (m)):real) net``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LIM_ADD) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LIM_SUB) THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ABS) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  DISCH_THEN(MP_TAC o SPEC ``inv(&2:real)`` o MATCH_MP LIM_CMUL) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN BINOP_TAC THEN
  SIMP_TAC std_ss [FUN_EQ_THM, max_def, abs] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  SIMP_TAC arith_ss [REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN (RW_TAC arith_ss [REAL_SUB_LE] THENL
  [REPEAT (POP_ASSUM MP_TAC) THEN RW_TAC std_ss [AND_IMP_INTRO, REAL_LE_ANTISYM, REAL_SUB_REFL,
    REAL_ADD_LID] THEN  REWRITE_TAC [GSYM REAL_DOUBLE],
   REWRITE_TAC [REAL_ARITH ``a - b + (a + b) = a + a - b + b:real``, REAL_SUB_ADD, REAL_DOUBLE],
   REWRITE_TAC [REAL_ARITH ``-(a - b) + (a + b) = b + b - a + a:real``,
    REAL_SUB_ADD, REAL_DOUBLE],
   FULL_SIMP_TAC real_ss [REAL_NOT_LE] THEN METIS_TAC [REAL_LT_ANTISYM]]));

val LIM_MIN = store_thm ("LIM_MIN",
 ``!net:('a)net f g l:real m:real.
    (f --> l) net /\ (g --> m) net
    ==> ((\x. min (f(x)) (g(x)))
         --> (min (l) (m)):real) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN(MP_TAC o MATCH_MP LIM_NEG)) THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG o MATCH_MP LIM_MAX) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN
  reverse BINOP_TAC >- PROVE_TAC [GSYM REAL_MIN_MAX, REAL_MIN_ACI] THEN
  SIMP_TAC std_ss [FUN_EQ_THM] THEN
  GEN_TAC >> PROVE_TAC [GSYM REAL_MIN_MAX, REAL_MIN_ACI]);

val LIM_NULL = store_thm ("LIM_NULL",
 ``!net f l. (f --> l) net <=> ((\x. f(x) - l) --> 0) net``,
  SIMP_TAC arith_ss [LIM, dist, REAL_SUB_RZERO]);

val LIM_NULL_ABS = store_thm ("LIM_NULL_ABS",
 ``!net f. (f --> 0) net <=> ((\x. (abs(f x))) --> 0) net``,
  SIMP_TAC std_ss [LIM, dist, REAL_SUB_RZERO, ABS_ABS]);

val LIM_NULL_CMUL_EQ = store_thm ("LIM_NULL_CMUL_EQ",
 ``!net f c.
        ~(c = &0) ==> (((\x. c * f x) --> 0) net <=> (f --> 0) net)``,
  METIS_TAC[LIM_CMUL_EQ, REAL_MUL_RZERO]);

val LIM_NULL_CMUL = store_thm ("LIM_NULL_CMUL",
 ``!net f c. (f --> 0) net ==> ((\x. c * f x) --> 0) net``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THEN
  ASM_SIMP_TAC std_ss [LIM_NULL_CMUL_EQ, REAL_MUL_LZERO, LIM_CONST]);

val LIM_NULL_ADD = store_thm ("LIM_NULL_ADD",
 ``!net f g:'a->real.
        (f --> 0) net /\ (g --> 0) net
        ==> ((\x. f x + g x) --> 0) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  REWRITE_TAC[REAL_ADD_LID]);

val LIM_NULL_SUB = store_thm ("LIM_NULL_SUB",
 ``!net f g:'a->real.
        (f --> 0) net /\ (g --> 0) net
        ==> ((\x. f x - g x) --> 0) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN
  REWRITE_TAC[REAL_SUB_RZERO]);

val LIM_NULL_COMPARISON = store_thm ("LIM_NULL_COMPARISON",
 ``!net f g. eventually (\x. abs(f x) <= g x) net /\
             ((\x. (g x)) --> 0) net
             ==> (f --> 0) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [tendsto, RIGHT_AND_FORALL_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  SIMP_TAC arith_ss [dist, REAL_SUB_RZERO] THEN REAL_ARITH_TAC);

val LIM_COMPONENT = store_thm ("LIM_COMPONENT",
 ``!net f i l:real. (f --> l) net
       ==> ((\a. f(a)) --> l) net``,
  REWRITE_TAC[LIM, dist] THEN
  METIS_TAC[REAL_LET_TRANS]);

val LIM_TRANSFORM_BOUND = store_thm ("LIM_TRANSFORM_BOUND",
 ``!f g. eventually (\n. abs(f n) <= abs(g n)) net /\ (g --> 0) net
         ==> (f --> 0) net``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [tendsto, RIGHT_AND_FORALL_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  SIMP_TAC arith_ss [dist, REAL_SUB_RZERO] THEN REAL_ARITH_TAC);

val LIM_NULL_CMUL_BOUNDED = store_thm ("LIM_NULL_CMUL_BOUNDED",
 ``!f g:'a->real B.
        eventually (\a. (g a = 0) \/ abs(f a) <= B) net /\
        (g --> 0) net
        ==> ((\n. f n * g n) --> 0) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[tendsto] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / (abs B + &1:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_ARITH ``&0 < abs x + &1:real``] THEN
  UNDISCH_TAC ``eventually
        (\(a :'a). ((g :'a -> real) a = (0 :real)) \/
           abs ((f :'a -> real) a) <= (B :real)) (net :'a net)`` THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MP) THEN
  SIMP_TAC std_ss [dist, REAL_SUB_RZERO, o_THM, ABS_MUL] THEN
  MATCH_MP_TAC ALWAYS_EVENTUALLY THEN X_GEN_TAC ``x:'a`` THEN BETA_TAC THEN
  ASM_CASES_TAC ``(g:'a->real) x = 0`` THEN
  ASM_SIMP_TAC std_ss [ABS_0, REAL_MUL_RZERO] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``B * e / (abs B + &1:real)`` THEN CONJ_TAC THENL
  [ONCE_REWRITE_TAC [real_div] THEN ONCE_REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC REAL_LE_MUL2 THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC std_ss [REAL_ABS_POS, REAL_LT_IMP_LE], ALL_TAC] THEN
  SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``&0 < abs x + &1:real``] THEN
  MATCH_MP_TAC(REAL_ARITH
   ``e * B <= e * abs B /\ &0 < e ==> B * e < e * (abs B + &1:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN REAL_ARITH_TAC);

val LIM_SUM = store_thm ("LIM_SUM",
 ``!net f:'a->'b->real l s.
        FINITE s /\ (!i. i IN s ==> ((f i) --> (l i)) net)
        ==> ((\x. sum s (\i. f i x)) --> sum s l) net``,
  GEN_TAC THEN GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s:'a->bool. ( (!(i :'a). i IN s ==>
     ((f :'a -> 'b -> real) i --> (l :'a -> real) i) (net :'b net)) ==>
  ((\(x :'b). sum s (\(i :'a). f i x)) --> sum s l) net) =
                       (\s. (!(i :'a). i IN s ==>
     ((f :'a -> 'b -> real) i --> (l :'a -> real) i) (net :'b net)) ==>
  ((\(x :'b). sum s (\(i :'a). f i x)) --> sum s l) net)  s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES, LIM_CONST, LIM_ADD, IN_INSERT, ETA_AX] THEN
  METIS_TAC [SUM_CLAUSES, LIM_CONST, LIM_ADD, IN_INSERT, ETA_AX]);

val LIM_NULL_SUM = store_thm ("LIM_NULL_SUM",
 ``!net f:'a->'b->real s.
  FINITE s /\ (!a. a IN s ==> ((\x. f x a) --> 0) net)
  ==> ((\x. sum s (f x)) --> 0) net``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!a. (\x. f x a) = (\a. (\x. f x a)) a``] THEN
  ONCE_REWRITE_TAC [METIS [] ``0:real = (\a. 0) (a:'b)``] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUM) THEN BETA_TAC THEN
   ONCE_REWRITE_TAC [METIS [] ``!i. (\i. f x i) = (\i. f x) i``] THEN
  METIS_TAC [SUM_0', ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Deducing things about the limit from the elements.                        *)
(* ------------------------------------------------------------------------- *)

val LIM_IN_CLOSED_SET = store_thm ("LIM_IN_CLOSED_SET",
 ``!net f:'a->real s l.
    closed s /\ eventually (\x. f(x) IN s) net /\
    ~(trivial_limit net) /\ (f --> l) net
    ==> l IN s``,
  REWRITE_TAC[closed_def] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(SET_RULE ``~(x IN (UNIV DIFF s)) ==> x IN s``) THEN
  DISCH_TAC THEN UNDISCH_TAC ``open (univ(:real) DIFF s)`` THEN
  GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_BALL] THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `l:real`) THEN
  KNOW_TAC ``~(?e. &0 < e /\ (!x. dist (l,x) < e ==>
                x IN univ(:real) /\ ~(x IN s)))`` THENL
  [ALL_TAC, ASM_SIMP_TAC std_ss [SUBSET_DEF, IN_BALL, IN_DIFF, IN_UNION]] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``((f:'a->real) --> l) net`` THEN GEN_REWR_TAC LAND_CONV [tendsto] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  UNDISCH_TAC ``eventually (\x. (f:'a->real) x IN s) net`` THEN
  ASM_REWRITE_TAC[GSYM EVENTUALLY_AND, TAUT `a ==> ~b <=> ~(a /\ b)`] THEN
  MATCH_MP_TAC NOT_EVENTUALLY THEN ASM_MESON_TAC[DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Need to prove closed(cball(x,e)) before deducing this as a corollary.     *)
(* ------------------------------------------------------------------------- *)

val LIM_ABS_UBOUND = store_thm ("LIM_ABS_UBOUND",
 ``!net:('a)net f (l:real) b.
   ~(trivial_limit net) /\ (f --> l) net /\
   eventually (\x. abs(f x) <= b) net
   ==> abs(l) <= b``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[LIM] THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[eventually] THEN
  STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?x:'a. dist(f(x):real,l) < abs(l:real) - b /\ abs(f x) <= b``
   (CHOOSE_THEN MP_TAC) THENL [ASM_MESON_TAC[NET], ALL_TAC] THEN
  REWRITE_TAC[REAL_NOT_LT, REAL_LE_SUB_RADD, DE_MORGAN_THM, dist] THEN
  REAL_ARITH_TAC);

val LIM_ABS_LBOUND = store_thm ("LIM_ABS_LBOUND",
 ``!net:('a)net f (l:real) b.
   ~(trivial_limit net) /\ (f --> l) net /\
   eventually (\x. b <= abs(f x)) net
   ==> b <= abs(l)``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[LIM] THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_REWRITE_TAC[eventually] THEN
  STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN DISCH_TAC THEN
  SUBGOAL_THEN
  ``?x:'a. dist(f(x):real,l) < b - abs(l:real) /\ b <= abs(f x)``
   (CHOOSE_THEN MP_TAC) THENL [ASM_MESON_TAC[NET], ALL_TAC] THEN
  REWRITE_TAC[REAL_NOT_LT, REAL_LE_SUB_RADD, DE_MORGAN_THM, dist] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Uniqueness of the limit, when nontrivial. *)
(* ------------------------------------------------------------------------- *)

val LIM_UNIQUE = store_thm ("LIM_UNIQUE",
 ``!net:('a)net f l:real l'.
  ~(trivial_limit net) /\ (f --> l) net /\ (f --> l') net ==> (l = l')``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(ASSUME_TAC o REWRITE_RULE[REAL_SUB_REFL] o MATCH_MP LIM_SUB) THEN
  SUBGOAL_THEN ``!e. &0 < e ==> abs(l:real - l') <= e`` MP_TAC THENL
  [GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC LIM_ABS_UBOUND THEN
   MAP_EVERY EXISTS_TAC [``net:('a)net``, ``\x:'a. 0:real``] THEN
   ASM_SIMP_TAC std_ss [ABS_0, REAL_LT_IMP_LE, eventually] THEN
   ASM_MESON_TAC[trivial_limit],
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN REWRITE_TAC[DIST_NZ, dist] THEN
  DISCH_TAC THEN DISCH_THEN(MP_TAC o SPEC ``abs(l - l':real) / &2``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_RDIV_EQ, REAL_LE_RDIV_EQ, REAL_LT] THEN
  UNDISCH_TAC ``&0 < abs(l - l':real)`` THEN REAL_ARITH_TAC]);

val TENDSTO_LIM = store_thm ("TENDSTO_LIM",
 ``!net f l. ~(trivial_limit net) /\ (f --> l) net ==> (lim net f = l)``,
  REWRITE_TAC[reallim] THEN METIS_TAC[LIM_UNIQUE]);

val LIM_CONST_EQ = store_thm ("LIM_CONST_EQ",
 ``!net:('a net) c d:real.
  ((\x. c) --> d) net <=> trivial_limit net \/ (c = d)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``trivial_limit (net:'a net)`` THEN ASM_REWRITE_TAC[] THENL
  [ASM_REWRITE_TAC[LIM], ALL_TAC] THEN
  EQ_TAC THEN SIMP_TAC std_ss [LIM_CONST] THEN DISCH_TAC THEN
  MATCH_MP_TAC(SPEC ``net:'a net`` LIM_UNIQUE) THEN
  EXISTS_TAC ``(\x. c):'a->real`` THEN ASM_REWRITE_TAC[LIM_CONST]);

(* ------------------------------------------------------------------------- *)
(* Some unwieldy but occasionally useful theorems about uniform limits.      *)
(* ------------------------------------------------------------------------- *)

val UNIFORM_LIM_ADD = store_thm ("UNIFORM_LIM_ADD",
 ``!net:('a)net P f g l m.
  (!e:real. &0 < e
   ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
  (!e:real. &0 < e
   ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
    ==> !e. &0 < e ==> eventually (\x. !n. P n
     ==> abs((f n x + g n x) - (l n + m n)) < e) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  GEN_TAC THEN REWRITE_TAC[GSYM FORALL_AND_THM] THEN
  BETA_TAC THEN STRIP_TAC THEN X_GEN_TAC ``n:'b`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  REWRITE_TAC [REAL_ADD2_SUB2] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs ((f:'b->'a->real) n x - l n) + abs (-g n x - -m n):real`` THEN
  ASM_REAL_ARITH_TAC);

val UNIFORM_LIM_SUB = store_thm ("UNIFORM_LIM_SUB",
 ``!net:('a)net P f g l m.
  (!e:real. &0 < e
   ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
  (!e:real. &0 < e
   ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
    ==> !e. &0 < e ==> eventually (\x. !n. P n
     ==> abs((f n x - g n x) - (l n - m n)) < e) net``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_LT_HALF1, GSYM EVENTUALLY_AND] THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  GEN_TAC THEN REWRITE_TAC[GSYM FORALL_AND_THM] THEN
  BETA_TAC THEN STRIP_TAC THEN X_GEN_TAC ``n:'b`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  REWRITE_TAC [REAL_ARITH ``abs (f n x - g n x - (l n - m n)):real =
                            abs (f n x + -g n x - (l n + -m n))``] THEN
  REWRITE_TAC [REAL_ADD2_SUB2] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs ((f:'b->'a->real) n x - l n) + abs (-g n x - -m n):real`` THEN
  REWRITE_TAC [ABS_TRIANGLE] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
  ASM_REWRITE_TAC [REAL_ARITH ``-a - -b = - (a - b):real``, ABS_NEG]);

(* ------------------------------------------------------------------------- *)
(* Limit under bilinear function, uniform version first.                     *)
(* ------------------------------------------------------------------------- *)

val UNIFORM_LIM_BILINEAR = store_thm ("UNIFORM_LIM_BILINEAR",
 ``!net:('a)net P (h:real->real->real) f g l m b1 b2.
        bilinear h /\
        eventually (\x. !n. P n ==> abs(l n) <= b1) net /\
        eventually (\x. !n. P n ==> abs(m n) <= b2) net /\
        (!e. &0 < e
             ==> eventually (\x. !n:'b. P n ==> abs(f n x - l n) < e) net) /\
        (!e. &0 < e
             ==> eventually (\x. !n. P n ==> abs(g n x - m n) < e) net)
        ==> !e. &0 < e
             ==> eventually (\x. !n. P n
                 ==> abs(h (f n x) (g n x) - h (l n) (m n)) < e) net``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o  MATCH_MP
   BILINEAR_BOUNDED_POS) THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, RIGHT_AND_FORALL_THM] THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``min (abs b2 + &1:real) (e / &2 / (B * (abs b1 + abs b2 + &2)))``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_HALF1, REAL_LT_DIV, REAL_LT_MUL, REAL_LT_MIN,
               REAL_ARITH ``&0 < abs x + &1:real``,
               REAL_ARITH ``&0 < abs x + abs y + &2:real``] THEN
  REWRITE_TAC[GSYM EVENTUALLY_AND] THEN BETA_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] EVENTUALLY_MONO) THEN
  X_GEN_TAC ``x:'a`` THEN SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `n:'b`) THEN
  ASM_CASES_TAC ``(P:'b->bool) n`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH
    ``h a b - h c d :real = (h a b - h a d) + (h a d - h c d)``] THEN
  ASM_SIMP_TAC std_ss [GSYM BILINEAR_LSUB, GSYM BILINEAR_RSUB] THEN
  MATCH_MP_TAC ABS_TRIANGLE_LT THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP
   (MESON[REAL_LE_ADD2, REAL_LET_TRANS]
     ``(!x y. abs(h x y:real) <= B * abs x * abs y)
       ==> B * abs a * abs b + B * abs c * abs d < e
           ==> abs(h a b) + abs(h c d) < e``)) THEN
  REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC(METIS [REAL_LT_ADD2, REAL_HALF_DOUBLE, REAL_MUL_SYM]
   ``x * B < e / &2:real /\ y * B < e / &2:real ==> B * x + B * y < e``) THEN
  CONJ_TAC THEN ASM_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ] THENL
   [ONCE_REWRITE_TAC[REAL_MUL_SYM], ALL_TAC] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``e / &2 / (B * (abs b1 + abs b2 + &2)) *
             (abs b1 + abs b2 + &1:real)`` THEN
  (CONJ_TAC THENL
    [MATCH_MP_TAC REAL_LE_MUL2 THEN
     ASM_SIMP_TAC std_ss [ABS_POS, REAL_LT_IMP_LE] THEN
     ASM_SIMP_TAC std_ss [REAL_ARITH ``a <= b2 ==> a <= abs b1 + abs b2 + &1:real``] THEN
     ASM_MESON_TAC[REAL_ARITH
       ``abs(f - l:real) < abs b2 + &1 /\ abs(l) <= b1
        ==> abs(f) <= abs b1 + abs b2 + &1``],
     ONCE_REWRITE_TAC[real_div] THEN
     KNOW_TAC ``(abs b1 + abs b2 + 2) <> 0:real`` THENL
     [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
      MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``2:real`` THEN
      REWRITE_TAC [REAL_LE_ADDL] THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
      ONCE_REWRITE_TAC [REAL_ARITH ``0 = 0 + 0:real``] THEN MATCH_MP_TAC REAL_LE_ADD2 THEN
      REWRITE_TAC [ABS_POS], ALL_TAC] THEN DISCH_TAC THEN
     ASM_SIMP_TAC arith_ss [REAL_LT_LMUL, REAL_LT_HALF1, GSYM REAL_MUL_ASSOC,
                  REAL_INV_MUL, REAL_LT_IMP_NE] THEN REWRITE_TAC [REAL_MUL_ASSOC] THEN
     REWRITE_TAC[METIS [real_div, REAL_MUL_RID, REAL_ARITH ``a * b * c = a * c * b:real``]
                 ``B * inv x * y < B <=> B * y / x < B * &1:real``] THEN
     ASM_SIMP_TAC arith_ss [REAL_LT_INV_EQ, REAL_LT_LMUL, REAL_LT_LDIV_EQ, REAL_MUL_RID,
                  REAL_ARITH ``&0 < abs x + abs y + &2:real``] THEN
     REAL_ARITH_TAC]));

val LIM_BILINEAR = store_thm ("LIM_BILINEAR",
 ``!net:('a)net (h:real->real->real) f g l m.
        (f --> l) net /\ (g --> m) net /\ bilinear h
        ==> ((\x. h (f x) (g x)) --> (h l m)) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [``net:('a)net``, ``\x:one. T``, ``h:real->real->real``,
    ``\n:one. (f:'a->real)``, ``\n:one. (g:'a->real)``,
    ``\n:one. (l:real)``, ``\n:one. (m:real)``,
    ``abs(l:real)``, ``abs(m:real)``]
   UNIFORM_LIM_BILINEAR) THEN
  ASM_REWRITE_TAC[REAL_LE_REFL, EVENTUALLY_TRUE] THEN
  ASM_SIMP_TAC std_ss [GSYM dist, GSYM tendsto]);

(* ------------------------------------------------------------------------- *)
(* These are special for limits out of the same vector space. *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_ID = store_thm ("LIM_WITHIN_ID",
 ``!a s. ((\x. x) --> a) (at a within s)``,
  REWRITE_TAC[LIM_WITHIN] THEN MESON_TAC[]);

val LIM_AT_ID = store_thm ("LIM_AT_ID",
 ``!a. ((\x. x) --> a) (at a)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN REWRITE_TAC[LIM_WITHIN_ID]);

val LIM_AT_ZERO = store_thm ("LIM_AT_ZERO",
 ``!f:real->real l a.
    (f --> l) (at a) <=> ((\x. f(a + x)) --> l) (at(0))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM_AT] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  ASM_CASES_TAC ``&0 < d:real`` THEN ASM_REWRITE_TAC[] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``x:real`` THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC ``a + x:real``) THEN
   SIMP_TAC std_ss [dist, REAL_ADD_SUB, REAL_SUB_RZERO],
  FIRST_X_ASSUM(MP_TAC o SPEC ``x - a:real``) THEN
  SIMP_TAC std_ss [dist, REAL_SUB_RZERO, REAL_SUB_ADD2]]);

(* ------------------------------------------------------------------------- *)
(* It's also sometimes useful to extract the limit point from the net. *)
(* ------------------------------------------------------------------------- *)

val netlimit = new_definition ("netlimit",
 ``netlimit net = @a. !x. ~(netord net x a)``);

val NETLIMIT_WITHIN = store_thm ("NETLIMIT_WITHIN",
 ``!a:real s. ~(trivial_limit (at a within s))
    ==> (netlimit (at a within s) = a)``,
  REWRITE_TAC[trivial_limit, netlimit, AT, WITHIN, DE_MORGAN_THM] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SELECT_UNIQUE THEN REWRITE_TAC[] THEN
  SUBGOAL_THEN
   ``!x:real. ~(&0 < dist(x,a) /\ dist(x,a) <= dist(a,a) /\ x IN s)``
    ASSUME_TAC THENL
    [ASM_MESON_TAC[DIST_REFL, REAL_NOT_LT], ASM_MESON_TAC[]]);

val NETLIMIT_AT = store_thm ("NETLIMIT_AT",
 ``!a. netlimit(at a) = a``,
  GEN_TAC THEN ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MATCH_MP_TAC NETLIMIT_WITHIN THEN
  SIMP_TAC std_ss [TRIVIAL_LIMIT_AT, WITHIN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Transformation of limit. *)
(* ------------------------------------------------------------------------- *)

val LIM_TRANSFORM = store_thm ("LIM_TRANSFORM",
 ``!net f g l.
  ((\x. f x - g x) --> 0) net /\ (f --> l) net ==> (g --> l) net``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_NEG) THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_THM_TAC THEN BINOP_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM] THEN
  REAL_ARITH_TAC);

val LIM_TRANSFORM_EVENTUALLY = store_thm ("LIM_TRANSFORM_EVENTUALLY",
 ``!net f g l.
   eventually (\x. f x = g x) net /\ (f --> l) net ==> (g --> l) net``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  KNOW_TAC ``((\ (x:'a). f x - g x) --> (0:real)) net`` THENL
  [METIS_TAC [LIM_EVENTUALLY], ALL_TAC] THEN
  METIS_TAC[LIM_TRANSFORM]);

val LIM_TRANSFORM_WITHIN = store_thm ("LIM_TRANSFORM_WITHIN",
  ``!f g x s d. &0 < d /\
  (!x'. x' IN s /\ &0 < dist(x',x) /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
  (f --> l) (at x within s) ==> (g --> l) (at x within s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  DISCH_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] LIM_TRANSFORM) THEN
  REWRITE_TAC[LIM_WITHIN] THEN REPEAT STRIP_TAC THEN EXISTS_TAC ``d:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_REFL, DIST_REFL]);

val LIM_TRANSFORM_AT = store_thm ("LIM_TRANSFORM_AT",
 ``!f g x d. &0 < d /\
  (!x'. &0 < dist(x',x) /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
  (f --> l) (at x) ==> (g --> l) (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN MESON_TAC[LIM_TRANSFORM_WITHIN]);

val LIM_TRANSFORM_EQ = store_thm ("LIM_TRANSFORM_EQ",
 ``!net f:'a->real g l.
  ((\x. f x - g x) --> 0) net ==> ((f --> l) net <=> (g --> l) net)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  DISCH_TAC THEN MATCH_MP_TAC LIM_TRANSFORM THENL
  [EXISTS_TAC ``f:'a->real`` THEN ASM_REWRITE_TAC[],
  EXISTS_TAC ``g:'a->real`` THEN ASM_REWRITE_TAC[] THEN
  ONCE_REWRITE_TAC[GSYM LIM_NEG_EQ] THEN BETA_TAC THEN
  ASM_REWRITE_TAC[REAL_NEG_SUB, REAL_NEG_0]]);

val LIM_TRANSFORM_WITHIN_SET = store_thm ("LIM_TRANSFORM_WITHIN_SET",
 ``!f a s t.
  eventually (\x. x IN s <=> x IN t) (at a)
  ==> ((f --> l) (at a within s) <=> (f --> l) (at a within t))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[EVENTUALLY_AT, LIM_WITHIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

val LIM_TRANSFORM_WITHIN_SET_IMP = store_thm ("LIM_TRANSFORM_WITHIN_SET_IMP",
 ``!f l a s t.
  eventually (\x. x IN t ==> x IN s) (at a) /\ (f --> l) (at a within s)
  ==> (f --> l) (at a within t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO, EVENTUALLY_AT, LIM_WITHIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Common case assuming being away from some crucial point like 0.           *)
(* ------------------------------------------------------------------------- *)

Theorem LIM_TRANSFORM_AWAY_WITHIN_lemma[local] :
   !f:real->real g a b s. ~(a = b) /\
  (!x. x IN s /\ ~(x = a) /\ ~(x = b) ==> (f(x) = g(x))) /\
  (f --> l) (at a within s) ==> (g --> l) (at a within s)
Proof
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_WITHIN THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``dist(a:real,b)``] THEN
  ASM_REWRITE_TAC[GSYM DIST_NZ] THEN X_GEN_TAC ``y:real`` THEN
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_MESON_TAC[DIST_SYM, REAL_LT_REFL]
QED

(* NOTE: removed the unused quantifier ‘b’ *)
Theorem LIM_TRANSFORM_AWAY_WITHIN :
   !f:real->real g a s l.
      (!x. x IN s /\ ~(x = a) ==> (f(x) = g(x))) /\
      (f --> l) (at a within s) ==> (g --> l) (at a within s)
Proof
    rpt STRIP_TAC
 >> MATCH_MP_TAC LIM_TRANSFORM_AWAY_WITHIN_lemma
 >> qexistsl_tac [‘f’, ‘a + 1’] >> rw []
 >> REAL_ARITH_TAC
QED

(* NOTE: removed the unused quantifier ‘b’ *)
Theorem LIM_TRANSFORM_AWAY_AT :
   !f:real->real g a l.
      (!x. ~(x = a) ==> (f(x) = g(x))) /\
      (f --> l) (at a) ==> (g --> l) (at a)
Proof
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MESON_TAC[LIM_TRANSFORM_AWAY_WITHIN]
QED

(* ------------------------------------------------------------------------- *)
(* Alternatively, within an open set. *)
(* ------------------------------------------------------------------------- *)

val LIM_TRANSFORM_WITHIN_OPEN = store_thm ("LIM_TRANSFORM_WITHIN_OPEN",
 ``!f g:real->real s a l. open s /\ a IN s /\
  (!x. x IN s /\ ~(x = a) ==> (f x = g x)) /\
  (f --> l) (at a) ==> (g --> l) (at a)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_AT THEN
  EXISTS_TAC ``f:real->real`` THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``open s`` THEN GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_BALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN POP_ASSUM MP_TAC THEN
  REWRITE_TAC[SUBSET_DEF, IN_BALL] THEN ASM_MESON_TAC[DIST_NZ, DIST_SYM]);

Theorem LIM_TRANSFORM_WITHIN_OPEN_EQ :
    !f g:real->real s a l.
       open s /\ a IN s /\ (!x. x IN s /\ ~(x = a) ==> (f x = g x)) ==>
      ((f --> l) (at a) <=> (g --> l) (at a))
Proof
    rpt STRIP_TAC
 >> EQ_TAC >> DISCH_TAC
 >| [ (* goal 1 (of 2) *)
      MATCH_MP_TAC LIM_TRANSFORM_WITHIN_OPEN \\
      qexistsl_tac [‘f’, ‘s’] >> rw [],
      (* goal 2 (of 2) *)
      MATCH_MP_TAC LIM_TRANSFORM_WITHIN_OPEN \\
      qexistsl_tac [‘g’, ‘s’] >> rw [] ]
QED

val LIM_TRANSFORM_WITHIN_OPEN_IN = store_thm ("LIM_TRANSFORM_WITHIN_OPEN_IN",
 ``!f g:real->real s t a l.
  open_in (subtopology euclidean t) s /\ a IN s /\
  (!x. x IN s /\ ~(x = a) ==> (f x = g x)) /\
  (f --> l) (at a within t) ==> (g --> l) (at a within t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_WITHIN THEN
  EXISTS_TAC ``f:real->real`` THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``open_in (subtopology euclidean t) s`` THEN
  GEN_REWR_TAC LAND_CONV [OPEN_IN_CONTAINS_BALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real`` o CONJUNCT2) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN POP_ASSUM MP_TAC THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTER, IN_BALL] THEN ASM_MESON_TAC[DIST_NZ, DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Another quite common idiom of an explicit conditional in a sequence. *)
(* ------------------------------------------------------------------------- *)

val LIM_CASES_FINITE_SEQUENTIALLY = store_thm ("LIM_CASES_FINITE_SEQUENTIALLY",
 ``!f g l. FINITE {n | P n}
  ==> (((\n. if P n then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[GSYM AND_IMP_INTRO] LIM_TRANSFORM_EVENTUALLY) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  SIMP_TAC std_ss [GSPECIFICATION, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``N:num`` THEN DISCH_TAC THEN SIMP_TAC std_ss [EVENTUALLY_SEQUENTIALLY] THEN
  EXISTS_TAC ``N + 1:num`` THEN
  METIS_TAC[ARITH_PROVE ``~(x <= n:num /\ n + 1 <= x)``]);

val lemma = prove (
 ``(if p then x else y) = (if ~p then y else x)``,
 RW_TAC std_ss []);

val LIM_CASES_COFINITE_SEQUENTIALLY = store_thm ("LIM_CASES_COFINITE_SEQUENTIALLY",
 ``!f g l. FINITE {n | ~P n}
  ==> (((\n. if P n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially)``,
  ONCE_REWRITE_TAC[lemma] THEN
  SIMP_TAC std_ss [LIM_CASES_FINITE_SEQUENTIALLY]);

val LIM_CASES_SEQUENTIALLY = store_thm ("LIM_CASES_SEQUENTIALLY",
 ``!f g l m. (((\n. if m <= n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially) /\
   (((\n. if m < n then f n else g n) --> l) sequentially <=>
  (f --> l) sequentially) /\
   (((\n. if n <= m then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially) /\
   (((\n. if n < m then f n else g n) --> l) sequentially <=>
  (g --> l) sequentially)``,
  SIMP_TAC std_ss [LIM_CASES_FINITE_SEQUENTIALLY, LIM_CASES_COFINITE_SEQUENTIALLY,
  NOT_LESS, NOT_LESS_EQUAL, FINITE_NUMSEG_LT, FINITE_NUMSEG_LE]);

(* ------------------------------------------------------------------------- *)
(* A congruence rule allowing us to transform limits assuming not at point.  *)
(* ------------------------------------------------------------------------- *)

val LIM_CONG_WITHIN = store_thm ("LIM_CONG_WITHIN",
 ``(!x. ~(x = a) ==> (f x = g x))
  ==> (((\x. f x) --> l) (at a within s) <=> ((g --> l) (at a within s)))``,
 REWRITE_TAC[LIM_WITHIN, GSYM DIST_NZ] THEN SIMP_TAC std_ss []);

val LIM_CONG_AT = store_thm ("LIM_CONG_AT",
 ``(!x. ~(x = a) ==> (f x = g x))
  ==> (((\x. f x) --> l) (at a) <=> ((g --> l) (at a)))``,
 REWRITE_TAC[LIM_AT, GSYM DIST_NZ] THEN SIMP_TAC std_ss []);

(* ------------------------------------------------------------------------- *)
(* Useful lemmas on closure and set of possible sequential limits.           *)
(* ------------------------------------------------------------------------- *)

val CLOSURE_SEQUENTIAL = store_thm ("CLOSURE_SEQUENTIAL",
 ``!s l:real.
  l IN closure(s) <=> ?x. (!n. x(n) IN s) /\ (x --> l) sequentially``,
  SIMP_TAC std_ss [closure, IN_UNION, LIMPT_SEQUENTIAL, GSPECIFICATION, IN_DELETE] THEN
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `((b ==> c) /\ (~a /\ c ==> b)) /\ (a ==> c) ==> (a \/ b <=> c)`) THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN DISCH_TAC THEN
  EXISTS_TAC ``\n:num. l:real`` THEN ASM_REWRITE_TAC[LIM_CONST]);

val CLOSED_CONTAINS_SEQUENTIAL_LIMIT = store_thm ("CLOSED_CONTAINS_SEQUENTIAL_LIMIT",
 ``!s x l:real.
  closed s /\ (!n. x n IN s) /\ (x --> l) sequentially ==> l IN s``,
  MESON_TAC[CLOSURE_SEQUENTIAL, CLOSURE_CLOSED]);

val CLOSED_SEQUENTIAL_LIMITS = store_thm ("CLOSED_SEQUENTIAL_LIMITS",
 ``!s. closed s <=>
   !x l. (!n. x(n) IN s) /\ (x --> l) sequentially ==> l IN s``,
  MESON_TAC[CLOSURE_SEQUENTIAL, CLOSURE_CLOSED,
  CLOSED_LIMPT, LIMPT_SEQUENTIAL, IN_DELETE]);

val CLOSED_APPROACHABLE = store_thm ("CLOSED_APPROACHABLE",
 ``!x s. closed s
  ==> ((!e. &0 < e ==> ?y. y IN s /\ dist(y,x) < e) <=> x IN s)``,
  MESON_TAC[CLOSURE_CLOSED, CLOSURE_APPROACHABLE]);

val IN_CLOSURE_DELETE = store_thm ("IN_CLOSURE_DELETE",
 ``!s x:real. x IN closure(s DELETE x) <=> x limit_point_of s``,
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, LIMPT_APPROACHABLE, IN_DELETE, CONJ_ASSOC]);

val DENSE_IMP_PERFECT = store_thm ("DENSE_IMP_PERFECT",
 ``!s. (closure s = univ(:real)) ==> !x. x IN s ==> x limit_point_of s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  KNOW_TAC ``~(!x'. ~(x' = x) /\ dist (x',x) < e ==> ~(x' IN s))`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``x:real``, ``e / &2:real``] REAL_CHOOSE_DIST) THEN
  KNOW_TAC ``~(?y. dist (x,y) = e / &2)`` THENL
  [ALL_TAC, ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, REAL_LT_HALF1]] THEN
  DISCH_THEN(X_CHOOSE_TAC ``y:real``) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``y:real`` o MATCH_MP (SET_RULE
   ``(s = UNIV) ==> !x. x IN s``)) THEN
  REWRITE_TAC[CLOSURE_APPROACHABLE] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_HALF, NOT_EXISTS_THM] THEN
  X_GEN_TAC ``z:real`` THEN FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN
  ASM_CASES_TAC ``(z:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [] THEN STRIP_TAC THENL
  [METIS_TAC [REAL_LE_LT, REAL_NOT_LT], ALL_TAC] THEN
  DISCH_TAC THEN UNDISCH_TAC ``~(dist (z,x) < e)`` THEN REWRITE_TAC [] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF_DOUBLE] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``dist (z,y) + dist (y,x)`` THEN
  REWRITE_TAC [DIST_TRIANGLE] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
  ASM_REWRITE_TAC [] THEN METIS_TAC [REAL_LT_RADD, DIST_SYM]);

val DENSE_LIMIT_POINTS = store_thm ("DENSE_LIMIT_POINTS",
 ``!x. ({x | x limit_point_of s} = univ(:real)) <=> (closure s = univ(:real))``,
  GEN_TAC THEN EQ_TAC THENL [SIMP_TAC std_ss [closure] THEN SET_TAC[], DISCH_TAC] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DENSE_IMP_PERFECT) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[closure]) THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some other lemmas about sequences.                                        *)
(* ------------------------------------------------------------------------- *)

val SEQ_OFFSET = store_thm ("SEQ_OFFSET",
 ``!f l k. (f --> l) sequentially ==> ((\i. f(i + k)) --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N <= n ==> N <= n + k:num``]);

val SEQ_OFFSET_NEG = store_thm ("SEQ_OFFSET_NEG",
 ``!f l k. (f --> l) sequentially ==> ((\i. f(i - k)) --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N + k <= n ==> N <= n - k:num``]);

val SEQ_OFFSET_REV = store_thm ("SEQ_OFFSET_REV",
 ``!f l k. ((\i. f(i + k)) --> l) sequentially ==> (f --> l) sequentially``,
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  MESON_TAC[ARITH_PROVE ``N + k <= n ==> N <= n - k /\ ((n - k) + k = n:num)``]);

val SEQ_HARMONIC_OFFSET = store_thm ("SEQ_HARMONIC_OFFSET",
 ``!a. ((\n. inv(&n + a)) --> 0) sequentially``,
  GEN_TAC THEN REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  ASSUME_TAC REAL_ARCH_INV THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_REWRITE_TAC [] THEN DISCH_THEN (X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  X_CHOOSE_THEN ``M:num`` STRIP_ASSUME_TAC
  (SPEC ``-a:real`` SIMP_REAL_ARCH) THEN
  EXISTS_TAC ``M + N:num`` THEN REWRITE_TAC[DIST_0] THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``inv (&N:real)`` THEN
  KNOW_TAC ``(&n + a:real) <> 0`` THENL
  [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   UNDISCH_TAC ``-a <= &M:real`` THEN
   GEN_REWR_TAC LAND_CONV [GSYM REAL_LE_NEG] THEN REWRITE_TAC [REAL_NEG_NEG] THEN
   DISCH_TAC THEN FULL_SIMP_TAC arith_ss [GSYM REAL_LE, GSYM REAL_ADD] THEN
   KNOW_TAC ``&M + &N + (-&M) <= &n + a:real`` THENL
   [FULL_SIMP_TAC arith_ss [REAL_LE_ADD2], ALL_TAC] THEN
   REWRITE_TAC [GSYM real_sub] THEN ONCE_REWRITE_TAC [REAL_ADD_COMM] THEN
   REWRITE_TAC [REAL_ADD_SUB_ALT] THEN DISCH_TAC THEN
   MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``&N:real`` THEN
   FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ], ALL_TAC] THEN DISCH_TAC THEN
  BETA_TAC THEN ASM_SIMP_TAC arith_ss [ABS_INV] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM REAL_OF_NUM_LE, GSYM REAL_OF_NUM_ADD]) THEN
  ASM_REAL_ARITH_TAC);

val SEQ_HARMONIC = store_thm ("SEQ_HARMONIC",
 ``((\n. inv(&n)) --> 0) sequentially``,
  MP_TAC(SPEC ``&0:real`` SEQ_HARMONIC_OFFSET) THEN REWRITE_TAC[REAL_ADD_RID]);

(* ------------------------------------------------------------------------- *)
(* More properties of closed balls.                                          *)
(* ------------------------------------------------------------------------- *)

val CLOSED_CBALL = store_thm ("CLOSED_CBALL",
 ``!x:real e. closed(cball(x,e))``,
  REWRITE_TAC[CLOSED_SEQUENTIAL_LIMITS, IN_CBALL, dist] THEN
  GEN_TAC THEN GEN_TAC THEN X_GEN_TAC ``s:num->real`` THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_ABS_UBOUND) THEN
  EXISTS_TAC ``\n. x - (s:num->real) n`` THEN
  REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY, EVENTUALLY_SEQUENTIALLY] THEN
  ASM_SIMP_TAC std_ss [LIM_SUB, LIM_CONST, SEQUENTIALLY]);

val IN_INTERIOR_CBALL = store_thm ("IN_INTERIOR_CBALL",
 ``!x s. x IN interior s <=> ?e. &0 < e /\ cball(x,e) SUBSET s``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[OPEN_CONTAINS_CBALL, SUBSET_TRANS,
  BALL_SUBSET_CBALL, CENTRE_IN_BALL, OPEN_BALL]);

val LIMPT_BALL = store_thm ("LIMPT_BALL",
 ``!x:real y e. y limit_point_of ball(x,e) <=> &0 < e /\ y IN cball(x,e)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``&0 < e:real`` THENL
  [ALL_TAC, ASM_MESON_TAC[LIMPT_EMPTY, REAL_NOT_LT, BALL_EQ_EMPTY]] THEN
  ASM_REWRITE_TAC[] THEN EQ_TAC THENL
  [MESON_TAC[CLOSED_CBALL, CLOSED_LIMPT, LIMPT_SUBSET, BALL_SUBSET_CBALL],
   REWRITE_TAC[IN_CBALL, LIMPT_APPROACHABLE, IN_BALL]] THEN
  DISCH_TAC THEN X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``y:real = x`` THEN ASM_REWRITE_TAC[DIST_NZ] THENL
  [MP_TAC(SPECL [``d:real``, ``e:real``] REAL_DOWN2) THEN
   ASM_REWRITE_TAC[] THEN
   GEN_MESON_TAC 0 40 1 [REAL_CHOOSE_DIST, DIST_SYM, REAL_LT_IMP_LE],
   ALL_TAC] THEN
  MP_TAC(SPECL [``abs(y:real - x)``, ``d:real``] REAL_DOWN2) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[DIST_NZ, dist]) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``(y:real) - (k / dist(y,x)) * (y - x)`` THEN
  REWRITE_TAC[dist, REAL_ARITH ``(y - c * z) - y = -c * z:real``] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, ABS_NEG, REAL_POS_NZ] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC[REAL_ARITH ``x - (y - k * (y - x)) = (&1 - k) * (x - y:real)``] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``&0 < k ==> &0 < abs k:real``, ABS_MUL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``&0 < k /\ k < d ==> abs k < d:real``] THEN
  MATCH_MP_TAC REAL_LTE_TRANS THEN EXISTS_TAC ``abs(x:real - y)`` THEN
  ASM_REWRITE_TAC[] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
  KNOW_TAC ``0:real < abs (x - y)`` THENL [ASM_MESON_TAC[ABS_SUB], ALL_TAC] THEN
  DISCH_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_RMUL] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < k /\ k < &1 ==> abs(&1 - k) < &1:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ, REAL_MUL_LZERO,
   REAL_MUL_LID]);

val CLOSURE_BALL = store_thm ("CLOSURE_BALL",
 ``!x:real e. &0 < e ==> (closure(ball(x,e)) = cball(x,e))``,
  SIMP_TAC std_ss [EXTENSION, closure, GSPECIFICATION, IN_UNION, LIMPT_BALL] THEN
  REWRITE_TAC[IN_BALL, IN_CBALL] THEN REAL_ARITH_TAC);

val INTERIOR_BALL = store_thm ("INTERIOR_BALL",
 ``!a r. interior(ball(a,r)) = ball(a,r)``,
  SIMP_TAC std_ss [INTERIOR_OPEN, OPEN_BALL]);

val INTERIOR_CBALL = store_thm ("INTERIOR_CBALL",
 ``!x:real e. interior(cball(x,e)) = ball(x,e)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``&0 <= e:real`` THENL
  [ALL_TAC,
   SUBGOAL_THEN ``(cball(x:real,e) = {}) /\ (ball(x:real,e) = {})``
    (fn th => REWRITE_TAC[th, INTERIOR_EMPTY]) THEN
   REWRITE_TAC[IN_BALL, IN_CBALL, EXTENSION, NOT_IN_EMPTY] THEN
   CONJ_TAC THEN X_GEN_TAC ``y:real`` THEN
   MP_TAC(ISPECL [``x:real``, ``y:real``] DIST_POS_LE) THEN
   POP_ASSUM MP_TAC THEN REAL_ARITH_TAC] THEN
  MATCH_MP_TAC INTERIOR_UNIQUE THEN
  REWRITE_TAC[BALL_SUBSET_CBALL, OPEN_BALL] THEN
  X_GEN_TAC ``t:real->bool`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_CBALL, IN_BALL, REAL_LT_LE] THEN STRIP_TAC THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN DISCH_THEN(SUBST_ALL_TAC o SYM) THEN
  UNDISCH_TAC ``open t`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``z:real``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``d:real`` MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_CASES_TAC ``z:real = x`` THENL
  [FIRST_X_ASSUM SUBST_ALL_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_TAC ``k:real`` o MATCH_MP REAL_DOWN) THEN
  SUBGOAL_THEN ``?w:real. dist(w,x) = k`` STRIP_ASSUME_TAC THENL
  [ASM_MESON_TAC[REAL_CHOOSE_DIST, DIST_SYM, REAL_LT_IMP_LE],
   ASM_MESON_TAC[REAL_NOT_LE, DIST_REFL, DIST_SYM]],
  RULE_ASSUM_TAC(REWRITE_RULE[DIST_NZ]) THEN
  DISCH_THEN(MP_TAC o SPEC ``z + ((d / &2) / dist(z,x)) * (z - x:real)``) THEN
  FULL_SIMP_TAC arith_ss [dist, REAL_ADD_SUB, ABS_MUL, ABS_DIV,
  ABS_ABS, ABS_N, REAL_POS_NZ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, GSYM dist, REAL_POS_NZ] THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_LDIV_EQ, REAL_LT] THEN
  ASM_REWRITE_TAC [REAL_ARITH ``abs d < d * &2 <=> &0 < d:real``] THEN
  DISCH_THEN(ANTE_RES_THEN MP_TAC) THEN REWRITE_TAC[dist] THEN
  REWRITE_TAC[REAL_ARITH ``x - (z + k * (z - x)) = (&1 + k) * (x - z:real)``] THEN
  REWRITE_TAC[REAL_NOT_LE, ABS_MUL] THEN
  GEN_REWR_TAC LAND_CONV [GSYM REAL_MUL_LID] THEN
  ONCE_REWRITE_TAC[ABS_SUB] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RMUL, GSYM dist] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < x ==> &1:real < abs(&1 + x)``) THEN
  ONCE_REWRITE_TAC[DIST_SYM] THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT, dist]]);

val FRONTIER_BALL = store_thm ("FRONTIER_BALL",
 ``!a e. &0 < e ==> (frontier(ball(a,e)) = sphere(a,e))``,
  SIMP_TAC std_ss [frontier, sphere, CLOSURE_BALL, INTERIOR_OPEN, OPEN_BALL,
   REAL_LT_IMP_LE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION, IN_BALL, IN_CBALL] THEN
  REAL_ARITH_TAC);

val FRONTIER_CBALL = store_thm ("FRONTIER_CBALL",
 ``!a e. (frontier(cball(a,e)) = sphere(a,e))``,
  SIMP_TAC std_ss [frontier, sphere, INTERIOR_CBALL, CLOSED_CBALL, CLOSURE_CLOSED,
   REAL_LT_IMP_LE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, SPECIFICATION, IN_BALL, IN_CBALL, dist] THEN
  GEN_REWR_TAC (QUANT_CONV o QUANT_CONV o QUANT_CONV o RAND_CONV) [GSYM SPECIFICATION] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN REAL_ARITH_TAC);

val CBALL_EQ_EMPTY = store_thm ("CBALL_EQ_EMPTY",
 ``!x e. (cball(x,e) = {}) <=> e < &0``,
  REWRITE_TAC[EXTENSION, IN_CBALL, NOT_IN_EMPTY, REAL_NOT_LE] THEN
  MESON_TAC[DIST_POS_LE, DIST_REFL, REAL_LTE_TRANS]);

val CBALL_EMPTY = store_thm ("CBALL_EMPTY",
 ``!x e. e < &0 ==> (cball(x,e) = {})``,
 REWRITE_TAC[CBALL_EQ_EMPTY]);

val CBALL_EQ_SING = store_thm ("CBALL_EQ_SING",
 ``!x:real e. (cball(x,e) = {x}) <=> (e = &0)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[EXTENSION, IN_CBALL, IN_SING] THEN
  EQ_TAC THENL [ALL_TAC, MESON_TAC[DIST_LE_0]] THEN
  DISCH_THEN(fn th => MP_TAC(SPEC ``x + (e / &2) * 1:real`` th) THEN
  MP_TAC(SPEC ``x:real`` th)) THEN
  REWRITE_TAC[dist, REAL_ARITH ``x - (x + e):real = -e``,
   REAL_ARITH ``(x + e = x) <=> (e:real = 0)``] THEN
  REWRITE_TAC[ABS_NEG, ABS_MUL, REAL_ENTIRE, ABS_0, REAL_SUB_REFL] THEN
  SIMP_TAC std_ss [ABS_1, REAL_ARITH ``~(1 = 0:real)``] THEN
  SIMP_TAC arith_ss [REAL_MUL_RID, REAL_EQ_LDIV_EQ,
   REAL_ARITH ``0 < 2:real``, REAL_MUL_LZERO] THEN
  GEN_REWR_TAC LAND_CONV [REAL_LE_LT] THEN RW_TAC arith_ss [] THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN ASM_REWRITE_TAC [abs] THEN
  COND_CASES_TAC THENL
  [FULL_SIMP_TAC std_ss [REAL_LE_LT] THEN DISJ1_TAC THEN
   ASM_SIMP_TAC std_ss [REAL_LT_HALF2], ALL_TAC] THEN
  UNDISCH_TAC ``0 < e:real`` THEN GEN_REWR_TAC LAND_CONV [GSYM REAL_LT_HALF1] THEN
  DISCH_TAC THEN FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN METIS_TAC [REAL_LT_ANTISYM]);

val CBALL_SING = store_thm ("CBALL_SING",
 ``!x e. (e = &0) ==> (cball(x,e) = {x})``,
 REWRITE_TAC[CBALL_EQ_SING]);

val SPHERE_SING = store_thm ("SPHERE_SING",
 ``!x e. (e = &0) ==> (sphere(x,e) = {x})``,
  SIMP_TAC std_ss [sphere, DIST_EQ_0, GSPEC_EQ, GSPEC_EQ2]);

val SPHERE_EQ_SING = store_thm ("SPHERE_EQ_SING",
 ``!a:real r x. (sphere(a,r) = {x}) <=> (x = a) /\ (r = &0)``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [SPHERE_SING] THEN
  ASM_CASES_TAC ``r < &0:real`` THEN ASM_SIMP_TAC std_ss [SPHERE_EMPTY, NOT_INSERT_EMPTY] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN ASM_SIMP_TAC std_ss [SPHERE_SING] THENL
  [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC(SET_RULE
   ``!y. (x IN s ==> y IN s /\ ~(y = x)) ==> ~(s = {x})``) THEN
  EXISTS_TAC ``a - (x - a):real`` THEN REWRITE_TAC[IN_SPHERE] THEN
  REWRITE_TAC [dist] THEN REPEAT(POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* For points in the interior, localization of limits makes no difference.   *)
(* ------------------------------------------------------------------------- *)

val EVENTUALLY_WITHIN_INTERIOR = store_thm ("EVENTUALLY_WITHIN_INTERIOR",
 ``!p s x.
  x IN interior s
  ==> (eventually p (at x within s) <=> eventually p (at x))``,
  REWRITE_TAC[EVENTUALLY_WITHIN, EVENTUALLY_AT, IN_INTERIOR] THEN
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min (d:real) e`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[DIST_SYM]);

val LIM_WITHIN_INTERIOR = store_thm ("LIM_WITHIN_INTERIOR",
 ``!f l s x. x IN interior s
   ==> ((f --> l) (at x within s) <=> (f --> l) (at x))``,
  SIMP_TAC std_ss [tendsto, EVENTUALLY_WITHIN_INTERIOR]);

val NETLIMIT_WITHIN_INTERIOR = store_thm ("NETLIMIT_WITHIN_INTERIOR",
 ``!s x:real. x IN interior s ==> (netlimit(at x within s) = x)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC NETLIMIT_WITHIN THEN
  REWRITE_TAC[TRIVIAL_LIMIT_WITHIN] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP(REWRITE_RULE[OPEN_CONTAINS_BALL]
   (SPEC_ALL OPEN_INTERIOR))) THEN
  ASM_MESON_TAC[LIMPT_SUBSET, LIMPT_BALL, CENTRE_IN_CBALL, REAL_LT_IMP_LE,
   SUBSET_TRANS, INTERIOR_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* A non-singleton connected set is perfect (i.e. has no isolated points). *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_IMP_PERFECT = store_thm ("CONNECTED_IMP_PERFECT",
 ``!s x:real.
   connected s /\ ~(?a. s = {a}) /\ x IN s ==> x limit_point_of s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[limit_point_of] THEN
  X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `(~p ==> F) ==> p`) THEN DISCH_TAC THEN
  KNOW_TAC ``open t`` THENL [ASM_REWRITE_TAC [], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [OPEN_CONTAINS_CBALL] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``connected s`` THEN GEN_REWR_TAC LAND_CONV [CONNECTED_CLOPEN] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `{x:real}`) THEN
  REWRITE_TAC[NOT_IMP] THEN REPEAT CONJ_TAC THENL
  [REWRITE_TAC[OPEN_IN_OPEN] THEN EXISTS_TAC ``t:real->bool`` THEN
   ASM_SET_TAC[],
   REWRITE_TAC[CLOSED_IN_CLOSED] THEN
   EXISTS_TAC ``cball(x:real,e)`` THEN REWRITE_TAC[CLOSED_CBALL] THEN
   REWRITE_TAC[EXTENSION, IN_INTER, IN_SING] THEN
   ASM_MESON_TAC[CENTRE_IN_CBALL, SUBSET_DEF, REAL_LT_IMP_LE],
  ASM_SET_TAC[]]);

val CONNECTED_IMP_PERFECT_CLOSED = store_thm ("CONNECTED_IMP_PERFECT_CLOSED",
 ``!s x. connected s /\ closed s /\ ~(?a. s = {a})
   ==> (x limit_point_of s <=> x IN s)``,
  MESON_TAC[CONNECTED_IMP_PERFECT, CLOSED_LIMPT]);

(* ------------------------------------------------------------------------- *)
(* Boundedness.                                                              *)
(* ------------------------------------------------------------------------- *)

Definition bounded_def :
    Bounded s <=> ?a. !x:real. x IN s ==> abs(x) <= a
End
Overload bounded = “Bounded”

val BOUNDED_EMPTY = store_thm ("BOUNDED_EMPTY",
 ``bounded {}``,
  REWRITE_TAC[bounded_def, NOT_IN_EMPTY]);

val BOUNDED_SUBSET = store_thm ("BOUNDED_SUBSET",
 ``!s t. bounded t /\ s SUBSET t ==> bounded s``,
  MESON_TAC[bounded_def, SUBSET_DEF]);

val BOUNDED_INTERIOR = store_thm ("BOUNDED_INTERIOR",
 ``!s:real->bool. bounded s ==> bounded(interior s)``,
  MESON_TAC[BOUNDED_SUBSET, INTERIOR_SUBSET]);

val BOUNDED_CLOSURE = store_thm ("BOUNDED_CLOSURE",
 ``!s:real->bool. bounded s ==> bounded(closure s)``,
  REWRITE_TAC[bounded_def, CLOSURE_SEQUENTIAL] THEN
  GEN_TAC THEN STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN
  GEN_TAC THEN
  METIS_TAC[REWRITE_RULE[eventually] LIM_ABS_UBOUND,
   TRIVIAL_LIMIT_SEQUENTIALLY, trivial_limit]);

val BOUNDED_CLOSURE_EQ = store_thm ("BOUNDED_CLOSURE_EQ",
 ``!s:real->bool. bounded(closure s) <=> bounded s``,
  GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_CLOSURE] THEN
  MESON_TAC[BOUNDED_SUBSET, CLOSURE_SUBSET]);

val BOUNDED_CBALL = store_thm ("BOUNDED_CBALL",
 ``!x:real e. bounded(cball(x,e))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[bounded_def] THEN
  EXISTS_TAC ``abs(x:real) + e`` THEN REWRITE_TAC[IN_CBALL, dist] THEN
  REAL_ARITH_TAC);

val BOUNDED_BALL = store_thm ("BOUNDED_BALL",
 ``!x e. bounded(ball(x,e))``,
  MESON_TAC[BALL_SUBSET_CBALL, BOUNDED_CBALL, BOUNDED_SUBSET]);

val FINITE_IMP_BOUNDED = store_thm ("FINITE_IMP_BOUNDED",
 ``!s:real->bool. FINITE s ==> bounded s``,
  KNOW_TAC ``!s:real->bool. (bounded s) = (\s. bounded s) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN REWRITE_TAC[BOUNDED_EMPTY] THEN
  SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[bounded_def, IN_INSERT] THEN GEN_TAC THEN X_GEN_TAC ``x:real`` THEN
  REWRITE_TAC [AND_IMP_INTRO] THEN STRIP_TAC THEN
  EXISTS_TAC ``abs(x:real) + abs a`` THEN REPEAT STRIP_TAC THEN
  ASM_MESON_TAC[ABS_POS, REAL_ARITH
   ``(y <= b /\ &0 <= x ==> y <= x + abs b) /\ x <= x + abs b:real``]);

val BOUNDED_UNION = store_thm ("BOUNDED_UNION",
 ``!s t. bounded (s UNION t) <=> bounded s /\ bounded t``,
  REWRITE_TAC[bounded_def, IN_UNION] THEN MESON_TAC[REAL_LE_MAX]);

val BOUNDED_BIGUNION = store_thm ("BOUNDED_BIGUNION",
 ``!f. FINITE f /\ (!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)``,
  REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!f. ((!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)) =
             (\f. (!s. s IN f ==> bounded s) ==> bounded(BIGUNION f)) f`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  REWRITE_TAC[BIGUNION_EMPTY, BOUNDED_EMPTY, IN_INSERT, BIGUNION_INSERT] THEN
  MESON_TAC[BOUNDED_UNION]);

val BOUNDED_POS = store_thm ("BOUNDED_POS",
 ``!s. bounded s <=> ?b. &0 < b /\ !x. x IN s ==> abs(x) <= b``,
  REWRITE_TAC[bounded_def] THEN
  METIS_TAC[REAL_ARITH ``&0 < &1 + abs(y) /\ (x <= y ==> x:real <= &1 + abs(y))``]);

val BOUNDED_POS_LT = store_thm ("BOUNDED_POS_LT",
 ``!s. bounded s <=> ?b. &0 < b /\ !x. x IN s ==> abs(x) < b``,
  REWRITE_TAC[bounded_def] THEN
  MESON_TAC[REAL_LT_IMP_LE,
   REAL_ARITH ``&0 < &1 + abs(y) /\ (x <= y ==> x < &1 + abs(y:real))``]);

val BOUNDED_INTER = store_thm ("BOUNDED_INTER",
 ``!s t. bounded s \/ bounded t ==> bounded (s INTER t)``,
  MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET]);

val BOUNDED_DIFF = store_thm ("BOUNDED_DIFF",
 ``!s t. bounded s ==> bounded (s DIFF t)``,
  METIS_TAC[BOUNDED_SUBSET, DIFF_SUBSET]);

val BOUNDED_INSERT = store_thm ("BOUNDED_INSERT",
 ``!x s. bounded(x INSERT s) <=> bounded s``,
  ONCE_REWRITE_TAC[SET_RULE ``x INSERT s = {x} UNION s``] THEN
  SIMP_TAC std_ss [BOUNDED_UNION, FINITE_IMP_BOUNDED, FINITE_EMPTY, FINITE_INSERT]);

val BOUNDED_SING = store_thm ("BOUNDED_SING",
 ``!a. bounded {a}``,
  REWRITE_TAC[BOUNDED_INSERT, BOUNDED_EMPTY]);

val BOUNDED_BIGINTER = store_thm ("BOUNDED_BIGINTER",
 ``!f:(real->bool)->bool.
    (?s:real->bool. s IN f /\ bounded s) ==> bounded(BIGINTER f)``,
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] BOUNDED_SUBSET) THEN
  ASM_SET_TAC[]);

val NOT_BOUNDED_UNIV = store_thm ("NOT_BOUNDED_UNIV",
 ``~(bounded univ(:real))``,
  SIMP_TAC std_ss [BOUNDED_POS, NOT_FORALL_THM, NOT_EXISTS_THM, IN_UNIV,
                   DE_MORGAN_THM, REAL_NOT_LE] THEN
  X_GEN_TAC ``B:real`` THEN ASM_CASES_TAC ``&0 < B:real`` THEN ASM_REWRITE_TAC[] THEN
  EXISTS_TAC ``(B + &1):real`` THEN REAL_ARITH_TAC);

val COBOUNDED_IMP_UNBOUNDED = store_thm ("COBOUNDED_IMP_UNBOUNDED",
 ``!s. bounded(univ(:real) DIFF s) ==> ~bounded s``,
  GEN_TAC THEN REWRITE_TAC[TAUT `a ==> ~b <=> ~(a /\ b)`] THEN
  REWRITE_TAC[GSYM BOUNDED_UNION, SET_RULE ``UNIV DIFF s UNION s = UNIV``] THEN
  REWRITE_TAC[NOT_BOUNDED_UNIV]);

val BOUNDED_LINEAR_IMAGE = store_thm ("BOUNDED_LINEAR_IMAGE",
 ``!f:real->real s. bounded s /\ linear f ==> bounded(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``B1:real``) MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_TAC ``B2:real`` o MATCH_MP LINEAR_BOUNDED_POS) THEN
  EXISTS_TAC ``B2 * B1:real`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL, FORALL_IN_IMAGE] THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``B2 * abs(x:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL]);

val BOUNDED_SCALING = store_thm ("BOUNDED_SCALING",
 ``!c s. bounded s ==> bounded (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC BOUNDED_LINEAR_IMAGE THEN
  ASM_SIMP_TAC std_ss [LINEAR_COMPOSE_CMUL, LINEAR_ID]);

val BOUNDED_NEGATIONS = store_thm ("BOUNDED_NEGATIONS",
 ``!s. bounded s ==> bounded (IMAGE (\x. -x) s)``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``-&1:real`` o MATCH_MP BOUNDED_SCALING) THEN
  REWRITE_TAC[bounded_def, IN_IMAGE, REAL_MUL_LNEG, REAL_MUL_LID]);

val BOUNDED_TRANSLATION = store_thm ("BOUNDED_TRANSLATION",
 ``!a:real s. bounded s ==> bounded (IMAGE (\x. a + x) s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real``) THEN
  EXISTS_TAC ``B + abs(a:real)`` THEN POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN REAL_ARITH_TAC);

val BOUNDED_TRANSLATION_EQ = store_thm ("BOUNDED_TRANSLATION_EQ",
 ``!a s. bounded (IMAGE (\x:real. a + x) s) <=> bounded s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o SPEC ``-a:real`` o MATCH_MP BOUNDED_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val BOUNDED_DIFFS = store_thm ("BOUNDED_DIFFS",
 ``!s t:real->bool.
  bounded s /\ bounded t ==> bounded {x - y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``B:real``) (X_CHOOSE_TAC ``C:real``)) THEN
  EXISTS_TAC ``B + C:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  CONJ_TAC THENL [MATCH_MP_TAC REAL_LT_ADD THEN ASM_REWRITE_TAC [], REPEAT STRIP_TAC] THEN
  ASM_REWRITE_TAC[] THEN KNOW_TAC ``abs p_1 <= B:real /\ abs p_2 <= C:real`` THENL
  [ASM_SET_TAC [], ALL_TAC] THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs p_1 + abs p_2:real`` THEN REWRITE_TAC [real_sub, ABS_TRIANGLE] THEN
  CONJ_TAC THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC [ABS_NEG]);

val BOUNDED_SUMS = store_thm ("BOUNDED_SUMS",
 ``!s t:real->bool.
   bounded s /\ bounded t ==> bounded {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``B:real``) (X_CHOOSE_TAC ``C:real``)) THEN
  EXISTS_TAC ``B + C:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  CONJ_TAC THENL [MATCH_MP_TAC REAL_LT_ADD THEN ASM_REWRITE_TAC [], REPEAT STRIP_TAC] THEN
  ASM_REWRITE_TAC[] THEN KNOW_TAC ``abs p_1 <= B:real /\ abs p_2 <= C:real`` THENL
  [ASM_SET_TAC [], ALL_TAC] THEN STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs p_1 + abs p_2:real`` THEN REWRITE_TAC [ABS_TRIANGLE] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC []);

val BOUNDED_SUMS_IMAGE = store_thm ("BOUNDED_SUMS_IMAGE",
 ``!f g t. bounded {f x | x IN t} /\ bounded {g x | x IN t}
    ==> bounded {f x + g x | x IN t}``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_SUMS) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] BOUNDED_SUBSET) THEN
  REWRITE_TAC [SUBSET_DEF] THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC []);

val BOUNDED_SUMS_IMAGES = store_thm ("BOUNDED_SUMS_IMAGES",
 ``!f:'a->'b->real t s. FINITE s /\
     (!a. a IN s ==> bounded {f x a | x IN t})
     ==> bounded { sum s (f x) | x IN t}``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[GSYM AND_IMP_INTRO] THEN
  KNOW_TAC ``!s. ((!a. a IN s ==> bounded {(f:'a->'b->real) x a | x IN t}) ==>
                                  bounded {sum s (f x) | x IN t}) =
             (\s. (!a. a IN s ==> bounded {f x a | x IN t}) ==>
                                  bounded {sum s (f x) | x IN t}) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [SUM_CLAUSES] THEN CONJ_TAC THENL
  [DISCH_THEN(K ALL_TAC) THEN MATCH_MP_TAC BOUNDED_SUBSET THEN
   EXISTS_TAC ``{0:real}`` THEN
   SIMP_TAC std_ss [FINITE_IMP_BOUNDED, FINITE_EMPTY, FINITE_INSERT] THEN SET_TAC[],
   ALL_TAC] THEN REPEAT STRIP_TAC THEN
  KNOW_TAC ``bounded {(f:'a->'b->real) x e | x IN t} /\
             bounded {sum s ((f:'a->'b->real) x) | x IN t}`` THENL
  [ALL_TAC, METIS_TAC [BOUNDED_SUMS_IMAGE]] THEN ASM_SIMP_TAC std_ss [IN_INSERT]);

val BOUNDED_SUBSET_BALL = store_thm ("BOUNDED_SUBSET_BALL",
 ``!s x:real. bounded(s) ==> ?r. &0 < r /\ s SUBSET ball(x,r)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[BOUNDED_POS] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``&2 * B + abs(x:real)`` THEN
  ASM_SIMP_TAC std_ss [ABS_POS, REAL_ARITH
   ``&0 < B /\ &0 <= x ==> &0 < &2 * B + x:real``] THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_REWRITE_TAC[IN_BALL, dist] THEN
  UNDISCH_TAC ``&0 < B:real`` THEN REAL_ARITH_TAC);

val BOUNDED_SUBSET_CBALL = store_thm ("BOUNDED_SUBSET_CBALL",
 ``!s x:real. bounded(s) ==> ?r. &0 < r /\ s SUBSET cball(x,r)``,
  MESON_TAC[BOUNDED_SUBSET_BALL, SUBSET_TRANS, BALL_SUBSET_CBALL]);

val UNBOUNDED_INTER_COBOUNDED = store_thm ("UNBOUNDED_INTER_COBOUNDED",
 ``!s t. ~bounded s /\ bounded(univ(:real) DIFF t) ==> ~(s INTER t = {})``,
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> s SUBSET univ(:real) DIFF t``] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val COBOUNDED_INTER_UNBOUNDED = store_thm ("COBOUNDED_INTER_UNBOUNDED",
 ``!s t. bounded(univ(:real) DIFF s) /\ ~bounded t ==> ~(s INTER t = {})``,
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> t SUBSET univ(:real) DIFF s``] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val SUBSPACE_BOUNDED_EQ_TRIVIAL = store_thm ("SUBSPACE_BOUNDED_EQ_TRIVIAL",
 ``!s:real->bool. subspace s ==> (bounded s <=> (s = {0}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [BOUNDED_SING] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (SET_RULE
  ``~(s = {a}) ==> a IN s ==> ?b. b IN s /\ ~(b = a)``)) THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_0] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real`` STRIP_ASSUME_TAC) THEN
  SIMP_TAC std_ss [bounded_def, NOT_EXISTS_THM] THEN X_GEN_TAC ``B:real`` THEN
  EXISTS_TAC ``(B + &1) / abs v * v:real`` THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM ABS_ZERO]) THEN
  ASM_SIMP_TAC std_ss [SUBSPACE_MUL, ABS_MUL, ABS_DIV, ABS_ABS] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, ABS_ZERO] THEN REAL_ARITH_TAC);

val BOUNDED_COMPONENTWISE = store_thm ("BOUNDED_COMPONENTWISE",
 ``!s:real->bool.
   bounded s <=> bounded (IMAGE (\x. x) s)``,
 METIS_TAC [IMAGE_ID]);

(* ------------------------------------------------------------------------- *)
(* Some theorems on sups and infs using the notion "bounded".                *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_HAS_SUP = store_thm ("BOUNDED_HAS_SUP",
 ``!s. bounded s /\ ~(s = {})
    ==> (!x. x IN s ==> x <= sup s) /\
    (!b. (!x. x IN s ==> x <= b) ==> sup s <= b)``,
  REWRITE_TAC[bounded_def, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[SUP, REAL_ARITH ``abs(x) <= a ==> x <= a:real``]);

val SUP_INSERT = store_thm ("SUP_INSERT",
 ``!x s:real->bool. bounded s
   ==> (sup(x INSERT s) = if s = {} then x else (max x (sup s)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_SUP_UNIQUE THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_SING] THENL
  [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
   REWRITE_TAC[REAL_LE_MAX, REAL_LT_MAX, IN_INSERT] THEN
   MP_TAC(ISPEC ``s:real->bool`` BOUNDED_HAS_SUP) THEN ASM_REWRITE_TAC[] THEN
   REPEAT STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_REFL, REAL_NOT_LT]);

val BOUNDED_HAS_INF = store_thm ("BOUNDED_HAS_INF",
 ``!s. bounded s /\ ~(s = {})
   ==> (!x. x IN s ==> inf s <= x) /\
   (!b. (!x. x IN s ==> b <= x) ==> b <= inf s)``,
  REWRITE_TAC[bounded_def, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[INF, REAL_ARITH ``abs(x) <= a ==> -a <= x:real``]);

val INF_INSERT = store_thm ("INF_INSERT",
 ``!x s. bounded s
   ==> (inf(x INSERT s) = if s = {} then x else (min x (inf s)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_INF_UNIQUE THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[IN_SING] THENL
  [MESON_TAC[REAL_LE_REFL], ALL_TAC] THEN
   REWRITE_TAC[REAL_MIN_LE, REAL_MIN_LT, IN_INSERT] THEN
   MP_TAC(ISPEC ``s:real->bool`` BOUNDED_HAS_INF) THEN ASM_REWRITE_TAC[] THEN
   REPEAT STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_REFL, REAL_NOT_LT]);

(* ------------------------------------------------------------------------- *)
(* Subset and overlapping relations on balls.                                *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``(!a':real r r'.
       cball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r < &0) /\
     (!a':real r r'.
       cball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r < r' \/ r < &0)``,
    CONJ_TAC THENL
    [KNOW_TAC ``(!a' r r'.
  cball (a,r) SUBSET cball (a',r') <=> dist (a,a') + r <= r' \/ r < 0) =
               (!r r' a.
  cball (a,r) SUBSET cball (0,r') <=> dist (a,0) + r <= r' \/ r < 0)`` THENL
  [EQ_TAC THENL
   [DISCH_TAC THEN REPEAT GEN_TAC THEN
    FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
     REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``a - (a - b) = b:real``] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
    [DISCH_TAC THEN GEN_TAC THEN
     POP_ASSUM (MP_TAC o Q.SPEC `-(a - a' - x:real)`) THEN
     REWRITE_TAC [ABS_NEG] THEN REAL_ARITH_TAC, ALL_TAC] THEN
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a + a' - x:real)`) THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN
  FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
   REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN GEN_TAC THEN
   POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
  REAL_ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC[] THEN POP_ASSUM K_TAC],
    KNOW_TAC ``(!a' r r'.
  cball (a,r) SUBSET ball (a',r') <=> dist (a,a') + r < r' \/ r < 0) =
               (!r r' a.
  cball (a,r) SUBSET ball (0,r') <=> dist (a,0) + r < r' \/ r < 0)`` THENL
  [EQ_TAC THENL
   [DISCH_TAC THEN REPEAT GEN_TAC THEN
    FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
     REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [REAL_ARITH ``a - (a - b) = b:real``] THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
    [DISCH_TAC THEN GEN_TAC THEN
     POP_ASSUM (MP_TAC o Q.SPEC `-(a - a' - x:real)`) THEN
     REWRITE_TAC [ABS_NEG] THEN REAL_ARITH_TAC, ALL_TAC] THEN
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a + a' - x:real)`) THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN
  FULL_SIMP_TAC std_ss [cball, ball, SUBSET_DEF, GSPECIFICATION, dist,
   REAL_SUB_LZERO, REAL_SUB_RZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN GEN_TAC THEN
   POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
  REAL_ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC[] THEN POP_ASSUM K_TAC]] THEN
   (REPEAT GEN_TAC THEN REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_BALL] THEN
    EQ_TAC THENL
    [REWRITE_TAC[DIST_0],
     REWRITE_TAC [dist] THEN REAL_ARITH_TAC] THEN
    DISJ_CASES_TAC(REAL_ARITH ``r < &0 \/ &0 <= r:real``) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN DISJ1_TAC THEN
    ASM_CASES_TAC ``a:real = 0`` THENL
     [FIRST_X_ASSUM(MP_TAC o SPEC ``r:real``) THEN
      ASM_SIMP_TAC std_ss [DIST_0, ABS_MUL, LESS_EQ_REFL] THEN
      ASM_REAL_ARITH_TAC,
      FIRST_X_ASSUM(MP_TAC o SPEC ``(&1 + r / abs(a)) * a:real``) THEN
      SIMP_TAC std_ss [dist, REAL_ARITH ``a - (&1 + x) * a:real = -(x * a)``] THEN
      ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, ABS_NEG, REAL_POS,
                   REAL_LE_DIV, ABS_POS, REAL_ADD_RDISTRIB, REAL_DIV_RMUL,
               ABS_ZERO, REAL_ARITH ``&0 <= x ==> (abs(&1 + x) = &1 + x:real)``] THEN
      ASM_REAL_ARITH_TAC]));

val tac = DISCH_THEN(MP_TAC o MATCH_MP SUBSET_CLOSURE) THEN
          ASM_SIMP_TAC std_ss [CLOSED_CBALL, CLOSURE_CLOSED, CLOSURE_BALL];

val SUBSET_BALLS = store_thm ("SUBSET_BALLS",
 ``(!a a':real r r'.
      ball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r <= r' \/ r <= &0) /\
   (!a a':real r r'.
      ball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r <= &0) /\
   (!a a':real r r'.
      cball(a,r) SUBSET ball(a',r') <=> dist(a,a') + r < r' \/ r < &0) /\
   (!a a':real r r'.
      cball(a,r) SUBSET cball(a',r') <=> dist(a,a') + r <= r' \/ r < &0)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  KNOW_TAC ``(!a a':real r r'.
  (ball (a,r) SUBSET ball (a',r') <=>
   dist (a,a') + r <= r' \/ r <= 0) /\
  (ball (a,r) SUBSET cball (a',r') <=>
   dist (a,a') + r <= r' \/ r <= 0) /\
  (cball (a,r) SUBSET ball (a',r') <=>
     dist (a,a') + r < r' \/ r < 0) /\
  (cball (a,r) SUBSET cball (a',r') <=>
    dist (a,a') + r <= r' \/ r < 0)) =
   (!a:real r r'.
  (ball (a,r) SUBSET ball (0,r') <=>
   dist (a,0) + r <= r' \/ r <= 0) /\
  (ball (a,r) SUBSET cball (0,r') <=>
   dist (a,0) + r <= r' \/ r <= 0) /\
  (cball (a,r) SUBSET ball (0,r') <=>
     dist (a,0) + r < r' \/ r < 0) /\
  (cball (a,r) SUBSET cball (0,r') <=>
    dist (a,0) + r <= r' \/ r < 0))`` THENL
 [EQ_TAC THENL
  [DISCH_TAC THEN REPEAT GEN_TAC THEN METIS_TAC [], ALL_TAC] THEN
  DISCH_TAC THEN REPEAT GEN_TAC THEN FULL_SIMP_TAC std_ss [DIST_0] THEN
  FULL_SIMP_TAC std_ss [cball, ball, dist, SUBSET_DEF, GSPECIFICATION] THEN
  FULL_SIMP_TAC std_ss [REAL_SUB_LZERO, ABS_NEG] THEN
  POP_ASSUM (MP_TAC o Q.SPEC `a - a':real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r:real`) THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `r':real`) THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [EQ_SYM_EQ] THEN
  REPEAT STRIP_TAC THENL
  [UNDISCH_TAC ``abs (a - a') + r <= r' \/ r <= 0 <=>
        !x:real. abs (a - a' - x) < r ==> abs x < r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r <= r' \/ r <= 0 <=>
        !x:real. abs (a - a' - x) < r ==> abs x <= r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r < r' \/ r < 0 <=>
        !x:real. abs (a - a' - x) <= r ==> abs x < r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC],
   UNDISCH_TAC ``abs (a - a') + r <= r' \/ r < 0 <=>
        !x:real. abs (a - a' - x) <= r ==> abs x <= r'`` THEN
   REPEAT (POP_ASSUM K_TAC) THEN DISCH_TAC THEN
   ASM_REWRITE_TAC [] THEN EQ_TAC THENL
   [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(-a' - x:real)`) THEN
    REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o Q.SPEC `-(a' - x:real)`) THEN
    REAL_ARITH_TAC]],
 DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  REPEAT STRIP_TAC THEN
  (EQ_TAC THENL
    [ALL_TAC, REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL, dist] THEN REAL_ARITH_TAC]) THEN
  MATCH_MP_TAC(SET_RULE
   ``((s = {}) <=> q) /\ (s SUBSET t /\ ~(s = {}) /\ ~(t = {}) ==> p)
    ==> s SUBSET t ==> p \/ q``) THEN
  SIMP_TAC std_ss [BALL_EQ_EMPTY, CBALL_EQ_EMPTY, REAL_NOT_LE, REAL_NOT_LT] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THENL
   [tac, tac, ALL_TAC, ALL_TAC] THEN REWRITE_TAC[lemma] THEN
  REPEAT(POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

Theorem INTER_BALLS_EQ_EMPTY :
   (!a b:real r s. (ball(a,r) INTER ball(b,s) = {}) <=>
                     r <= &0 \/ s <= &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (ball(a,r) INTER cball(b,s) = {}) <=>
                     r <= &0 \/ s < &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (cball(a,r) INTER ball(b,s) = {}) <=>
                     r < &0 \/ s <= &0 \/ r + s <= dist(a,b)) /\
   (!a b:real r s. (cball(a,r) INTER cball(b,s) = {}) <=>
                     r < &0 \/ s < &0 \/ r + s < dist(a,b))
Proof
  rpt STRIP_TAC >| (* 4 subgoals *)
  [(* goal 1 (of 4) *)
   Suff `!b:real. 0 <= b ==>
               !r s:real. ((ball (0,r) INTER ball (b,s) = {}) <=>
                r <= 0 \/ s <= 0 \/ r + s <= dist (0,b))` >-
   (SIMP_TAC std_ss [ball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]),
   (* goal 2 (of 4) *)
   Suff `!b:real. 0 <= b ==>
               !r s:real. ((ball (0,r) INTER cball (b,s) = {}) <=>
                r <= 0 \/ s < 0 \/ r + s <= dist (0,b))` >-
   (SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]),
   (* goal 3 (of 4) *)
   Suff `!b:real. 0 <= b ==>
               !r s:real. ((cball (0,r) INTER ball (b,s) = {}) <=>
                r < 0 \/ s <= 0 \/ r + s <= dist (0,b))` >-
   (SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC]),
   (* goal 4 (of 4) *)
   Suff `!b:real. 0 <= b ==>
               !r s:real. ((cball (0,r) INTER cball (b,s) = {}) <=>
                r < 0 \/ s < 0 \/ r + s < dist (0,b))` >-
   (SIMP_TAC std_ss [ball, cball, dist, REAL_ARITH ``abs (0 - x:real) = abs x``,
                    EXTENSION, GSPECIFICATION, INTER_DEF, NOT_IN_EMPTY, REAL_NOT_LT] THEN
    DISCH_TAC THEN POP_ASSUM (MP_TAC o SPEC ``abs (a - b:real)``) THEN
    REWRITE_TAC [ABS_POS, ABS_ABS] THEN DISCH_TAC THEN
    POP_ASSUM (MP_TAC o SPECL [``r:real``,``s:real``]) THEN
    GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    POP_ASSUM K_TAC THEN REWRITE_TAC [abs] THEN COND_CASES_TAC THEN
    REWRITE_TAC [GSYM abs] THENL [EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a - x:real``) THEN REAL_ARITH_TAC, ALL_TAC] THEN
    EQ_TAC THENL [DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN REAL_ARITH_TAC,
    DISCH_TAC THEN GEN_TAC THEN
    POP_ASSUM (MP_TAC o SPEC ``-(a - x):real``) THEN REAL_ARITH_TAC])] THEN
  (* still 4 subgoals *)
  rpt STRIP_TAC THEN
  REWRITE_TAC[EXTENSION, NOT_IN_EMPTY, IN_INTER, IN_CBALL, IN_BALL] THEN
  (reverse EQ_TAC
   >- (Q.SPEC_TAC (`b`, `v`) THEN REWRITE_TAC [dist] THEN REAL_ARITH_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``c:real`` o SPEC ``c:real``) THEN
  SIMP_TAC std_ss [ABS_MUL, LESS_EQ_REFL, dist, ABS_NEG,
           REAL_SUB_LZERO, GSYM REAL_SUB_RDISTRIB, REAL_MUL_RID] THEN
  ASM_REWRITE_TAC[abs] THEN REWRITE_TAC[GSYM abs] THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``min b r:real`` th) THEN
    MP_TAC(SPEC ``max (&0) (b - s:real)`` th) THEN
    MP_TAC(SPEC ``(r + (b - s)) / &2:real`` th)) THEN
  REWRITE_TAC [real_div] THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``a - b * c = a * 1 - b * c:real``] THEN
  REWRITE_TAC [METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``, real_div]
   ``1 = 2 * inv 2:real``, REAL_ARITH ``a * (b * c) = (a * b) * c:real``] THEN
  REWRITE_TAC [GSYM REAL_SUB_RDISTRIB] THEN
  SIMP_TAC std_ss [real_div, ABS_MUL, REAL_ARITH ``2 <> 0:real``, ABS_INV, ABS_N] THEN
  SIMP_TAC std_ss [GSYM real_div] THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_LE_RDIV_EQ,
                        REAL_LT_LDIV_EQ, REAL_LE_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN

  (* NOTE: previously, when porting this proof from HOL-Light to HOL4, I had
     to rewrite max/min/abs before calling REAL_ASM_ARITH_TAC, and this have
     caused 1024 subgoals here (1024 calls to REAL_ARITH), which take about 10
     10 seconds to finish. Now we forcely use the new one from RealArith, and
     this means this last step does not participate the performance comparisons
     when we globally switch REAL_ARITH, etc from realLib. -- Chun Tian
   *)
  REAL_ASM_ARITH_TAC
QED

(* ------------------------------------------------------------------------- *)
(* Compactness (the definition is the one based on convegent subsequences).  *)
(* ------------------------------------------------------------------------- *)

val compact = new_definition ("compact",
 ``compact s <=> !f:num->real. (!n. f(n) IN s)
   ==> ?l r. l IN s /\ (!m n:num. m < n ==> r(m) < r(n)) /\
       ((f o r) --> l) sequentially``);

val MONOTONE_BIGGER = store_thm ("MONOTONE_BIGGER",
 ``!r. (!m n. m < n ==> r(m) < r(n)) ==> !n:num. n <= r(n)``,
  GEN_TAC THEN DISCH_TAC THEN INDUCT_TAC THEN
  METIS_TAC[ZERO_LESS_EQ, ARITH_PROVE ``n <= m /\ m < p ==> SUC n <= p``, LT]);

val LIM_SUBSEQUENCE = store_thm ("LIM_SUBSEQUENCE",
 ``!s r l. (!m n. m < n ==> r(m) < r(n)) /\ (s --> l) sequentially
  ==> (s o r --> l) sequentially``,
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  MESON_TAC[MONOTONE_BIGGER, LESS_EQ_TRANS]);

(* In this "weak" version, r(n) may increase weakly and slowly,
   but eventually r(n) should go to infinity. (added by Chun Tian for SLLN_IID)

   This lemma is useful when ‘r = \n. flr (a pow n)’, where ‘1 < a’ (but close to 1)
 *)
Theorem LIM_SUBSEQUENCE_WEAK :
    !s r l. (!m n. m <= n ==> r(m) <= r(n)) /\ (!n. ?m. n <= r(m)) /\
            (s --> l) sequentially ==> (s o r --> l) sequentially
Proof
    RW_TAC std_ss [LIM_SEQUENTIALLY, dist, o_THM]
 >> Q.PAT_X_ASSUM ‘!e. 0 < e ==> P’ (MP_TAC o (Q.SPEC ‘e’))
 >> RW_TAC std_ss []
 >> Q.PAT_X_ASSUM ‘!n. ?m. n <= r m’ (MP_TAC o (Q.SPEC ‘N’))
 >> RW_TAC std_ss []
 >> Q.EXISTS_TAC ‘MAX N m’
 >> RW_TAC std_ss [MAX_LE]
 >> FIRST_X_ASSUM MATCH_MP_TAC
 >> MATCH_MP_TAC LESS_EQ_TRANS
 >> Q.EXISTS_TAC ‘r m’ >> art []
 >> FIRST_X_ASSUM MATCH_MP_TAC >> art []
QED

val MONOTONE_SUBSEQUENCE = store_thm ("MONOTONE_SUBSEQUENCE",
 ``!s:num->real. ?r:num->num.
   (!m n. m < n ==> r(m) < r(n)) /\
  ((!m n. m <= n ==> s(r(m)) <= s(r(n))) \/
   (!m n. m <= n ==> s(r(n)) <= s(r(m))))``,
  GEN_TAC THEN
  ASM_CASES_TAC ``!n:num. ?p. n < p /\ !m. p <= m ==> s(m):real <= s(p)`` THEN
  POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, NOT_IMP, DE_MORGAN_THM] THEN
  SIMP_TAC std_ss [RIGHT_OR_EXISTS_THM, SKOLEM_THM, REAL_NOT_LE, REAL_NOT_LT] THENL
  [ABBREV_TAC ``N = 0:num``, DISCH_THEN(X_CHOOSE_THEN ``N:num`` MP_TAC)] THEN
  DISCH_THEN(X_CHOOSE_THEN ``next:num->num`` STRIP_ASSUME_TAC) THEN
  (KNOW_TAC ``(?r. (r 0 = (next:num->num) (SUC N)) /\
             (!n. r (SUC n) = (next:num->num) (r n)))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC]) THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THENL
  [SUBGOAL_THEN ``!m:num n:num. r n <= m ==> s(m) <= s(r n):real``
   ASSUME_TAC THEN TRY CONJ_TAC THEN TRY DISJ2_TAC THEN
   GEN_TAC THEN INDUCT_TAC THEN ASM_SIMP_TAC std_ss [LT, LE] THEN
   ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL, LESS_IMP_LESS_OR_EQ, LESS_TRANS],
   SUBGOAL_THEN ``!n. N < (r:num->num) n`` ASSUME_TAC THEN
   TRY(CONJ_TAC THENL [GEN_TAC, DISJ1_TAC THEN GEN_TAC]) THEN
   INDUCT_TAC THEN ASM_SIMP_TAC std_ss [LT, LE] THEN
   TRY STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
   ASM_MESON_TAC[REAL_LT_REFL, LT_LE, LESS_LESS_EQ_TRANS, REAL_LE_REFL,
    REAL_LT_LE, REAL_LE_TRANS, LT]]);

val CONVERGENT_BOUNDED_INCREASING = store_thm ("CONVERGENT_BOUNDED_INCREASING",
 ``!s:num->real b. (!m n. m <= n ==> s m <= s n) /\ (!n. abs(s n) <= b)
   ==> ?l. !e. &0 < e ==> ?N. !n. N <= n ==> abs(s n - l) < e``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``\x. ?n. (s:num->real) n = x`` REAL_COMPLETE) THEN BETA_TAC THEN
  KNOW_TAC ``(?x:real n:num. s n = x) /\ (?M. !x. (?n. s n = x) ==> x <= M)`` THENL
  [ASM_MESON_TAC[REAL_ARITH ``abs(x:real) <= b ==> x <= b``],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN EXISTS_TAC ``l:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``l - e:real``) THEN
  METIS_TAC[REAL_ARITH ``&0:real < e ==> ~(l <= l - e)``,
  REAL_ARITH ``x <= y /\ y <= l /\ ~(x <= l - e) ==> abs(y - l) < e:real``]);

val CONVERGENT_BOUNDED_MONOTONE = store_thm ("CONVERGENT_BOUNDED_MONOTONE",
 ``!s:num->real b. (!n. abs(s n) <= b) /\
   ((!m n. m <= n ==> s m <= s n) \/
    (!m n. m <= n ==> s n <= s m))
   ==> ?l. !e. &0 < e ==> ?N. !n. N <= n ==> abs(s n - l) < e``,
  REPEAT STRIP_TAC THENL
  [ASM_MESON_TAC[CONVERGENT_BOUNDED_INCREASING], ALL_TAC] THEN
  MP_TAC(SPEC ``\n. -((s:num->real) n)`` CONVERGENT_BOUNDED_INCREASING) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_NEG2, ABS_NEG] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x - -l) = abs(-x - l:real)``]);

val COMPACT_REAL_LEMMA = store_thm ("COMPACT_REAL_LEMMA",
 ``!s b. (!n:num. abs(s n) <= b)
   ==> ?l r. (!m n:num. m < n ==> r(m) < r(n)) /\
   !e. &0:real < e ==> ?N. !n. N <= n ==> abs(s(r n) - l) < e``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  KNOW_TAC ``?(r :num -> num) (l :real).
  (!(m :num) (n :num). m < n ==> r m < r n) /\
  !(e :real).
    (0 :real) < e ==>
    ?(N :num).
      !(n :num). N <= n ==> abs ((s :num -> real) (r n) - l) < e`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  MP_TAC(SPEC ``s:num->real`` MONOTONE_SUBSEQUENCE) THEN
  DISCH_THEN (X_CHOOSE_TAC ``r:num->num``) THEN EXISTS_TAC ``r:num->num`` THEN
  ASM_SIMP_TAC std_ss [] THEN POP_ASSUM MP_TAC THEN STRIP_TAC THENL
  [MP_TAC(SPEC ``\n. ((s:num->real) ((r:num->num) n))`` CONVERGENT_BOUNDED_INCREASING),
   MP_TAC(SPEC ``\n. -((s:num->real) ((r:num->num) n))`` CONVERGENT_BOUNDED_INCREASING)] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_NEG2, ABS_NEG] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x - -l) = abs(-x - l:real)``]);

val COMPACT_LEMMA = store_thm ("COMPACT_LEMMA",
``!s. bounded s /\ (!n. (x:num->real) n IN s)
      ==> ?l:real r. (!m n. m < n ==> r m < (r:num->num) n) /\
      !e. &0 < e ==> ?N. !n i. N <= n ==> abs(x(r n) - l) < e``,
  METIS_TAC [COMPACT_REAL_LEMMA, bounded_def]);

val BOUNDED_CLOSED_IMP_COMPACT = store_thm ("BOUNDED_CLOSED_IMP_COMPACT",
 ``!s:real->bool. bounded s /\ closed s ==> compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[compact] THEN
  X_GEN_TAC ``x:num->real`` THEN DISCH_TAC THEN
  MP_TAC(ISPEC ``s:real->bool`` COMPACT_LEMMA) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC [``l:real``, ``r:num->num``] THEN
  ASM_SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC(TAUT `(b ==> a) /\ b ==> a /\ b`) THEN
  REPEAT STRIP_TAC THENL
  [FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CLOSED_SEQUENTIAL_LIMITS]) THEN
   EXISTS_TAC ``(x:num->real) o (r:num->num)`` THEN
   ASM_SIMP_TAC std_ss [o_THM], ALL_TAC] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, REAL_HALF,
   ARITH_PROVE ``0:num < n <=> ~(n = 0)``] THEN
  STRIP_TAC THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN
  REWRITE_TAC[dist] THEN REPEAT STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  GEN_REWR_TAC LAND_CONV [GSYM REAL_ADD_RID] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
  UNDISCH_TAC `` !n:num. N <= n ==> abs (x ((r:num->num) n) - l) < e / 2:real`` THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `n:num`) THEN
  ASM_REWRITE_TAC [] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  METIS_TAC [REAL_LT_HALF1]);

(* ------------------------------------------------------------------------- *)
(* Completeness.                                                             *)
(* ------------------------------------------------------------------------- *)

Definition cauchy_def :
    cauchy (s:num->real) <=>
     !e. &0 < e ==> ?N. !m n. m >= N /\ n >= N ==> dist(s m,s n) < e
End
Theorem cauchy[local] = cauchy_def

val complete = new_definition ("complete",
  ``complete s <=>
     !f:num->real. (!n. f n IN s) /\ cauchy f
                      ==> ?l. l IN s /\ (f --> l) sequentially``);

val CAUCHY = store_thm ("CAUCHY",
 ``!s:num->real.
      cauchy s <=> !e. &0 < e ==> ?N. !n. n >= N ==> dist(s n,s N) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[cauchy, GREATER_EQ] THEN EQ_TAC THENL
   [MESON_TAC[LESS_EQ_REFL], DISCH_TAC] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_LT_HALF1] THEN
  MESON_TAC[DIST_TRIANGLE_HALF_L]);

val CONVERGENT_IMP_CAUCHY = store_thm ("CONVERGENT_IMP_CAUCHY",
 ``!s l. (s --> l) sequentially ==> cauchy s``,
  REWRITE_TAC[LIM_SEQUENTIALLY, cauchy] THEN
  REPEAT GEN_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  ASM_MESON_TAC[GREATER_EQ, LESS_EQ_REFL, DIST_TRIANGLE_HALF_L]);

val GREATER_EQ_REFL = store_thm ("GREATER_EQ_REFL",
  ``!m:num. m >= m``,
  REWRITE_TAC [GREATER_EQ, LESS_EQ_REFL]);

val CAUCHY_IMP_BOUNDED = store_thm ("CAUCHY_IMP_BOUNDED",
 ``!s:num->real. cauchy s ==> bounded {y | ?n. y = s n}``,
  REWRITE_TAC[cauchy, bounded_def, GSPECIFICATION] THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``&1:real``) THEN REWRITE_TAC[REAL_LT_01] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` (MP_TAC o SPEC ``N:num``)) THEN
  REWRITE_TAC[GREATER_EQ_REFL] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``!n:num. N <= n ==> abs(s n :real) <= abs(s N) + &1:real``
  ASSUME_TAC THENL
   [ASM_MESON_TAC[GREATER_EQ, dist, DIST_SYM, ABS_TRIANGLE_SUB,
                  REAL_ARITH ``a <= b + c /\ c < &1 ==> a <= b + &1:real``],
    MP_TAC(ISPECL [``\n:num. abs(s n :real)``, ``{0..N}``]
                  UPPER_BOUND_FINITE_SET_REAL) THEN
    SIMP_TAC std_ss [FINITE_NUMSEG, IN_NUMSEG, LESS_EQ_0, GSYM LEFT_EXISTS_IMP_THM] THEN
    ASM_MESON_TAC[LESS_EQ_CASES,
                  REAL_ARITH ``x <= a \/ x <= b ==> x <= abs a + abs b:real``]]);

val COMPACT_IMP_COMPLETE = store_thm ("COMPACT_IMP_COMPLETE",
 ``!s:real->bool. compact s ==> complete s``,
  GEN_TAC THEN REWRITE_TAC[complete, compact] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `f:num->real`) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN EXISTS_TAC ``l:real`` THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP] LIM_ADD)) THEN
  DISCH_THEN(MP_TAC o SPEC ``\n. (f:num->real)(n) - f(r n)``) THEN
  DISCH_THEN(MP_TAC o SPEC ``0:real``) THEN ASM_SIMP_TAC std_ss [o_THM] THEN
  SIMP_TAC std_ss [REAL_ADD_RID, REAL_SUB_ADD2, ETA_AX] THEN
  DISCH_THEN MATCH_MP_TAC THEN
  UNDISCH_TAC ``cauchy f`` THEN GEN_REWR_TAC LAND_CONV [cauchy] THEN
  SIMP_TAC std_ss [GE, LIM, SEQUENTIALLY, dist, REAL_SUB_RZERO] THEN
  SUBGOAL_THEN ``!n:num. n <= r(n)`` MP_TAC THENL [INDUCT_TAC, ALL_TAC] THEN
  ASM_MESON_TAC[LESS_EQ_TRANS, LESS_EQ_REFL, LT, LESS_EQ_LESS_TRANS, ZERO_LESS_EQ, LE_SUC_LT]);

val COMPLETE_UNIV = store_thm ("COMPLETE_UNIV",
 ``complete univ(:real)``,
  REWRITE_TAC[complete, IN_UNIV] THEN X_GEN_TAC ``x:num->real`` THEN
  DISCH_TAC THEN FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_IMP_BOUNDED) THEN
  DISCH_THEN(ASSUME_TAC o MATCH_MP BOUNDED_CLOSURE) THEN
  MP_TAC(ISPEC ``closure {y:real | ?n:num. y = x n}``
   COMPACT_IMP_COMPLETE) THEN
  ASM_SIMP_TAC std_ss [BOUNDED_CLOSED_IMP_COMPACT, CLOSED_CLOSURE, complete] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:num->real``) THEN
  KNOW_TAC ``(!n. x n IN closure {y | ?n. y = x n}) /\ cauchy x`` THENL
  [ALL_TAC, MESON_TAC[]] THEN
  ASM_SIMP_TAC std_ss [closure, GSPECIFICATION, IN_UNION] THEN MESON_TAC[]);

val COMPLETE_EQ_CLOSED = store_thm ("COMPLETE_EQ_CLOSED",
 ``!s:real->bool. complete s <=> closed s``,
  GEN_TAC THEN EQ_TAC THENL
  [REWRITE_TAC[complete, CLOSED_LIMPT, LIMPT_SEQUENTIAL] THEN
   SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN GEN_TAC THEN
   SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN DISCH_TAC THEN
   GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `f:num->real`) THEN
   MESON_TAC[CONVERGENT_IMP_CAUCHY, IN_DELETE, LIM_UNIQUE,
    TRIVIAL_LIMIT_SEQUENTIALLY],
   REWRITE_TAC[complete, CLOSED_SEQUENTIAL_LIMITS] THEN DISCH_TAC THEN
   X_GEN_TAC ``f:num->real`` THEN STRIP_TAC THEN
   MP_TAC(REWRITE_RULE[complete] COMPLETE_UNIV) THEN
   DISCH_THEN(MP_TAC o SPEC ``f:num->real``) THEN
   ASM_REWRITE_TAC[IN_UNIV] THEN ASM_MESON_TAC[]]);

val CONVERGENT_EQ_CAUCHY = store_thm ("CONVERGENT_EQ_CAUCHY",
 ``!s. (?l. (s --> l) sequentially) <=> cauchy s``,
  GEN_TAC THEN EQ_TAC THENL
  [METIS_TAC [LEFT_IMP_EXISTS_THM, CONVERGENT_IMP_CAUCHY],
   REWRITE_TAC[REWRITE_RULE[complete, IN_UNIV] COMPLETE_UNIV]]);

val CONVERGENT_IMP_BOUNDED = store_thm ("CONVERGENT_IMP_BOUNDED",
 ``!s l. (s --> l) sequentially ==> bounded (IMAGE s univ(:num))``,
  SIMP_TAC std_ss [LEFT_FORALL_IMP_THM, CONVERGENT_EQ_CAUCHY] THEN
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP CAUCHY_IMP_BOUNDED) THEN
  REWRITE_TAC [bounded_def] THEN SET_TAC []);

(* ------------------------------------------------------------------------- *)
(* Total boundedness.                                                        *)
(* ------------------------------------------------------------------------- *)

val COMPACT_IMP_TOTALLY_BOUNDED = store_thm
  ("COMPACT_IMP_TOTALLY_BOUNDED",
 ``!s:real->bool. compact s
   ==> !e. &0 < e ==> ?k. FINITE k /\ k SUBSET s /\
       s SUBSET (BIGUNION (IMAGE (\x. ball(x,e)) k))``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  REWRITE_TAC[TAUT `~(a /\ b /\ c) <=> a /\ b ==> ~c`, SUBSET_DEF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``?x:num->real. !n. x(n) IN s /\ !m. m < n ==> ~(dist(x(m),x(n)) < e)``
   MP_TAC THENL
  [SUBGOAL_THEN
   ``?x:num->real.
     !n. x(n) = @y. y IN s /\ !m. m < n ==> ~(dist(x(m),y) < e)``
     MP_TAC THENL
   [KNOW_TAC ``?(x :num -> real). !(n :num). x n =
    (\x n. @(y :real). y IN (s :real -> bool) /\
      !(m :num). m < n ==> ~((dist (x m,y) :real) < (e :real))) x n`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC(MATCH_MP WF_REC WF_num) THEN SIMP_TAC std_ss [], ALL_TAC] THEN
    DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN EXISTS_TAC ``x:num->real`` THEN
    KNOW_TAC ``!(n :num). (\n. (x :num -> real) n IN (s :real -> bool) /\
     !(m :num). m < n ==> ~((dist (x m,x n) :real) < (e :real))) n`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC COMPLETE_INDUCTION THEN X_GEN_TAC ``n:num`` THEN
    BETA_TAC THEN FIRST_X_ASSUM(SUBST1_TAC o SPEC ``n:num``) THEN STRIP_TAC THEN
    CONV_TAC SELECT_CONV THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (x:num->real) {m | m < n}``) THEN
    SIMP_TAC std_ss [IMAGE_FINITE, FINITE_NUMSEG_LT, NOT_FORALL_THM, NOT_IMP] THEN
    SIMP_TAC std_ss [IN_BIGUNION, IN_IMAGE, GSPECIFICATION] THEN METIS_TAC[IN_BALL],
    ALL_TAC] THEN
   SIMP_TAC std_ss [compact, NOT_FORALL_THM] THEN
   DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN EXISTS_TAC ``x:num->real`` THEN
   POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN
   STRIP_TAC THEN ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN REPEAT STRIP_TAC THEN
   CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
   FIRST_X_ASSUM(MP_TAC o MATCH_MP CONVERGENT_IMP_CAUCHY) THEN
   REWRITE_TAC[cauchy] THEN DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN
   ASM_SIMP_TAC std_ss [o_THM, NOT_EXISTS_THM, NOT_IMP, NOT_FORALL_THM, NOT_IMP] THEN
   X_GEN_TAC ``N:num`` THEN MAP_EVERY EXISTS_TAC [``N:num``, ``SUC N``] THEN
   CONJ_TAC THENL [ARITH_TAC, ASM_MESON_TAC[LT]]);

(* ------------------------------------------------------------------------- *)
(* Heine-Borel theorem (following Burkill & Burkill vol. 2) *)
(* ------------------------------------------------------------------------- *)

val HEINE_BOREL_LEMMA = store_thm ("HEINE_BOREL_LEMMA",
 ``!s:real->bool. compact s
    ==> !t. s SUBSET (BIGUNION t) /\ (!b. b IN t ==> open b)
       ==> ?e. &0 < e /\
           !x. x IN s ==> ?b. b IN t /\ ball(x,e) SUBSET b``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(CHOOSE_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT_01, REAL_ARITH ``x <= y ==> x < y + &1:real``,
   FORALL_AND_THM, REAL_POS, NOT_FORALL_THM, NOT_IMP, SKOLEM_THM, compact] THEN
  DISCH_THEN (X_CHOOSE_TAC ``f:num->real``) THEN
  EXISTS_TAC ``f:num->real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN ASM_REWRITE_TAC[] THEN
  DISCH_TAC THEN MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``?b:real->bool. l IN b /\ b IN t`` STRIP_ASSUME_TAC THENL
  [ASM_MESON_TAC[SUBSET_DEF, IN_BIGUNION], ALL_TAC] THEN
  SUBGOAL_THEN ``?e. &0 < e /\ !z:real. dist(z,l) < e ==> z IN b``
   STRIP_ASSUME_TAC THENL [ASM_MESON_TAC[open_def], ALL_TAC] THEN
  UNDISCH_TAC ``(f o r:num->num --> l:real) sequentially`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  SUBGOAL_THEN ``&0 < e / &2:real`` (fn th =>
   REWRITE_TAC [th, o_THM] THEN MP_TAC(ONCE_REWRITE_RULE [REAL_ARCH_INV] th))
   THENL [ASM_REWRITE_TAC[REAL_HALF], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N1:num`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N2:num`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``(r:num->num)(N1 + N2)``, ``b:real->bool``]) THEN
  ASM_REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN MATCH_MP_TAC DIST_TRIANGLE_HALF_R THEN
  EXISTS_TAC ``(f:num->real)(r(N1 + N2:num))`` THEN CONJ_TAC THENL
  [ALL_TAC, FIRST_X_ASSUM MATCH_MP_TAC THEN ARITH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IN_BALL]) THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> x < a ==> x < b:real``) THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``inv(&N1:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE] THEN REWRITE_TAC[real_div, REAL_MUL_LID] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN
  REWRITE_TAC[REAL_OF_NUM_ADD, REAL_OF_NUM_LE, REAL_LT] THEN
  ASM_MESON_TAC[ARITH_PROVE ``(~(n = 0) ==> 0 < n:num)``, LESS_EQ_ADD, MONOTONE_BIGGER,
   LESS_IMP_LESS_OR_EQ, LESS_EQ_TRANS]);

val COMPACT_IMP_HEINE_BOREL = store_thm
  ("COMPACT_IMP_HEINE_BOREL",
 ``!s. compact (s:real->bool)
  ==> !f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
  ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f')``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``f:(real->bool)->bool`` o
   MATCH_MP HEINE_BOREL_LEMMA) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, SUBSET_DEF, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_TAC ``B:real->real->bool``) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``e:real`` o
   MATCH_MP COMPACT_IMP_TOTALLY_BOUNDED) THEN
  ASM_SIMP_TAC std_ss [BIGUNION_IMAGE, SUBSET_DEF, GSPECIFICATION] THEN
  REWRITE_TAC[IN_BIGUNION, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (B:real->real->bool) k`` THEN
  ASM_SIMP_TAC std_ss [IMAGE_FINITE, SUBSET_DEF, IN_IMAGE, LEFT_IMP_EXISTS_THM] THEN
  ASM_MESON_TAC[IN_BALL]);

(* ------------------------------------------------------------------------- *)
(* Bolzano-Weierstrass property.                                             *)
(* ------------------------------------------------------------------------- *)

val HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS = store_thm
  ("HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS",
 ``!s:real->bool.
  (!f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
   ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f'))
   ==> !t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM, limit_point_of] THEN REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[TAUT `a ==> b /\ c ==> d <=> c ==> ~d ==> a ==> ~b`] THEN
  KNOW_TAC ``t SUBSET s
       ==> (!x. ?t'. ~(x IN s:real->bool /\
                 (x IN t' /\ open t' ==> (?y. ~(y = x) /\ y IN t /\ y IN t'))))
       ==> (!f. (!t. t IN f ==> open t) /\ s SUBSET BIGUNION f
              ==> (?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET BIGUNION f'))
        ==> ~INFINITE t`` THENL
  [ALL_TAC, SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, RIGHT_AND_FORALL_THM] THEN
   METIS_TAC []] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_TAC ``f:real->real->bool``) THEN
  DISCH_THEN(MP_TAC o SPEC
   ``{t:real->bool | ?x:real. x IN s /\ (t = f x)}``) THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_BIGUNION, NOT_IMP] THEN
  KNOW_TAC ``(!t. (?x. x IN s:real->bool /\ (t = f x)) ==> open t) /\
     (!x. x IN s ==> ?s'. x IN s' /\ ?x. x IN s /\ (s' = f x))`` THENL
  [METIS_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN
  EXISTS_TAC ``{x:real | x IN t /\ (f(x):real->bool) IN g}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC FINITE_IMAGE_INJ_GENERAL THEN ASM_MESON_TAC[SUBSET_DEF],
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real`` THEN
   DISCH_TAC THEN SUBGOAL_THEN ``(u:real) IN s`` ASSUME_TAC THEN
   ASM_MESON_TAC[SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* Complete the chain of compactness variants.                               *)
(* ------------------------------------------------------------------------- *)

val BOLZANO_WEIERSTRASS_IMP_BOUNDED = store_thm ("BOLZANO_WEIERSTRASS_IMP_BOUNDED",
 ``!s:real->bool.
   (!t. INFINITE t /\ t SUBSET s ==> ?x. x limit_point_of t)
   ==> bounded s``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [compact, bounded_def] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_EXISTS_THM, SKOLEM_THM, NOT_IMP] THEN
  REWRITE_TAC[REAL_NOT_LE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``beyond:real->real``) THEN
  KNOW_TAC ``?f. (f(0) = beyond(&0)) /\
   (!n. f(SUC n) = beyond(abs(f n) + &1):real)`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (x:num->real) UNIV`` THEN
  SUBGOAL_THEN
  ``!m n. m < n ==> abs((x:num->real) m) + &1 < abs(x n)``
   ASSUME_TAC THENL
  [GEN_TAC THEN INDUCT_TAC THEN ASM_REWRITE_TAC[LT] THEN
   ASM_MESON_TAC[REAL_LT_TRANS, REAL_ARITH ``b < b + &1:real``],
   ALL_TAC] THEN
  SUBGOAL_THEN ``!m n. ~(m = n) ==> &1 < dist((x:num->real) m,x n)``
  ASSUME_TAC THENL
  [REPEAT GEN_TAC THEN REPEAT_TCL DISJ_CASES_THEN ASSUME_TAC
   (SPECL [``m:num``, ``n:num``] LT_CASES) THEN
   ASM_MESON_TAC[dist, LT_CASES, ABS_TRIANGLE_SUB, ABS_SUB,
    REAL_ARITH ``x + &1 < y /\ y <= x + d ==> &1 < d:real``],
   ALL_TAC] THEN
  REPEAT CONJ_TAC THENL
  [ASM_MESON_TAC[IMAGE_11_INFINITE, num_INFINITE, DIST_REFL,
   REAL_ARITH ``~(&1 < &0:real)``],
  SIMP_TAC std_ss [SUBSET_DEF, IN_IMAGE, IN_UNIV, LEFT_IMP_EXISTS_THM] THEN
  INDUCT_TAC THEN METIS_TAC[], ALL_TAC] THEN
  X_GEN_TAC ``l:real`` THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  SIMP_TAC std_ss [IN_IMAGE, IN_UNIV, GSYM LEFT_EXISTS_AND_THM] THEN
  KNOW_TAC ``~(!(e :real). (0 :real) < e ==>
      (?(x'' :num) (x' :real). (x' = (x :num -> real) x'') /\ (x' <> (l :real)) /\
        ((dist (x',l) :real) < e)))`` THENL
  [ALL_TAC, METIS_TAC []] THEN SIMP_TAC std_ss [UNWIND_THM2] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  FIRST_ASSUM(MP_TAC o SPEC ``&1 / &2:real``) THEN
  REWRITE_TAC [METIS [REAL_HALF_BETWEEN] ``0 < 1 / 2:real``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:num`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``dist((x:num->real) k,l)``) THEN
  ASM_SIMP_TAC std_ss [DIST_POS_LT] THEN
  X_GEN_TAC ``m:num`` THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  ASM_CASES_TAC ``m:num = k`` THEN
  ASM_MESON_TAC[DIST_TRIANGLE_HALF_L, REAL_LT_TRANS, REAL_LT_REFL]);

val SEQUENCE_INFINITE_LEMMA = store_thm ("SEQUENCE_INFINITE_LEMMA",
 ``!f l. (!n. ~(f(n) = l)) /\ (f --> l) sequentially
    ==> INFINITE {y:real | ?n. y = f n}``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPEC
    ``IMAGE (\y:real. dist(y,l)) {y | ?n:num. y = f n}`` INF_FINITE) THEN
  ASM_SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, IN_IMAGE, IMAGE_FINITE, GSPECIFICATION] THEN
  ASM_MESON_TAC[LIM_SEQUENTIALLY, LESS_EQ_REFL, REAL_NOT_LE, DIST_POS_LT]);

val LE_1 = store_thm ("LE_1",
 ``(!n:num. ~(n = 0) ==> 0 < n) /\
   (!n:num. ~(n = 0) ==> 1 <= n) /\
   (!n:num. 0 < n ==> ~(n = 0)) /\
   (!n:num. 0 < n ==> 1 <= n) /\
   (!n:num. 1 <= n ==> 0 < n) /\
   (!n:num. 1 <= n ==> ~(n = 0))``,
  REWRITE_TAC[LT_NZ, GSYM NOT_LESS, ONE, LT]);

val LIMPT_OF_SEQUENCE_SUBSEQUENCE = store_thm ("LIMPT_OF_SEQUENCE_SUBSEQUENCE",
  ``!f:num->real l.
     l limit_point_of (IMAGE f univ(:num))
     ==> ?r. (!m n. m < n ==> r(m) < r(n)) /\ ((f o r) --> l) sequentially``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [LIMPT_APPROACHABLE]) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC
   ``inf((inv(&n + &1:real)) INSERT IMAGE (\k. dist((f:num->real) k,l))
         {k | k IN {0..n} /\ ~(f k = l)})``) THEN
  SIMP_TAC std_ss [REAL_LT_INF_FINITE, FINITE_INSERT, NOT_INSERT_EMPTY,
   FINITE_RESTRICT, FINITE_NUMSEG, IMAGE_FINITE] THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, EXISTS_IN_IMAGE, FORALL_IN_IMAGE, IN_UNIV] THEN
  SIMP_TAC std_ss [REAL_LT_INV_EQ, METIS [REAL_LT, REAL_OF_NUM_ADD, GSYM ADD1, LESS_0]
                            ``&0 < &n + &1:real``] THEN
  SIMP_TAC std_ss [FORALL_AND_THM, FORALL_IN_GSPEC, GSYM DIST_NZ, SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``nn:num->num`` STRIP_ASSUME_TAC) THEN
  KNOW_TAC ``?r:num->num. (r 0 = nn 0) /\ (!n. r (SUC n) = nn(r n))`` THENL
  [RW_TAC std_ss [num_Axiom], ALL_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
  [ONCE_REWRITE_TAC [METIS []
    `` (r:num->num) m < r n <=> (\m n. r m < r n) m n``] THEN
  MATCH_MP_TAC TRANSITIVE_STEPWISE_LT THEN CONJ_TAC THENL
  [METIS_TAC [LESS_TRANS], ALL_TAC] THEN
   X_GEN_TAC ``n:num`` THEN ASM_REWRITE_TAC[] THEN
   FIRST_X_ASSUM(MP_TAC o SPECL
    [``(r:num->num) n``, ``(nn:num->num)(r(n:num))``]) THEN
   ASM_SIMP_TAC arith_ss [IN_NUMSEG, ZERO_LESS_EQ, REAL_LT_REFL],
   DISCH_THEN(ASSUME_TAC o MATCH_MP MONOTONE_BIGGER)] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_ARCH_INV] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!n:num. (N <= n ==> dist ((f o r) n,l) < e) <=>
                          (\n. N <= n ==> dist ((f o r) n,l) < e) n``] THEN
  MATCH_MP_TAC INDUCTION THEN ASM_SIMP_TAC std_ss [CONJUNCT1 LE] THEN
  X_GEN_TAC ``n:num`` THEN DISCH_THEN(K ALL_TAC) THEN DISCH_TAC THEN
  ASM_SIMP_TAC std_ss [o_THM] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
  EXISTS_TAC ``inv(&((r:num->num) n) + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``inv(&N:real)`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LE_INV2 THEN
  ASM_SIMP_TAC std_ss [REAL_OF_NUM_LE, REAL_LT, LE_1, REAL_OF_NUM_ADD] THEN
  MATCH_MP_TAC(ARITH_PROVE ``N <= SUC n /\ n <= r n ==> N <= r n + 1``) THEN
  ASM_REWRITE_TAC[]);

val SEQUENCE_UNIQUE_LIMPT = store_thm ("SEQUENCE_UNIQUE_LIMPT",
 ``!f l l':real.
   (f --> l) sequentially /\ l' limit_point_of {y | ?n. y = f n}
   ==> (l' = l)``,
  REWRITE_TAC[SET_RULE ``{y | ?n. y = f n} = IMAGE f univ(:num)``] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP LIMPT_OF_SEQUENCE_SUBSEQUENCE) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:num->num`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``(f:num->real) o (r:num->num)`` THEN
  ASM_SIMP_TAC std_ss [TRIVIAL_LIMIT_SEQUENTIALLY, LIM_SUBSEQUENCE]);

val BOLZANO_WEIERSTRASS_IMP_CLOSED = store_thm ("BOLZANO_WEIERSTRASS_IMP_CLOSED",
 ``!s:real->bool.
  (!t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t)
   ==> closed s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSED_SEQUENTIAL_LIMITS] THEN
  MAP_EVERY X_GEN_TAC [``f:num->real``, ``l:real``] THEN
  DISCH_TAC THEN
  MAP_EVERY (MP_TAC o ISPECL [``f:num->real``, ``l:real``])
   [SEQUENCE_UNIQUE_LIMPT, SEQUENCE_INFINITE_LEMMA] THEN
  MATCH_MP_TAC(TAUT
   `(~d ==> a /\ ~(b /\ c)) ==> (a ==> b) ==> c ==> d`) THEN
  DISCH_TAC THEN CONJ_TAC THENL [ASM_MESON_TAC[], STRIP_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{y:real | ?n:num. y = f n}``) THEN
  ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION],
   ABBREV_TAC ``t = {y:real | ?n:num. y = f n}``] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Hence express everything as an equivalence.                               *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EQ_HEINE_BOREL = store_thm ("COMPACT_EQ_HEINE_BOREL",
 ``!s:real->bool. compact s <=>
   !f. (!t. t IN f ==> open t) /\ s SUBSET (BIGUNION f)
   ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET (BIGUNION f')``,
  GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [COMPACT_IMP_HEINE_BOREL] THEN
  DISCH_THEN(MP_TAC o MATCH_MP HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS) THEN
  DISCH_TAC THEN MATCH_MP_TAC BOUNDED_CLOSED_IMP_COMPACT THEN
  ASM_MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED,
   BOLZANO_WEIERSTRASS_IMP_CLOSED]);

val COMPACT_EQ_BOLZANO_WEIERSTRASS = store_thm ("COMPACT_EQ_BOLZANO_WEIERSTRASS",
 ``!s:real->bool. compact s <=>
   !t. INFINITE t /\ t SUBSET s ==> ?x. x IN s /\ x limit_point_of t``,
  GEN_TAC THEN EQ_TAC THENL
  [SIMP_TAC std_ss [COMPACT_EQ_HEINE_BOREL, HEINE_BOREL_IMP_BOLZANO_WEIERSTRASS],
   MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED, BOLZANO_WEIERSTRASS_IMP_CLOSED,
    BOUNDED_CLOSED_IMP_COMPACT]]);

val COMPACT_EQ_BOUNDED_CLOSED = store_thm ("COMPACT_EQ_BOUNDED_CLOSED",
``!s:real->bool. compact s <=> bounded s /\ closed s``,
  GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[BOUNDED_CLOSED_IMP_COMPACT] THEN
  MESON_TAC[COMPACT_EQ_BOLZANO_WEIERSTRASS, BOLZANO_WEIERSTRASS_IMP_BOUNDED,
  BOLZANO_WEIERSTRASS_IMP_CLOSED]);

val COMPACT_IMP_BOUNDED = store_thm ("COMPACT_IMP_BOUNDED",
 ``!s. compact s ==> bounded s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED]);

val COMPACT_IMP_CLOSED = store_thm ("COMPACT_IMP_CLOSED",
 ``!s. compact s ==> closed s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED]);

val COMPACT_SEQUENCE_WITH_LIMIT = store_thm ("COMPACT_SEQUENCE_WITH_LIMIT",
 ``!f l:real.
  (f --> l) sequentially ==> compact (l INSERT IMAGE f univ(:num))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
  REWRITE_TAC[BOUNDED_INSERT] THEN CONJ_TAC THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_BOUNDED],
   SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_INSERT, IN_INSERT] THEN
  SIMP_TAC std_ss [IMAGE_DEF, IN_UNIV, SET_RULE ``{f x | x IN s} =
    {y | ?x. x IN s /\ (y = f x)}``] THEN REPEAT STRIP_TAC THEN DISJ1_TAC THEN
  MATCH_MP_TAC SEQUENCE_UNIQUE_LIMPT THEN METIS_TAC[]]);

val CLOSED_IN_COMPACT = store_thm ("CLOSED_IN_COMPACT",
 ``!s t:real->bool.
  compact s /\ closed_in (subtopology euclidean s) t
   ==> compact t``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_EQ] THEN
  MESON_TAC[BOUNDED_SUBSET]);

val CLOSED_IN_COMPACT_EQ = store_thm ("CLOSED_IN_COMPACT_EQ",
 ``!s t. compact s
  ==> (closed_in (subtopology euclidean s) t <=>
   compact t /\ t SUBSET s)``,
  MESON_TAC[CLOSED_IN_CLOSED_EQ, COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* A version of Heine-Borel for subtopology.                                 *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY = store_thm ("COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY",
 ``!s:real->bool. compact s <=>
   (!f. (!t. t IN f ==> open_in(subtopology euclidean s) t) /\
                        s SUBSET BIGUNION f
     ==> ?f'. f' SUBSET f /\ FINITE f' /\ s SUBSET BIGUNION f')``,
  GEN_TAC THEN REWRITE_TAC[COMPACT_EQ_HEINE_BOREL] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``f:(real->bool)->bool`` THENL
  [REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_TAC THEN
   POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM] THEN
   DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_TAC ``m:(real->bool)->(real->bool)``) ASSUME_TAC) THEN
   FIRST_X_ASSUM(MP_TAC o SPEC
   ``IMAGE (m:(real->bool)->(real->bool)) f``) THEN
   ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
   KNOW_TAC ``(s :real -> bool) SUBSET
     BIGUNION
       (IMAGE (m :(real -> bool) -> real -> bool)
          (f :(real -> bool) -> bool))`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``f':(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``IMAGE (\t:real->bool. s INTER t) f'`` THEN
  ASM_SIMP_TAC std_ss [IMAGE_FINITE, BIGUNION_IMAGE, SUBSET_DEF, FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  UNDISCH_TAC ``f' SUBSET IMAGE (m :(real -> bool) -> real -> bool) f`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_IMAGE]) THEN
  STRIP_TAC THEN ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN ASM_MESON_TAC[SUBSET_DEF],
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{s INTER t:real->bool | t IN f}``) THEN
  SIMP_TAC std_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, OPEN_IN_OPEN, BIGUNION_IMAGE] THEN
  KNOW_TAC ``(!(t :real -> bool).
        t IN (f :(real -> bool) -> bool) ==>
        ?(t' :real -> bool).
          (open t' :bool) /\ ((s :real -> bool) INTER t = s INTER t')) /\
     s SUBSET {y | ?(t :real -> bool). t IN f /\ y IN s INTER t}`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, BIGUNION_IMAGE] THEN
  STRIP_TAC THEN EXISTS_TAC ``f' :(real -> bool) -> bool`` THEN
  ASM_SET_TAC []]);

(* ------------------------------------------------------------------------- *)
(* More easy lemmas.                                                         *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CLOSURE = store_thm ("COMPACT_CLOSURE",
 ``!s. compact(closure s) <=> bounded s``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE, BOUNDED_CLOSURE_EQ]);

val BOLZANO_WEIERSTRASS_CONTRAPOS = store_thm ("BOLZANO_WEIERSTRASS_CONTRAPOS",
 ``!s t:real->bool.
  compact s /\ t SUBSET s /\
  (!x. x IN s ==> ~(x limit_point_of t))
  ==> FINITE t``,
  REWRITE_TAC[COMPACT_EQ_BOLZANO_WEIERSTRASS] THEN MESON_TAC[]);

val DISCRETE_BOUNDED_IMP_FINITE = store_thm ("DISCRETE_BOUNDED_IMP_FINITE",
 ``!s:real->bool e. &0 < e /\
  (!x y. x IN s /\ y IN s /\ abs(y - x) < e ==> (y = x)) /\
   bounded s ==> FINITE s``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``compact(s:real->bool)`` MP_TAC THENL
  [ASM_REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
   ASM_MESON_TAC[DISCRETE_IMP_CLOSED],
  DISCH_THEN(MP_TAC o MATCH_MP COMPACT_IMP_HEINE_BOREL)] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\x:real. ball(x,e)) s``) THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, OPEN_BALL, BIGUNION_IMAGE, GSPECIFICATION] THEN
  KNOW_TAC ``(s :real -> bool) SUBSET
     {y | ?(x :real). x IN s /\ y IN ball (x,(e :real))}`` THENL
  [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN ASM_MESON_TAC[CENTRE_IN_BALL],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`]] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``s:real->bool = t`` (fn th => ASM_REWRITE_TAC[th]) THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``s SUBSET BIGUNION (IMAGE (\x. ball (x,e)) t)`` THEN
  GEN_REWR_TAC (LAND_CONV o RAND_CONV) [BIGUNION_IMAGE] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o REWRITE_RULE [SUBSET_DEF]) THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_BALL, dist] THEN ASM_MESON_TAC[SUBSET_DEF]);

val BOLZANO_WEIERSTRASS = store_thm ("BOLZANO_WEIERSTRASS",
 ``!s:real->bool. bounded s /\ INFINITE s ==> ?x. x limit_point_of s``,
  GEN_TAC THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP NO_LIMIT_POINT_IMP_CLOSED) THEN
  STRIP_TAC THEN
  MP_TAC(ISPEC ``s:real->bool`` COMPACT_EQ_BOLZANO_WEIERSTRASS) THEN
  ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED] THEN
  EXISTS_TAC ``s:real->bool`` THEN
  ASM_REWRITE_TAC[SUBSET_REFL] THEN ASM_MESON_TAC[]);

val BOUNDED_EQ_BOLZANO_WEIERSTRASS = store_thm ("BOUNDED_EQ_BOLZANO_WEIERSTRASS",
 ``!s:real->bool.
  bounded s <=> !t. t SUBSET s /\ INFINITE t ==> ?x. x limit_point_of t``,
  MESON_TAC[BOLZANO_WEIERSTRASS_IMP_BOUNDED, BOLZANO_WEIERSTRASS,
   BOUNDED_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* In particular, some common special cases.                                 *)
(* ------------------------------------------------------------------------- *)

val COMPACT_EMPTY = store_thm ("COMPACT_EMPTY",
 ``compact {}``,
  REWRITE_TAC[compact, NOT_IN_EMPTY]);

val COMPACT_UNION = store_thm ("COMPACT_UNION",
 ``!s t. compact s /\ compact t ==> compact (s UNION t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_UNION, CLOSED_UNION]);

val COMPACT_INTER = store_thm ("COMPACT_INTER",
 ``!s t. compact s /\ compact t ==> compact (s INTER t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTER, CLOSED_INTER]);

val COMPACT_INTER_CLOSED = store_thm ("COMPACT_INTER_CLOSED",
 ``!s t. compact s /\ closed t ==> compact (s INTER t)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER] THEN
  MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET]);

val CLOSED_INTER_COMPACT = store_thm ("CLOSED_INTER_COMPACT",
 ``!s t. closed s /\ compact t ==> compact (s INTER t)``,
  MESON_TAC[COMPACT_INTER_CLOSED, INTER_COMM]);

val COMPACT_BIGINTER = store_thm ("COMPACT_BIGINTER",
 ``!f:(real->bool)->bool.
  (!s. s IN f ==> compact s) /\ ~(f = {})
  ==> compact(BIGINTER f)``,
  SIMP_TAC std_ss[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_BIGINTER] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC BOUNDED_BIGINTER THEN ASM_SET_TAC[]);

val FINITE_IMP_CLOSED = store_thm ("FINITE_IMP_CLOSED",
 ``!s. FINITE s ==> closed s``,
  MESON_TAC[BOLZANO_WEIERSTRASS_IMP_CLOSED, SUBSET_FINITE_I]);

val FINITE_IMP_CLOSED_IN = store_thm ("FINITE_IMP_CLOSED_IN",
 ``!s t. FINITE s /\ s SUBSET t ==> closed_in (subtopology euclidean t) s``,
  SIMP_TAC std_ss [CLOSED_SUBSET_EQ, FINITE_IMP_CLOSED]);

val FINITE_IMP_COMPACT = store_thm ("FINITE_IMP_COMPACT",
 ``!s. FINITE s ==> compact s``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, FINITE_IMP_CLOSED, FINITE_IMP_BOUNDED]);

val COMPACT_SING = store_thm ("COMPACT_SING",
 ``!a. compact {a}``,
  SIMP_TAC std_ss [FINITE_IMP_COMPACT, FINITE_EMPTY, FINITE_INSERT]);

val COMPACT_INSERT = store_thm ("COMPACT_INSERT",
 ``!a s. compact s ==> compact(a INSERT s)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  SIMP_TAC std_ss [COMPACT_UNION, COMPACT_SING]);

val CLOSED_SING = store_thm ("CLOSED_SING",
 ``!a. closed {a}``,
 MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, COMPACT_SING]);

val CLOSED_IN_SING = store_thm ("CLOSED_IN_SING",
 ``!u x:real. closed_in (subtopology euclidean u) {x} <=> x IN u``,
  SIMP_TAC std_ss [CLOSED_SUBSET_EQ, CLOSED_SING] THEN SET_TAC[]);

val CLOSURE_SING = store_thm ("CLOSURE_SING",
 ``!x:real. closure {x} = {x}``,
   SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_SING]);

val CLOSED_INSERT = store_thm ("CLOSED_INSERT",
 ``!a s. closed s ==> closed(a INSERT s)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  SIMP_TAC std_ss [CLOSED_UNION, CLOSED_SING]);

val COMPACT_CBALL = store_thm ("COMPACT_CBALL",
 ``!x e. compact(cball(x,e))``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_CBALL, CLOSED_CBALL]);

val COMPACT_FRONTIER_BOUNDED = store_thm ("COMPACT_FRONTIER_BOUNDED",
 ``!s. bounded s ==> compact(frontier s)``,
  SIMP_TAC std_ss [frontier, COMPACT_EQ_BOUNDED_CLOSED,
   CLOSED_DIFF, OPEN_INTERIOR, CLOSED_CLOSURE] THEN
  MESON_TAC[DIFF_SUBSET, BOUNDED_SUBSET, BOUNDED_CLOSURE]);

val COMPACT_FRONTIER = store_thm ("COMPACT_FRONTIER",
 ``!s. compact s ==> compact (frontier s)``,
  MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, COMPACT_FRONTIER_BOUNDED]);

val BOUNDED_FRONTIER = store_thm ("BOUNDED_FRONTIER",
 ``!s:real->bool. bounded s ==> bounded(frontier s)``,
  MESON_TAC[COMPACT_FRONTIER_BOUNDED, COMPACT_IMP_BOUNDED]);

val FRONTIER_SUBSET_COMPACT = store_thm ("FRONTIER_SUBSET_COMPACT",
 ``!s. compact s ==> frontier s SUBSET s``,
  MESON_TAC[FRONTIER_SUBSET_CLOSED, COMPACT_EQ_BOUNDED_CLOSED]);

val OPEN_DELETE = store_thm ("OPEN_DELETE",
 ``!s x. open s ==> open(s DELETE x)``,
SIMP_TAC std_ss [SET_RULE ``s DELETE x = s DIFF {x}``,
                 OPEN_DIFF, CLOSED_SING]);

val OPEN_IN_DELETE = store_thm ("OPEN_IN_DELETE",
 ``!u s a:real.
  open_in (subtopology euclidean u) s
  ==> open_in (subtopology euclidean u) (s DELETE a)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``(a:real) IN s`` THENL
  [ONCE_REWRITE_TAC[SET_RULE ``s DELETE a = s DIFF {a}``] THEN
   MATCH_MP_TAC OPEN_IN_DIFF THEN ASM_REWRITE_TAC[CLOSED_IN_SING] THEN
   FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
   ASM_SIMP_TAC std_ss [SET_RULE ``~(a IN s) ==> (s DELETE a = s)``]]);

val CLOSED_BIGINTER_COMPACT = store_thm ("CLOSED_BIGINTER_COMPACT",
 ``!s:real->bool.
  closed s <=> !e. compact(cball(0,e) INTER s)``,
  GEN_TAC THEN EQ_TAC THENL
  [SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER, CLOSED_CBALL,
   BOUNDED_INTER, BOUNDED_CBALL], ALL_TAC] THEN
  STRIP_TAC THEN REWRITE_TAC[CLOSED_LIMPT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``abs(x:real) + &1:real``) THEN
  DISCH_THEN(MP_TAC o MATCH_MP COMPACT_IMP_CLOSED) THEN
  REWRITE_TAC[CLOSED_LIMPT] THEN DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  REWRITE_TAC[IN_INTER] THEN
  KNOW_TAC ``(x :real) limit_point_of
     cball ((0 :real),abs x + (1 :real)) INTER (s :real -> bool)`` THENL
  [ALL_TAC, MESON_TAC[]] THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[LIMPT_APPROACHABLE] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min e (&1 / &2:real)``) THEN
  KNOW_TAC ``0 < min e (1 / 2:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [REAL_HALF_BETWEEN],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, IN_CBALL] THEN
  REWRITE_TAC [REAL_LT_MIN, DIST_0, dist] THEN STRIP_TAC THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

val COMPACT_BIGUNION = store_thm ("COMPACT_BIGUNION",
 ``!s. FINITE s /\ (!t. t IN s ==> compact t) ==> compact(BIGUNION s)``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_BIGUNION, BOUNDED_BIGUNION]);

val COMPACT_DIFF = store_thm ("COMPACT_DIFF",
 ``!s t. compact s /\ open t ==> compact(s DIFF t)``,
  ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
  SIMP_TAC std_ss [COMPACT_INTER_CLOSED, GSYM OPEN_CLOSED]);

val COMPACT_SPHERE = store_thm ("COMPACT_SPHERE",
 ``!a:real r. compact(sphere(a,r))``,
  REPEAT GEN_TAC THEN
 REWRITE_TAC[GSYM FRONTIER_CBALL] THEN MATCH_MP_TAC COMPACT_FRONTIER THEN
  REWRITE_TAC[COMPACT_CBALL]);

val BOUNDED_SPHERE = store_thm ("BOUNDED_SPHERE",
 ``!a:real r. bounded(sphere(a,r))``,
  SIMP_TAC std_ss [COMPACT_SPHERE, COMPACT_IMP_BOUNDED]);

val CLOSED_SPHERE = store_thm ("CLOSED_SPHERE",
 ``!a r. closed(sphere(a,r))``,
  SIMP_TAC std_ss [COMPACT_SPHERE, COMPACT_IMP_CLOSED]);

val FRONTIER_SING = store_thm ("FRONTIER_SING",
 ``!a:real. frontier {a} = {a}``,
  REWRITE_TAC[frontier, CLOSURE_SING, INTERIOR_SING, DIFF_EMPTY]);

(* ------------------------------------------------------------------------- *)
(* Finite intersection property. I could make it an equivalence in fact.     *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
 ``(s = UNIV DIFF t) <=> (UNIV DIFF s = t)``,
  SET_TAC[]);

val COMPACT_IMP_FIP = store_thm ("COMPACT_IMP_FIP",
 ``!s:real->bool f.
        compact s /\
        (!t. t IN f ==> closed t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\t:real->bool. UNIV DIFF t) f``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  DISCH_THEN(fn th => REPEAT STRIP_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [OPEN_DIFF, CLOSED_DIFF, OPEN_UNIV, CLOSED_UNIV, NOT_IMP] THEN
  CONJ_TAC THENL
   [UNDISCH_TAC ``(s:real->bool) INTER BIGINTER f = {}`` THEN
    ONCE_REWRITE_TAC[SUBSET_DEF, EXTENSION] THEN
    REWRITE_TAC [IN_BIGUNION] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
        REWRITE_TAC [EXISTS_IN_IMAGE] THEN BETA_TAC THEN SET_TAC[],
    X_GEN_TAC ``g:(real->bool)->bool`` THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (\t:real->bool. UNIV DIFF t) g``) THEN
    ASM_CASES_TAC ``FINITE(g:(real->bool)->bool)`` THEN
    ASM_SIMP_TAC std_ss [IMAGE_FINITE] THEN ONCE_REWRITE_TAC[SUBSET_DEF, EXTENSION] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_INTER, IN_BIGINTER, IN_IMAGE, IN_DIFF,
                IN_UNIV, NOT_IN_EMPTY, lemma, UNWIND_THM1, IN_BIGUNION] THEN
    SET_TAC[]]);

val CLOSED_IMP_FIP = store_thm ("CLOSED_IMP_FIP",
 ``!s:real->bool f.
        closed s /\
        (!t. t IN f ==> closed t) /\ (?t. t IN f /\ bounded t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC(SET_RULE
   ``~((s INTER t) INTER u = {}) ==> ~(s INTER u = {})``) THEN
  MATCH_MP_TAC COMPACT_IMP_FIP THEN ASM_REWRITE_TAC[] THEN CONJ_TAC THENL
   [ASM_MESON_TAC[CLOSED_INTER_COMPACT, COMPACT_EQ_BOUNDED_CLOSED],
    REWRITE_TAC [METIS [INTER_ASSOC, GSYM BIGINTER_INSERT]
          ``!f.  s INTER t INTER BIGINTER f =  s INTER BIGINTER (t INSERT f)``] THEN
  GEN_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [FINITE_INSERT, INSERT_SUBSET]]);

val CLOSED_IMP_FIP_COMPACT = store_thm ("CLOSED_IMP_FIP_COMPACT",
 ``!s:real->bool f.
        closed s /\ (!t. t IN f ==> compact t) /\
        (!f'. FINITE f' /\ f' SUBSET f ==> ~(s INTER (BIGINTER f') = {}))
        ==> ~(s INTER (BIGINTER f) = {})``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [SUBSET_EMPTY, BIGINTER_EMPTY, INTER_UNIV] THENL
   [MESON_TAC[FINITE_EMPTY], ALL_TAC] THEN
  STRIP_TAC THEN MATCH_MP_TAC CLOSED_IMP_FIP THEN
  ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, MEMBER_NOT_EMPTY]);

val CLOSED_FIP = store_thm ("CLOSED_FIP",
 ``!f. (!t:real->bool. t IN f ==> closed t) /\ (?t. t IN f /\ bounded t) /\
       (!f'. FINITE f' /\ f' SUBSET f ==> ~(BIGINTER f' = {}))
       ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = {}) <=> (UNIV INTER s = {})``] THEN
  MATCH_MP_TAC CLOSED_IMP_FIP THEN ASM_REWRITE_TAC[CLOSED_UNIV, INTER_UNIV]);

val COMPACT_FIP = store_thm ("COMPACT_FIP",
 ``!f. (!t:real->bool. t IN f ==> compact t) /\
       (!f'. FINITE f' /\ f' SUBSET f ==> ~(BIGINTER f' = {}))
       ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE ``(s = {}) <=> (UNIV INTER s = {})``] THEN
  MATCH_MP_TAC CLOSED_IMP_FIP_COMPACT THEN
  ASM_REWRITE_TAC[CLOSED_UNIV, INTER_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Bounded closed nest property (proof does not use Heine-Borel).            *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_CLOSED_NEST = store_thm ("BOUNDED_CLOSED_NEST",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       bounded(s 0)
       ==> ?a:real. !n:num. a IN s(n)``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, SKOLEM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_TAC ``a:num->real``) STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``compact(s  0n:real->bool)`` MP_TAC THENL
   [METIS_TAC[BOUNDED_CLOSED_IMP_COMPACT], ALL_TAC] THEN
  REWRITE_TAC[compact] THEN
  DISCH_THEN(MP_TAC o SPEC ``a:num->real``) THEN
  KNOW_TAC ``(!n:num. a n IN s  0n:real->bool)`` THENL
  [ASM_MESON_TAC[SUBSET_DEF, ZERO_LESS_EQ],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN
  EXISTS_TAC ``l:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:num->num`` STRIP_ASSUME_TAC) THEN
  GEN_REWR_TAC I [TAUT `p <=> ~(~p)`] THEN
  REWRITE_TAC [NOT_FORALL_THM] THEN X_GEN_TAC ``N:num`` THEN
  MP_TAC(ISPECL [``l:real``, ``(s:num->real->bool) N``]
                CLOSED_APPROACHABLE) THEN
  ASM_MESON_TAC[SUBSET_DEF, LESS_EQ_REFL, LESS_EQ_TRANS, LE_CASES, MONOTONE_BIGGER]);

(* ------------------------------------------------------------------------- *)
(* Decreasing case does not even need compactness, just completeness.        *)
(* ------------------------------------------------------------------------- *)

val DECREASING_CLOSED_NEST = store_thm ("DECREASING_CLOSED_NEST",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       (!e. &0 < e ==> ?n. !x y. x IN s(n) /\ y IN s(n) ==> dist(x,y) < e)
       ==> ?a:real. !n:num. a IN s(n)``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, SKOLEM_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
     (X_CHOOSE_TAC ``a:num->real``) STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``?l:real. (a --> l) sequentially`` MP_TAC THENL
   [ASM_MESON_TAC[cauchy, GE, SUBSET_DEF, LESS_EQ_TRANS, LESS_EQ_REFL,
                  complete, COMPLETE_UNIV, IN_UNIV],
    ASM_MESON_TAC[LIM_SEQUENTIALLY, CLOSED_APPROACHABLE,
                  SUBSET_DEF, LESS_EQ_REFL, LESS_EQ_TRANS, LE_CASES]]);

(* ------------------------------------------------------------------------- *)
(* Strengthen it to the intersection actually being a singleton.             *)
(* ------------------------------------------------------------------------- *)

val DECREASING_CLOSED_NEST_SING = store_thm ("DECREASING_CLOSED_NEST_SING",
 ``!s. (!n. closed(s n)) /\ (!n. ~(s n = {})) /\
       (!m n. m <= n ==> s(n) SUBSET s(m)) /\
       (!e. &0 < e ==> ?n. !x y. x IN s(n) /\ y IN s(n) ==> dist(x,y) < e)
       ==> ?a:real. BIGINTER {t | ?n:num. t = s n} = {a}``,
  GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DECREASING_CLOSED_NEST) THEN
  STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN
  SIMP_TAC std_ss [EXTENSION, IN_BIGINTER, IN_SING, GSPECIFICATION] THEN
  METIS_TAC[DIST_POS_LT, REAL_LT_REFL, SUBSET_DEF, LE_CASES]);

(* ------------------------------------------------------------------------- *)
(* A version for a more general chain, not indexed by N.                     *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_CLOSED_CHAIN = store_thm ("BOUNDED_CLOSED_CHAIN",
 ``!f b:real->bool.
        (!s. s IN f ==> closed s /\ ~(s = {})) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s) /\
         b IN f /\ bounded b
         ==> ~(BIGINTER f = {})``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SUBGOAL_THEN ``~(b INTER (BIGINTER f):real->bool = {})`` MP_TAC THENL
   [ALL_TAC, SET_TAC[]] THEN
  MATCH_MP_TAC COMPACT_IMP_FIP THEN
  ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED] THEN
  X_GEN_TAC ``u:(real->bool)->bool`` THEN STRIP_TAC THEN
  SUBGOAL_THEN ``?s:real->bool. s IN f /\ !t. t IN u ==> s SUBSET t``
   MP_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  UNDISCH_TAC ``(u:(real->bool)->bool) SUBSET f`` THEN
  UNDISCH_TAC ``FINITE(u:(real->bool)->bool)`` THEN
  SPEC_TAC(``u:(real->bool)->bool``,``u:(real->bool)->bool``) THEN
  ONCE_REWRITE_TAC [METIS [] ``!u. (u SUBSET f ==> ?s. s IN f /\ !t. t IN u ==> s SUBSET t) =
                          (\u. u SUBSET f ==> ?s. s IN f /\ !t. t IN u ==> s SUBSET t) u``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:(real->bool)->bool``, ``t:real->bool``] THEN
  REWRITE_TAC[INSERT_SUBSET] THEN
  ONCE_REWRITE_TAC [AND_IMP_INTRO] THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``s:real->bool``, ``t:real->bool``]) THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Analogous things directly for compactness.                                *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CHAIN = store_thm ("COMPACT_CHAIN",
 ``!f:(real->bool)->bool.
        (!s. s IN f ==> compact s /\ ~(s = {})) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
        ==> ~(BIGINTER f = {})``,
  GEN_TAC THEN REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THENL
   [ASM_REWRITE_TAC[BIGINTER_EMPTY] THEN SET_TAC[],
    MATCH_MP_TAC BOUNDED_CLOSED_CHAIN THEN ASM_SET_TAC[]]);

val COMPACT_NEST = store_thm ("COMPACT_NEST",
 ``!s. (!n. compact(s n) /\ ~(s n = {})) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> ~(BIGINTER {s n | n IN univ(:num)} = {})``,
  GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC COMPACT_CHAIN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``!n n'. (s n SUBSET s n' \/ s n' SUBSET s n) =
                          (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Cauchy-type criteria for *uniform* convergence.                           *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONVERGENT_EQ_CAUCHY = store_thm ("UNIFORMLY_CONVERGENT_EQ_CAUCHY",
 ``!P s:num->'a->real.
         (?l. !e. &0 < e
                  ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e) <=>
         (!e. &0 < e
              ==> ?N. !m n x. N <= m /\ N <= n /\ P x
                              ==> dist(s m x,s n x) < e)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_TAC ``l:'a->real``) THEN X_GEN_TAC ``e:real`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
    ASM_REWRITE_TAC[REAL_HALF] THEN MESON_TAC[DIST_TRIANGLE_HALF_L],
    ALL_TAC] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN ``!x:'a. P x ==> cauchy (\n. s n x :real)`` MP_TAC THENL
   [REWRITE_TAC[cauchy, GE] THEN ASM_MESON_TAC[], ALL_TAC] THEN
  REWRITE_TAC[GSYM CONVERGENT_EQ_CAUCHY, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN KNOW_TAC ``(!(x :'a). ?(l :real). (P :'a -> bool) x ==>
        (!(e :real). (0 :real) < e ==>
           (?(N :num). !(n :num). N <= n ==>
               (dist ((\(n :num). (s :num -> 'a -> real) n x) n,l) :real) < e)))`` THENL
  [METIS_TAC [], POP_ASSUM K_TAC] THEN SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:'a->real``) THEN
  EXISTS_TAC ``l:'a->real`` THEN POP_ASSUM MP_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``n:num``, ``x:'a``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:'a``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_TAC ``M:num``) THEN
  UNDISCH_TAC ``!m n x. N:num <= m /\ N <= n /\ P x
                 ==> dist (s m x,s n x) < e / 2:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`n:num`, `N + M:num`, `x:'a`]) THEN
  ASM_REWRITE_TAC[LE_ADD] THEN ONCE_REWRITE_TAC[ADD_SYM] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``M + N:num``) THEN REWRITE_TAC[LE_ADD] THEN
  ASM_MESON_TAC[DIST_TRIANGLE_HALF_L, DIST_SYM]);

Theorem UNIFORMLY_CONVERGENT_EQ_CAUCHY_ALT:
   !P s:num->'a->real.
      (?l. !e. &0 < e ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e) <=>
      (!e. &0 < e ==>
           ?N. !m n x. N <= m /\ N <= n /\ m < n /\ P x ==>
                       dist(s m x,s n x) < e)
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONVERGENT_EQ_CAUCHY] THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  ASM_SIMP_TAC std_ss [] THEN
  HO_MATCH_MP_TAC WLOG_LT THEN
  ASM_SIMP_TAC std_ss [DIST_REFL] THEN MESON_TAC[DIST_SYM]
QED

val UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT = store_thm ("UNIFORMLY_CAUCHY_IMP_UNIFORMLY_CONVERGENT",
 ``!P (s:num->'a->real) l.
    (!e. &0 < e
         ==> ?N. !m n x. N <= m /\ N <= n /\ P x ==> dist(s m x,s n x) < e) /\
    (!x. P x ==> !e. &0 < e ==> ?N. !n. N <= n ==> dist(s n x,l x) < e)
    ==> (!e. &0 < e ==> ?N. !n x. N <= n /\ P x ==> dist(s n x,l x) < e)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM UNIFORMLY_CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``l':'a->real``) ASSUME_TAC) THEN
  SUBGOAL_THEN ``!x. P x ==> ((l:'a->real) x = l' x)`` MP_TAC THENL
   [ALL_TAC, METIS_TAC[]] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``\n. (s:num->'a->real) n x`` THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Define continuity over a net to take in restrictions of the set.          *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "continuous" (Infix(NONASSOC, 450));

val continuous = new_definition ("continuous",
 ``f continuous net <=> (f --> f(netlimit net)) net``);

val CONTINUOUS_TRIVIAL_LIMIT = store_thm ("CONTINUOUS_TRIVIAL_LIMIT",
 ``!f net. trivial_limit net ==> f continuous net``,
  SIMP_TAC std_ss [continuous, LIM]);

val CONTINUOUS_WITHIN = store_thm ("CONTINUOUS_WITHIN",
 ``!f x:real. f continuous (at x within s) <=> (f --> f(x)) (at x within s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous] THEN
  ASM_CASES_TAC ``trivial_limit(at (x:real) within s)`` THENL
  [ASM_REWRITE_TAC[LIM], ASM_SIMP_TAC std_ss [NETLIMIT_WITHIN]]);

val CONTINUOUS_AT = store_thm ("CONTINUOUS_AT",
 ``!f (x:real). f continuous (at x) <=> (f --> f(x)) (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN, IN_UNIV]);

val CONTINUOUS_AT_WITHIN = store_thm ("CONTINUOUS_AT_WITHIN",
 ``!f:real->real x s.
  f continuous (at x) ==> f continuous (at x within s)``,
  SIMP_TAC std_ss [LIM_AT_WITHIN, CONTINUOUS_AT, CONTINUOUS_WITHIN]);

val CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL = store_thm ("CONTINUOUS_WITHIN_CLOSED_NONTRIVIAL",
 ``!a s. closed s /\ ~(a IN s) ==> f continuous (at a within s)``,
  ASM_SIMP_TAC std_ss [continuous, LIM, LIM_WITHIN_CLOSED_TRIVIAL]);

val CONTINUOUS_TRANSFORM_WITHIN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN",
 ``!f g:real->real s x d. &0 < d /\ x IN s /\
   (!x'. x' IN s /\ dist(x',x) < d ==> (f(x') = g(x'))) /\
    f continuous (at x within s) ==> g continuous (at x within s)``,
  SIMP_TAC std_ss [CONTINUOUS_WITHIN] THEN
  METIS_TAC[LIM_TRANSFORM_WITHIN, DIST_REFL]);

val CONTINUOUS_TRANSFORM_AT = store_thm ("CONTINUOUS_TRANSFORM_AT",
 ``!f g:real->real x d.
   &0 < d /\ (!x'. dist(x',x) < d ==> (f(x') = g(x'))) /\
   f continuous (at x) ==> g continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT] THEN
  METIS_TAC[LIM_TRANSFORM_AT, DIST_REFL]);

val CONTINUOUS_TRANSFORM_WITHIN_OPEN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_OPEN",
 ``!f g:real->real s a. open s /\ a IN s /\
   (!x. x IN s ==> (f x = g x)) /\
    f continuous at a ==> g continuous at a``,
  METIS_TAC[CONTINUOUS_AT, LIM_TRANSFORM_WITHIN_OPEN]);

val CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN",
 ``!f g:real->real s t a.
   open_in (subtopology euclidean t) s /\ a IN s /\
   (!x. x IN s ==> (f x = g x)) /\
    f continuous (at a within t) ==> g continuous (at a within t)``,
  METIS_TAC[CONTINUOUS_WITHIN, LIM_TRANSFORM_WITHIN_OPEN_IN]);

val CONTINUOUS_TRANSFORM_WITHIN_SET_IMP = store_thm ("CONTINUOUS_TRANSFORM_WITHIN_SET_IMP",
 ``!f a s t. eventually (\x. x IN t ==> x IN s) (at a) /\
   f continuous (at a within s) ==> f continuous (at a within t)``,
  REWRITE_TAC[CONTINUOUS_WITHIN, LIM_TRANSFORM_WITHIN_SET_IMP]);

(* ------------------------------------------------------------------------- *)
(* Derive the epsilon-delta forms, which we often use as "definitions" *)
(* ------------------------------------------------------------------------- *)

val continuous_within = store_thm ("continuous_within",
 ``f continuous (at x within s) <=> !e. &0 < e
   ==> ?d. &0 < d /\ !x'. x' IN s /\ dist(x',x) < d
     ==> dist(f(x'),f(x)) < e``,
  SIMP_TAC std_ss [CONTINUOUS_WITHIN, LIM_WITHIN] THEN
  SIMP_TAC std_ss [GSYM DIST_NZ] THEN MESON_TAC[DIST_REFL]);

val continuous_at = store_thm ("continuous_at",
 ``f continuous (at x) <=>
  !e. &0 < e ==> ?d. &0 < d /\
  !x'. dist(x',x) < d ==> dist(f(x'),f(x)) < e``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  SIMP_TAC std_ss [continuous_within, IN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Versions in terms of open balls.                                          *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_BALL = store_thm ("CONTINUOUS_WITHIN_BALL",
 ``!f s x. f continuous (at x within s) <=>
   !e. &0 < e ==> ?d. &0 < d /\
   IMAGE f (ball(x,d) INTER s) SUBSET ball(f x,e)``,
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_BALL, continuous_within, IN_INTER] THEN
  MESON_TAC[DIST_SYM]);

val CONTINUOUS_AT_BALL = store_thm ("CONTINUOUS_AT_BALL",
 ``!f x. f continuous (at x) <=>
   !e. &0 < e ==> ?d. &0 < d /\
   IMAGE f (ball(x,d)) SUBSET ball(f x,e)``,
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE, IN_BALL, continuous_at] THEN
  MESON_TAC[DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(*                                                                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_COMPARISON = store_thm ("CONTINUOUS_WITHIN_COMPARISON",
 ``!f:real->real g:real->real s a.
        g continuous (at a within s) /\
        (!x. x IN s ==> dist(f a,f x) <= dist(g a,g x))
        ==> f continuous (at a within s)``,
  ONCE_REWRITE_TAC[DIST_SYM] THEN
  REWRITE_TAC[continuous_within] THEN MESON_TAC[REAL_LET_TRANS]);

(* ------------------------------------------------------------------------- *)
(* For setwise continuity, just start from the epsilon-delta definitions.    *)
(* ------------------------------------------------------------------------- *)

val _ = set_fixity "continuous_on" (Infix(NONASSOC, 450));
val _ = set_fixity "uniformly_continuous_on" (Infix(NONASSOC, 450));

Definition continuous_on_def :
    f continuous_on s <=> !x. x IN s ==> f continuous (at x within s)
End
Theorem CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN = continuous_on_def

Theorem continuous_on :
    !f s. f continuous_on s <=>
          !x. x IN s ==> !e. &0 < e
                     ==> ?d. &0 < d /\ !x'. x' IN s /\ dist(x',x) < d
                                             ==> dist(f(x'),f(x)) < e
Proof
    rw [continuous_on_def, continuous_within]
QED

val uniformly_continuous_on = new_definition ("uniformly_continuous_on",
 ``f uniformly_continuous_on s <=>
   !e. &0 < e
   ==> ?d. &0 < d /\ !x x'. x IN s /\ x' IN s /\ dist(x',x) < d
     ==> dist(f(x'),f(x)) < e``);

(* ------------------------------------------------------------------------- *)
(* Some simple consequential lemmas.                                         *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS = store_thm ("UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS",
 ``!f s. f uniformly_continuous_on s ==> f continuous_on s``,
  REWRITE_TAC[uniformly_continuous_on, continuous_on] THEN MESON_TAC[]);

val CONTINUOUS_AT_IMP_CONTINUOUS_ON = store_thm ("CONTINUOUS_AT_IMP_CONTINUOUS_ON",
 ``!f s. (!x. x IN s ==> f continuous (at x)) ==> f continuous_on s``,
  REWRITE_TAC[continuous_at, continuous_on] THEN MESON_TAC[]);

val CONTINUOUS_ON = store_thm ("CONTINUOUS_ON",
 ``!f (s:real->bool).
  f continuous_on s <=> !x. x IN s ==> (f --> f(x)) (at x within s)``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_WITHIN]);

val CONTINUOUS_ON_EQ_CONTINUOUS_AT = store_thm ("CONTINUOUS_ON_EQ_CONTINUOUS_AT",
 ``!f:real->real s.
  open s ==> (f continuous_on s <=> (!x. x IN s ==> f continuous (at x)))``,
  SIMP_TAC std_ss [CONTINUOUS_ON, CONTINUOUS_AT, LIM_WITHIN_OPEN]);

val CONTINUOUS_WITHIN_SUBSET = store_thm ("CONTINUOUS_WITHIN_SUBSET",
 ``!f s t x. f continuous (at x within s) /\ t SUBSET s
  ==> f continuous (at x within t)``,
 REWRITE_TAC[CONTINUOUS_WITHIN] THEN MESON_TAC[LIM_WITHIN_SUBSET]);

val CONTINUOUS_ON_SUBSET = store_thm ("CONTINUOUS_ON_SUBSET",
 ``!f s t. f continuous_on s /\ t SUBSET s ==> f continuous_on t``,
  REWRITE_TAC[CONTINUOUS_ON] THEN MESON_TAC[SUBSET_DEF, LIM_WITHIN_SUBSET]);

val UNIFORMLY_CONTINUOUS_ON_SUBSET = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUBSET",
 ``!f s t. f uniformly_continuous_on s /\ t SUBSET s
  ==> f uniformly_continuous_on t``,
  REWRITE_TAC[uniformly_continuous_on] THEN
  MESON_TAC[SUBSET_DEF, LIM_WITHIN_SUBSET]);

val CONTINUOUS_ON_INTERIOR = store_thm ("CONTINUOUS_ON_INTERIOR",
 ``!f:real->real s x.
  f continuous_on s /\ x IN interior(s) ==> f continuous at x``,
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  MESON_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_AT, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_ON_EQ = store_thm ("CONTINUOUS_ON_EQ",
 ``!f g s. (!x. x IN s ==> (f(x) = g(x))) /\ f continuous_on s
  ==> g continuous_on s``,
  SIMP_TAC std_ss [continuous_on, CONJ_EQ_IMP]);

val UNIFORMLY_CONTINUOUS_ON_EQ = store_thm ("UNIFORMLY_CONTINUOUS_ON_EQ",
 ``!f g s. (!x. x IN s ==> (f x = g x)) /\ f uniformly_continuous_on s
   ==> g uniformly_continuous_on s``,
  SIMP_TAC std_ss [uniformly_continuous_on, CONJ_EQ_IMP]);

val CONTINUOUS_ON_SING = store_thm ("CONTINUOUS_ON_SING",
 ``!f:real->real a. f continuous_on {a}``,
  SIMP_TAC std_ss [continuous_on, IN_SING, DIST_REFL] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_EMPTY = store_thm ("CONTINUOUS_ON_EMPTY",
 ``!f:real->real. f continuous_on {}``,
  MESON_TAC[CONTINUOUS_ON_SING, EMPTY_SUBSET, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_ON_NO_LIMPT = store_thm ("CONTINUOUS_ON_NO_LIMPT",
 ``!f:real->real s.
  ~(?x. x limit_point_of s) ==> f continuous_on s``,
  REWRITE_TAC[continuous_on, LIMPT_APPROACHABLE] THEN MESON_TAC[DIST_REFL]);

val CONTINUOUS_ON_FINITE = store_thm ("CONTINUOUS_ON_FINITE",
 ``!f:real->real s. FINITE s ==> f continuous_on s``,
  MESON_TAC[CONTINUOUS_ON_NO_LIMPT, LIMIT_POINT_FINITE]);

val CONTRACTION_IMP_CONTINUOUS_ON = store_thm ("CONTRACTION_IMP_CONTINUOUS_ON",
 ``!f:real->real.
   (!x y. x IN s /\ y IN s ==> dist(f x,f y) <= dist(x,y))
   ==> f continuous_on s``,
  SIMP_TAC std_ss [continuous_on] THEN MESON_TAC[REAL_LET_TRANS]);

val ISOMETRY_ON_IMP_CONTINUOUS_ON = store_thm ("ISOMETRY_ON_IMP_CONTINUOUS_ON",
 ``!f:real->real.
   (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
   ==> f continuous_on s``,
  SIMP_TAC std_ss [CONTRACTION_IMP_CONTINUOUS_ON, REAL_LE_REFL]);

(* ------------------------------------------------------------------------- *)
(* Characterization of various kinds of continuity in terms of sequences.    *)
(* ------------------------------------------------------------------------- *)

val FORALL_POS_MONO_1 = store_thm ("FORALL_POS_MONO_1",
 ``!P. (!d e. d < e /\ P d ==> P e) /\ (!n. P(inv(&n + &1)))
       ==> !e. (&0:real) < e ==> P e``,
  SIMP_TAC std_ss [REAL_OF_NUM_SUC] THEN SIMP_TAC std_ss [GSYM FORALL_SUC] THEN
  REWRITE_TAC [FORALL_POS_MONO]);

val CONTINUOUS_WITHIN_SEQUENTIALLY = store_thm ("CONTINUOUS_WITHIN_SEQUENTIALLY",
 ``!f s a:real.
    f continuous (at a within s) <=>
    !x. (!n. x(n) IN s) /\ (x --> a) sequentially
    ==> ((f o x) --> f(a)) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_within] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN MESON_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT, REAL_OF_NUM_LE, REAL_POS,
   REAL_ARITH ``&0 <= n ==> &0 < n + &1:real``, NOT_FORALL_THM, SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:num->real``) THEN EXISTS_TAC ``y:num->real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN
  SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
  STRIP_TAC THEN CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[LESS_EQ_REFL]] THEN
  KNOW_TAC ``!e. (?N:num. !n. N <= n ==> dist (y n,a) < e) =
             (\e. ?N:num. !n. N <= n ==> dist (y n,a) < e) e`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FORALL_POS_MONO_1 THEN BETA_TAC THEN
  CONJ_TAC THENL [ASM_MESON_TAC[REAL_LT_TRANS], ALL_TAC] THEN
  X_GEN_TAC ``n:num`` THEN EXISTS_TAC ``n:num`` THEN X_GEN_TAC ``m:num`` THEN
  DISCH_TAC THEN MATCH_MP_TAC REAL_LTE_TRANS THEN
  EXISTS_TAC ``&1 / (&m + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_INV2, real_div, REAL_ARITH ``&0 <= x ==> &0 < x + &1:real``,
   REAL_POS, REAL_MUL_LID, REAL_LE_RADD, REAL_OF_NUM_LE]);

val CONTINUOUS_AT_SEQUENTIALLY = store_thm ("CONTINUOUS_AT_SEQUENTIALLY",
 ``!f a:real. f continuous (at a) <=>
   !x. (x --> a) sequentially ==> ((f o x) --> f(a)) sequentially``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN_SEQUENTIALLY, IN_UNIV]);

val CONTINUOUS_ON_SEQUENTIALLY = store_thm ("CONTINUOUS_ON_SEQUENTIALLY",
 ``!f s:real->bool. f continuous_on s <=>
   !x a. a IN s /\ (!n. x(n) IN s) /\ (x --> a) sequentially
   ==> ((f o x) --> f(a)) sequentially``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
  CONTINUOUS_WITHIN_SEQUENTIALLY] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY = store_thm ("UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY",
 ``!f s:real->bool. f uniformly_continuous_on s <=>
   !x y. (!n. x(n) IN s) /\ (!n. y(n) IN s) /\
   ((\n. x(n) - y(n)) --> 0) sequentially
   ==> ((\n. f(x(n)) - f(y(n))) --> 0) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, dist, REAL_SUB_RZERO] THEN
  EQ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, NOT_EXISTS_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC ``&1 / (&n + &1:real)``) THEN
  SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, REAL_OF_NUM_LE, REAL_POS,
   REAL_ARITH ``&0 <= n ==> &0 < n + &1:real``, NOT_FORALL_THM, SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``x:num->real``) THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:num->real``) THEN
  EXISTS_TAC ``x:num->real`` THEN EXISTS_TAC ``y:num->real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IMP, FORALL_AND_THM] THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[ABS_SUB] THEN CONJ_TAC THENL
  [KNOW_TAC ``!e:real. (?N:num. !n. N <= n ==> abs (y n - x n) < e) =
                   (\e. ?N:num. !n. N <= n ==> abs (y n - x n) < e) e`` THENL
   [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
   MATCH_MP_TAC FORALL_POS_MONO_1 THEN BETA_TAC THEN
   CONJ_TAC THENL [ASM_MESON_TAC[REAL_LT_TRANS], ALL_TAC] THEN
   X_GEN_TAC ``n:num`` THEN EXISTS_TAC ``n:num`` THEN X_GEN_TAC ``m:num`` THEN
   DISCH_TAC THEN MATCH_MP_TAC REAL_LTE_TRANS THEN
   EXISTS_TAC ``&1 / (&m + &1:real)`` THEN ASM_REWRITE_TAC[] THEN
   ASM_SIMP_TAC std_ss [REAL_LE_INV2, real_div, REAL_ARITH ``&0 <= x ==> &0 < x + &1:real``,
    REAL_POS, REAL_MUL_LID, REAL_LE_RADD, REAL_OF_NUM_LE],
  EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  EXISTS_TAC ``\x:num. x`` THEN ASM_SIMP_TAC std_ss [LESS_EQ_REFL]]);

val LIM_CONTINUOUS_FUNCTION = store_thm ("LIM_CONTINUOUS_FUNCTION",
 ``!f net g l.
  f continuous (at l) /\ (g --> l) net ==> ((\x. f(g x)) --> f l) net``,
  REWRITE_TAC[tendsto, continuous_at, eventually] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Combination results for pointwise continuity.                             *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_CONST = store_thm ("CONTINUOUS_CONST",
 ``!net c. (\x. c) continuous net``,
  REWRITE_TAC[continuous, LIM_CONST]);

val CONTINUOUS_CMUL = store_thm ("CONTINUOUS_CMUL",
 ``!f c net. f continuous net ==> (\x. c * f(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_CMUL]);

val CONTINUOUS_NEG = store_thm ("CONTINUOUS_NEG",
 ``!f net. f continuous net ==> (\x. -(f x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_NEG]);

val CONTINUOUS_ADD = store_thm ("CONTINUOUS_ADD",
 ``!f g net. f continuous net /\ g continuous net
  ==> (\x. f(x) + g(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_ADD]);

val CONTINUOUS_SUB = store_thm ("CONTINUOUS_SUB",
 ``!f g net. f continuous net /\ g continuous net
  ==> (\x. f(x) - g(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_SUB]);

val CONTINUOUS_ABS = store_thm ("CONTINUOUS_ABS",
 ``!(f:'a->real) net. f continuous net
  ==> (\x. abs(f(x)):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_ABS]);

val CONTINUOUS_MAX = store_thm ("CONTINUOUS_MAX",
 ``!(f:'a->real) (g:'a->real) net.
   f continuous net /\ g continuous net
   ==> (\x. (max (f(x)) (g(x))):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MAX]);

val CONTINUOUS_MIN = store_thm ("CONTINUOUS_MIN",
 ``!(f:'a->real) (g:'a->real) net.
   f continuous net /\ g continuous net
   ==> (\x. (min (f(x)) (g(x))):real) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MIN]);

val CONTINUOUS_SUM = store_thm ("CONTINUOUS_SUM",
 ``!net f s. FINITE s /\ (!a. a IN s ==> (f a) continuous net)
  ==> (\x. sum s (\a. f a x)) continuous net``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  KNOW_TAC ``!s. ((!a:'b. a IN s ==> f a continuous net) ==>
              (\x:'a. sum s (\a. f a x)) continuous net) =
             (\s. (!a. a IN s ==> f a continuous net) ==>
              (\x. sum s (\a. f a x)) continuous net) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   CONTINUOUS_CONST, CONTINUOUS_ADD, ETA_AX] THEN
  METIS_TAC [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   CONTINUOUS_CONST, CONTINUOUS_ADD, ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Same thing for setwise continuity.                                        *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CONST = store_thm ("CONTINUOUS_ON_CONST",
 ``!s c. (\x. c) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_CONST]);

val CONTINUOUS_ON_CMUL = store_thm ("CONTINUOUS_ON_CMUL",
 ``!f c s. f continuous_on s ==> (\x. c * f(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_CMUL]);

val CONTINUOUS_ON_NEG = store_thm ("CONTINUOUS_ON_NEG",
 ``!f s. f continuous_on s
  ==> (\x. -(f x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_NEG]);

val CONTINUOUS_ON_ADD = store_thm ("CONTINUOUS_ON_ADD",
 ``!f g s. f continuous_on s /\ g continuous_on s
  ==> (\x. f(x) + g(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ADD]);

val CONTINUOUS_ON_SUB = store_thm ("CONTINUOUS_ON_SUB",
 ``!f g s. f continuous_on s /\ g continuous_on s
  ==> (\x. f(x) - g(x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_SUB]);

val CONTINUOUS_ON_ABS = store_thm ("CONTINUOUS_ON_ABS",
 ``!f:real->real s. f continuous_on s
  ==> (\x. (abs(f(x))):real) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ABS]);

val CONTINUOUS_ON_MAX = store_thm ("CONTINUOUS_ON_MAX",
 ``!f:real->real g:real->real s.
  f continuous_on s /\ g continuous_on s
  ==> (\x. (max (f(x)) (g(x))):real)
   continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_MAX]);

val CONTINUOUS_ON_MIN = store_thm ("CONTINUOUS_ON_MIN",
 ``!f:real->real g:real->real s.
  f continuous_on s /\ g continuous_on s
  ==> (\x. (min (f(x)) (g(x))):real)
   continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_MIN]);

val CONTINUOUS_ON_SUM = store_thm ("CONTINUOUS_ON_SUM",
 ``!t f s. FINITE s /\ (!a. a IN s ==> (f a) continuous_on t)
  ==> (\x. sum s (\a. f a x)) continuous_on t``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_SUM]);

(* ------------------------------------------------------------------------- *)
(* Same thing for uniform continuity, using sequential formulations.         *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_ON_CONST = store_thm ("UNIFORMLY_CONTINUOUS_ON_CONST",
 ``!s c. (\x. c) uniformly_continuous_on s``,
  SIMP_TAC std_ss [UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY, o_DEF,
   REAL_SUB_REFL, LIM_CONST]);

val LINEAR_UNIFORMLY_CONTINUOUS_ON = store_thm ("LINEAR_UNIFORMLY_CONTINUOUS_ON",
 ``!f:real->real s. linear f ==> f uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [uniformly_continuous_on, dist, GSYM LINEAR_SUB] THEN
  FIRST_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
   MATCH_MP LINEAR_BOUNDED_POS) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``e / B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``B * abs(y - x:real)`` THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[REAL_LT_RDIV_EQ, REAL_MUL_SYM]);

val lemma = prove (
 ``(!y. ((?x. (y = f x) /\ P x) /\ Q y ==> R y)) <=>
   (!x. P x /\ Q (f x) ==> R (f x))``,
  MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_COMPOSE = store_thm ("UNIFORMLY_CONTINUOUS_ON_COMPOSE",
 ``!f g s. f uniformly_continuous_on s /\
           g uniformly_continuous_on (IMAGE f s)
 ==> (g o f) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [uniformly_continuous_on, o_THM, IN_IMAGE] THEN
  KNOW_TAC ``((!e:real. 0 < e ==> ?d. 0 < d /\
     !x x'. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
    !x x'. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
             ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
    !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [SWAP_FORALL_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC `` ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x'. (x = f x') /\ x' IN s) /\ (?x. (x' = f x) /\ x IN s) /\
       dist (x',x) < d ==> dist (g x',g x) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
              ((!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ (?x. (x' = f x) /\ x IN s) /\ dist (x',f x) < d
                    ==> dist (g x',g (f x)) < e) ==>
               !e:real. 0 < e ==> ?d. 0 < d /\
     !x' x. x IN s /\ x' IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c <=> b /\ a /\ c`] THEN
  KNOW_TAC ``((!e. 0 < e ==> ?d. 0 < d /\
     !x' x. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x' x. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x' x. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
              ((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [SWAP_FORALL_THM], ALL_TAC] THEN DISC_RW_KILL THEN
  KNOW_TAC ``((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. (?x. (x' = f x) /\ x IN s) /\ x IN s /\ dist (x',f x) < d ==>
       dist (g x',g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e) =
            ((!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==> dist (f x',f x) < e) /\
              (!e. 0 < e ==> ?d. 0 < d /\
     !x x'. x' IN s /\ x IN s /\ dist (f x',f x) < d ==>
       dist (g (f x'),g (f x)) < e) ==>
               !e. 0 < e ==> ?d. 0 < d /\
    !x x'. x' IN s /\ x IN s /\ dist (x',x) < d ==>
      dist (g (f x'),g (f x)) < e)`` THENL
  [METIS_TAC [], ALL_TAC] THEN DISC_RW_KILL THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_CASES_TAC ``&0 < e`` THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[]);

val BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE = store_thm ("BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE",
 ``!f:real->real g (h:real->real->real) s.
    f uniformly_continuous_on s /\ g uniformly_continuous_on s /\
    bilinear h /\ bounded(IMAGE f s) /\ bounded(IMAGE g s)
    ==> (\x. h (f x) (g x)) uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[uniformly_continuous_on, dist] THEN
  BETA_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``!a b c d. (h:real->real->real) a b - h c d =
     h (a - c) b + h c (b - d)`` (fn th => ONCE_REWRITE_TAC[th]) THENL
  [FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP BILINEAR_LSUB th]) THEN
   FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP BILINEAR_RSUB th]) THEN
   REAL_ARITH_TAC, ALL_TAC] THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC o
   MATCH_MP BILINEAR_BOUNDED_POS) THEN
  UNDISCH_TAC ``bounded(IMAGE (g:real->real) s)`` THEN
  UNDISCH_TAC ``bounded(IMAGE (f:real->real) s)`` THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B1:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``B2:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``(g:real->real) uniformly_continuous_on s`` THEN
  UNDISCH_TAC ``(f:real->real) uniformly_continuous_on s`` THEN
  REWRITE_TAC[uniformly_continuous_on] THEN
  DISCH_THEN(MP_TAC o SPEC ``e:real / &2 / &2 / B / B2``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_HALF, dist] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``e:real / &2 / &2 / B / B1``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_HALF, dist] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x:real``, ``y:real``]) THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x:real``, ``y:real``]) THEN
  ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC
   ``B * e / &2 / &2 / B / B2 * B2 + B * B1 * e / &2 / &2 / B / B1:real`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC(REAL_ARITH
   ``abs(x) <= a /\ abs(y) <= b ==> abs(x + y:real) <= a + b``) THEN
  CONJ_TAC THEN
  FIRST_X_ASSUM(fn th => W(MP_TAC o PART_MATCH lhand th o lhand o snd)) THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LE_TRANS) THEN
  REWRITE_TAC [real_div] THEN REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  MATCH_MP_TAC REAL_LE_LMUL1 THEN ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE] THENL
  [REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC],ALL_TAC] THEN
  MATCH_MP_TAC REAL_LE_MUL2 THEN REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, ABS_POS],
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [real_div, GSYM REAL_MUL_ASSOC] THEN
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [GSYM real_div, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [real_div] THEN
  REWRITE_TAC [REAL_ARITH `` B1 * e * inv 2 * inv 2 * inv B * inv B1 * B =
                             e * inv 2 * inv 2 * inv B * inv B1 * B1 * B:real``] THEN
  REWRITE_TAC [GSYM real_div] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_POS_NZ] THEN
  REWRITE_TAC [REAL_HALF_DOUBLE] THEN ASM_SIMP_TAC std_ss [REAL_LT_HALF2]]);

val UNIFORMLY_CONTINUOUS_ON_MUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_MUL",
 ``!f g:real->real s.
    f uniformly_continuous_on s /\ g uniformly_continuous_on s /\
    bounded(IMAGE f s) /\ bounded(IMAGE g s)
    ==> (\x. f x * g x) uniformly_continuous_on s``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``(f:real->real)``, ``g:real->real``,
   ``\c (v:real). c * v``, ``s:real->bool``]
  BILINEAR_UNIFORMLY_CONTINUOUS_ON_COMPOSE) THEN
  ASM_SIMP_TAC std_ss [o_THM] THEN DISCH_THEN MATCH_MP_TAC THEN
  REWRITE_TAC[bilinear, linear] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_CMUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_CMUL",
 ``!f c s. f uniformly_continuous_on s
   ==> (\x. c * f(x)) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY] THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`x:num->real`, `y:num->real`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_CMUL) THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LDISTRIB, REAL_MUL_RZERO]);

val UNIFORMLY_CONTINUOUS_ON_VMUL = store_thm ("UNIFORMLY_CONTINUOUS_ON_VMUL",
 ``!s:real->bool c v:real.
    c uniformly_continuous_on s
    ==> (\x. c x * v) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o ISPEC ``\x. (x * v:real)`` o MATCH_MP
   (REWRITE_RULE[CONJ_EQ_IMP] UNIFORMLY_CONTINUOUS_ON_COMPOSE)) THEN
  SIMP_TAC std_ss [o_DEF] THEN DISCH_THEN MATCH_MP_TAC THEN
  MATCH_MP_TAC LINEAR_UNIFORMLY_CONTINUOUS_ON THEN
  REWRITE_TAC [linear] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_NEG = store_thm ("UNIFORMLY_CONTINUOUS_ON_NEG",
 ``!f s. f uniformly_continuous_on s
   ==> (\x. -(f x)) uniformly_continuous_on s``,
  ONCE_REWRITE_TAC[REAL_NEG_MINUS1] THEN
  REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_CMUL]);

val UNIFORMLY_CONTINUOUS_ON_ADD = store_thm ("UNIFORMLY_CONTINUOUS_ON_ADD",
 ``!f g s. f uniformly_continuous_on s /\ g uniformly_continuous_on s
  ==> (\x. f(x) + g(x)) uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[UNIFORMLY_CONTINUOUS_ON_SEQUENTIALLY] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`x:num->real`, `y:num->real`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [o_DEF] THEN DISCH_THEN(MP_TAC o MATCH_MP LIM_ADD) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN BETA_TAC THEN
  REWRITE_TAC[REAL_ADD_LID] THEN AP_THM_TAC THEN BINOP_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN BETA_TAC THEN REAL_ARITH_TAC);

val UNIFORMLY_CONTINUOUS_ON_SUB = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUB",
 ``!f g s. f uniformly_continuous_on s /\ g uniformly_continuous_on s
   ==> (\x. f(x) - g(x)) uniformly_continuous_on s``,
  REWRITE_TAC[real_sub] THEN
  SIMP_TAC std_ss [UNIFORMLY_CONTINUOUS_ON_NEG, UNIFORMLY_CONTINUOUS_ON_ADD]);

val UNIFORMLY_CONTINUOUS_ON_SUM = store_thm ("UNIFORMLY_CONTINUOUS_ON_SUM",
 ``!t f s. FINITE s /\ (!a. a IN s ==> (f a) uniformly_continuous_on t)
    ==> (\x. sum s (\a. f a x)) uniformly_continuous_on t``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  KNOW_TAC ``!s. ((!a. a IN s ==> f a uniformly_continuous_on t) ==>
              (\x. sum s (\a. f a x)) uniformly_continuous_on t) =
             (\s. (!a. a IN s ==> f a uniformly_continuous_on t) ==>
              (\x. sum s (\a. f a x)) uniformly_continuous_on t) s`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_INSERT, NOT_IN_EMPTY, SUM_CLAUSES,
   UNIFORMLY_CONTINUOUS_ON_CONST, ETA_AX] THEN REPEAT STRIP_TAC THEN
  METIS_TAC [UNIFORMLY_CONTINUOUS_ON_ADD]);

(* ------------------------------------------------------------------------- *)
(* Identity function is continuous in every sense.                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_ID = store_thm ("CONTINUOUS_WITHIN_ID",
 ``!a s. (\x. x) continuous (at a within s)``,
  REWRITE_TAC[continuous_within] THEN MESON_TAC[]);

val CONTINUOUS_AT_ID = store_thm ("CONTINUOUS_AT_ID",
 ``!a. (\x. x) continuous (at a)``,
  REWRITE_TAC[continuous_at] THEN MESON_TAC[]);

val CONTINUOUS_ON_ID = store_thm ("CONTINUOUS_ON_ID",
 ``!s. (\x. x) continuous_on s``,
  REWRITE_TAC[continuous_on] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_ID = store_thm ("UNIFORMLY_CONTINUOUS_ON_ID",
 ``!s. (\x. x) uniformly_continuous_on s``,
  REWRITE_TAC[uniformly_continuous_on] THEN MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Continuity of all kinds is preserved under composition. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_COMPOSE = store_thm ("CONTINUOUS_WITHIN_COMPOSE",
 ``!f g x s. f continuous (at x within s) /\
      g continuous (at (f x) within IMAGE f s)
    ==> (g o f) continuous (at x within s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [continuous_within, o_THM, IN_IMAGE] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  ASM_MESON_TAC[]);

val CONTINUOUS_AT_COMPOSE = store_thm ("CONTINUOUS_AT_COMPOSE",
 ``!f g x. f continuous (at x) /\ g continuous (at (f x))
   ==> (g o f) continuous (at x)``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  MESON_TAC[CONTINUOUS_WITHIN_COMPOSE, IN_IMAGE, CONTINUOUS_WITHIN_SUBSET,
   SUBSET_UNIV, IN_UNIV]);

val CONTINUOUS_ON_COMPOSE = store_thm ("CONTINUOUS_ON_COMPOSE",
 ``!f g s. f continuous_on s /\ g continuous_on (IMAGE f s)
  ==> (g o f) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  MESON_TAC[IN_IMAGE, CONTINUOUS_WITHIN_COMPOSE]);

(* ------------------------------------------------------------------------- *)
(* Continuity in terms of open preimages. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_OPEN = store_thm ("CONTINUOUS_WITHIN_OPEN",
 ``!f:real->real x u.
    f continuous (at x within u) <=>
   !t. open t /\ f(x) IN t
   ==> ?s. open s /\ x IN s /\
    !x'. x' IN s /\ x' IN u ==> f(x') IN t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_within] THEN EQ_TAC THENL
  [DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN
   DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
   GEN_REWR_TAC LAND_CONV [open_def] THEN
   DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
   ASM_MESON_TAC[IN_BALL, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL, DIST_SYM],
   DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``ball((f:real->real) x,e)``) THEN
   ASM_SIMP_TAC std_ss [OPEN_BALL, CENTRE_IN_BALL] THEN
   MESON_TAC[open_def, IN_BALL, REAL_LT_TRANS, DIST_SYM]]);

val CONTINUOUS_AT_OPEN = store_thm ("CONTINUOUS_AT_OPEN",
 ``!f:real->real x.
   f continuous (at x) <=>
   !t. open t /\ f(x) IN t
   ==> ?s. open s /\ x IN s /\
    !x'. x' IN s ==> f(x') IN t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_at] THEN EQ_TAC THENL
  [DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN
   DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
   GEN_REWR_TAC LAND_CONV [open_def] THEN
   DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
   ASM_MESON_TAC[IN_BALL, DIST_SYM, OPEN_BALL, CENTRE_IN_BALL],
   DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``ball((f:real->real) x,e)``) THEN
   ASM_SIMP_TAC std_ss [OPEN_BALL, CENTRE_IN_BALL] THEN
   MESON_TAC[open_def, IN_BALL, REAL_LT_TRANS, DIST_SYM]]);

val CONTINUOUS_ON_OPEN_GEN = store_thm ("CONTINUOUS_ON_OPEN_GEN",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> (f continuous_on s <=>
    !u. open_in (subtopology euclidean t) u
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN u})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[continuous_on] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [open_in, SUBSET_DEF, GSPECIFICATION] THEN
   DISCH_TAC THEN X_GEN_TAC ``u:real->bool`` THEN STRIP_TAC THEN
   X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``(f:real->real) x``) THEN ASM_SET_TAC[],
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o
   SPEC ``ball((f:real->real) x,e) INTER t``) THEN
  KNOW_TAC ``open_in (subtopology euclidean t) (ball ((f:real->real) x,e) INTER t)`` THENL
  [ASM_MESON_TAC[OPEN_IN_OPEN, INTER_COMM, OPEN_BALL], ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [open_in, SUBSET_DEF, IN_INTER, GSPECIFICATION, IN_BALL, IN_IMAGE] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF, FORALL_IN_IMAGE]) THEN
  FULL_SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  ASM_MESON_TAC[DIST_REFL, DIST_SYM]]);

val CONTINUOUS_ON_OPEN = store_thm ("CONTINUOUS_ON_OPEN",
 ``!f:real->real s.
   f continuous_on s <=>
   !t. open_in (subtopology euclidean (IMAGE f s)) t
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_OPEN_GEN THEN
  REWRITE_TAC[SUBSET_REFL]);

val CONTINUOUS_OPEN_IN_PREIMAGE_GEN = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE_GEN",
 ``!f:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    open_in (subtopology euclidean t) u
    ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN u}``,
  METIS_TAC[CONTINUOUS_ON_OPEN_GEN]);

val CONTINUOUS_ON_IMP_OPEN_IN = store_thm ("CONTINUOUS_ON_IMP_OPEN_IN",
 ``!f:real->real s t. f continuous_on s /\
   open_in (subtopology euclidean (IMAGE f s)) t
   ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
 METIS_TAC[CONTINUOUS_ON_OPEN]);

(* ------------------------------------------------------------------------- *)
(* Similarly in terms of closed sets. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CLOSED_GEN = store_thm ("CONTINUOUS_ON_CLOSED_GEN",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> (f continuous_on s <=>
    !u. closed_in (subtopology euclidean t) u
    ==> closed_in (subtopology euclidean s)
    {x | x IN s /\ f x IN u})``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(fn th =>
  ONCE_REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THEN
  EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``u:real->bool`` THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THENL
  [REWRITE_TAC[closed_in], REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ]] THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_CLOSED = store_thm ("CONTINUOUS_ON_CLOSED",
 ``!f:real->real s.
    f continuous_on s <=>
   !t. closed_in (subtopology euclidean (IMAGE f s)) t
    ==> closed_in (subtopology euclidean s) {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_CLOSED_GEN THEN
  REWRITE_TAC[SUBSET_REFL]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_GEN = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_GEN",
 ``!f:real->real s t u.
   f continuous_on s /\ IMAGE f s SUBSET t /\
   closed_in (subtopology euclidean t) u
   ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN u}``,
  METIS_TAC[CONTINUOUS_ON_CLOSED_GEN]);

val CONTINUOUS_ON_IMP_CLOSED_IN = store_thm ("CONTINUOUS_ON_IMP_CLOSED_IN",
 ``!f:real->real s t. f continuous_on s /\
    closed_in (subtopology euclidean (IMAGE f s)) t
    ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  METIS_TAC[CONTINUOUS_ON_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* Half-global and completely global cases. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_OPEN_IN_PREIMAGE = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE",
 ``!f s t.
  f continuous_on s /\ open t
  ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[SET_RULE
  ``x IN s /\ f x IN t <=> x IN s /\ f x IN (t INTER IMAGE f s)``] THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CONTINUOUS_ON_OPEN]) THEN
  ONCE_REWRITE_TAC[INTER_COMM] THEN MATCH_MP_TAC OPEN_IN_OPEN_INTER THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_CLOSED_IN_PREIMAGE = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE",
 ``!f s t.
   f continuous_on s /\ closed t
   ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[SET_RULE
   ``x IN s /\ f x IN t <=> x IN s /\ f x IN (t INTER IMAGE f s)``] THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[CONTINUOUS_ON_CLOSED]) THEN
  ONCE_REWRITE_TAC[INTER_COMM] THEN MATCH_MP_TAC CLOSED_IN_CLOSED_INTER THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_OPEN_PREIMAGE = store_thm ("CONTINUOUS_OPEN_PREIMAGE",
 ``!f:real->real s t.
   f continuous_on s /\ open s /\ open t
   ==> open {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  REWRITE_TAC [OPEN_IN_OPEN] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (f:real->real) s INTER t``) THEN
  KNOW_TAC ``(?t'. open t' /\ (IMAGE (f:real->real) s INTER t = IMAGE f s INTER t'))`` THENL
  [EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC [],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN t} =
                                            s INTER t'`` SUBST1_TAC THENL
  [ASM_SET_TAC [], ASM_MESON_TAC [OPEN_INTER]]]);

val CONTINUOUS_CLOSED_PREIMAGE = store_thm ("CONTINUOUS_CLOSED_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ closed s /\ closed t
    ==> closed {x | x IN s /\ f(x) IN t}``,
  REPEAT STRIP_TAC THEN UNDISCH_TAC ``f continuous_on s`` THEN
  GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_CLOSED] THEN
  REWRITE_TAC [CLOSED_IN_CLOSED] THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (f:real->real) s INTER t``) THEN
  KNOW_TAC ``(?t'. closed t' /\ (IMAGE (f:real->real) s INTER t = IMAGE f s INTER t'))`` THENL
  [EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC [],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN t} =
                                            s INTER t'`` SUBST1_TAC THENL
  [ASM_SET_TAC [], ASM_MESON_TAC [CLOSED_INTER]]]);

val CONTINUOUS_OPEN_PREIMAGE_UNIV = store_thm ("CONTINUOUS_OPEN_PREIMAGE_UNIV",
 ``!f:real->real s.
  (!x. f continuous (at x)) /\ open s ==> open {x | f(x) IN s}``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``f:real->real``, ``univ(:real)``, ``s:real->bool``]
   CONTINUOUS_OPEN_PREIMAGE) THEN
  ASM_SIMP_TAC std_ss [OPEN_UNIV, IN_UNIV, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val CONTINUOUS_CLOSED_PREIMAGE_UNIV = store_thm ("CONTINUOUS_CLOSED_PREIMAGE_UNIV",
 ``!f:real->real s.
  (!x. f continuous (at x)) /\ closed s ==> closed {x | f(x) IN s}``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``f:real->real``, ``univ(:real)``, ``s:real->bool``]
   CONTINUOUS_CLOSED_PREIMAGE) THEN
  ASM_SIMP_TAC std_ss [CLOSED_UNIV, IN_UNIV, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val CONTINUOUS_OPEN_IN_PREIMAGE_EQ = store_thm ("CONTINUOUS_OPEN_IN_PREIMAGE_EQ",
 ``!f:real->real s. f continuous_on s <=>
   !t. open t ==> open_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONTINUOUS_OPEN_IN_PREIMAGE] THEN
  REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN DISCH_TAC THEN
  X_GEN_TAC ``t:real->bool`` THEN GEN_REWR_TAC LAND_CONV [OPEN_IN_OPEN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SET_TAC[]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_EQ = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_EQ",
 ``!f:real->real s. f continuous_on s <=> !t. closed t
     ==> closed_in (subtopology euclidean s) {x | x IN s /\ f x IN t}``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONTINUOUS_CLOSED_IN_PREIMAGE] THEN
  REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN DISCH_TAC THEN
  X_GEN_TAC ``t:real->bool`` THEN
  GEN_REWR_TAC LAND_CONV [CLOSED_IN_CLOSED] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Linear functions are (uniformly) continuous on any set. *)
(* ------------------------------------------------------------------------- *)

val LINEAR_LIM_0 = store_thm ("LINEAR_LIM_0",
 ``!f. linear f ==> (f --> 0) (at (0))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIM_AT] THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP LINEAR_BOUNDED_POS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``e / B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV] THEN REWRITE_TAC[dist, REAL_SUB_RZERO] THEN
  ASM_MESON_TAC[REAL_MUL_SYM, REAL_LET_TRANS, REAL_LT_RDIV_EQ]);

val LINEAR_CONTINUOUS_AT = store_thm ("LINEAR_CONTINUOUS_AT",
 ``!f:real->real a. linear f ==> f continuous (at a)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``\x. (f:real->real) (a + x) - f(a)`` LINEAR_LIM_0) THEN
  KNOW_TAC ``linear (\x. f (a + x) - f a)`` THENL
  [POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [linear] THEN
   REPEAT STRIP_TAC THEN REAL_ARITH_TAC, ALL_TAC] THEN
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [GSYM LIM_NULL, CONTINUOUS_AT] THEN
  GEN_REWR_TAC RAND_CONV [LIM_AT_ZERO] THEN SIMP_TAC std_ss []);

val LINEAR_CONTINUOUS_WITHIN = store_thm ("LINEAR_CONTINUOUS_WITHIN",
 ``!f:real->real s x. linear f ==> f continuous (at x within s)``,
  SIMP_TAC std_ss [CONTINUOUS_AT_WITHIN, LINEAR_CONTINUOUS_AT]);

val LINEAR_CONTINUOUS_ON = store_thm ("LINEAR_CONTINUOUS_ON",
 ``!f:real->real s. linear f ==> f continuous_on s``,
  MESON_TAC[LINEAR_CONTINUOUS_AT, CONTINUOUS_AT_IMP_CONTINUOUS_ON]);

val LINEAR_CONTINUOUS_COMPOSE = store_thm ("LINEAR_CONTINUOUS_COMPOSE",
 ``!net f:'a->real g:real->real.
   f continuous net /\ linear g ==> (\x. g(f x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_LINEAR]);

val LINEAR_CONTINUOUS_ON_COMPOSE = store_thm ("LINEAR_CONTINUOUS_ON_COMPOSE",
 ``!f:real->real g:real->real s.
    f continuous_on s /\ linear g ==> (\x. g(f x)) continuous_on s``,
  SIMP_TAC std_ss[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
   LINEAR_CONTINUOUS_COMPOSE]);

val CONTINUOUS_COMPONENT_COMPOSE = store_thm ("CONTINUOUS_COMPONENT_COMPOSE",
 ``!net f:'a->real i. f continuous net ==> (\x. f x) continuous net``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``linear(\x:real. x)`` MP_TAC THENL
  [REWRITE_TAC[LINEAR_ID], REWRITE_TAC[GSYM IMP_CONJ_ALT]] THEN
  METIS_TAC [LINEAR_CONTINUOUS_COMPOSE]);

val CONTINUOUS_ON_COMPONENT_COMPOSE = store_thm ("CONTINUOUS_ON_COMPONENT_COMPOSE",
 ``!f:real->real s. f continuous_on s
    ==> (\x. f x) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
                   CONTINUOUS_COMPONENT_COMPOSE]);

(* ------------------------------------------------------------------------- *)
(* Also bilinear functions, in composition form. *)
(* ------------------------------------------------------------------------- *)

val BILINEAR_CONTINUOUS_COMPOSE = store_thm ("BILINEAR_CONTINUOUS_COMPOSE",
 ``!net f:'a->real g:'a->real h:real->real->real.
   f continuous net /\ g continuous net /\ bilinear h
   ==> (\x. h (f x) (g x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_BILINEAR]);

val BILINEAR_CONTINUOUS_ON_COMPOSE = store_thm ("BILINEAR_CONTINUOUS_ON_COMPOSE",
 ``!f g h s. f continuous_on s /\ g continuous_on s /\ bilinear h
   ==> (\x. h (f x) (g x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN,
                   BILINEAR_CONTINUOUS_COMPOSE]);

val BILINEAR_DOT = store_thm ("BILINEAR_DOT",
 ``bilinear (\x y:real. (x * y))``,
SIMP_TAC std_ss [bilinear, linear] THEN REAL_ARITH_TAC);

val CONTINUOUS_DOT2 = store_thm ("CONTINUOUS_DOT2",
 ``!net f g:'a->real.
   f continuous net /\ g continuous net
   ==> (\x. f x * g x) continuous net``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP (MATCH_MP (REWRITE_RULE
   [TAUT `p /\ q /\ r ==> s <=> r ==> p /\ q ==> s`]
  BILINEAR_CONTINUOUS_COMPOSE) BILINEAR_DOT)) THEN BETA_TAC THEN REWRITE_TAC[]);

val CONTINUOUS_ON_DOT2 = store_thm ("CONTINUOUS_ON_DOT2",
 ``!f:real->real g s.
    f continuous_on s /\ g continuous_on s
    ==> (\x. f x * g x) continuous_on s``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP (MATCH_MP (REWRITE_RULE
  [TAUT `p /\ q /\ r ==> s <=> r ==> p /\ q ==> s`]
  BILINEAR_CONTINUOUS_ON_COMPOSE) BILINEAR_DOT)) THEN BETA_TAC THEN REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Preservation of compactness and connectedness under continuous function. *)
(* ------------------------------------------------------------------------- *)

val COMPACT_CONTINUOUS_IMAGE = store_thm ("COMPACT_CONTINUOUS_IMAGE",
 ``!f:real->real s.
    f continuous_on s /\ compact s ==> compact(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on, compact] THEN
  STRIP_TAC THEN X_GEN_TAC ``y:num->real`` THEN
  SIMP_TAC std_ss [IN_IMAGE, SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN ASM_REWRITE_TAC[] THEN
  KNOW_TAC ``((?(l :real) (r :num -> num).
              l IN s /\ (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((x :num -> real) o r --> l) sequentially) ==>
               ?(l :real) (r :num -> num).
              (?(x :real). (l = f x) /\ x IN s) /\
                        (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((y :num -> real) o r --> l) sequentially) =
             ((?(r :num -> num) (l :real).
              l IN s /\ (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((x :num -> real) o r --> l) sequentially) ==>
               ?(r :num -> num) (l :real).
              (?(x :real). (l = f x) /\ x IN s) /\
                        (!(m :num) (n :num). m < n ==> r m < r n) /\
                         ((y :num -> real) o r --> l) sequentially)`` THENL
  [METIS_TAC [SWAP_EXISTS_THM], DISC_RW_KILL] THEN
  STRIP_TAC THEN EXISTS_TAC ``r:num->num`` THEN
  EXISTS_TAC ``(f:real->real) l`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``l:real``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `` ((x :num -> real) o (r :num -> num) --> l) sequentially`` THEN
  GEN_REWR_TAC LAND_CONV [LIM_SEQUENTIALLY] THEN
  DISCH_THEN(MP_TAC o SPEC ``d:real``) THEN ASM_SIMP_TAC std_ss [o_THM] THEN
  ASM_MESON_TAC[]);

val COMPACT_TRANSLATION = store_thm ("COMPACT_TRANSLATION",
 ``!s a:real. compact s ==> compact (IMAGE (\x. a + x) s)``,
  SIMP_TAC std_ss [COMPACT_CONTINUOUS_IMAGE, CONTINUOUS_ON_ADD,
   CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]);

val COMPACT_TRANSLATION_EQ = store_thm ("COMPACT_TRANSLATION_EQ",
 ``!a s. compact (IMAGE (\x:real. a + x) s) <=> compact s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[COMPACT_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o ISPEC ``-a:real`` o MATCH_MP COMPACT_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val COMPACT_LINEAR_IMAGE = store_thm ("COMPACT_LINEAR_IMAGE",
 ``!f:real->real s. compact s /\ linear f ==> compact(IMAGE f s)``,
  SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, COMPACT_CONTINUOUS_IMAGE]);

val CONNECTED_CONTINUOUS_IMAGE = store_thm ("CONNECTED_CONTINUOUS_IMAGE",
 ``!f:real->real s.
   f continuous_on s /\ connected s ==> connected(IMAGE f s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  SIMP_TAC std_ss [CONNECTED_CLOPEN, NOT_FORALL_THM, NOT_IMP, DE_MORGAN_THM] THEN
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``t:real->bool`` th) THEN
   MP_TAC(SPEC ``IMAGE (f:real->real) s DIFF t`` th)) THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN ``{x | x IN s /\ (f:real->real) x IN IMAGE f s DIFF t} =
   s DIFF {x | x IN s /\ f x IN t}`` SUBST1_TAC THENL
  [UNDISCH_TAC ``t SUBSET IMAGE (f:real->real) s`` THEN
   SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_DIFF, GSPECIFICATION, SUBSET_DEF] THEN
   MESON_TAC[],
   REPEAT STRIP_TAC THEN
   EXISTS_TAC ``{x | x IN s /\ (f:real->real) x IN t}`` THEN
   ASM_REWRITE_TAC[] THEN POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
   SIMP_TAC std_ss [IN_IMAGE, SUBSET_DEF, GSPECIFICATION, NOT_IN_EMPTY, EXTENSION] THEN
   MESON_TAC[]]);

val CONNECTED_TRANSLATION = store_thm ("CONNECTED_TRANSLATION",
 ``!a s. connected s ==> connected (IMAGE (\x:real. a + x) s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_ID, CONTINUOUS_ON_CONST]);

val CONNECTED_TRANSLATION_EQ = store_thm ("CONNECTED_TRANSLATION_EQ",
 ``!a s. connected (IMAGE (\x:real. a + x) s) <=> connected s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[CONNECTED_TRANSLATION] THEN
  DISCH_THEN(MP_TAC o ISPEC ``-a:real`` o MATCH_MP CONNECTED_TRANSLATION) THEN
  SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID,
   REAL_ARITH ``-a + (a + x:real) = x``]);

val CONNECTED_LINEAR_IMAGE = store_thm ("CONNECTED_LINEAR_IMAGE",
 ``!f:real->real s. connected s /\ linear f ==> connected(IMAGE f s)``,
  SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, CONNECTED_CONTINUOUS_IMAGE]);

(* ------------------------------------------------------------------------- *)
(* Quotient maps are occasionally useful.                                    *)
(* ------------------------------------------------------------------------- *)

val QUASICOMPACT_OPEN_CLOSED = store_thm ("QUASICOMPACT_OPEN_CLOSED",
 ``!f:real->real s t.
   IMAGE f s SUBSET t
   ==> ((!u. u SUBSET t
    ==> (open_in (subtopology euclidean s)
        {x | x IN s /\ f x IN u}
      ==> open_in (subtopology euclidean t) u)) <=>
          (!u. u SUBSET t
        ==> (closed_in (subtopology euclidean s)
            {x | x IN s /\ f x IN u}
           ==> closed_in (subtopology euclidean t) u)))``,
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``u:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``u SUBSET t ==> (t DIFF (t DIFF u) = u)``] THEN
  REWRITE_TAC [DIFF_SUBSET] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (MESON[]
   ``open_in top x ==> (x = y) ==> open_in top y``)) THEN
  ASM_SET_TAC[]);

val QUOTIENT_MAP_IMP_CONTINUOUS_OPEN = store_thm ("QUOTIENT_MAP_IMP_CONTINUOUS_OPEN",
 ``!f:real->real s t.
    IMAGE f s SUBSET t /\
    (!u. u SUBSET t
    ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
     open_in (subtopology euclidean t) u))
     ==> f continuous_on s``,
  METIS_TAC[OPEN_IN_IMP_SUBSET, CONTINUOUS_ON_OPEN_GEN]);

val QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED = store_thm ("QUOTIENT_MAP_IMP_CONTINUOUS_CLOSED",
 ``!f:real->real s t.
   IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (closed_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
     closed_in (subtopology euclidean t) u))
     ==> f continuous_on s``,
  METIS_TAC[CLOSED_IN_IMP_SUBSET, CONTINUOUS_ON_CLOSED_GEN]);

val OPEN_MAP_IMP_QUOTIENT_MAP = store_thm ("OPEN_MAP_IMP_QUOTIENT_MAP",
 ``!f:real->real s. f continuous_on s /\
  (!t. open_in (subtopology euclidean s) t
  ==> open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t))
    ==> !t. t SUBSET IMAGE f s
      ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN t} <=>
           open_in (subtopology euclidean (IMAGE f s)) t)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
  [SUBGOAL_THEN
   ``(t = IMAGE f {x | x IN s /\ (f:real->real) x IN t})``
    SUBST1_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC std_ss []],
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  ASM_SIMP_TAC std_ss []]);

val CLOSED_MAP_IMP_QUOTIENT_MAP = store_thm ("CLOSED_MAP_IMP_QUOTIENT_MAP",
 ``!f:real->real s. f continuous_on s /\
  (!t. closed_in (subtopology euclidean s) t
  ==> closed_in (subtopology euclidean (IMAGE f s)) (IMAGE f t))
   ==> !t. t SUBSET IMAGE f s
     ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN t} <=>
          open_in (subtopology euclidean (IMAGE f s)) t)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC
    ``s DIFF {x | x IN s /\ (f:real->real) x IN t}``) THEN
   KNOW_TAC ``closed_in (subtopology euclidean (s :real -> bool))
   (s DIFF {x | x IN s /\ (f :real -> real) x IN (t :real -> bool)})`` THENL
  [MATCH_MP_TAC CLOSED_IN_DIFF THEN
   ASM_SIMP_TAC std_ss [CLOSED_IN_SUBTOPOLOGY_REFL,
    TOPSPACE_EUCLIDEAN, SUBSET_UNIV],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
   DISCH_THEN(MP_TAC o CONJUNCT2) THEN MATCH_MP_TAC EQ_IMPLIES THEN
   AP_TERM_TAC THEN ASM_SET_TAC[]],
  UNDISCH_TAC ``f continuous_on s`` THEN GEN_REWR_TAC LAND_CONV [CONTINUOUS_ON_OPEN] THEN
  ASM_SIMP_TAC std_ss []]);

val CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP",
 ``!f:real->real g s t.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET s /\
  (!y. y IN t ==> (f(g y) = y))
   ==> (!u. u SUBSET t
    ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
         open_in (subtopology euclidean t) u))``,
  REWRITE_TAC[CONTINUOUS_ON_OPEN] THEN REPEAT STRIP_TAC THEN EQ_TAC THENL
  [DISCH_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``(IMAGE (g:real->real) t) INTER
                              {x | x IN s /\ (f:real->real) x IN u}``) THEN
   SUBGOAL_THEN ``open_in (subtopology euclidean (IMAGE (g:real->real) t))
               (IMAGE g t INTER {x | x IN s /\ (f:real->real) x IN u})``
               (fn th => REWRITE_TAC[th]) THENL
   [POP_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN] THEN ASM_SET_TAC[],
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]],
   DISCH_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
   SUBGOAL_THEN ``IMAGE (f:real->real) s = t``
    (fn th => ASM_REWRITE_TAC[th]) THEN
   ASM_SET_TAC[]]);

val CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_LEFT_INVERSE_IMP_QUOTIENT_MAP",
 ``!f:real->real g s.
    f continuous_on s /\ g continuous_on (IMAGE f s) /\
    (!x. x IN s ==> (g(f x) = x))
    ==> (!u. u SUBSET (IMAGE f s)
      ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
           open_in (subtopology euclidean (IMAGE f s)) u))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP THEN
  EXISTS_TAC ``g:real->real`` THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_OPEN_CLOSED = store_thm ("QUOTIENT_MAP_OPEN_CLOSED",
 ``!f:real->real s t.
    IMAGE f s SUBSET t
    ==> ((!u. u SUBSET t
      ==> (open_in (subtopology euclidean s)
          {x | x IN s /\ f x IN u} <=>
          open_in (subtopology euclidean t) u)) <=>
          (!u. u SUBSET t
          ==> (closed_in (subtopology euclidean s)
              {x | x IN s /\ f x IN u} <=>
              closed_in (subtopology euclidean t) u)))``,
  SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``u:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``u SUBSET t ==> (t DIFF (t DIFF u) = u)``] THEN
  REWRITE_TAC [DIFF_SUBSET] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT] THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_COMPOSE_QUOTIENT = store_thm ("CONTINUOUS_ON_COMPOSE_QUOTIENT",
 ``!f:real->real g:real->real s t u.
   IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
   (!v. v SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
        open_in (subtopology euclidean t) v)) /\
       (g o f) continuous_on s
         ==> g continuous_on t``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THEN
  SUBGOAL_THEN
   ``IMAGE ((g:real->real) o (f:real->real)) s SUBSET u``
   (fn th => REWRITE_TAC[MATCH_MP CONTINUOUS_ON_OPEN_GEN th]) THENL
  [REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[], DISCH_TAC] THEN
  X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``v:real->bool``) THEN
  ASM_REWRITE_TAC[o_THM] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{x | x IN t /\ (g:real->real) x IN v}``) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (MESON[]
   ``open_in top s ==> (s = t) ==> open_in top t``)) THEN
  ASM_SET_TAC[]);

val FUNCTION_FACTORS_LEFT_GEN = store_thm ("FUNCTION_FACTORS_LEFT_GEN",
 ``!P f g. (!x y. P x /\ P y /\ (g x = g y) ==> (f x = f y)) <=>
           (?h. !x. P x ==> (f(x) = h(g x)))``,
  ONCE_REWRITE_TAC[MESON[]
   ``(!x. P x ==> (f(x) = g(k x))) <=> (!y x. P x /\ (y = k x) ==> (f x = g y))``] THEN
  SIMP_TAC std_ss [GSYM SKOLEM_THM] THEN MESON_TAC[]);

val LIFT_TO_QUOTIENT_SPACE = store_thm ("LIFT_TO_QUOTIENT_SPACE",
 ``!f:real->real h:real->real s t u.
  (IMAGE f s = t) /\ (!v. v SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
       open_in (subtopology euclidean t) v)) /\
       h continuous_on s /\ (IMAGE h s = u) /\
      (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (h x = h y))
     ==> ?g. g continuous_on t /\ (IMAGE g t = u) /\
         !x. x IN s ==> (h(x) = g(f x))``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SIMP_TAC std_ss [FUNCTION_FACTORS_LEFT_GEN] THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN
  EXISTS_TAC ``g:real->real`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CONTINUOUS_ON_COMPOSE_QUOTIENT THEN MAP_EVERY EXISTS_TAC
   [``f:real->real``, ``s:real->bool``, ``u:real->bool``] THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
   CONTINUOUS_ON_EQ)) THEN ASM_SIMP_TAC std_ss [o_THM]);

val QUOTIENT_MAP_COMPOSE = store_thm ("QUOTIENT_MAP_COMPOSE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\
  (!v. v SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN v} <=>
      open_in (subtopology euclidean t) v)) /\
      (!v. v SUBSET u
      ==> (open_in (subtopology euclidean t) {x | x IN t /\ g x IN v} <=>
           open_in (subtopology euclidean u) v))
          ==> !v. v SUBSET u
            ==> (open_in (subtopology euclidean s)
                {x | x IN s /\ (g o f) x IN v} <=>
                 open_in (subtopology euclidean u) v)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [o_THM] THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (g:real->real) ((f:real->real) x) IN v} =
     {x | x IN s /\ f x IN {x | x IN t /\ g x IN v}}``
   SUBST1_TAC THENL [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [SUBSET_RESTRICT]]);

val QUOTIENT_MAP_FROM_COMPOSITION = store_thm ("QUOTIENT_MAP_FROM_COMPOSITION",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
    (!v. v SUBSET u
    ==> (open_in (subtopology euclidean s)
         {x | x IN s /\ (g o f) x IN v} <=>
         open_in (subtopology euclidean u) v))
         ==> !v. v SUBSET u
           ==> (open_in (subtopology euclidean t)
                {x | x IN t /\ g x IN v} <=>
                open_in (subtopology euclidean u) v)``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THENL
  [FIRST_X_ASSUM(MP_TAC o SPEC ``v:real->bool``) THEN
   ASM_SIMP_TAC std_ss [o_THM] THEN DISCH_THEN(SUBST1_TAC o SYM) THEN
   SUBGOAL_THEN
    ``{x | x IN s /\ (g:real->real) ((f:real->real) x) IN v} =
      {x | x IN s /\ f x IN {x | x IN t /\ g x IN v}}``
     SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
   MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
   EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[],
   MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
   EXISTS_TAC ``u:real->bool`` THEN ASM_REWRITE_TAC[]]);

val QUOTIENT_MAP_FROM_SUBSET = store_thm ("QUOTIENT_MAP_FROM_SUBSET",
 ``!f:real->real s t u.
    f continuous_on t /\ IMAGE f t SUBSET u /\
    s SUBSET t /\ (IMAGE f s = u) /\
    (!v. v SUBSET u
    ==> (open_in (subtopology euclidean s)
         {x | x IN s /\ f x IN v} <=>
         open_in (subtopology euclidean u) v))
         ==> !v. v SUBSET u
           ==> (open_in (subtopology euclidean t)
               {x | x IN t /\ f x IN v} <=>
                open_in (subtopology euclidean u) v)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC QUOTIENT_MAP_FROM_COMPOSITION THEN
  MAP_EVERY EXISTS_TAC [``\x:real. x``, ``s:real->bool``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, IMAGE_ID, o_THM]);

val QUOTIENT_MAP_RESTRICT = store_thm ("QUOTIENT_MAP_RESTRICT",
 ``!f:real->real s t c.
    IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (open_in (subtopology euclidean t) c \/
      closed_in (subtopology euclidean t) c)
      ==> !u. u SUBSET c
        ==> (open_in (subtopology euclidean {x | x IN s /\ f x IN c})
             {x | x IN {x | x IN s /\ f x IN c} /\ f x IN u} <=>
             open_in (subtopology euclidean c) u)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(fn th => MP_TAC th THEN MP_TAC (MATCH_MP
   (REWRITE_RULE[IMP_CONJ_ALT] QUOTIENT_MAP_IMP_CONTINUOUS_OPEN) th)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) {x | x IN s /\ f x IN c} SUBSET c``
   ASSUME_TAC THENL [SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THENL
  [FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET),
   ASM_SIMP_TAC std_ss [QUOTIENT_MAP_OPEN_CLOSED] THEN
   FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET)] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `u:real->bool`) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  (KNOW_TAC ``(u:real->bool) SUBSET t`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []]) THEN
  (MATCH_MP_TAC EQ_IMPLIES THEN BINOP_TAC THENL
  [MATCH_MP_TAC(MESON[] ``(t = s) /\ (P s <=> Q s) ==> (P s <=> Q t)``) THEN
   CONJ_TAC THENL [ASM_SET_TAC[], SIMP_TAC std_ss [GSPECIFICATION]], ALL_TAC]) THEN
  (EQ_TAC THENL
  [MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_SUBSET_TRANS) ORELSE
   MATCH_MP_TAC(ONCE_REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_SUBSET_TRANS),
   MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] OPEN_IN_TRANS) ORELSE
   MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CLOSED_IN_TRANS)]) THEN
  (MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN ORELSE
   MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN ORELSE ASM_SIMP_TAC std_ss []) THEN
  ASM_SET_TAC[]);

Theorem CONNECTED_MONOTONE_QUOTIENT_PREIMAGE :
   !f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (!y. y IN t ==> connected {x | x IN s /\ (f x = y)}) /\
        connected t ==> connected s
Proof
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [connected, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN UNDISCH_TAC ``connected(t:real->bool)`` THEN
  SIMP_TAC std_ss' [CONNECTED_OPEN_IN] THEN
  MAP_EVERY EXISTS_TAC
  [``IMAGE (f:real->real) (s INTER u)``,
   ``IMAGE (f:real->real) (s INTER v)``] THEN
  ASM_REWRITE_TAC[IMAGE_EQ_EMPTY] THEN
  SUBGOAL_THEN
   ``IMAGE (f:real->real) (s INTER u) INTER IMAGE f (s INTER v) = {}``
   ASSUME_TAC THENL
  [REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
   X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
   KNOW_TAC ``y IN t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN REWRITE_TAC[connected]] THEN
  MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
  ASM_SET_TAC[], ALL_TAC] THEN
  ONCE_REWRITE_TAC[CONJ_ASSOC] THEN
  CONJ_TAC THENL [CONJ_TAC, ASM_SET_TAC[]] THEN
  FIRST_X_ASSUM(fn th =>
   W(MP_TAC o PART_MATCH (rand o rand) th o snd)) THENL
  [KNOW_TAC ``IMAGE (f:real->real) (s INTER u) SUBSET t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN(SUBST1_TAC o SYM)],
   KNOW_TAC ``IMAGE (f:real->real) (s INTER v) SUBSET t:real->bool`` THENL
   [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN(SUBST1_TAC o SYM)]] THEN
  MATCH_MP_TAC(MESON[]
   ``({x | x IN s /\ f x IN IMAGE f u} = u) /\ open_in top u
       ==> open_in top {x | x IN s /\ f x IN IMAGE f u}``) THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER] THEN ASM_SET_TAC[]
QED

val CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN = store_thm ("CONNECTED_MONOTONE_QUOTIENT_PREIMAGE_GEN",
 ``!f:real->real s t c.
   (IMAGE f s = t) /\ (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u)) /\
       (!y. y IN t ==> connected {x | x IN s /\ (f x = y)}) /\
       (open_in (subtopology euclidean t) c \/
      closed_in (subtopology euclidean t) c) /\
      connected c ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MATCH_MP_TAC(ONCE_REWRITE_RULE[CONJ_EQ_IMP]
   (REWRITE_RULE[CONJ_ASSOC] CONNECTED_MONOTONE_QUOTIENT_PREIMAGE)) THEN
  SUBGOAL_THEN ``(c:real->bool) SUBSET t`` ASSUME_TAC THENL
  [ASM_MESON_TAC[OPEN_IN_IMP_SUBSET, CLOSED_IN_IMP_SUBSET], ALL_TAC] THEN
  EXISTS_TAC ``f:real->real`` THEN REPEAT CONJ_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
    QUOTIENT_MAP_IMP_CONTINUOUS_OPEN)) THEN
   ASM_REWRITE_TAC[SUBSET_REFL] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] CONTINUOUS_ON_SUBSET) THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT],
  ASM_SET_TAC[],
  MATCH_MP_TAC QUOTIENT_MAP_RESTRICT THEN
  METIS_TAC[SUBSET_REFL],
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN
  KNOW_TAC ``y IN t:real->bool`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN MATCH_MP_TAC EQ_IMPLIES] THEN
  AP_TERM_TAC THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* More properties of open and closed maps.                                  *)
(* ------------------------------------------------------------------------- *)

val CLOSED_MAP_CLOSURES = store_thm ("CLOSED_MAP_CLOSURES",
 ``!f:real->real.
  (!s. closed s ==> closed(IMAGE f s)) <=>
  (!s. closure(IMAGE f s) SUBSET IMAGE f (closure s))``,
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL THEN
   ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, CLOSURE_SUBSET, IMAGE_SUBSET],
   REWRITE_TAC[GSYM CLOSURE_SUBSET_EQ] THEN ASM_MESON_TAC[CLOSURE_CLOSED]]);

val OPEN_MAP_INTERIORS = store_thm ("OPEN_MAP_INTERIORS",
 ``!f:real->real.
  (!s. open s ==> open(IMAGE f s)) <=>
  (!s. IMAGE f (interior s) SUBSET interior(IMAGE f s))``,
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [MATCH_MP_TAC INTERIOR_MAXIMAL THEN
  ASM_SIMP_TAC std_ss [OPEN_INTERIOR, INTERIOR_SUBSET, IMAGE_SUBSET],
  REWRITE_TAC[GSYM SUBSET_INTERIOR_EQ] THEN ASM_MESON_TAC[INTERIOR_OPEN]]);

val OPEN_MAP_RESTRICT = store_thm ("OPEN_MAP_RESTRICT",
 ``!f:real->real s t t'.
  (!u. open_in (subtopology euclidean s) u
  ==> open_in (subtopology euclidean t) (IMAGE f u)) /\
      t' SUBSET t
     ==> !u. open_in (subtopology euclidean {x | x IN s /\ f x IN t'}) u
         ==> open_in (subtopology euclidean t') (IMAGE f u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN
  REPEAT DISCH_TAC THEN X_GEN_TAC ``c:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val CLOSED_MAP_RESTRICT = store_thm ("CLOSED_MAP_RESTRICT",
 ``!f:real->real s t t'.
  (!u. closed_in (subtopology euclidean s) u
  ==> closed_in (subtopology euclidean t) (IMAGE f u)) /\
      t' SUBSET t
     ==> !u. closed_in (subtopology euclidean {x | x IN s /\ f x IN t'}) u
     ==> closed_in (subtopology euclidean t') (IMAGE f u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, CONJ_EQ_IMP] THEN
  REPEAT DISCH_TAC THEN X_GEN_TAC ``c:real->bool`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_OPEN_MAP_EQ = store_thm ("QUOTIENT_MAP_OPEN_MAP_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t /\
  (!u. u SUBSET t
  ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
       open_in (subtopology euclidean t) u))
      ==> ((!k. open_in (subtopology euclidean s) k
            ==> open_in (subtopology euclidean t) (IMAGE f k)) <=>
               (!k. open_in (subtopology euclidean s) k
                ==> open_in (subtopology euclidean s)
                    {x | x IN s /\ f x IN IMAGE f k}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  UNDISCH_TAC ``!u. u SUBSET t ==>
        (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
         open_in (subtopology euclidean t) u)`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (f:real->real) k``) THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val QUOTIENT_MAP_CLOSED_MAP_EQ = store_thm ("QUOTIENT_MAP_CLOSED_MAP_EQ",
 ``!f:real->real s t.
   IMAGE f s SUBSET t /\
   (!u. u SUBSET t
   ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
        open_in (subtopology euclidean t) u))
       ==> ((!k. closed_in (subtopology euclidean s) k
         ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
            (!k. closed_in (subtopology euclidean s) k
           ==> closed_in (subtopology euclidean s)
               {x | x IN s /\ f x IN IMAGE f k}))``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ASM_SIMP_TAC std_ss [QUOTIENT_MAP_OPEN_CLOSED] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN
  X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  UNDISCH_TAC ``!u. u SUBSET t ==>
        (closed_in (subtopology euclidean s)
           {x | x IN s /\ f x IN u} <=>
         closed_in (subtopology euclidean t) u)`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (f:real->real) k``) THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val CLOSED_MAP_IMP_OPEN_MAP = store_thm ("CLOSED_MAP_IMP_OPEN_MAP",
 ``!f:real->real s t.
  (IMAGE f s = t) /\
  (!u. closed_in (subtopology euclidean s) u
  ==> closed_in (subtopology euclidean t) (IMAGE f u)) /\
      (!u. open_in (subtopology euclidean s) u
      ==> open_in (subtopology euclidean s)
          {x | x IN s /\ f x IN IMAGE f u})
          ==> (!u. open_in (subtopology euclidean s) u
            ==> open_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``IMAGE (f:real->real) u =
   t DIFF IMAGE f (s DIFF {x | x IN s /\ f x IN IMAGE f u})``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_REFL]]);

val OPEN_MAP_IMP_CLOSED_MAP = store_thm ("OPEN_MAP_IMP_CLOSED_MAP",
 ``!f:real->real s t.
   (IMAGE f s = t) /\
   (!u. open_in (subtopology euclidean s) u
   ==> open_in (subtopology euclidean t) (IMAGE f u)) /\
      (!u. closed_in (subtopology euclidean s) u
      ==> closed_in (subtopology euclidean s)
          {x | x IN s /\ f x IN IMAGE f u})
          ==> (!u. closed_in (subtopology euclidean s) u
            ==> closed_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
  ``IMAGE (f:real->real) u =
    t DIFF IMAGE f (s DIFF {x | x IN s /\ f x IN IMAGE f u})``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN ASM_SET_TAC[],
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_REFL]]);

val OPEN_MAP_FROM_COMPOSITION_SURJECTIVE = store_thm ("OPEN_MAP_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
   f continuous_on s /\ (IMAGE f s = t) /\ IMAGE g t SUBSET u /\
  (!k. open_in (subtopology euclidean s) k
  ==> open_in (subtopology euclidean u) (IMAGE (g o f) k))
    ==> (!k. open_in (subtopology euclidean t) k
      ==> open_in (subtopology euclidean u) (IMAGE g k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE g k = IMAGE ((g:real->real) o (f:real->real))
     {x | x IN s /\ f(x) IN k}`` SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
   REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[SUBSET_REFL]]);

val CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE = store_thm ("CLOSED_MAP_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ (IMAGE f s = t) /\ IMAGE g t SUBSET u /\
  (!k. closed_in (subtopology euclidean s) k
   ==> closed_in (subtopology euclidean u) (IMAGE (g o f) k))
     ==> (!k. closed_in (subtopology euclidean t) k
       ==> closed_in (subtopology euclidean u) (IMAGE g k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE g k = IMAGE ((g:real->real) o (f:real->real))
    {x | x IN s /\ f(x) IN k}`` SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[SUBSET_REFL]]);

val OPEN_MAP_FROM_COMPOSITION_INJECTIVE = store_thm ("OPEN_MAP_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
  g continuous_on t /\ (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
  (!k. open_in (subtopology euclidean s) k
   ==> open_in (subtopology euclidean u) (IMAGE (g o f) k))
     ==> (!k. open_in (subtopology euclidean s) k
       ==> open_in (subtopology euclidean t) (IMAGE f k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
  ``IMAGE f k = {x | x IN t /\
     g(x) IN IMAGE ((g:real->real) o (f:real->real)) k}``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``u:real->bool`` THEN ASM_SIMP_TAC std_ss []]);

val CLOSED_MAP_FROM_COMPOSITION_INJECTIVE = store_thm ("CLOSED_MAP_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
  IMAGE f s SUBSET t /\ IMAGE g t SUBSET u /\
  g continuous_on t /\ (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
  (!k. closed_in (subtopology euclidean s) k
  ==> closed_in (subtopology euclidean u) (IMAGE (g o f) k))
    ==> (!k. closed_in (subtopology euclidean s) k
      ==> closed_in (subtopology euclidean t) (IMAGE f k))``,
  REPEAT STRIP_TAC THEN SUBGOAL_THEN
   ``IMAGE f k = {x | x IN t /\
     g(x) IN IMAGE ((g:real->real) o (f:real->real)) k}``
   SUBST1_TAC THENL
  [FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  REWRITE_TAC[IMAGE_COMPOSE] THEN ASM_SET_TAC[],
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``u:real->bool`` THEN ASM_SIMP_TAC std_ss []]);

val OPEN_MAP_CLOSED_SUPERSET_PREIMAGE = store_thm ("OPEN_MAP_CLOSED_SUPERSET_PREIMAGE",
 ``!f:real->real s t u w.
  (!k. open_in (subtopology euclidean s) k
   ==> open_in (subtopology euclidean t) (IMAGE f k)) /\
     closed_in (subtopology euclidean s) u /\
     w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
     ==> ?v. closed_in (subtopology euclidean t) v /\
          w SUBSET v /\
         {x | x IN s /\ f(x) IN v} SUBSET u``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``t DIFF IMAGE (f:real->real) (s DIFF u)`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CLOSED_IN_DIFF THEN REWRITE_TAC[CLOSED_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL]);

val OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ = store_thm ("OPEN_MAP_CLOSED_SUPERSET_PREIMAGE_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
    ==> ((!k. open_in (subtopology euclidean s) k
      ==> open_in (subtopology euclidean t) (IMAGE f k)) <=>
        (!u w. closed_in (subtopology euclidean s) u /\
        w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
        ==> ?v. closed_in (subtopology euclidean t) v /\
            w SUBSET v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN
  ASM_SIMP_TAC std_ss [OPEN_MAP_CLOSED_SUPERSET_PREIMAGE] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
  [``s DIFF k:real->bool``, ``t DIFF IMAGE (f:real->real) k``]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
  KNOW_TAC ``t DIFF IMAGE (f:real->real) k SUBSET t /\
     {x | x IN s /\ f x IN t DIFF IMAGE (f:real->real) k} SUBSET s DIFF k`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) k = t DIFF v`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL]]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE",
 ``!f:real->real s t u w.
  (!k. closed_in (subtopology euclidean s) k
   ==> closed_in (subtopology euclidean t) (IMAGE f k)) /\
         open_in (subtopology euclidean s) u /\
        w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
       ==> ?v. open_in (subtopology euclidean t) v /\
          w SUBSET v /\
         {x | x IN s /\ f(x) IN v} SUBSET u``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``t DIFF IMAGE (f:real->real) (s DIFF u)`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN REWRITE_TAC[OPEN_IN_REFL] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. closed_in (subtopology euclidean s) k
    ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
       (!u w. open_in (subtopology euclidean s) u /\
       w SUBSET t /\ {x | x IN s /\ f(x) IN w} SUBSET u
       ==> ?v. open_in (subtopology euclidean t) v /\
           w SUBSET v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THEN
  ASM_SIMP_TAC std_ss [CLOSED_MAP_OPEN_SUPERSET_PREIMAGE] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
  [``s DIFF k:real->bool``, ``t DIFF IMAGE (f:real->real) k``]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
  KNOW_TAC ``t DIFF IMAGE (f:real->real) k SUBSET t /\
     {x | x IN s /\ f x IN t DIFF IMAGE (f:real->real) k} SUBSET s DIFF k`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) k = t DIFF v`` SUBST1_TAC THENL
  [ASM_SET_TAC[], ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL]]);

val CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT = store_thm ("CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_POINT",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. closed_in (subtopology euclidean s) k
    ==> closed_in (subtopology euclidean t) (IMAGE f k)) <=>
   (!u y. open_in (subtopology euclidean s) u /\
     y IN t /\ {x | x IN s /\ (f(x) = y)} SUBSET u
  ==> ?v. open_in (subtopology euclidean t) v /\
     y IN v /\ {x | x IN s /\ f(x) IN v} SUBSET u))``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [CLOSED_MAP_OPEN_SUPERSET_PREIMAGE_EQ] THEN
  EQ_TAC THEN DISCH_TAC THENL
  [MAP_EVERY X_GEN_TAC [``u:real->bool``, ``y:real``] THEN
  STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``u:real->bool``, ``{y:real}``]) THEN
  ASM_REWRITE_TAC[SING_SUBSET, IN_SING],
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``w:real->bool``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN
  KNOW_TAC ``(!y. ?v. open_in (subtopology euclidean s) u /\
          y IN t /\ {x | x IN s /\ (f x = y)} SUBSET u
          ==> open_in (subtopology euclidean t) v /\
              y IN v /\ {x | x IN s /\ f x IN v} SUBSET u)
     ==> (?v. open_in (subtopology euclidean t) v /\
          w SUBSET v /\ {x | x IN s /\ f x IN v} SUBSET u)`` THENL
  [ALL_TAC, METIS_TAC [GSYM RIGHT_EXISTS_IMP_THM]] THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``vv:real->real->bool`` THEN DISCH_TAC THEN
  EXISTS_TAC ``BIGUNION {(vv:real->real->bool) y | y IN w}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC OPEN_IN_BIGUNION THEN REWRITE_TAC[FORALL_IN_GSPEC] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [BIGUNION_GSPEC] THEN
   CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
   SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, GSYM RIGHT_EXISTS_AND_THM,
    LEFT_IMP_EXISTS_THM] THEN
   MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_SET_TAC[]]]);

val CONNECTED_OPEN_MONOTONE_PREIMAGE = store_thm ("CONNECTED_OPEN_MONOTONE_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
  (!c. open_in (subtopology euclidean s) c
   ==> open_in (subtopology euclidean t) (IMAGE f c)) /\
      (!y. y IN t ==> connected {x | x IN s /\ (f x = y)})
       ==> !c. connected c /\ c SUBSET t
         ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``c:real->bool`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] OPEN_MAP_RESTRICT)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN MP_TAC(ISPECL
   [``f:real->real``, ``{x | x IN s /\ (f:real->real) x IN c}``]
   OPEN_MAP_IMP_QUOTIENT_MAP) THEN
  SUBGOAL_THEN ``IMAGE f {x | x IN s /\ (f:real->real) x IN c} = c``
   ASSUME_TAC THENL [ASM_SET_TAC[], ASM_REWRITE_TAC[]] THEN
  KNOW_TAC ``(f:real->real) continuous_on {x | x IN s /\ f x IN c}`` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
   CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  MATCH_MP_TAC CONNECTED_MONOTONE_QUOTIENT_PREIMAGE THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``c:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [SET_RULE
   ``y IN c ==> ({x | x IN {x | x IN s /\ f x IN c} /\ (f x = y)} =
                 {x | x IN s /\ (f x = y)})``] THEN
  ASM_SET_TAC[]);

val CONNECTED_CLOSED_MONOTONE_PREIMAGE = store_thm ("CONNECTED_CLOSED_MONOTONE_PREIMAGE",
 ``!f:real->real s t.
    f continuous_on s /\ (IMAGE f s = t) /\
   (!c. closed_in (subtopology euclidean s) c
   ==> closed_in (subtopology euclidean t) (IMAGE f c)) /\
      (!y. y IN t ==> connected {x | x IN s /\ (f x = y)})
      ==> !c. connected c /\ c SUBSET t
        ==> connected {x | x IN s /\ f x IN c}``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``c:real->bool`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] CLOSED_MAP_RESTRICT)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN MP_TAC(ISPECL
   [``f:real->real``, ``{x | x IN s /\ (f:real->real) x IN c}``]
    CLOSED_MAP_IMP_QUOTIENT_MAP) THEN
  SUBGOAL_THEN ``IMAGE f {x | x IN s /\ (f:real->real) x IN c} = c``
   ASSUME_TAC THENL [ASM_SET_TAC[], ASM_REWRITE_TAC[]] THEN
  KNOW_TAC ``(f:real->real) continuous_on {x | x IN s /\ f x IN c}`` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
   CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  MATCH_MP_TAC CONNECTED_MONOTONE_QUOTIENT_PREIMAGE THEN
  MAP_EVERY EXISTS_TAC [``f:real->real``, ``c:real->bool``] THEN
  ASM_REWRITE_TAC[] THEN
  SIMP_TAC std_ss [SET_RULE
   ``y IN c ==> ({x | x IN {x | x IN s /\ f x IN c} /\ (f x = y)} =
                 {x | x IN s /\ (f x = y)})``] THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Proper maps, including projections out of compact sets.                   *)
(* ------------------------------------------------------------------------- *)

val PROPER_MAP = store_thm ("PROPER_MAP",
 ``!f:real->real s t.
  IMAGE f s SUBSET t
  ==> ((!k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}) <=>
       (!k. closed_in (subtopology euclidean s) k
        ==> closed_in (subtopology euclidean t) (IMAGE f k)) /\
            (!a. a IN t ==> compact {x | x IN s /\ (f x = a)}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [REPEAT STRIP_TAC THENL
   [ALL_TAC,
    ONCE_REWRITE_TAC[SET_RULE ``(x = a) <=> x IN {a}``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    ASM_REWRITE_TAC[SING_SUBSET, COMPACT_SING]] THEN
   FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
   REWRITE_TAC[CLOSED_IN_LIMPT] THEN
   CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``y:real``] THEN
   REWRITE_TAC[LIMPT_SEQUENTIAL_INJ, IN_DELETE] THEN
   SIMP_TAC std_ss [IN_IMAGE, GSYM LEFT_EXISTS_AND_THM, SKOLEM_THM] THEN
   KNOW_TAC ``(?(x :num -> real) (f' :num -> real).
   ((!(n :num).
       ((f' n = (f :real -> real) (x n)) /\
        x n IN (k :real -> bool)) /\ f' n <> (y :real)) /\
    (!(m :num) (n :num). (f' m = f' n) <=> (m = n)) /\
    ((f' --> y) sequentially :bool)) /\ y IN (t :real -> bool)) ==>
     ?(x :real). (y = f x) /\ x IN k`` THENL
   [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
   SIMP_TAC std_ss [GSYM CONJ_ASSOC, FORALL_AND_THM] THEN
   SIMP_TAC std_ss [GSYM FUN_EQ_THM] THEN
   SIMP_TAC std_ss [UNWIND_THM2, FUN_EQ_THM] THEN
   DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
   SUBGOAL_THEN
   ``~(BIGINTER {{a | a IN k /\ (f:real->real) a IN
      (y INSERT IMAGE (\i. f(x(n + i))) univ(:num))} | n IN univ(:num)} = {})``
   MP_TAC THENL
   [MATCH_MP_TAC COMPACT_FIP THEN CONJ_TAC THENL
    [SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV] THEN X_GEN_TAC ``n:num`` THEN
     UNDISCH_TAC ``closed_in (subtopology euclidean s) k`` THEN DISCH_TAC THEN
     FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CLOSED_IN_CLOSED]) THEN
     DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
     ONCE_REWRITE_TAC [METIS [] ``f a IN s <=> (\a. f a IN s) a``] THEN
     ASM_REWRITE_TAC[SET_RULE
     ``{x | x IN s INTER k /\ P x} = k INTER {x | x IN s /\ P x}``] THEN
     MATCH_MP_TAC CLOSED_INTER_COMPACT THEN ASM_REWRITE_TAC[] THEN
     BETA_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
     CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
     MATCH_MP_TAC COMPACT_SEQUENCE_WITH_LIMIT THEN
     UNDISCH_TAC ``((\n. f ((x:num->real) n)) --> y) sequentially`` THEN DISCH_TAC THEN
     FIRST_ASSUM(MP_TAC o SPEC ``n:num`` o MATCH_MP SEQ_OFFSET) THEN
     BETA_TAC THEN GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [ADD_SYM] THEN
     SIMP_TAC std_ss [],
     SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_FINITE_SUBSET_IMAGE] THEN
     X_GEN_TAC ``i:num->bool`` THEN STRIP_TAC THEN
     UNDISCH_TAC ``FINITE (i:num->bool)`` THEN DISCH_TAC THEN
     FIRST_ASSUM(MP_TAC o ISPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
     SIMP_TAC std_ss [] THEN DISCH_THEN(X_CHOOSE_TAC ``m:num``) THEN
     SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, BIGINTER_IMAGE, GSPECIFICATION] THEN
     EXISTS_TAC ``(x:num->real) m`` THEN
     X_GEN_TAC ``p:num`` THEN DISCH_TAC THEN
     CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
     REWRITE_TAC[IN_INSERT, IN_IMAGE, IN_UNIV] THEN DISJ2_TAC THEN
     EXISTS_TAC ``m - p:num`` THEN BETA_TAC THEN
     UNDISCH_TAC ``!x:num. x IN i ==> x <= m`` THEN DISCH_THEN (MP_TAC o SPEC ``p:num``) THEN
     ASM_REWRITE_TAC [] THEN ARITH_TAC],
     REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
     DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
     POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION, IN_UNIV] THEN
     DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``0:num``) THEN
     SIMP_TAC std_ss [ADD_CLAUSES, IN_INSERT, IN_IMAGE, IN_UNIV] THEN
     DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (DISJ_CASES_THEN MP_TAC)) THEN
     ASM_SIMP_TAC std_ss [] THEN DISCH_THEN(X_CHOOSE_TAC ``i:num``) THEN
     FIRST_X_ASSUM (MP_TAC o SPEC ``i + 1:num``) THEN
     ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
     ASM_SIMP_TAC std_ss [IN_INSERT, IN_IMAGE, IN_UNIV] THEN ARITH_TAC],
   STRIP_TAC THEN X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
   REWRITE_TAC[COMPACT_EQ_HEINE_BOREL] THEN
   X_GEN_TAC ``c:(real->bool)->bool`` THEN STRIP_TAC THEN
   SUBGOAL_THEN
   ``!a. a IN k
   ==> ?g. g SUBSET c /\ FINITE g /\
    {x | x IN s /\ ((f:real->real) x = a)} SUBSET BIGUNION g``
   MP_TAC THENL
   [X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN UNDISCH_THEN
    ``!a. a IN t ==> compact {x | x IN s /\ ((f:real->real) x = a)}``
    (MP_TAC o SPEC ``a:real``) THEN
    KNOW_TAC ``(a :real) IN (t :real -> bool)`` THENL
    [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN REWRITE_TAC[COMPACT_EQ_HEINE_BOREL]] THEN
     DISCH_THEN MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN ASM_SET_TAC[],
   DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
   X_GEN_TAC ``uu:real->(real->bool)->bool`` THEN DISCH_TAC] THEN
  SUBGOAL_THEN
  ``!a. a IN k ==> ?v. open v /\ a IN v /\
   {x | x IN s /\ (f:real->real) x IN v} SUBSET BIGUNION(uu a)``
   MP_TAC THENL
  [REPEAT STRIP_TAC THEN
   UNDISCH_THEN
   ``!k. closed_in (subtopology euclidean s) k
     ==> closed_in (subtopology euclidean t) (IMAGE (f:real->real) k)``
    (MP_TAC o SPEC ``(s:real->bool) DIFF BIGUNION(uu(a:real))``) THEN
   SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
   KNOW_TAC ``(s :real -> bool) DIFF
    BIGUNION ((uu :real -> (real -> bool) -> bool) (a :real)) SUBSET s /\
     open_in (subtopology euclidean s) (s DIFF (s DIFF BIGUNION (uu a)))`` THENL
   [CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[SET_RULE ``s DIFF (s DIFF t) = s INTER t``] THEN
    MATCH_MP_TAC OPEN_IN_OPEN_INTER THEN
    MATCH_MP_TAC OPEN_BIGUNION THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``v:real->bool``) THEN
    EXISTS_TAC ``v:real->bool`` THEN POP_ASSUM MP_TAC THEN
    STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``)) THEN
    ASM_REWRITE_TAC[] THEN
    KNOW_TAC ``a IN t:real->bool`` THENL [ASM_SET_TAC[],
     DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    STRIP_TAC THEN ASM_SET_TAC[]],
   DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
   SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
   X_GEN_TAC ``vv:real->(real->bool)`` THEN DISCH_TAC] THEN
  UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (vv:real->(real->bool)) k``) THEN
  KNOW_TAC ``(!(t :real -> bool).
    t IN IMAGE (vv :real -> real -> bool) (k :real -> bool) ==>
    (open t :bool)) /\ k SUBSET BIGUNION (IMAGE vv k)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r ==> s <=> q /\ p ==> r ==> s`] THEN
  SIMP_TAC real_ss [FORALL_FINITE_SUBSET_IMAGE] THEN
  X_GEN_TAC ``j:real->bool`` THEN REPEAT STRIP_TAC THEN
  EXISTS_TAC ``BIGUNION (IMAGE (uu:real->(real->bool)->bool) j)`` THEN
  REPEAT CONJ_TAC THENL
  [ASM_SET_TAC[],
   ASM_SIMP_TAC std_ss [FINITE_BIGUNION_EQ, FORALL_IN_IMAGE, IMAGE_FINITE] THEN
   ASM_SET_TAC[],
   SIMP_TAC std_ss [BIGUNION_IMAGE, SUBSET_DEF, IN_BIGUNION, GSPECIFICATION] THEN
   ASM_SET_TAC[]]]);

val COMPACT_CONTINUOUS_IMAGE_EQ = store_thm ("COMPACT_CONTINUOUS_IMAGE_EQ",
 ``!f:real->real s.
   (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
   ==> (f continuous_on s <=>
   !t. compact t /\ t SUBSET s ==> compact(IMAGE f t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [MESON_TAC[COMPACT_CONTINUOUS_IMAGE, CONTINUOUS_ON_SUBSET], DISCH_TAC] THEN
   FIRST_X_ASSUM(X_CHOOSE_TAC ``g:real->real`` o
   SIMP_RULE std_ss [INJECTIVE_ON_LEFT_INVERSE]) THEN
   REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN
   X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
   MP_TAC(ISPECL [``g:real->real``, ``IMAGE (f:real->real) s``,
    ``s:real->bool``] PROPER_MAP) THEN
  KNOW_TAC ``IMAGE (g :real -> real)
   (IMAGE (f :real -> real) (s :real -> bool)) SUBSET s`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC] THEN
  MATCH_MP_TAC(TAUT `(q ==> s) /\ p ==> (p <=> q /\ r) ==> s`) THEN
  REPEAT STRIP_TAC THENL
  [SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN u} = IMAGE g u``
   (fn th => ASM_MESON_TAC[th]),
   SUBGOAL_THEN
   ``{x | x IN IMAGE f s /\ (g:real->real) x IN k} = IMAGE f k``
   (fn th => ASM_SIMP_TAC std_ss [th])] THEN
  UNDISCH_TAC `` closed_in
        (subtopology euclidean
           (IMAGE (f :real -> real) (s :real -> bool)))
        (u :real -> bool)`` THEN DISCH_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN ASM_SET_TAC[]);

val PROPER_MAP_FROM_COMPACT = store_thm ("PROPER_MAP_FROM_COMPACT",
 ``!f:real->real s k.
   f continuous_on s /\ IMAGE f s SUBSET t /\ compact s /\
   closed_in (subtopology euclidean t) k
   ==> compact {x | x IN s /\ f x IN k}``,
   REPEAT STRIP_TAC THEN
   MATCH_MP_TAC CLOSED_IN_COMPACT THEN EXISTS_TAC ``s:real->bool`` THEN
   METIS_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_GEN]);

val PROPER_MAP_COMPOSE = store_thm ("PROPER_MAP_COMPOSE",
 ``!f:real->real g:real->real s t u.
   IMAGE f s SUBSET t /\
   (!k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}) /\
   (!k. k SUBSET u /\ compact k ==> compact {x | x IN t /\ g x IN k})
   ==> !k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k}``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[o_THM] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``{x | x IN t /\ (g:real->real) x IN k}``) THEN
  KNOW_TAC ``{x | x IN (t :real -> bool) /\
   (g :real -> real) x IN (k :real -> bool)} SUBSET t /\
    compact {x | x IN t /\ g x IN k}`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
   POP_ASSUM K_TAC THEN MATCH_MP_TAC EQ_IMPLIES] THEN
  AP_TERM_TAC THEN ASM_SET_TAC[]);

val PROPER_MAP_FROM_COMPOSITION_LEFT = store_thm ("PROPER_MAP_FROM_COMPOSITION_LEFT",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ (IMAGE f s = t) /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
    (!k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k})
   ==> !k. k SUBSET u /\ compact k ==> compact {x | x IN t /\ g x IN k}``,
  REWRITE_TAC[o_THM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o ISPEC ``f:real->real`` o MATCH_MP
  (REWRITE_RULE[IMP_CONJ_ALT] COMPACT_CONTINUOUS_IMAGE)) THEN
  KNOW_TAC ``(f :real -> real) continuous_on
   {x | x IN (s :real -> bool) /\
   (g :real -> real) (f x) IN (k :real -> bool)} `` THENL
  [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
  CONTINUOUS_ON_SUBSET)) THEN SET_TAC[],
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val lemma = prove (
 ``!s t. closed_in (subtopology euclidean s) t ==> compact s ==> compact t``,
  MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_SUBSET, CLOSED_IN_CLOSED_EQ]);

val PROPER_MAP_FROM_COMPOSITION_RIGHT = store_thm ("PROPER_MAP_FROM_COMPOSITION_RIGHT",
 ``!f:real->real g:real->real s t u.
    f continuous_on s /\ IMAGE f s SUBSET t /\
    g continuous_on t /\ IMAGE g t SUBSET u /\
   (!k. k SUBSET u /\ compact k
   ==> compact {x | x IN s /\ (g o f) x IN k})
   ==> !k. k SUBSET t /\ compact k ==> compact {x | x IN s /\ f x IN k}``,
  REWRITE_TAC[o_THM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``IMAGE (g:real->real) k``) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (k :real -> bool) SUBSET (u :real -> bool) /\
   compact (IMAGE g k)`` THENL
  [CONJ_TAC THENL [ASM_SET_TAC[], MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE] THEN
   ASM_MESON_TAC[CONTINUOUS_ON_SUBSET],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   MATCH_MP_TAC lemma THEN
   MATCH_MP_TAC CLOSED_IN_SUBSET_TRANS THEN
   EXISTS_TAC ``s:real->bool`` THEN
   CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE_GEN THEN
  EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CLOSED_SUBSET THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED]]);

(* ------------------------------------------------------------------------- *)
(* Pasting functions together on open sets.                                  *)
(* ------------------------------------------------------------------------- *)

val PASTING_LEMMA = store_thm ("PASTING_LEMMA",
 ``!f:'a->real->real g t s k.
        (!i. i IN k
             ==> open_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x)) /\
        (!x. x IN s ==> ?j. j IN k /\ x IN t j /\ (g x = f j x))
        ==> g continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_OPEN_IN_PREIMAGE_EQ] THEN
  STRIP_TAC THEN X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ g x IN u} =
     BIGUNION {{x | x IN (t i) /\ ((f:'a->real->real) i x) IN u} |
            i IN k}``
  SUBST1_TAC THENL
   [SUBGOAL_THEN ``!i. i IN k ==> ((t:'a->real->bool) i) SUBSET s``
    ASSUME_TAC THENL
     [ASM_MESON_TAC[OPEN_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
      SIMP_TAC std_ss [BIGUNION_GSPEC] THEN ASM_SET_TAC[]],
    MATCH_MP_TAC OPEN_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
    METIS_TAC[OPEN_IN_TRANS]]);

val PASTING_LEMMA_EXISTS = store_thm ("PASTING_LEMMA_EXISTS",
 ``!f:'a->real->real t s k.
        s SUBSET BIGUNION {t i | i IN k} /\
        (!i. i IN k
             ==> open_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x))
        ==> ?g. g continuous_on s /\
                (!x i. i IN k /\ x IN s INTER t i ==> (g x = f i x))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\x. (f:'a->real->real)(@i. i IN k /\ x IN t i) x`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN MATCH_MP_TAC PASTING_LEMMA THEN
  MAP_EVERY EXISTS_TAC
   [``f:'a->real->real``, ``t:'a->real->bool``, ``k:'a->bool``] THEN
  ASM_SET_TAC[]);

val CONTINUOUS_ON_UNION_LOCAL_OPEN = store_thm ("CONTINUOUS_ON_UNION_LOCAL_OPEN",
 ``!f:real->real s.
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ f continuous_on t
        ==> f continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``(\i:(real->bool). (f:real->real))``, ``f:real->real``,
    ``(\i:(real->bool). i)``, ``s UNION (t:real->bool)``, ``{s:real->bool;t}``]
   PASTING_LEMMA) THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_INSERT, EXISTS_IN_INSERT, NOT_IN_EMPTY] THEN
  REWRITE_TAC[IN_UNION]);

val CONTINUOUS_ON_UNION_OPEN = store_thm ("CONTINUOUS_ON_UNION_OPEN",
 ``!f s t. open s /\ open t /\ f continuous_on s /\ f continuous_on t
           ==> f continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL_OPEN THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION] THEN SET_TAC[]);

val CONTINUOUS_ON_CASES_LOCAL_OPEN = store_thm ("CONTINUOUS_ON_CASES_LOCAL_OPEN",
 ``!P f g:real->real s t.
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL_OPEN THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  ASM_SIMP_TAC std_ss [] THEN METIS_TAC[]);

val CONTINUOUS_ON_CASES_OPEN = store_thm ("CONTINUOUS_ON_CASES_OPEN",
 ``!P f g s t.
           open s /\
           open t /\
           f continuous_on s /\
           g continuous_on t /\
           (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
           ==> (\x. if P x then f x else g x) continuous_on s UNION t``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL_OPEN THEN
  ASM_REWRITE_TAC[] THEN CONJ_TAC THEN MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Likewise on closed sets, with a finiteness assumption.                    *)
(* ------------------------------------------------------------------------- *)

val PASTING_LEMMA_CLOSED = store_thm ("PASTING_LEMMA_CLOSED",
 ``!f:'a->real->real g t s k.
        FINITE k /\
        (!i. i IN k
             ==> closed_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x)) /\
        (!x. x IN s ==> ?j. j IN k /\ x IN t j /\ (g x = f j x))
        ==> g continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
  STRIP_TAC THEN X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ g x IN u} =
     BIGUNION {{x | x IN (t i) /\ ((f:'a->real->real) i x) IN u} |
            i IN k}``
  SUBST1_TAC THENL
   [SUBGOAL_THEN ``!i. i IN k ==> ((t:'a->real->bool) i) SUBSET s``
    ASSUME_TAC THENL
     [ASM_MESON_TAC[CLOSED_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY],
      SIMP_TAC std_ss [BIGUNION_GSPEC] THEN ASM_SET_TAC[]],
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN
    ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, IMAGE_FINITE, FORALL_IN_IMAGE] THEN
    METIS_TAC[CLOSED_IN_TRANS]]);

val PASTING_LEMMA_EXISTS_CLOSED = store_thm ("PASTING_LEMMA_EXISTS_CLOSED",
 ``!f:'a->real->real t s k.
        FINITE k /\
        s SUBSET BIGUNION {t i | i IN k} /\
        (!i. i IN k
             ==> closed_in (subtopology euclidean s) (t i) /\
                 (f i) continuous_on (t i)) /\
        (!i j x. i IN k /\ j IN k /\ x IN s INTER t i INTER t j
                 ==> (f i x = f j x))
        ==> ?g. g continuous_on s /\
                (!x i. i IN k /\ x IN s INTER t i ==> (g x = f i x))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\x. (f:'a->real->real)(@i. i IN k /\ x IN t i) x`` THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC PASTING_LEMMA_CLOSED THEN
  MAP_EVERY EXISTS_TAC
   [``f:'a->real->real``, ``t:'a->real->bool``, ``k:'a->bool``] THEN
  ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Closure of halflines, halfspaces and hyperplanes.                         *)
(* ------------------------------------------------------------------------- *)

val LIM_LIFT_DOT = store_thm ("LIM_LIFT_DOT",
 ``!f:real->real a.
        (f --> l) net ==> ((\y. a * f(y)) --> (a * l)) net``,
  METIS_TAC [LIM_CMUL]);

val CONTINUOUS_AT_LIFT_DOT = store_thm ("CONTINUOUS_AT_LIFT_DOT",
 ``!a:real x. (\y. a * y) continuous at x``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [CONTINUOUS_AT, o_THM] THEN
  KNOW_TAC ``((\y. a * (\y. y) y:real) --> (a * x)) (at x)`` THENL
  [ALL_TAC, SIMP_TAC std_ss []] THEN
  MATCH_MP_TAC LIM_LIFT_DOT THEN REWRITE_TAC[LIM_AT] THEN METIS_TAC[]);

val CONTINUOUS_ON_LIFT_DOT = store_thm ("CONTINUOUS_ON_LIFT_DOT",
 ``!s. (\y. a * y) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_AT_IMP_CONTINUOUS_ON, CONTINUOUS_AT_LIFT_DOT]);

val CLOSED_INTERVAL_LEFT = store_thm ("CLOSED_INTERVAL_LEFT",
 ``!b:real.
     closed {x:real | x <= b}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(x:real) - (b:real)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val CLOSED_INTERVAL_RIGHT = store_thm ("CLOSED_INTERVAL_RIGHT",
 ``!a:real.
     closed {x:real | a <= x}``,
  SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE, GSPECIFICATION] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) - (x:real)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val CLOSED_HALFSPACE_LE = store_thm ("CLOSED_HALFSPACE_LE",
 ``!a:real b. closed {x | a * x <= b}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPEC ``univ(:real)`` CONTINUOUS_ON_LIFT_DOT) THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_CLOSED, GSYM CLOSED_IN, SUBTOPOLOGY_UNIV] THEN
  DISCH_THEN(MP_TAC o SPEC
   ``IMAGE (\x. x) {r | ?x:real. (a * x = r) /\ r <= b}``) THEN
   KNOW_TAC ``closed_in (subtopology euclidean (IMAGE (\y. a * y) univ(:real)))
             (IMAGE (\x. x) {r | ?x. (a * x = r) /\ r <= b})`` THENL
   [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
    SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE, IN_UNIV] THEN
    METIS_TAC []] THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``{x | (x:real) <= (b)}`` THEN
  SIMP_TAC std_ss [CLOSED_INTERVAL_LEFT] THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_UNIV, GSPECIFICATION, IN_INTER] THEN
  METIS_TAC []);

val CLOSED_HALFSPACE_GE = store_thm ("CLOSED_HALFSPACE_GE",
 ``!a:real b. closed {x | a * x >= b}``,
  REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``] THEN
  REWRITE_TAC[GSYM REAL_MUL_LNEG, CLOSED_HALFSPACE_LE]);

val CLOSED_HYPERPLANE = store_thm ("CLOSED_HYPERPLANE",
 ``!a b. closed {x | a * x = b}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
  REWRITE_TAC[REAL_ARITH ``b <= a * x <=> a * x >= b:real``] THEN
  REWRITE_TAC[SET_RULE `` {x | a * x <= b /\ a * x >= b} =
                          {x | a * x <= b} INTER  {x | a * x >= b}``] THEN
  SIMP_TAC std_ss [CLOSED_INTER, CLOSED_HALFSPACE_LE, CLOSED_HALFSPACE_GE]);

val CLOSURE_HYPERPLANE = store_thm ("CLOSURE_HYPERPLANE",
 ``!a b. closure {x | a * x = b} = {x | a * x = b}``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_HYPERPLANE]);

val CLOSED_STANDARD_HYPERPLANE = store_thm ("CLOSED_STANDARD_HYPERPLANE",
 ``!a. closed {x:real | x = a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HYPERPLANE) THEN
  rw []);

val CLOSED_HALFSPACE_COMPONENT_LE = store_thm ("CLOSED_HALFSPACE_COMPONENT_LE",
 ``!a. closed {x:real | x <= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HALFSPACE_LE) THEN
  rw []);

val CLOSED_HALFSPACE_COMPONENT_GE = store_thm ("CLOSED_HALFSPACE_COMPONENT_GE",
 ``!a. closed {x:real | x >= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSED_HALFSPACE_GE) THEN
  rw []);

(* ------------------------------------------------------------------------- *)
(* Openness of halfspaces.                                                   *)
(* ------------------------------------------------------------------------- *)

val OPEN_HALFSPACE_LT = store_thm ("OPEN_HALFSPACE_LT",
 ``!a b. open {x | a * x < b}``,
  REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | ~p x} = UNIV DIFF {x | p x}``] THEN
  REWRITE_TAC[GSYM closed_def, GSYM real_ge, CLOSED_HALFSPACE_GE]);

val OPEN_HALFSPACE_COMPONENT_LT = store_thm ("OPEN_HALFSPACE_COMPONENT_LT",
 ``!a. open {x:real | x < a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] OPEN_HALFSPACE_LT) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

val OPEN_HALFSPACE_GT = store_thm ("OPEN_HALFSPACE_GT",
 ``!a b. open {x | a * x > b}``,
  REWRITE_TAC[REAL_ARITH ``x > y <=> ~(x <= y:real)``] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | ~p x} = UNIV DIFF {x | p x}``] THEN
  REWRITE_TAC[GSYM closed_def, CLOSED_HALFSPACE_LE]);

val OPEN_HALFSPACE_COMPONENT_GT = store_thm ("OPEN_HALFSPACE_COMPONENT_GT",
 ``!a. open {x:real | x > a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] OPEN_HALFSPACE_GT) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

val OPEN_POSITIVE_MULTIPLES = store_thm ("OPEN_POSITIVE_MULTIPLES",
 ``!s:real->bool. open s ==> open {c * x | &0 < c /\ x IN s}``,
  SIMP_TAC std_ss [open_def, FORALL_IN_GSPEC] THEN GEN_TAC THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``c:real``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``c * e:real`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``inv(c) * y:real``) THEN
  KNOW_TAC ``(dist (inv (c :real) * (y :real),(x :real)) :real) < (e :real)`` THENL
   [SUBGOAL_THEN ``x:real = inv c * c * x`` SUBST1_TAC THENL
     [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID,
                   REAL_LT_IMP_NE],
          ONCE_REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
      ASM_SIMP_TAC std_ss [DIST_MUL, abs, REAL_LT_INV_EQ, REAL_LT_IMP_LE] THEN
      ONCE_REWRITE_TAC[METIS [REAL_MUL_SYM, GSYM real_div] ``inv c * x:real = x / c:real``] THEN
      METIS_TAC[REAL_LT_LDIV_EQ, REAL_MUL_SYM]],
        DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN SRW_TAC [][] THEN
    EXISTS_TAC ``c:real`` THEN EXISTS_TAC ``inv(c) * y:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_LT_IMP_NE] THEN
    REAL_ARITH_TAC]);

val OPEN_INTERVAL_LEFT = store_thm ("OPEN_INTERVAL_LEFT",
 ``!b:real. open {x:real | x < b}``,
    REWRITE_TAC[OPEN_HALFSPACE_COMPONENT_LT]);

val OPEN_INTERVAL_RIGHT = store_thm ("OPEN_INTERVAL_RIGHT",
 ``!a:real. open {x:real | a < x}``,
    REWRITE_TAC[GSYM real_gt, OPEN_HALFSPACE_COMPONENT_GT]);

val OPEN_POSITIVE_ORTHANT = store_thm ("OPEN_POSITIVE_ORTHANT",
 ``open {x:real | &0 < x}``,
  MP_TAC(ISPEC ``0:real`` OPEN_INTERVAL_RIGHT) THEN
  REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Closures and interiors of halfspaces.                                     *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_HALFSPACE_LE = store_thm ("INTERIOR_HALFSPACE_LE",
 ``!a:real b.
        ~(a = 0) ==> (interior {x | a * x <= b} = {x | a * x < b})``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_UNIQUE THEN
  SIMP_TAC std_ss [OPEN_HALFSPACE_LT, SUBSET_DEF, GSPECIFICATION, REAL_LT_IMP_LE] THEN
  X_GEN_TAC ``s:real->bool`` THEN STRIP_TAC THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_LE] THEN
  DISCH_TAC THEN UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[SUBSET_DEF, IN_CBALL] THEN
  DISCH_THEN(MP_TAC o SPEC ``x + e / abs(a) * a:real``) THEN
  REWRITE_TAC[METIS [dist, REAL_ADD_SUB2, ABS_NEG] ``dist(x:real,x + y) = abs y``] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_DIV, ABS_ABS, REAL_DIV_RMUL,
               ABS_ZERO, REAL_ARITH ``&0 < x ==> abs x <= x:real``] THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x + e / abs(a) * a:real``) THEN
  ASM_REWRITE_TAC [REAL_LDISTRIB] THEN
  REWRITE_TAC [REAL_ARITH ``a * (b * a) = b * (a * a:real)``] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < e ==> ~(b + e <= b:real)``) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_MUL, REAL_LT_DIV, GSYM ABS_NZ, REAL_POSSQ]);

val INTERIOR_HALFSPACE_GE = store_thm ("INTERIOR_HALFSPACE_GE",
 ``!a:real b.
        ~(a = 0) ==> (interior {x | a * x >= b} = {x | a * x > b})``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``,
                   REAL_ARITH ``a > b <=> -a < -b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL, INTERIOR_HALFSPACE_LE, REAL_NEG_EQ0]);

val INTERIOR_HALFSPACE_COMPONENT_LE = store_thm ("INTERIOR_HALFSPACE_COMPONENT_LE",
 ``!a. interior {x:real | x <= a} = {x | x < a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HALFSPACE_LE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val INTERIOR_HALFSPACE_COMPONENT_GE = store_thm ("INTERIOR_HALFSPACE_COMPONENT_GE",
 ``!a. interior {x:real | x >= a} = {x | x > a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HALFSPACE_GE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val CLOSURE_HALFSPACE_LT = store_thm ("CLOSURE_HALFSPACE_LT",
 ``!a:real b.
        ~(a = 0) ==> (closure {x | a * x < b} = {x | a * x <= b})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CLOSURE_INTERIOR] THEN
  SIMP_TAC std_ss [SET_RULE ``UNIV DIFF {x | P x} = {x | ~P x}``] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``~(x < b) <=> x >= b:real``, INTERIOR_HALFSPACE_GE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_UNIV, GSPECIFICATION] THEN REAL_ARITH_TAC);

val CLOSURE_HALFSPACE_GT = store_thm ("CLOSURE_HALFSPACE_GT",
 ``!a:real b.
        ~(a = 0) ==> (closure {x | a * x > b} = {x | a * x >= b})``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a >= b <=> -a <= -b:real``,
                   REAL_ARITH ``a > b <=> -a < -b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL, CLOSURE_HALFSPACE_LT, REAL_NEG_EQ0]);

val CLOSURE_HALFSPACE_COMPONENT_LT = store_thm ("CLOSURE_HALFSPACE_COMPONENT_LT",
 ``!a. closure {x:real | x < a} = {x | x <= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSURE_HALFSPACE_LT) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val CLOSURE_HALFSPACE_COMPONENT_GT = store_thm ("CLOSURE_HALFSPACE_COMPONENT_GT",
 ``!a. closure {x:real | x > a} = {x | x >= a}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] CLOSURE_HALFSPACE_GT) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

val INTERIOR_HYPERPLANE = store_thm ("INTERIOR_HYPERPLANE",
 ``!a b. ~(a = 0) ==> (interior {x | a * x = b} = {})``,
  REWRITE_TAC[REAL_ARITH ``(x = y) <=> x <= y /\ x >= y:real``] THEN
  SIMP_TAC std_ss [SET_RULE ``{x | p x /\ q x} = {x | p x} INTER {x | q x}``] THEN
  REWRITE_TAC[INTERIOR_INTER] THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM, REAL_ARITH ``x <= y /\ x >= y:real <=> (x = y)``] THEN
  ASM_SIMP_TAC std_ss [INTERIOR_HALFSPACE_LE, INTERIOR_HALFSPACE_GE] THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTER, GSPECIFICATION, NOT_IN_EMPTY] THEN
  REAL_ARITH_TAC);

val FRONTIER_HALFSPACE_LE = store_thm ("FRONTIER_HALFSPACE_LE",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x <= b} = {x | a * x = b})``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = 0`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LZERO] THENL
   [ASM_CASES_TAC ``&0 <= b:real`` THEN
    ASM_SIMP_TAC std_ss [GSPEC_T, FRONTIER_UNIV, GSPEC_F, FRONTIER_EMPTY],
    ASM_SIMP_TAC std_ss [frontier, INTERIOR_HALFSPACE_LE, CLOSURE_CLOSED,
                 CLOSED_HALFSPACE_LE] THEN
    SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION] THEN REAL_ARITH_TAC]);

val FRONTIER_HALFSPACE_GE = store_thm ("FRONTIER_HALFSPACE_GE",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x >= b} = {x | a * x = b})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``-a:real``, ``-b:real``] FRONTIER_HALFSPACE_LE) THEN
  ASM_REWRITE_TAC [REAL_NEG_EQ0, REAL_NEG_LMUL] THEN
  REWRITE_TAC [GSYM REAL_NEG_LMUL] THEN REWRITE_TAC [REAL_EQ_NEG] THEN
  SIMP_TAC std_ss [REAL_LE_NEG2, real_ge]);

val FRONTIER_HALFSPACE_LT = store_thm ("FRONTIER_HALFSPACE_LT",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x < b} = {x | a * x = b})``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``a:real = 0`` THEN
  ASM_SIMP_TAC std_ss [REAL_NEG_LMUL] THENL
   [ASM_CASES_TAC ``&0 < b:real`` THEN REWRITE_TAC [REAL_MUL_LZERO] THEN
    ASM_SIMP_TAC std_ss [GSPEC_T, FRONTIER_UNIV, GSPEC_F, FRONTIER_EMPTY],
    ASM_SIMP_TAC std_ss [frontier, CLOSURE_HALFSPACE_LT, INTERIOR_OPEN,
                 OPEN_HALFSPACE_LT] THEN
    SIMP_TAC std_ss [EXTENSION, IN_DIFF, GSPECIFICATION] THEN REAL_ARITH_TAC]);

val FRONTIER_HALFSPACE_GT = store_thm ("FRONTIER_HALFSPACE_GT",
 ``!a:real b. ~((a = 0) /\ (b = &0))
                ==> (frontier {x | a * x > b} = {x | a * x = b})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``-a:real``, ``-b:real``] FRONTIER_HALFSPACE_LT) THEN
  ASM_REWRITE_TAC[REAL_NEG_EQ0, REAL_MUL_LNEG] THEN
  SIMP_TAC std_ss [REAL_LT_NEG, REAL_EQ_NEG, real_gt]);

val INTERIOR_STANDARD_HYPERPLANE = store_thm ("INTERIOR_STANDARD_HYPERPLANE",
 ``!a. interior {x:real | x = a} = {}``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``1:real``, ``a:real``] INTERIOR_HYPERPLANE) THEN
  ONCE_REWRITE_TAC [REAL_ARITH ``1 <> 0:real``] THEN SIMP_TAC std_ss [REAL_MUL_LID]);

(* ------------------------------------------------------------------------- *)
(* Unboundedness of halfspaces.                                              *)
(* ------------------------------------------------------------------------- *)

val UNBOUNDED_HALFSPACE_COMPONENT_LE = store_thm
  ("UNBOUNDED_HALFSPACE_COMPONENT_LE",
  ``!a. ~bounded {x:real | x <= a}``,
    REPEAT GEN_TAC
 >> ASM_SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC]
 >> X_GEN_TAC ``B:real``
 >> EXISTS_TAC ``-((&1:real) + max (abs B) (abs a))``
 >> REAL_ARITH_TAC);

val UNBOUNDED_HALFSPACE_COMPONENT_GE = store_thm
  ("UNBOUNDED_HALFSPACE_COMPONENT_GE",
 ``!a. ~bounded {x:real | x >= a}``,
  REPEAT GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_NEGATIONS) THEN
  MP_TAC(SPECL [``-a:real``] UNBOUNDED_HALFSPACE_COMPONENT_LE) THEN
  REWRITE_TAC[GSYM MONO_NOT_EQ] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_TERM_TAC THEN MATCH_MP_TAC SURJECTIVE_IMAGE_EQ THEN CONJ_TAC THENL
   [MESON_TAC[REAL_NEG_NEG],
    SIMP_TAC std_ss [GSPECIFICATION] THEN REAL_ARITH_TAC]);

val UNBOUNDED_HALFSPACE_COMPONENT_LT = store_thm ("UNBOUNDED_HALFSPACE_COMPONENT_LT",
 ``!a. ~bounded {x:real | x < a}``,
  ONCE_REWRITE_TAC[GSYM BOUNDED_CLOSURE_EQ] THEN
  REWRITE_TAC[CLOSURE_HALFSPACE_COMPONENT_LT,
              UNBOUNDED_HALFSPACE_COMPONENT_LE]);

val UNBOUNDED_HALFSPACE_COMPONENT_GT = store_thm ("UNBOUNDED_HALFSPACE_COMPONENT_GT",
 ``!a. ~bounded {x:real | x > a}``,
  ONCE_REWRITE_TAC[GSYM BOUNDED_CLOSURE_EQ] THEN
  REWRITE_TAC[CLOSURE_HALFSPACE_COMPONENT_GT,
              UNBOUNDED_HALFSPACE_COMPONENT_GE]);

(* ------------------------------------------------------------------------- *)
(* Equality of continuous functions on closure and related results.          *)
(* ------------------------------------------------------------------------- *)

val FORALL_IN_CLOSURE = store_thm ("FORALL_IN_CLOSURE",
 ``!f:real->real s t.
        closed t /\ f continuous_on (closure s) /\
        (!x. x IN s ==> f x IN t)
        ==> (!x. x IN closure s ==> f x IN t)``,
  REWRITE_TAC[SET_RULE ``(!x. x IN s ==> f x IN t) <=>
                        s SUBSET {x | x IN s /\ f x IN t}``] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSURE_MINIMAL THEN
  ASM_REWRITE_TAC[CLOSED_CLOSURE] THEN CONJ_TAC THENL
   [MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
    ASM_REWRITE_TAC[CLOSED_CLOSURE]]);

val FORALL_IN_CLOSURE_EQ = store_thm ("FORALL_IN_CLOSURE_EQ",
 ``!f s t.
         closed t /\ f continuous_on closure s
         ==> ((!x. x IN closure s ==> f x IN t) <=>
              (!x. x IN s ==> f x IN t))``,
  METIS_TAC[FORALL_IN_CLOSURE, CLOSURE_SUBSET, SUBSET_DEF]);

val CONTINUOUS_LE_ON_CLOSURE = store_thm ("CONTINUOUS_LE_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> f(x) <= a)
        ==> !x. x IN closure(s) ==> f(x) <= a``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  KNOW_TAC `` !(x :real). x IN closure (s :real -> bool)
           ==> (f :real -> real) x IN {y | y <= (a :real)}`` THENL
  [ALL_TAC, SET_TAC []] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_SIMP_TAC std_ss [ETA_AX, CLOSED_HALFSPACE_COMPONENT_LE] THEN ASM_SET_TAC []);

val CONTINUOUS_GE_ON_CLOSURE = store_thm ("CONTINUOUS_GE_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> a <= f(x))
        ==> !x. x IN closure(s) ==> a <= f(x)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  KNOW_TAC `` !(x :real). x IN closure (s :real -> bool)
           ==> (f :real -> real) x IN {y | y >= (a :real)}`` THENL
  [ALL_TAC, SET_TAC [real_ge]] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_SIMP_TAC std_ss [ETA_AX, CLOSED_HALFSPACE_COMPONENT_GE] THEN ASM_SET_TAC [real_ge]);

val CONTINUOUS_CONSTANT_ON_CLOSURE = store_thm ("CONTINUOUS_CONSTANT_ON_CLOSURE",
 ``!f:real->real s a.
        f continuous_on closure(s) /\ (!x. x IN s ==> (f(x) = a))
        ==> !x. x IN closure(s) ==> (f(x) = a)``,
  REWRITE_TAC[SET_RULE
   ``x IN s ==> (f x = a) <=> x IN s ==> f x IN {a}``] THEN
  REPEAT GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC FORALL_IN_CLOSURE THEN
  ASM_REWRITE_TAC[CLOSED_SING]);

val CONTINUOUS_AGREE_ON_CLOSURE = store_thm ("CONTINUOUS_AGREE_ON_CLOSURE",
 ``!g h:real->real.
        g continuous_on closure s /\ h continuous_on closure s /\
        (!x. x IN s ==> (g x = h x))
        ==> !x. x IN closure s ==> (g x = h x)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(g x - h x = 0) =  ((\x. g x - h x) x = 0:real)``] THEN
  MATCH_MP_TAC CONTINUOUS_CONSTANT_ON_CLOSURE THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_SUB]);

val CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT = store_thm ("CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT",
 ``!f:real->real s a.
        f continuous_on s
        ==> closed_in (subtopology euclidean s) {x | x IN s /\ (f x = a)}``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[SET_RULE
   ``{x | x IN s /\ (f(x) = a)} = {x | x IN s /\ f(x) IN {a}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
  ASM_REWRITE_TAC[CLOSED_SING]);

val CONTINUOUS_CLOSED_PREIMAGE_CONSTANT = store_thm ("CONTINUOUS_CLOSED_PREIMAGE_CONSTANT",
 ``!f:real->real s.
      f continuous_on s /\ closed s ==> closed {x | x IN s /\ (f(x) = a)}``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``{x | x IN s /\ ((f:real->real)(x) = a)} = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN ONCE_REWRITE_TAC[SET_RULE
   ``{x | x IN s /\ (f(x) = a)} = {x | x IN s /\ f(x) IN {a}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
  ASM_REWRITE_TAC[CLOSED_SING] THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Theorems relating continuity and uniform continuity to closures.          *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_CLOSURE = store_thm ("CONTINUOUS_ON_CLOSURE",
 ``!f:real->real s.
        f continuous_on closure s <=>
        !x e. x IN closure s /\ &0 < e
              ==> ?d. &0 < d /\
                      !y. y IN s /\ dist(y,x) < d ==> dist(f y,f x) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on] THEN
  EQ_TAC THENL [METIS_TAC[REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET], ALL_TAC] THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPECL [``x:real``, ``e / &2:real``]) THEN
  KNOW_TAC ``x IN closure s:real->bool /\ 0 < e / 2:real`` THENL
  [ASM_REWRITE_TAC[REAL_HALF], DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [])] THEN
  DISCH_TAC THEN FIRST_ASSUM (fn th => REWRITE_TAC [th]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``d / &2:real`` THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``y:real``, ``e / &2:real``]) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``y:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min k (d / &2:real)``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_LT_MIN] THEN
  KNOW_TAC ``!a b c e. abs(a - b) < e / &2 /\ abs(b - c) < e / &2:real ==>
                                    abs(a - c) < e / 2 + e / 2:real`` THENL
  [REAL_ARITH_TAC, DISCH_TAC] THEN STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN REWRITE_TAC [dist] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``(f:real->real) y'`` THEN CONJ_TAC THENL
  [REWRITE_TAC [GSYM dist] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
   FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [],
   REWRITE_TAC [GSYM dist] THEN FIRST_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC [] THEN
   MATCH_MP_TAC DIST_TRIANGLE_LT THEN EXISTS_TAC ``y:real`` THEN
   GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN MATCH_MP_TAC REAL_LT_ADD2 THEN
   METIS_TAC [DIST_SYM]]);

val CONTINUOUS_ON_CLOSURE_SEQUENTIALLY = store_thm ("CONTINUOUS_ON_CLOSURE_SEQUENTIALLY",
 ``!f:real->real s.
        f continuous_on closure s <=>
        !x a. a IN closure s /\ (!n. x n IN s) /\ (x --> a) sequentially
              ==> ((f o x) --> f a) sequentially``,
  REWRITE_TAC[CONTINUOUS_ON_CLOSURE] THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM continuous_within] THEN
  REWRITE_TAC[CONTINUOUS_WITHIN_SEQUENTIALLY] THEN MESON_TAC[]);

val UNIFORMLY_CONTINUOUS_ON_CLOSURE = store_thm ("UNIFORMLY_CONTINUOUS_ON_CLOSURE",
 ``!f:real->real s.
        f uniformly_continuous_on s /\ f continuous_on closure s
        ==> f uniformly_continuous_on closure s``,
  REPEAT GEN_TAC THEN
  REWRITE_TAC[uniformly_continuous_on] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &3:real``) THEN
  KNOW_TAC ``0 < e / 3:real`` THENL
  [FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   ASM_REAL_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``d / &3:real`` THEN CONJ_TAC THENL
  [FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  UNDISCH_TAC ``f continuous_on closure s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [continuous_on]) THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``y:real`` th) THEN MP_TAC(SPEC ``x:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MP_TAC(ISPECL [``x:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d1 (d / &3:real)``) THEN
  KNOW_TAC ``0 < min d1 (d / 3:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x':real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``x':real``) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN DISCH_TAC THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  MP_TAC(ISPECL [``y:real``, ``s:real->bool``] CLOSURE_APPROACHABLE) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``min d2 (d / &3:real)``) THEN
  KNOW_TAC ``0 < min d2 (d / 3:real)`` THENL
  [REWRITE_TAC [min_def] THEN COND_CASES_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
   REWRITE_TAC [REAL_MUL_LZERO] THEN ASM_REWRITE_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y':real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``y':real``) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``x':real``, ``y':real``]) THEN
  FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
  METIS_TAC[dist, ABS_SUB, REAL_ARITH
   ``abs(y - x) * 3 < d /\ abs(x' - x) * 3 < d /\ abs(y' - y) * 3 < d
    ==> abs(y' - x') < d:real``]);

(* ------------------------------------------------------------------------- *)
(* Cauchy continuity, and the extension of functions to closures.            *)
(* ------------------------------------------------------------------------- *)

val UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS = store_thm
  ("UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS",
 ``!f:real->real s.
        f uniformly_continuous_on s
        ==> (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on, cauchy, o_DEF] THEN
  MESON_TAC[]);

val CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS = store_thm
  ("CONTINUOUS_CLOSED_IMP_CAUCHY_CONTINUOUS",
 ``!f:real->real s.
        f continuous_on s /\ closed s
        ==> (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))``,
  REWRITE_TAC[GSYM COMPLETE_EQ_CLOSED, CONTINUOUS_ON_SEQUENTIALLY] THEN
  REWRITE_TAC[complete] THEN MESON_TAC[CONVERGENT_IMP_CAUCHY]);

val CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA = store_thm
  ("CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> !a x. (!n. (x n) IN s) /\ (x --> a) sequentially
                  ==> ?l. ((f o x) --> l) sequentially /\
                          !y. (!n. (y n) IN s) /\ (y --> a) sequentially
                              ==> ((f o y) --> l) sequentially``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN
  KNOW_TAC ``cauchy x /\ (!n. x n IN s)`` THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_CAUCHY],
    DISCH_THEN (fn th => REWRITE_TAC [th])] THEN
  REWRITE_TAC [GSYM CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN (X_CHOOSE_TAC ``l:real``) THEN EXISTS_TAC ``l:real`` THEN
  ASM_REWRITE_TAC [] THEN
  X_GEN_TAC ``y:num->real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``y:num->real``) THEN
  KNOW_TAC ``cauchy y /\ (!n. y n IN s)`` THENL
  [ASM_MESON_TAC[CONVERGENT_IMP_CAUCHY],
    DISCH_THEN (fn th => REWRITE_TAC [th])] THEN
  REWRITE_TAC[GSYM CONVERGENT_EQ_CAUCHY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``l':real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``l:real = l'`` (fn th => ASM_REWRITE_TAC[th]) THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_0] THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
  EXISTS_TAC ``\n:num. (f:real->real)(x n) - f(y n)`` THEN
  RULE_ASSUM_TAC(REWRITE_RULE[o_DEF]) THEN
  ASM_SIMP_TAC std_ss [LIM_SUB, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``\n. if EVEN n then x(n DIV 2):real else y(n DIV 2)``) THEN
  REWRITE_TAC[cauchy, o_THM, LIM_SEQUENTIALLY] THEN
  KNOW_TAC ``(!(e :real).
    (0 :real) < e ==>
    ?(N :num).
      !(m :num) (n :num).
        m >= N /\ n >= N ==>
        (dist
           ((\(n :num).
               if EVEN n then (x :num -> real) (n DIV  2n)
               else (y :num -> real) (n DIV  2n)) m,
            (\(n :num).
               if EVEN n then x (n DIV  2n)
               else y (n DIV  2n)) n) :real) < e) /\
      (!(n :num). (\(n :num).
       if EVEN n then x (n DIV  2n) else y (n DIV  2n)) n IN
    (s :real -> bool))`` THENL
  [ (* goal 1 (of 2) *)
    CONJ_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
    X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN MAP_EVERY UNDISCH_TAC
     [``((y:num->real) --> a) sequentially``,
      ``((x:num->real) --> a) sequentially``] THEN
    REWRITE_TAC[LIM_SEQUENTIALLY] THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N1:num``) THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN ASM_REWRITE_TAC[REAL_HALF] THEN
    DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
    EXISTS_TAC ``2 * (N1 + N2:num)`` THEN
    MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN STRIP_TAC THEN
    UNDISCH_TAC ``!n. (y:num->real) n IN s`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``!n. (x:num->real) n IN s`` THEN DISCH_TAC THEN
    POP_ASSUM K_TAC THEN POP_ASSUM K_TAC THEN
    REPEAT(FIRST_X_ASSUM(fn th =>
      MP_TAC(SPEC ``m DIV 2`` th) THEN MP_TAC(SPEC ``n DIV 2`` th))) THEN
    KNOW_TAC ``N1 <= n DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N1 <= m DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N2 <= n DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    KNOW_TAC ``N2 <= m DIV 2`` THENL
    [SIMP_TAC std_ss [X_LE_DIV, ARITH_PROVE ``0 < 2:num``] THEN
     ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN DISCH_TAC] THEN
    REPEAT(COND_CASES_TAC THEN ASM_REWRITE_TAC[]) THEN
    FULL_SIMP_TAC std_ss [dist, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
    Cases_on `EVEN m` >> Cases_on `EVEN n` >> fs [] >| (* 4 subgoals *)
    [ MP_TAC (Q.SPECL [`x (m DIV 2) - a`, `x (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`x (m DIV 2) - a`, `y (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`y (m DIV 2) - a`, `x (n DIV 2) - a`] ABS_TRIANGLE_NEG),
      MP_TAC (Q.SPECL [`y (m DIV 2) - a`, `y (n DIV 2) - a`] ABS_TRIANGLE_NEG) ]
    >> ASM_REAL_ARITH_TAC,
    (* goal 2 (of 2) *)
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
    ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``2 * n:num``, ``2 * n + 1:num``]) THEN
    KNOW_TAC ``2 * n >= N /\ 2 * n + 1 >= N:num`` THENL
    [ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    SIMP_TAC arith_ss [EVEN_ADD, EVEN_MULT] THEN
    KNOW_TAC ``((2 * n) DIV 2 = n) /\ ((2 * n + 1) DIV 2 = n)`` THENL
    [SIMP_TAC arith_ss [DIV_EQ_X, ARITH_PROVE ``0 < 2:num``], ALL_TAC] THEN
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    REWRITE_TAC[dist, REAL_SUB_RZERO] ]);

val CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE = store_thm ("CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> ?g. g continuous_on closure s /\ (!x. x IN s ==> (g x = f x))``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``!a:real. ?x.
       a IN closure s ==> (!n. x n IN s) /\ (x --> a) sequentially``
  MP_TAC THENL [MESON_TAC[CLOSURE_SEQUENTIAL], ALL_TAC] THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``X:real->num->real`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_CONTINUOUS_UNIQUENESS_LEMMA) THEN
  DISCH_THEN(MP_TAC o GEN ``a:real`` o
   SPECL [``a:real``, ``(X:real->num->real) a``]) THEN
  KNOW_TAC ``(!(a :real). a IN closure (s :real -> bool) ==>
   ?(l :real).
     (((f :real -> real) o X a --> l) sequentially :bool) /\
     !(y :num -> real).
       (!(n :num). y n IN s) /\ ((y --> a) sequentially :bool) ==>
       ((f o y --> l) sequentially :bool)) ==>
  ?(g :real -> real).
  g continuous_on closure s /\ !(x :real). x IN s ==> (g x = f x)`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN
  MATCH_MP_TAC(TAUT `b /\ (b ==> a) ==> a /\ b`) THEN CONJ_TAC THENL
   [X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``a:real``) THEN
    ASM_SIMP_TAC std_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET] THEN
    DISCH_THEN(MP_TAC o SPEC ``(\n. a):num->real`` o CONJUNCT2) THEN
    ASM_SIMP_TAC std_ss [LIM_CONST_EQ, o_DEF, TRIVIAL_LIMIT_SEQUENTIALLY],
    STRIP_TAC] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CLOSURE_SEQUENTIALLY] THEN
  MAP_EVERY X_GEN_TAC [``x:num->real``, ``a:real``] THEN STRIP_TAC THEN
  MATCH_MP_TAC LIM_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC ``(f:real->real) o (x:num->real)`` THEN ASM_SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC ALWAYS_EVENTUALLY THEN ASM_SIMP_TAC std_ss [o_THM]);

val UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE = store_thm ("UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE",
 ``!f:real->real s.
   f uniformly_continuous_on s
   ==> ?g. g uniformly_continuous_on closure s /\ (!x. x IN s ==> (g x = f x)) /\
           !h. h continuous_on closure s /\ (!x. x IN s ==> (h x = f x))
               ==> !x. x IN closure s ==> (h x = g x)``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE o
   MATCH_MP UNIFORMLY_CONTINUOUS_IMP_CAUCHY_CONTINUOUS) THEN
  STRIP_TAC THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [METIS_TAC[UNIFORMLY_CONTINUOUS_ON_CLOSURE, UNIFORMLY_CONTINUOUS_ON_EQ],
    METIS_TAC[CONTINUOUS_AGREE_ON_CLOSURE]]);

val CAUCHY_CONTINUOUS_IMP_CONTINUOUS = store_thm ("CAUCHY_CONTINUOUS_IMP_CONTINUOUS",
 ``!f:real->real s.
        (!x. cauchy x /\ (!n. (x n) IN s) ==> cauchy(f o x))
        ==> f continuous_on s``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(CHOOSE_TAC o MATCH_MP CAUCHY_CONTINUOUS_EXTENDS_TO_CLOSURE) THEN
  ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, CLOSURE_SUBSET, CONTINUOUS_ON_EQ]);

val BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE = store_thm ("BOUNDED_UNIFORMLY_CONTINUOUS_IMAGE",
 ``!f:real->real s.
        f uniformly_continuous_on s /\ bounded s ==> bounded(IMAGE f s)``,
  REPEAT STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC o MATCH_MP UNIFORMLY_CONTINUOUS_EXTENDS_TO_CLOSURE) THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC BOUNDED_SUBSET THEN
  EXISTS_TAC ``IMAGE (g:real->real) (closure s)`` THEN CONJ_TAC THENL
   [ASM_MESON_TAC[COMPACT_CLOSURE, UNIFORMLY_CONTINUOUS_IMP_CONTINUOUS,
                  COMPACT_IMP_BOUNDED, COMPACT_CONTINUOUS_IMAGE],
    MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Occasionally useful invariance properties.                                *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_AT_COMPOSE_EQ = store_thm ("CONTINUOUS_AT_COMPOSE_EQ",
 ``!f:real->real g:real->real h:real->real.
        g continuous at x /\ h continuous at (g x) /\
        (!y. g(h y) = y) /\ (h(g x) = x)
        ==> ((f continuous at (g x) <=> (\x. f(g x)) continuous at x))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[o_DEF] CONTINUOUS_AT_COMPOSE] THEN
  DISCH_TAC THEN
  SUBGOAL_THEN
   ``((f:real->real) o (g:real->real) o (h:real->real))
     continuous at (g(x:real))``
  MP_TAC THENL
   [REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC CONTINUOUS_AT_COMPOSE THEN
    ASM_REWRITE_TAC[o_DEF],
    ASM_SIMP_TAC std_ss [o_DEF, ETA_AX]]);

val CONTINUOUS_AT_TRANSLATION = store_thm ("CONTINUOUS_AT_TRANSLATION",
 ``!a z f:real->real.
      f continuous at (a + z) <=> (\x. f(a + x)) continuous at z``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``a + z = (\z. a + z) z:real``] THEN
  MATCH_MP_TAC CONTINUOUS_AT_COMPOSE_EQ THEN
  EXISTS_TAC ``\x:real. x - a`` THEN
  SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_SUB,
           CONTINUOUS_AT_ID, CONTINUOUS_CONST] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Interior of an injective image.                                           *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_IMAGE_SUBSET = store_thm ("INTERIOR_IMAGE_SUBSET",
 ``!f:real->real s.
       (!x. f continuous at x) /\ (!x y. (f x = f y) ==> (x = y))
       ==> interior(IMAGE f s) SUBSET IMAGE f (interior s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[SUBSET_DEF] THEN
  SIMP_TAC std_ss [interior, GSPECIFICATION] THEN
  X_GEN_TAC ``y:real`` THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  SIMP_TAC std_ss [IN_IMAGE, GSPECIFICATION] THEN
  SUBGOAL_THEN ``y IN IMAGE (f:real->real) s`` MP_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[IN_IMAGE] THEN
  STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN FIRST_X_ASSUM SUBST_ALL_TAC THEN
  EXISTS_TAC ``{x | (f:real->real)(x) IN t}`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN CONJ_TAC THENL
   [MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE_UNIV THEN ASM_MESON_TAC[],
    ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Making a continuous function avoid some value in a neighbourhood.         *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_WITHIN_AVOID = store_thm ("CONTINUOUS_WITHIN_AVOID",
 ``!f:real->real x s a.
        f continuous (at x within s) /\ x IN s /\  ~(f x = a)
        ==> ?e. &0 < e /\ !y. y IN s /\ dist(x,y) < e ==> ~(f y = a)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``f continuous (at x within s)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [continuous_within]) THEN
  DISCH_THEN(MP_TAC o SPEC ``abs((f:real->real) x - a)``) THEN
  ASM_REWRITE_TAC[GSYM ABS_NZ, REAL_SUB_0] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN MATCH_MP_TAC MONO_AND THEN
  REWRITE_TAC[] THEN DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN
  POP_ASSUM (MP_TAC o SPEC ``y:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_AT_AVOID = store_thm ("CONTINUOUS_AT_AVOID",
 ``!f:real->real x a.
        f continuous (at x) /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. dist(x,y) < e ==> ~(f y = a)``,
  MP_TAC CONTINUOUS_WITHIN_AVOID THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o SPECL [``f:real->real``,``x:real``]) THEN
  DISCH_THEN(MP_TAC o SPEC ``univ(:real)``) THEN
  DISCH_TAC THEN X_GEN_TAC ``a:real`` THEN POP_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  REWRITE_TAC[WITHIN_UNIV, IN_UNIV]);

val CONTINUOUS_ON_AVOID = store_thm ("CONTINUOUS_ON_AVOID",
 ``!f:real->real x s a.
        f continuous_on s /\ x IN s /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. y IN s /\ dist(x,y) < e ==> ~(f y = a)``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_WITHIN_AVOID THEN
  ASM_SIMP_TAC std_ss []);

val CONTINUOUS_ON_OPEN_AVOID = store_thm ("CONTINUOUS_ON_OPEN_AVOID",
 ``!f:real->real x s a.
        f continuous_on s /\ open s /\ x IN s /\ ~(f x = a)
        ==> ?e. &0 < e /\ !y. dist(x,y) < e ==> ~(f y = a)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``open(s:real->bool)`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_AT] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_AT_AVOID THEN
  ASM_SIMP_TAC std_ss []);

(* ------------------------------------------------------------------------- *)
(* Proving a function is constant by proving open-ness of level set.         *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_LEVELSET_OPEN_IN_CASES = store_thm ("CONTINUOUS_LEVELSET_OPEN_IN_CASES",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open_in (subtopology euclidean s) {x | x IN s /\ (f x = a)}
        ==> (!x. x IN s ==> ~(f x = a)) \/ (!x. x IN s ==> (f x = a))``,
  REWRITE_TAC[SET_RULE ``(!x. x IN s ==> ~(f x = a)) <=>
                        ({x | x IN s /\ (f x = a)} = {})``,
              SET_RULE ``(!x. x IN s ==> (f x = a)) <=>
                        ({x | x IN s /\ (f x = a)} = s)``] THEN
  REWRITE_TAC[CONNECTED_CLOPEN] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_CLOSED_IN_PREIMAGE_CONSTANT]);

val CONTINUOUS_LEVELSET_OPEN_IN = store_thm ("CONTINUOUS_LEVELSET_OPEN_IN",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open_in (subtopology euclidean s) {x | x IN s /\ (f x = a)} /\
        (?x. x IN s /\ (f x = a))
        ==> (!x. x IN s ==> (f x = a))``,
  METIS_TAC[CONTINUOUS_LEVELSET_OPEN_IN_CASES]);

val CONTINUOUS_LEVELSET_OPEN = store_thm ("CONTINUOUS_LEVELSET_OPEN",
 ``!f:real->real s a.
        connected s /\
        f continuous_on s /\
        open {x | x IN s /\ (f x = a)} /\
        (?x. x IN s /\ (f x = a))
        ==> (!x. x IN s ==> (f x = a))``,
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC CONTINUOUS_LEVELSET_OPEN_IN THEN
  ASM_REWRITE_TAC[OPEN_IN_OPEN] THEN
  EXISTS_TAC ``{x | x IN s /\ ((f:real->real) x = a)}`` THEN
  ASM_REWRITE_TAC[] THEN SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Some arithmetical combinations (more to prove).                           *)
(* ------------------------------------------------------------------------- *)

val OPEN_SCALING = store_thm ("OPEN_SCALING",
 ``!s:real->bool c. ~(c = &0) /\ open s ==> open(IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [open_def, FORALL_IN_IMAGE] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e * abs(c:real)`` THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL, GSYM ABS_NZ] THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_IMAGE] THEN
  EXISTS_TAC ``inv(c) * y:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  SUBGOAL_THEN ``x = inv(c) * c * x:real`` SUBST1_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID],
    REWRITE_TAC[dist, GSYM REAL_MUL_ASSOC, GSYM REAL_SUB_LDISTRIB, ABS_MUL] THEN
    ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_SIMP_TAC std_ss [ABS_INV] THEN
    ASM_SIMP_TAC std_ss [GSYM real_div, REAL_LT_LDIV_EQ, GSYM ABS_NZ] THEN
    ASM_REWRITE_TAC[GSYM dist]]);

val OPEN_NEGATIONS = store_thm ("OPEN_NEGATIONS",
 ``!s:real->bool. open s ==> open (IMAGE (\x. -x) s)``,
  SUBGOAL_THEN ``(\x. -x) = \x:real. -(&1) * x``
   (fn th => SIMP_TAC std_ss [th, OPEN_SCALING, REAL_ARITH ``~(-(&1) = &0:real)``]) THEN
  REWRITE_TAC[FUN_EQ_THM] THEN REAL_ARITH_TAC);

val OPEN_TRANSLATION = store_thm ("OPEN_TRANSLATION",
 ``!s a:real. open s ==> open(IMAGE (\x. a + x) s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``\x:real. x - a``, ``s:real->bool``]
         CONTINUOUS_OPEN_PREIMAGE_UNIV) THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_SUB, CONTINUOUS_AT_ID, CONTINUOUS_CONST] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE, IN_UNIV] THEN
  ASM_MESON_TAC[REAL_ARITH ``(a + x) - a = x:real``,
                REAL_ARITH ``a + (x - a) = x:real``]);

val OPEN_TRANSLATION_EQ = store_thm ("OPEN_TRANSLATION_EQ",
 ``!a s. open (IMAGE (\x:real. a + x) s) <=> open s``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
  [ALL_TAC, REWRITE_TAC [OPEN_TRANSLATION]] THEN
  REWRITE_TAC [open_def] THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``a + x:real``) THEN
  KNOW_TAC ``a + x IN IMAGE (\x:real. a + x) s`` THENL
  [SIMP_TAC std_ss [IN_IMAGE, REAL_EQ_LADD] THEN METIS_TAC [],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC [] THEN
  GEN_TAC THEN DISCH_TAC THEN FULL_SIMP_TAC std_ss [dist, IN_IMAGE] THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``a + x':real``) THEN
  ASM_SIMP_TAC real_ss [REAL_ARITH ``a + b - (a + c) = b - c:real``] THEN
  REWRITE_TAC [REAL_EQ_LADD] THEN METIS_TAC []);

val OPEN_AFFINITY = store_thm ("OPEN_AFFINITY",
 ``!s a:real c.
        open s /\ ~(c = &0) ==> open (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IMAGE_COMPOSE, OPEN_TRANSLATION, OPEN_SCALING]);

val INTERIOR_TRANSLATION = store_thm ("INTERIOR_TRANSLATION",
 ``!a:real s.
    interior (IMAGE (\x. a + x) s) = IMAGE (\x. a + x) (interior s)``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``(!t. ?s. IMAGE ((\x. a + x):real->real) s = t)`` THENL
  [REWRITE_TAC [SURJECTIVE_IMAGE] THEN GEN_TAC THEN EXISTS_TAC ``-a + y:real`` THEN
   SIMP_TAC std_ss [] THEN REAL_ARITH_TAC, DISCH_TAC] THEN
  REWRITE_TAC [interior] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [FIRST_ASSUM (MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
   DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [IN_IMAGE] THEN
   SIMP_TAC std_ss [] THEN STRIP_TAC THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [] THEN
   FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN STRIP_TAC THEN
   EXISTS_TAC ``s':real->bool`` THEN REPEAT CONJ_TAC THENL
   [METIS_TAC [OPEN_TRANSLATION_EQ],
    UNDISCH_TAC ``IMAGE ((\x. a + x):real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_SIMP_TAC std_ss [IN_IMAGE] THEN
    REWRITE_TAC [REAL_EQ_LADD] THEN METIS_TAC [],
    REWRITE_TAC [SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``IMAGE ((\x. a + x):real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``a + y:real``) THEN SIMP_TAC std_ss [IN_IMAGE] THEN
    KNOW_TAC ``(?x:real. (a + y = a + x) /\ x IN s')`` THENL
    [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN UNDISCH_TAC ``t SUBSET IMAGE ((\x. a + x):real->real) s`` THEN
    REWRITE_TAC [SUBSET_DEF] THEN DISCH_THEN (MP_TAC o SPEC ``a + y:real``) THEN
    ASM_REWRITE_TAC [] THEN SIMP_TAC std_ss [IN_IMAGE, REAL_EQ_LADD]], ALL_TAC] THEN
  FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
  STRIP_TAC THEN EXISTS_TAC ``IMAGE (\x:real. a + x) t`` THEN
  REPEAT CONJ_TAC THENL
  [METIS_TAC [OPEN_TRANSLATION_EQ],
   SIMP_TAC std_ss [IN_IMAGE] THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [],
   MATCH_MP_TAC IMAGE_SUBSET THEN ASM_REWRITE_TAC []]);

val OPEN_SUMS = store_thm ("OPEN_SUMS",
 ``!s t:real->bool.
        open s \/ open t ==> open {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[open_def] THEN STRIP_TAC THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``),
    FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``)] THEN
  ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
  EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC[REAL_ADD_SYM, REAL_ARITH ``(z - y) + y:real = z``, dist,
                REAL_ARITH ``abs(z:real - (x + y)) < e ==> abs(z - y - x) < e``]);

(* ------------------------------------------------------------------------- *)
(* Upper and lower hemicontinuous functions, relation in the case of         *)
(* preimage map to open and closed maps, and fact that upper and lower       *)
(* hemicontinuity together imply continuity in the sense of the Hausdorff    *)
(* metric (at points where the function gives a bounded and nonempty set).   *)
(* ------------------------------------------------------------------------- *)

val UPPER_HEMICONTINUOUS = store_thm ("UPPER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
        (!x. x IN s ==> f(x) SUBSET t)
        ==> ((!u. open_in (subtopology euclidean t) u
                  ==> open_in (subtopology euclidean s)
                              {x | x IN s /\ f(x) SUBSET u}) <=>
             (!u. closed_in (subtopology euclidean t) u
                  ==> closed_in (subtopology euclidean s)
                                {x | x IN s /\ ~(f(x) INTER u = {})}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  MATCH_MP_TAC MONO_IMP THEN
  SIMP_TAC std_ss [OPEN_IN_DIFF, CLOSED_IN_DIFF, OPEN_IN_REFL, CLOSED_IN_REFL] THENL
   [REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ], REWRITE_TAC[closed_in]] THEN
  SIMP_TAC std_ss [TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val LOWER_HEMICONTINUOUS = store_thm ("LOWER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
        (!x. x IN s ==> f(x) SUBSET t)
        ==> ((!u. closed_in (subtopology euclidean t) u
                  ==> closed_in (subtopology euclidean s)
                                {x | x IN s /\ f(x) SUBSET u}) <=>
             (!u. open_in (subtopology euclidean t) u
                  ==> open_in (subtopology euclidean s)
                              {x | x IN s /\ ~(f(x) INTER u = {})}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``t DIFF u:real->bool``) THEN
  MATCH_MP_TAC MONO_IMP THEN
  SIMP_TAC std_ss [OPEN_IN_DIFF, CLOSED_IN_DIFF, OPEN_IN_REFL, CLOSED_IN_REFL] THENL
   [REWRITE_TAC[closed_in], REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ]] THEN
  SIMP_TAC std_ss [TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_RESTRICT] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]);

val OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE = store_thm ("OPEN_MAP_IFF_LOWER_HEMICONTINUOUS_PREIMAGE",
 ``!f:real->real s t.
        IMAGE f s SUBSET t
        ==> ((!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. closed_in (subtopology euclidean s) u
                      ==> closed_in (subtopology euclidean t)
                                    {y | y IN t /\
                                         {x | x IN s /\ (f x = y)} SUBSET u}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
    SIMP_TAC std_ss [OPEN_IN_CLOSED_IN_EQ, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[],
    X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
    REWRITE_TAC[OPEN_IN_CLOSED_IN_EQ, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(fn th => CONJ_TAC THENL [ASM_SET_TAC[], MP_TAC th]) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE = store_thm ("CLOSED_MAP_IFF_UPPER_HEMICONTINUOUS_PREIMAGE",
 ``!f:real->real s t.
        IMAGE f s SUBSET t
        ==> ((!u. closed_in (subtopology euclidean s) u
                  ==> closed_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t)
                              {y | y IN t /\
                                   {x | x IN s /\ (f x = y)} SUBSET u}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_DIFF, CLOSED_IN_REFL] THEN
    SIMP_TAC std_ss [closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[],
    X_GEN_TAC ``v:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``s DIFF v:real->bool``) THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_DIFF, OPEN_IN_REFL] THEN
    FIRST_ASSUM(ASSUME_TAC o MATCH_MP CLOSED_IN_IMP_SUBSET) THEN
    REWRITE_TAC[closed_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    DISCH_THEN(fn th => CONJ_TAC THENL [ASM_SET_TAC[], MP_TAC th]) THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN ASM_SET_TAC[]]);

val UPPER_LOWER_HEMICONTINUOUS_EXPLICIT = store_thm ("UPPER_LOWER_HEMICONTINUOUS_EXPLICIT",
 ``!f:real->real->bool t s.
      (!x. x IN s ==> f(x) SUBSET t) /\
      (!u. open_in (subtopology euclidean t) u
           ==> open_in (subtopology euclidean s)
                       {x | x IN s /\ f(x) SUBSET u}) /\
      (!u. closed_in (subtopology euclidean t) u
           ==> closed_in (subtopology euclidean s)
                         {x | x IN s /\ f(x) SUBSET u})
      ==> !x e. x IN s /\ &0 < e /\ bounded(f x) /\ ~(f x = {})
                ==> ?d. &0 < d /\
                        !x'. x' IN s /\ dist(x,x') < d
                             ==> (!y. y IN f x
                                      ==> ?y'. y' IN f x' /\ dist(y,y') < e) /\
                                 (!y'. y' IN f x'
                                       ==> ?y. y IN f x /\ dist(y',y) < e)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC
   ``!u. open_in (subtopology euclidean t) u
        ==> open_in (subtopology euclidean s)
                    {x | x IN s /\ (f:real->real->bool)(x) SUBSET u}`` THEN
  DISCH_THEN(MP_TAC o SPEC
   ``t INTER
    {a + b | a IN (f:real->real->bool) x /\ b IN ball(0,e)}``) THEN
  SIMP_TAC std_ss [OPEN_SUMS, OPEN_BALL, OPEN_IN_OPEN_INTER] THEN
  SIMP_TAC std_ss [open_in, SUBSET_RESTRICT] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
  ASM_SIMP_TAC std_ss [GSPECIFICATION, SUBSET_INTER] THEN
  KNOW_TAC ``(f :real -> real -> bool) (x :real) SUBSET
    {a + b | a IN f x /\ b IN ball ((0 :real),(e :real))}`` THENL
   [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
    METIS_TAC[CENTRE_IN_BALL, REAL_ADD_RID],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``d1:real``
     (CONJUNCTS_THEN2 ASSUME_TAC ASSUME_TAC))] THEN
  UNDISCH_TAC
   ``!u. closed_in (subtopology euclidean t) u
        ==> closed_in (subtopology euclidean s)
                    {x | x IN s /\ (f:real->real->bool)(x) SUBSET u}`` THEN
  ASM_SIMP_TAC std_ss [LOWER_HEMICONTINUOUS] THEN DISCH_THEN(MP_TAC o
    GEN ``a:real`` o SPEC ``t INTER ball(a:real,e / &2)``) THEN
  SIMP_TAC std_ss [OPEN_BALL, OPEN_IN_OPEN_INTER] THEN
  MP_TAC(SPEC ``closure((f:real->real->bool) x)``
    COMPACT_EQ_HEINE_BOREL) THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE] THEN DISCH_THEN(MP_TAC o SPEC
   ``{ball(a:real,e / &2) | a IN (f:real->real->bool) x}``) THEN
  SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, OPEN_BALL] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE] THEN
  KNOW_TAC ``closure ((f :real -> real -> bool) (x :real)) SUBSET
   BIGUNION (IMAGE (\(a :real). ball (a,(e :real) / (2 :real))) (f x))`` THENL
   [SIMP_TAC std_ss [CLOSURE_APPROACHABLE, SUBSET_DEF, BIGUNION_IMAGE, GSPECIFICATION] THEN
    REWRITE_TAC[IN_BALL] THEN ASM_SIMP_TAC std_ss [REAL_HALF],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``c:real->bool`` STRIP_ASSUME_TAC) THEN
  DISCH_TAC THEN FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP
   (METIS[CLOSURE_SUBSET, SUBSET_TRANS]
        ``closure s SUBSET t ==> s SUBSET t``)) THEN
  SUBGOAL_THEN
   ``open_in (subtopology euclidean s)
      (BIGINTER {{x | x IN s /\
          ~((f:real->real->bool) x INTER t INTER ball(a,e / &2) = {})} |
     a IN c})``
  MP_TAC THENL
   [MATCH_MP_TAC OPEN_IN_BIGINTER THEN
    ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IMAGE_FINITE,
     GSYM INTER_ASSOC] THEN ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY] THEN
    ASM_SET_TAC[], ALL_TAC] THEN
  REWRITE_TAC[open_in] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN
  KNOW_TAC ``(x :real) IN
   BIGINTER {{x |
     x IN (s :real -> bool) /\
     (f :real -> real -> bool) x INTER (t :real -> bool) INTER
     ball (a,(e :real) / (2 :real)) <> ({} :real -> bool)} |
    a IN (c :real -> bool)}`` THENL
   [SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION] THEN
    X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
    EXISTS_TAC ``a:real`` THEN
    ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_HALF] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``d2:real``
     (CONJUNCTS_THEN2 ASSUME_TAC ASSUME_TAC))] THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  X_GEN_TAC ``x':real`` THEN STRIP_TAC THEN CONJ_TAC THENL
   [ALL_TAC,
    UNDISCH_TAC ``!x'':real.
        x'' IN s /\ dist (x'',x) < d1 ==>
        f x'' SUBSET {a + b | a IN f x /\ b IN ball (0,e)}`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``x':real``) THEN
    ASM_REWRITE_TAC[] THEN
    KNOW_TAC ``dist (x',x) < d1:real`` THENL
    [ASM_MESON_TAC[DIST_SYM], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD, IN_BALL] THEN
    SIMP_TAC std_ss [REAL_ARITH ``(x:real = a + b) <=> (x - a = b)``,
                DIST_0, ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
    REWRITE_TAC[dist]] THEN
  UNDISCH_TAC ``!x':real.
         x' IN s /\ dist (x',x) < d2 ==>
         x' IN
         BIGINTER
           {{x | x IN s /\ f x INTER t INTER ball (a,e / 2) <> {}} |
            a IN c}`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``x':real``) THEN
  ASM_SIMP_TAC std_ss [BIGINTER_GSPEC, GSPECIFICATION] THEN
  KNOW_TAC ``dist (x',x) < d2:real`` THENL
  [ASM_MESON_TAC[DIST_SYM], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_TAC THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``(f:real->real->bool) x SUBSET
               BIGUNION (IMAGE (\a. ball (a,e / &2)) c)`` THEN
  REWRITE_TAC[SUBSET_DEF] THEN DISCH_THEN(MP_TAC o SPEC ``y:real``) THEN
  ASM_SIMP_TAC std_ss [BIGUNION_IMAGE, GSPECIFICATION, IN_BALL] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!(a' :real).
         a' IN (c :real -> bool) ==>
         (f :real -> real -> bool) (x' :real) INTER
         (t :real -> bool) INTER ball (a',(e :real) / (2 :real)) <>
         ({} :real -> bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  ASM_REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER, IN_BALL] THEN
  DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  METIS_TAC[DIST_TRIANGLE_HALF_L, DIST_SYM]);

(* ------------------------------------------------------------------------- *)
(* Connected components, considered as a "connectedness" relation or a set.  *)
(* ------------------------------------------------------------------------- *)

val connected_component = new_definition ("connected_component",
 ``connected_component s x y <=>
        ?t. connected t /\ t SUBSET s /\ x IN t /\ y IN t``);

val CONNECTED_COMPONENT_IN = store_thm ("CONNECTED_COMPONENT_IN",
 ``!s x y. connected_component s x y ==> x IN s /\ y IN s``,
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_REFL = store_thm ("CONNECTED_COMPONENT_REFL",
 ``!s x:real. x IN s ==> connected_component s x x``,
  REWRITE_TAC[connected_component] THEN REPEAT STRIP_TAC THEN
  EXISTS_TAC ``{x:real}`` THEN REWRITE_TAC[CONNECTED_SING] THEN
  ASM_SET_TAC[]);

val CONNECTED_COMPONENT_REFL_EQ = store_thm ("CONNECTED_COMPONENT_REFL_EQ",
 ``!s x:real. connected_component s x x <=> x IN s``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[CONNECTED_COMPONENT_REFL] THEN
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SYM = store_thm ("CONNECTED_COMPONENT_SYM",
 ``!s x y:real. connected_component s x y ==> connected_component s y x``,
  REWRITE_TAC[connected_component] THEN MESON_TAC[]);

val CONNECTED_COMPONENT_TRANS = store_thm ("CONNECTED_COMPONENT_TRANS",
 ``!s x y:real.
    connected_component s x y /\ connected_component s y z
    ==> connected_component s x z``,
  REPEAT GEN_TAC THEN REWRITE_TAC[connected_component] THEN
  DISCH_THEN(CONJUNCTS_THEN2 (X_CHOOSE_TAC ``t:real->bool``)
                             (X_CHOOSE_TAC ``u:real->bool``)) THEN
  EXISTS_TAC ``t UNION u:real->bool`` THEN
  ASM_REWRITE_TAC[IN_UNION, UNION_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_UNION THEN ASM_SET_TAC[]);

val CONNECTED_COMPONENT_OF_SUBSET = store_thm ("CONNECTED_COMPONENT_OF_SUBSET",
 ``!s t x. s SUBSET t /\ connected_component s x y
           ==> connected_component t x y``,
  REWRITE_TAC[connected_component] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SET = store_thm ("CONNECTED_COMPONENT_SET",
 ``!s x. connected_component s x =
            { y | ?t. connected t /\ t SUBSET s /\ x IN t /\ y IN t}``,
  SIMP_TAC std_ss [GSPECIFICATION, EXTENSION] THEN
  SIMP_TAC std_ss [IN_DEF, connected_component]);

val CONNECTED_COMPONENT_BIGUNION = store_thm ("CONNECTED_COMPONENT_BIGUNION",
 ``!s x. connected_component s x =
                BIGUNION {t | connected t /\ x IN t /\ t SUBSET s}``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_COMPONENT_SUBSET = store_thm ("CONNECTED_COMPONENT_SUBSET",
 ``!s x. (connected_component s x) SUBSET s``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_CONNECTED_COMPONENT_SET = store_thm ("CONNECTED_CONNECTED_COMPONENT_SET",
 ``!s. connected s <=> !x:real. x IN s ==> (connected_component s x = s)``,
  GEN_TAC THEN REWRITE_TAC[CONNECTED_COMPONENT_BIGUNION] THEN EQ_TAC THENL
   [SET_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[CONNECTED_EMPTY] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(SUBST1_TAC o SYM) THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN
  ASM_SET_TAC[]);

val CONNECTED_COMPONENT_UNIV = store_thm ("CONNECTED_COMPONENT_UNIV",
 ``!x. connected_component univ(:real) x = univ(:real)``,
  MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET, CONNECTED_UNIV, IN_UNIV]);

val CONNECTED_COMPONENT_EQ_UNIV = store_thm ("CONNECTED_COMPONENT_EQ_UNIV",
 ``!s x. (connected_component s x = univ(:real)) <=> (s = univ(:real))``,
  REPEAT GEN_TAC THEN EQ_TAC THEN SIMP_TAC std_ss [CONNECTED_COMPONENT_UNIV] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (s = UNIV) ==> (t = UNIV)``) THEN
  REWRITE_TAC[CONNECTED_COMPONENT_SUBSET]);

val CONNECTED_COMPONENT_EQ_SELF = store_thm ("CONNECTED_COMPONENT_EQ_SELF",
 ``!s x. connected s /\ x IN s ==> (connected_component s x = s)``,
  MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET]);

val CONNECTED_IFF_CONNECTED_COMPONENT = store_thm ("CONNECTED_IFF_CONNECTED_COMPONENT",
 ``!s. connected s <=>
          !x y. x IN s /\ y IN s ==> connected_component s x y``,
  REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT_SET] THEN
  REWRITE_TAC[EXTENSION] THEN MESON_TAC[IN_DEF, CONNECTED_COMPONENT_IN]);

val CONNECTED_COMPONENT_MAXIMAL = store_thm ("CONNECTED_COMPONENT_MAXIMAL",
 ``!s t x:real.
        x IN t /\ connected t /\ t SUBSET s
        ==> t SUBSET (connected_component s x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_COMPONENT_MONO = store_thm ("CONNECTED_COMPONENT_MONO",
 ``!s t x. s SUBSET t
           ==> (connected_component s x) SUBSET (connected_component t x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]);

val CONNECTED_CONNECTED_COMPONENT = store_thm ("CONNECTED_CONNECTED_COMPONENT",
 ``!s x. connected(connected_component s x)``,
  REWRITE_TAC[CONNECTED_COMPONENT_BIGUNION] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_BIGUNION THEN SET_TAC[]);

val CONNECTED_COMPONENT_EQ_EMPTY = store_thm ("CONNECTED_COMPONENT_EQ_EMPTY",
 ``!s x:real. (connected_component s x = {}) <=> ~(x IN s)``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [REWRITE_TAC[EXTENSION, NOT_IN_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
    SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    REWRITE_TAC[CONNECTED_COMPONENT_SET] THEN SET_TAC[]]);

val CONNECTED_COMPONENT_EMPTY = store_thm ("CONNECTED_COMPONENT_EMPTY",
 ``!x. connected_component {} x = {}``,
  REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY, NOT_IN_EMPTY]);

val CONNECTED_COMPONENT_EQ = store_thm ("CONNECTED_COMPONENT_EQ",
 ``!s x y. y IN connected_component s x
           ==> ((connected_component s y = connected_component s x))``,
  REWRITE_TAC[EXTENSION, IN_DEF] THEN
  MESON_TAC[CONNECTED_COMPONENT_SYM, CONNECTED_COMPONENT_TRANS]);

val CLOSED_CONNECTED_COMPONENT = store_thm ("CLOSED_CONNECTED_COMPONENT",
 ``!s x:real. closed s ==> closed(connected_component s x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``(x:real) IN s`` THENL
   [ALL_TAC, ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY, CLOSED_EMPTY]] THEN
  REWRITE_TAC[GSYM CLOSURE_EQ] THEN
  MATCH_MP_TAC SUBSET_ANTISYM THEN REWRITE_TAC[CLOSURE_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
  SIMP_TAC std_ss [CONNECTED_CLOSURE, CONNECTED_CONNECTED_COMPONENT] THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC(REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET) THEN
    ASM_SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    MATCH_MP_TAC CLOSURE_MINIMAL THEN
    ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET]]);

val CONNECTED_COMPONENT_DISJOINT = store_thm ("CONNECTED_COMPONENT_DISJOINT",
 ``!s a b. DISJOINT (connected_component s a) (connected_component s b) <=>
             ~(a IN connected_component s b)``,
  REWRITE_TAC[DISJOINT_DEF, EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
  REWRITE_TAC[IN_DEF] THEN
  MESON_TAC[CONNECTED_COMPONENT_SYM, CONNECTED_COMPONENT_TRANS]);

val CONNECTED_COMPONENT_NONOVERLAP = store_thm ("CONNECTED_COMPONENT_NONOVERLAP",
 ``!s a b:real.
        ((connected_component s a) INTER (connected_component s b) = {}) <=>
        ~(a IN s) \/ ~(b IN s) \/
        ~(connected_component s a = connected_component s b)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``(a:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(SIMP_RULE std_ss [GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  ASM_SIMP_TAC std_ss [INTER_EMPTY] THEN
  ASM_CASES_TAC ``(b:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  ASM_REWRITE_TAC[INTER_EMPTY] THEN ASM_CASES_TAC
   ``connected_component s (a:real) = connected_component s b`` THEN
  ASM_REWRITE_TAC[INTER_IDEMPOT, CONNECTED_COMPONENT_EQ_EMPTY] THEN
  POP_ASSUM MP_TAC THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
  REWRITE_TAC[] THEN MATCH_MP_TAC CONNECTED_COMPONENT_EQ THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM DISJOINT_DEF]) THEN
  REWRITE_TAC[CONNECTED_COMPONENT_DISJOINT]);

val CONNECTED_COMPONENT_OVERLAP = store_thm ("CONNECTED_COMPONENT_OVERLAP",
 ``!s a b:real.
        ~((connected_component s a) INTER (connected_component s b) = {}) <=>
        a IN s /\ b IN s /\
        (connected_component s a = connected_component s b)``,
  REWRITE_TAC[CONNECTED_COMPONENT_NONOVERLAP, DE_MORGAN_THM]);

val CONNECTED_COMPONENT_SYM_EQ = store_thm ("CONNECTED_COMPONENT_SYM_EQ",
 ``!s x y. connected_component s x y <=> connected_component s y x``,
  MESON_TAC[CONNECTED_COMPONENT_SYM]);

val CONNECTED_COMPONENT_EQ_EQ = store_thm ("CONNECTED_COMPONENT_EQ_EQ",
 ``!s x y:real.
        (connected_component s x = connected_component s y) <=>
           ~(x IN s) /\ ~(y IN s) \/
           x IN s /\ y IN s /\ connected_component s x y``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(y:real) IN s`` THENL
   [ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THENL
     [REWRITE_TAC[FUN_EQ_THM] THEN
      ASM_MESON_TAC[CONNECTED_COMPONENT_TRANS, CONNECTED_COMPONENT_REFL,
                    CONNECTED_COMPONENT_SYM],
      ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY]],
    RULE_ASSUM_TAC(REWRITE_RULE[GSYM CONNECTED_COMPONENT_EQ_EMPTY]) THEN
    ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY] THEN
    ONCE_REWRITE_TAC[CONNECTED_COMPONENT_SYM_EQ] THEN
    ASM_REWRITE_TAC[EMPTY_DEF] THEN ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY]]);

val CONNECTED_EQ_CONNECTED_COMPONENT_EQ = store_thm ("CONNECTED_EQ_CONNECTED_COMPONENT_EQ",
 ``!s. connected s <=>
       !x y. x IN s /\ y IN s
             ==> (connected_component s x = connected_component s y)``,
  SIMP_TAC std_ss [CONNECTED_COMPONENT_EQ_EQ] THEN
  REWRITE_TAC[CONNECTED_IFF_CONNECTED_COMPONENT]);

val CONNECTED_COMPONENT_IDEMP = store_thm ("CONNECTED_COMPONENT_IDEMP",
 ``!s x:real. connected_component (connected_component s x) x =
                connected_component s x``,
  REWRITE_TAC[FUN_EQ_THM, connected_component] THEN
  REPEAT GEN_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN EQ_TAC THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[CONNECTED_COMPONENT_MAXIMAL, SUBSET_TRANS,
                CONNECTED_COMPONENT_SUBSET]);

val CONNECTED_COMPONENT_UNIQUE = store_thm ("CONNECTED_COMPONENT_UNIQUE",
 ``!s c x:real.
        x IN c /\ c SUBSET s /\ connected c /\
        (!c'. x IN c' /\ c' SUBSET s /\ connected c'
              ==> c' SUBSET c)
        ==> (connected_component s x = c)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [FIRST_X_ASSUM MATCH_MP_TAC THEN
    REWRITE_TAC[CONNECTED_COMPONENT_SUBSET, CONNECTED_CONNECTED_COMPONENT] THEN
    REWRITE_TAC[IN_DEF] THEN ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_SET_TAC[],
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN ASM_REWRITE_TAC[]]);

val JOINABLE_CONNECTED_COMPONENT_EQ = store_thm ("JOINABLE_CONNECTED_COMPONENT_EQ",
 ``!s t x y:real.
        connected t /\ t SUBSET s /\
        ~(connected_component s x INTER t = {}) /\
        ~(connected_component s y INTER t = {})
        ==> (connected_component s x = connected_component s y)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY, IN_INTER] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``w:real`` STRIP_ASSUME_TAC)
   (X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC)) THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_EQ THEN
  SIMP_TAC std_ss [IN_DEF] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_TRANS THEN
  EXISTS_TAC ``z:real`` THEN CONJ_TAC THENL [ASM_MESON_TAC[IN_DEF], ALL_TAC] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_TRANS THEN
  EXISTS_TAC ``w:real`` THEN CONJ_TAC THENL
   [REWRITE_TAC[connected_component] THEN
    EXISTS_TAC ``t:real->bool`` THEN ASM_REWRITE_TAC[],
    ASM_MESON_TAC[IN_DEF, CONNECTED_COMPONENT_SYM]]);

val BIGUNION_CONNECTED_COMPONENT = store_thm ("BIGUNION_CONNECTED_COMPONENT",
 ``!s:real->bool. BIGUNION {connected_component s x |x| x IN s} = s``,
  GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC, CONNECTED_COMPONENT_SUBSET] THEN
  SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN EXISTS_TAC ``x:real`` THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC[IN_DEF] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ]);

val COMPLEMENT_CONNECTED_COMPONENT_BIGUNION = store_thm ("COMPLEMENT_CONNECTED_COMPONENT_BIGUNION",
 ``!s x:real.
     s DIFF connected_component s x =
     BIGUNION({connected_component s y | y | y IN s} DELETE
            (connected_component s x))``,
  REPEAT GEN_TAC THEN
  GEN_REWR_TAC (LAND_CONV o LAND_CONV)
    [GSYM BIGUNION_CONNECTED_COMPONENT] THEN
  MATCH_MP_TAC(SET_RULE
   ``(!x. x IN s DELETE a ==> DISJOINT a x)
     ==> (BIGUNION s DIFF a = BIGUNION (s DELETE a))``) THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, FORALL_IN_GSPEC, IN_DELETE] THEN
  SIMP_TAC std_ss [CONNECTED_COMPONENT_DISJOINT, CONNECTED_COMPONENT_EQ_EQ] THEN
  MESON_TAC[IN_DEF, SUBSET_DEF, CONNECTED_COMPONENT_SUBSET]);

val CLOSED_IN_CONNECTED_COMPONENT = store_thm ("CLOSED_IN_CONNECTED_COMPONENT",
 ``!s x:real. closed_in (subtopology euclidean s) (connected_component s x)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``connected_component s (x:real) = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_IN_EMPTY] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[CONNECTED_COMPONENT_EQ_EMPTY]) THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``closure(connected_component s x):real->bool`` THEN
  REWRITE_TAC[CLOSED_CLOSURE] THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  REWRITE_TAC[SUBSET_INTER, CONNECTED_COMPONENT_SUBSET, CLOSURE_SUBSET] THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN REWRITE_TAC[INTER_SUBSET] THEN
  CONJ_TAC THENL
   [ASM_REWRITE_TAC[IN_INTER] THEN
    MATCH_MP_TAC(REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET) THEN
    ASM_SIMP_TAC std_ss [IN_DEF, CONNECTED_COMPONENT_REFL_EQ],
    MATCH_MP_TAC CONNECTED_INTERMEDIATE_CLOSURE THEN
    EXISTS_TAC ``connected_component s (x:real)`` THEN
    SIMP_TAC std_ss [INTER_SUBSET, CONNECTED_CONNECTED_COMPONENT,
                SUBSET_INTER, CONNECTED_COMPONENT_SUBSET, CLOSURE_SUBSET]]);

val BIGUNION_DIFF = store_thm ("BIGUNION_DIFF",
 ``!s t. BIGUNION s DIFF t = BIGUNION {x DIFF t | x IN s}``,
  SIMP_TAC std_ss [BIGUNION_GSPEC] THEN SET_TAC[]);

val OPEN_IN_CONNECTED_COMPONENT = store_thm ("OPEN_IN_CONNECTED_COMPONENT",
 ``!s x:real.
        FINITE {connected_component s x |x| x IN s}
        ==> open_in (subtopology euclidean s) (connected_component s x)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``connected_component s (x:real) =
        s DIFF (BIGUNION {connected_component s y |y| y IN s} DIFF
                connected_component s x)``
  SUBST1_TAC THENL
   [REWRITE_TAC[BIGUNION_CONNECTED_COMPONENT] THEN
    MATCH_MP_TAC(SET_RULE ``t SUBSET s ==> (t = s DIFF (s DIFF t))``) THEN
    SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET],
    MATCH_MP_TAC OPEN_IN_DIFF THEN
    SIMP_TAC std_ss [OPEN_IN_SUBTOPOLOGY_REFL, TOPSPACE_EUCLIDEAN, SUBSET_UNIV] THEN
    SIMP_TAC std_ss [BIGUNION_DIFF] THEN
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
        CONJ_TAC THENL [METIS_TAC [GSYM IMAGE_DEF, IMAGE_FINITE], ALL_TAC] THEN
    X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    SUBGOAL_THEN
    ``(connected_component s y DIFF connected_component s x =
       connected_component s y) \/
      (connected_component s (y:real) DIFF connected_component s x = {})``
     (DISJ_CASES_THEN SUBST1_TAC)
    THENL
     [MATCH_MP_TAC(SET_RULE
       ``(~(s INTER t = {}) ==> (s = t)) ==> (s DIFF t = s) \/ (s DIFF t = {})``) THEN
      SIMP_TAC std_ss [CONNECTED_COMPONENT_OVERLAP],
      REWRITE_TAC[CLOSED_IN_CONNECTED_COMPONENT],
      REWRITE_TAC[CLOSED_IN_EMPTY]]]);

val CONNECTED_COMPONENT_EQUIVALENCE_RELATION = store_thm ("CONNECTED_COMPONENT_EQUIVALENCE_RELATION",
 ``!R s:real->bool.
        (!x y. R x y ==> R y x) /\
        (!x y z. R x y /\ R y z ==> R x z) /\
        (!a. a IN s
             ==> ?t. open_in (subtopology euclidean s) t /\ a IN t /\
                     !x. x IN t ==> R a x)
        ==> !a b. connected_component s a b ==> R a b``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``R:real->real->bool``, ``connected_component s (a:real)``]
    CONNECTED_EQUIVALENCE_RELATION) THEN
  ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
  KNOW_TAC ``(!(a' :real).
        a' IN connected_component (s :real -> bool) (a :real) ==>
        ?(t :real -> bool).
          open_in (subtopology euclidean (connected_component s a)) t /\
          a' IN t /\
          !(x :real). x IN t ==> (R :real -> real -> bool) a' x)`` THENL
   [X_GEN_TAC ``c:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``c:real``) THEN
    KNOW_TAC ``(c :real) IN (s :real -> bool)`` THENL
     [ASM_MESON_TAC[CONNECTED_COMPONENT_SUBSET, SUBSET_DEF],
          DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``t INTER connected_component s (a:real)`` THEN
    ASM_SIMP_TAC std_ss [IN_INTER, OPEN_IN_OPEN] THEN
        UNDISCH_TAC ``open_in (subtopology euclidean s) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    SIMP_TAC std_ss [] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``a:real``]
        CONNECTED_COMPONENT_SUBSET) THEN
    SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN MATCH_MP_TAC THEN ASM_SIMP_TAC std_ss [IN_DEF] THEN
    REWRITE_TAC[CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_MESON_TAC[CONNECTED_COMPONENT_IN]]);

val CONNECTED_COMPONENT_INTERMEDIATE_SUBSET = store_thm ("CONNECTED_COMPONENT_INTERMEDIATE_SUBSET",
 ``!t u a:real.
        connected_component u a SUBSET t /\ t SUBSET u
        ==> (connected_component t a = connected_component u a)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``(a:real) IN u`` THENL
   [REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_UNIQUE THEN
    ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
    CONJ_TAC THENL [ASM_MESON_TAC[CONNECTED_COMPONENT_REFL, IN_DEF], ALL_TAC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_SET_TAC[],
    ASM_MESON_TAC[CONNECTED_COMPONENT_EQ_EMPTY, SUBSET_DEF]]);

(* ------------------------------------------------------------------------- *)
(* The set of connected components of a set.                                 *)
(* ------------------------------------------------------------------------- *)

val components = new_definition ("components",
  ``components s = {connected_component s x | x | x:real IN s}``);

val IN_COMPONENTS = store_thm ("IN_COMPONENTS",
 ``!u:real->bool s. s IN components u
    <=> ?x. x IN u /\ (s = connected_component u x)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[components] THEN EQ_TAC
  THENL [SET_TAC[], STRIP_TAC THEN ASM_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``x:real IN u`` THEN SET_TAC[]]);

val BIGUNION_COMPONENTS = store_thm
  ("BIGUNION_COMPONENTS",
  ``!u:real->bool. u = BIGUNION (components u)``,
    REWRITE_TAC [EXTENSION]
 >> REPEAT GEN_TAC >> EQ_TAC
 >| [ (* goal 1 (of 2) *)
      DISCH_TAC >> REWRITE_TAC [IN_BIGUNION] \\
      EXISTS_TAC ``connected_component (u:real->bool) x`` \\
      CONJ_TAC >|
      [ REWRITE_TAC [CONNECTED_COMPONENT_SET] \\
        SUBGOAL_THEN ``?s:real->bool. connected s /\ s SUBSET u /\ x IN s`` MP_TAC >|
        [ EXISTS_TAC ``{x:real}`` \\
          ASM_REWRITE_TAC [CONNECTED_SING] \\
          POP_ASSUM MP_TAC >> SET_TAC [],
          SET_TAC [] ],
        REWRITE_TAC [components] >> ASM_SET_TAC [] ],
      (* goal 2 of 2 *)
      REWRITE_TAC [IN_BIGUNION] \\
      STRIP_TAC \\
      MATCH_MP_TAC (SET_RULE ``!x:real s u. x IN s /\ s SUBSET u ==> x IN u``) \\
      EXISTS_TAC ``s :real -> bool`` >> ASM_REWRITE_TAC [] \\
      `?(y :real). ((s :real -> bool) = connected_component u y)`
                by METIS_TAC [IN_COMPONENTS] \\
      ASM_REWRITE_TAC [CONNECTED_COMPONENT_SUBSET] ]);

val PAIRWISE_DISJOINT_COMPONENTS = store_thm ("PAIRWISE_DISJOINT_COMPONENTS",
 ``!u:real->bool. pairwise DISJOINT (components u)``,
  GEN_TAC THEN REWRITE_TAC[pairwise, DISJOINT_DEF] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``t:real->bool``] THEN STRIP_TAC THEN
  ASSERT_TAC ``(?a. s:real->bool = connected_component u a) /\
                ?b. t:real->bool = connected_component u b``
  THENL [ASM_MESON_TAC[IN_COMPONENTS],
  ASM_MESON_TAC[CONNECTED_COMPONENT_NONOVERLAP]]);

val IN_COMPONENTS_NONEMPTY = store_thm ("IN_COMPONENTS_NONEMPTY",
 ``!s c. c IN components s ==> ~(c = {})``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY]);

val IN_COMPONENTS_SUBSET = store_thm ("IN_COMPONENTS_SUBSET",
 ``!s c. c IN components s ==> c SUBSET s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_COMPONENT_SUBSET]);

val IN_COMPONENTS_CONNECTED = store_thm ("IN_COMPONENTS_CONNECTED",
 ``!s c. c IN components s ==> connected c``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT]);

val IN_COMPONENTS_MAXIMAL = store_thm ("IN_COMPONENTS_MAXIMAL",
 ``!s c:real->bool.
        c IN components s <=>
        ~(c = {}) /\ c SUBSET s /\ connected c /\
        !c'. ~(c' = {}) /\ c SUBSET c' /\ c' SUBSET s /\ connected c'
             ==> (c' = c)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [components, GSPECIFICATION] THEN EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``x:real`` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[CONNECTED_COMPONENT_EQ_EMPTY, CONNECTED_COMPONENT_SUBSET,
                    CONNECTED_CONNECTED_COMPONENT] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_MESON_TAC[CONNECTED_COMPONENT_REFL, IN_DEF, SUBSET_DEF],
    STRIP_TAC THEN
        UNDISCH_TAC ``(c:real->bool) <> {}`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
        STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN CONJ_TAC THENL
        [ALL_TAC, ASM_SET_TAC[]] THEN
    MATCH_MP_TAC(GSYM CONNECTED_COMPONENT_UNIQUE) THEN
    ASM_REWRITE_TAC[] THEN X_GEN_TAC ``c':real->bool`` THEN STRIP_TAC THEN
    REWRITE_TAC[SET_RULE ``c' SUBSET c <=> (c' UNION c = c)``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC CONNECTED_UNION THEN ASM_SET_TAC[]]);

val JOINABLE_COMPONENTS_EQ = store_thm ("JOINABLE_COMPONENTS_EQ",
 ``!s t c1 c2.
        connected t /\ t SUBSET s /\
        c1 IN components s /\ c2 IN components s /\
        ~(c1 INTER t = {}) /\ ~(c2 INTER t = {})
        ==> (c1 = c2)``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, components, FORALL_IN_GSPEC] THEN
  MESON_TAC[JOINABLE_CONNECTED_COMPONENT_EQ]);

val CLOSED_IN_COMPONENT = store_thm ("CLOSED_IN_COMPONENT",
 ``!s c:real->bool.
        c IN components s ==> closed_in (subtopology euclidean s) c``,
  SIMP_TAC std_ss [components, FORALL_IN_GSPEC, CLOSED_IN_CONNECTED_COMPONENT]);

val CLOSED_COMPONENTS = store_thm ("CLOSED_COMPONENTS",
 ``!s c. closed s /\ c IN components s ==> closed c``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, components, FORALL_IN_GSPEC] THEN
  SIMP_TAC std_ss [CLOSED_CONNECTED_COMPONENT]);

val COMPACT_COMPONENTS = store_thm ("COMPACT_COMPONENTS",
 ``!s c:real->bool. compact s /\ c IN components s ==> compact c``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN
  MESON_TAC[CLOSED_COMPONENTS, IN_COMPONENTS_SUBSET, BOUNDED_SUBSET]);

val CONTINUOUS_ON_COMPONENTS_GEN = store_thm ("CONTINUOUS_ON_COMPONENTS_GEN",
 ``!f:real->real s.
        (!c. c IN components s
             ==> open_in (subtopology euclidean s) c /\ f continuous_on c)
        ==> f continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_OPEN_IN_PREIMAGE_EQ] THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN t} =
     BIGUNION {{x | x IN c /\ f x IN t} | c IN components s}``
  SUBST1_TAC THENL
   [GEN_REWR_TAC LAND_CONV [METIS [BIGUNION_COMPONENTS] ``{x | x IN s /\ f x IN t} =
          {x | x IN BIGUNION (components s) /\ f x IN t}``] THEN
    SIMP_TAC std_ss [BIGUNION_GSPEC, IN_BIGUNION] THEN SET_TAC[],
    MATCH_MP_TAC OPEN_IN_BIGUNION THEN SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
    METIS_TAC[OPEN_IN_TRANS]]);

val CONTINUOUS_ON_COMPONENTS_FINITE = store_thm ("CONTINUOUS_ON_COMPONENTS_FINITE",
 ``!f:real->real s.
        FINITE(components s) /\
        (!c. c IN components s ==> f continuous_on c)
        ==> f continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
  DISCH_TAC THEN X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``{x | x IN s /\ (f:real->real) x IN t} =
    BIGUNION {{x | x IN c /\ f x IN t} | c IN components s}``
  SUBST1_TAC THENL
   [GEN_REWR_TAC LAND_CONV [METIS [BIGUNION_COMPONENTS] ``{x | x IN s /\ f x IN t} =
          {x | x IN BIGUNION (components s) /\ f x IN t}``] THEN
    SIMP_TAC std_ss [BIGUNION_GSPEC, IN_BIGUNION] THEN SET_TAC[],
    MATCH_MP_TAC CLOSED_IN_BIGUNION THEN
    ASM_SIMP_TAC std_ss [GSYM IMAGE_DEF, IMAGE_FINITE, FORALL_IN_IMAGE] THEN
    METIS_TAC[CLOSED_IN_TRANS, CLOSED_IN_COMPONENT]]);

val COMPONENTS_NONOVERLAP = store_thm ("COMPONENTS_NONOVERLAP",
 ``!s c c'. c IN components s /\ c' IN components s
            ==> ((c INTER c' = {}) <=> ~(c = c'))``,
  SIMP_TAC std_ss [components, GSPECIFICATION] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_NONOVERLAP]);

val COMPONENTS_EQ = store_thm ("COMPONENTS_EQ",
 ``!s c c'. c IN components s /\ c' IN components s
            ==> ((c = c') <=> ~(c INTER c' = {}))``,
  MESON_TAC[COMPONENTS_NONOVERLAP]);

val COMPONENTS_EQ_EMPTY = store_thm ("COMPONENTS_EQ_EMPTY",
 ``!s. (components s = {}) <=> (s = {})``,
  GEN_TAC THEN REWRITE_TAC[EXTENSION] THEN
  SIMP_TAC std_ss [components, connected_component, GSPECIFICATION] THEN
  SET_TAC[]);

val COMPONENTS_EMPTY = store_thm ("COMPONENTS_EMPTY",
 ``components {} = {}``,
  REWRITE_TAC[COMPONENTS_EQ_EMPTY]);

val CONNECTED_EQ_CONNECTED_COMPONENTS_EQ = store_thm ("CONNECTED_EQ_CONNECTED_COMPONENTS_EQ",
 ``!s. connected s <=>
       !c c'. c IN components s /\ c' IN components s ==> (c = c')``,
  SIMP_TAC std_ss [components, GSPECIFICATION] THEN
  MESON_TAC[CONNECTED_EQ_CONNECTED_COMPONENT_EQ]);

val COMPONENTS_EQ_SING_N_EXISTS = store_thm ("COMPONENTS_EQ_SING_N_EXISTS",
 ``(!s:real->bool. (components s = {s}) <=> connected s /\ ~(s = {})) /\
   (!s:real->bool. (?a. (components s = {a})) <=> connected s /\ ~(s = {}))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN X_GEN_TAC ``s:real->bool`` THEN
  MATCH_MP_TAC(TAUT `(p ==> q) /\ (q ==> r) /\ (r ==> p)
                     ==> (p <=> r) /\ (q <=> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[],
    STRIP_TAC THEN ASM_REWRITE_TAC[CONNECTED_EQ_CONNECTED_COMPONENTS_EQ] THEN
    ASM_MESON_TAC[IN_SING, COMPONENTS_EQ_EMPTY, NOT_INSERT_EMPTY],
    STRIP_TAC THEN ONCE_REWRITE_TAC[EXTENSION] THEN
    REWRITE_TAC[IN_SING] THEN
    SIMP_TAC std_ss [components, GSPECIFICATION] THEN
    ASM_MESON_TAC[CONNECTED_CONNECTED_COMPONENT_SET, MEMBER_NOT_EMPTY]]);

val COMPONENTS_EQ_SING = store_thm ("COMPONENTS_EQ_SING",
 ``(!s:real->bool. (components s = {s}) <=> connected s /\ ~(s = {}))``,
   REWRITE_TAC [COMPONENTS_EQ_SING_N_EXISTS]);

val COMPONENTS_EQ_SING_EXISTS = store_thm ("COMPONENTS_EQ_SING_EXISTS",
 `` (!s:real->bool. (?a. (components s = {a})) <=> connected s /\ ~(s = {}))``,
   REWRITE_TAC [COMPONENTS_EQ_SING_N_EXISTS]);

val COMPONENTS_UNIV = store_thm ("COMPONENTS_UNIV",
 ``components univ(:real) = {univ(:real)}``,
  REWRITE_TAC[COMPONENTS_EQ_SING, CONNECTED_UNIV, UNIV_NOT_EMPTY]);

val CONNECTED_EQ_COMPONENTS_SUBSET_SING = store_thm ("CONNECTED_EQ_COMPONENTS_SUBSET_SING",
 ``!s:real->bool. connected s <=> components s SUBSET {s}``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[COMPONENTS_EMPTY, CONNECTED_EMPTY, EMPTY_SUBSET] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET {a} <=> (s = {}) \/ (s = {a})``] THEN
  ASM_REWRITE_TAC[COMPONENTS_EQ_EMPTY, COMPONENTS_EQ_SING]);

val CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS = store_thm ("CONNECTED_EQ_COMPONENTS_SUBSET_SING_EXISTS",
 ``!s:real->bool. connected s <=> ?a. components s SUBSET {a}``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[COMPONENTS_EMPTY, CONNECTED_EMPTY, EMPTY_SUBSET] THEN
  REWRITE_TAC[SET_RULE ``s SUBSET {a} <=> (s = {}) \/ (s = {a})``] THEN
  ASM_REWRITE_TAC[COMPONENTS_EQ_EMPTY, COMPONENTS_EQ_SING_EXISTS]);

val IN_COMPONENTS_SELF = store_thm ("IN_COMPONENTS_SELF",
 ``!s:real->bool. s IN components s <=> connected s /\ ~(s = {})``,
  GEN_TAC THEN EQ_TAC THENL
   [MESON_TAC[IN_COMPONENTS_NONEMPTY, IN_COMPONENTS_CONNECTED],
    SIMP_TAC std_ss [GSYM COMPONENTS_EQ_SING, IN_SING]]);

val     COMPONENTS_MAXIMAL = store_thm ("COMPONENTS_MAXIMAL",
 ``!s t c:real->bool.
     c IN components s /\ connected t /\ t SUBSET s /\ ~(c INTER t = {})
     ==> t SUBSET c``,
  SIMP_TAC std_ss [CONJ_EQ_IMP, components, FORALL_IN_GSPEC] THEN
  REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  SIMP_TAC std_ss [IN_INTER, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(SUBST1_TAC o SYM o MATCH_MP CONNECTED_COMPONENT_EQ) THEN
  MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN ASM_REWRITE_TAC[]);

val COMPONENTS_UNIQUE = store_thm ("COMPONENTS_UNIQUE",
 ``!s:real->bool k.
        (BIGUNION k = s) /\
        (!c. c IN k
             ==> connected c /\ ~(c = {}) /\
                 !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c))
        ==> (components s = k)``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC I [EXTENSION] THEN
  X_GEN_TAC ``c:real->bool`` THEN REWRITE_TAC[IN_COMPONENTS] THEN
  EQ_TAC THENL
   [DISCH_THEN(X_CHOOSE_THEN ``x:real``
     (CONJUNCTS_THEN2 ASSUME_TAC SUBST1_TAC)) THEN
        UNDISCH_TAC `` !c. c IN k ==>
            connected c /\ c <> {} /\
            !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c)`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o SPEC ``x:real`` o REWRITE_RULE [EXTENSION]) THEN
    REWRITE_TAC[IN_BIGUNION] THEN ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC ``c:real->bool`` THEN STRIP_TAC THEN
    SUBGOAL_THEN ``connected_component s (x:real) = c``
     (fn th => ASM_REWRITE_TAC[th]) THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_UNIQUE THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    X_GEN_TAC ``c':real->bool`` THEN STRIP_TAC THEN
    REWRITE_TAC[SET_RULE ``c' SUBSET c <=> (c' UNION c = c)``] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN CONJ_TAC THENL
     [MATCH_MP_TAC CONNECTED_UNION, ASM_SET_TAC[]] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``c:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
        UNDISCH_TAC ``c <> {}:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
        STRIP_TAC THEN EXISTS_TAC ``x:real`` THEN
    CONJ_TAC THENL [ASM_SET_TAC[], CONV_TAC SYM_CONV] THEN
    FIRST_X_ASSUM MATCH_MP_TAC THEN
    REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT, CONNECTED_COMPONENT_SUBSET] THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]]);

val COMPONENTS_UNIQUE_EQ = store_thm ("COMPONENTS_UNIQUE_EQ",
 ``!s:real->bool k.
        (components s = k) <=>
        (BIGUNION k = s) /\
        (!c. c IN k
             ==> connected c /\ ~(c = {}) /\
                 !c'. connected c' /\ c SUBSET c' /\ c' SUBSET s ==> (c' = c))``,
  REPEAT GEN_TAC THEN EQ_TAC THENL
   [DISCH_THEN(SUBST1_TAC o SYM), REWRITE_TAC[COMPONENTS_UNIQUE]] THEN
  REWRITE_TAC[GSYM BIGUNION_COMPONENTS] THEN
  X_GEN_TAC ``c:real->bool`` THEN DISCH_TAC THEN REPEAT CONJ_TAC THENL
   [ASM_MESON_TAC[IN_COMPONENTS_CONNECTED],
    ASM_MESON_TAC[IN_COMPONENTS_NONEMPTY],
    RULE_ASSUM_TAC(REWRITE_RULE[IN_COMPONENTS_MAXIMAL]) THEN
    ASM_MESON_TAC[SUBSET_EMPTY]]);

val EXISTS_COMPONENT_SUPERSET = store_thm ("EXISTS_COMPONENT_SUPERSET",
 ``!s t:real->bool.
        t SUBSET s /\ ~(s = {}) /\ connected t
        ==> ?c. c IN components s /\ t SUBSET c``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [ASM_REWRITE_TAC[EMPTY_SUBSET] THEN
    ASM_MESON_TAC[COMPONENTS_EQ_EMPTY, MEMBER_NOT_EMPTY],
    FIRST_X_ASSUM(X_CHOOSE_TAC ``a:real`` o
      REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    EXISTS_TAC ``connected_component s (a:real)`` THEN
    REWRITE_TAC[IN_COMPONENTS] THEN CONJ_TAC THENL
     [ASM_SET_TAC[], ASM_MESON_TAC[CONNECTED_COMPONENT_MAXIMAL]]]);

val COMPONENTS_INTERMEDIATE_SUBSET = store_thm ("COMPONENTS_INTERMEDIATE_SUBSET",
 ``!s t u:real->bool.
        s IN components u /\ s SUBSET t /\ t SUBSET u
        ==> s IN components t``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [IN_COMPONENTS, GSYM LEFT_EXISTS_AND_THM] THEN
  MESON_TAC[CONNECTED_COMPONENT_INTERMEDIATE_SUBSET, SUBSET_DEF,
            CONNECTED_COMPONENT_REFL, IN_DEF, CONNECTED_COMPONENT_SUBSET]);

val IN_COMPONENTS_BIGUNION_COMPLEMENT = store_thm ("IN_COMPONENTS_BIGUNION_COMPLEMENT",
 ``!s c:real->bool.
        c IN components s
        ==> (s DIFF c = BIGUNION(components s DELETE c))``,
  SIMP_TAC std_ss [components, FORALL_IN_GSPEC,
              COMPLEMENT_CONNECTED_COMPONENT_BIGUNION]);

val CONNECTED_SUBSET_CLOPEN = store_thm ("CONNECTED_SUBSET_CLOPEN",
 ``!u s c:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s /\
        connected c /\ c SUBSET u /\ ~(c INTER s = {})
        ==> c SUBSET s``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected c`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CONNECTED_CLOSED_IN]) THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN DISCH_THEN(MP_TAC o
    SPECL [``c INTER s:real->bool``, ``c DIFF s:real->bool``]) THEN
  KNOW_TAC ``~((((closed_in (subtopology euclidean (c :real -> bool))
               (c INTER (s :real -> bool)) /\
               closed_in (subtopology euclidean c) (c DIFF s)) /\
               (c SUBSET c INTER s UNION (c DIFF s))) /\
               (c INTER s INTER (c DIFF s) = ({} :real -> bool))) /\
     ~(c SUBSET s)) ==> c SUBSET s`` THENL
         [ALL_TAC, METIS_TAC [CONJ_ASSOC, SET_RULE ``(c DIFF s = {}) <=> c SUBSET s``]] THEN
  MATCH_MP_TAC(TAUT `p ==> ~(p /\ ~q) ==> q`) THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  CONJ_TAC THENL
   [UNDISCH_TAC ``closed_in (subtopology euclidean u) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [CLOSED_IN_CLOSED]),
        UNDISCH_TAC ``open_in (subtopology euclidean u) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN])] THEN
  DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[OPEN_IN_OPEN, CLOSED_IN_CLOSED] THENL
   [EXISTS_TAC ``t:real->bool``, EXISTS_TAC ``univ(:real) DIFF t``] THEN
  ASM_REWRITE_TAC[GSYM OPEN_CLOSED] THEN ASM_SET_TAC[]);

val CLOPEN_BIGUNION_COMPONENTS = store_thm ("CLOPEN_BIGUNION_COMPONENTS",
 ``!u s:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s
        ==> ?k. k SUBSET components u /\ (s = BIGUNION k)``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``{c:real->bool | c IN components u /\ ~(c INTER s = {})}`` THEN
  SIMP_TAC std_ss [SUBSET_RESTRICT] THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  CONJ_TAC THENL
   [MP_TAC(ISPEC ``u:real->bool`` BIGUNION_COMPONENTS) THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN SET_TAC[],
    SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC CONNECTED_SUBSET_CLOPEN THEN
    EXISTS_TAC ``u:real->bool`` THEN
    ASM_MESON_TAC[IN_COMPONENTS_CONNECTED, IN_COMPONENTS_SUBSET]]);

val CLOPEN_IN_COMPONENTS = store_thm ("CLOPEN_IN_COMPONENTS",
 ``!u s:real->bool.
        closed_in (subtopology euclidean u) s /\
        open_in (subtopology euclidean u) s /\
        connected s /\ ~(s = {})
        ==> s IN components u``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[CONJ_ASSOC] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CLOPEN_BIGUNION_COMPONENTS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``k:(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  ASM_CASES_TAC ``k:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGUNION_EMPTY] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``c:real->bool``) THEN
  ASM_CASES_TAC ``k = {c:real->bool}`` THENL
   [METIS_TAC[BIGUNION_SING, GSYM SING_SUBSET], ALL_TAC] THEN
  MATCH_MP_TAC(TAUT `~p ==> p /\ q ==> r`) THEN
  SUBGOAL_THEN ``?c':real->bool. c' IN k /\ ~(c = c')`` STRIP_ASSUME_TAC THENL
   [ASM_MESON_TAC[SET_RULE
     ``a IN s /\ ~(s = {a}) ==> ?b. b IN s /\ ~(b = a)``],
    REWRITE_TAC[CONNECTED_EQ_CONNECTED_COMPONENTS_EQ] THEN
    DISCH_THEN(MP_TAC o SPECL [``c:real->bool``, ``c':real->bool``]) THEN
    ASM_REWRITE_TAC[NOT_IMP] THEN CONJ_TAC THEN
    MATCH_MP_TAC COMPONENTS_INTERMEDIATE_SUBSET THEN
    EXISTS_TAC ``u:real->bool`` THEN
    MP_TAC(ISPEC ``u:real->bool`` BIGUNION_COMPONENTS) THEN ASM_SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Continuity implies uniform continuity on a compact domain.                *)
(* ------------------------------------------------------------------------- *)

val COMPACT_UNIFORMLY_EQUICONTINUOUS = store_thm ("COMPACT_UNIFORMLY_EQUICONTINUOUS",
 ``!(fs:(real->real)->bool) s.
     (!x e. x IN s /\ &0 < e
            ==> ?d. &0 < d /\
                    (!f x'. f IN fs /\ x' IN s /\ dist (x',x) < d
                            ==> dist (f x',f x) < e)) /\
     compact s
     ==> !e. &0 < e
             ==> ?d. &0 < d /\
                     !f x x'. f IN fs /\ x IN s /\ x' IN s /\ dist (x',x) < d
                              ==> dist(f x',f x) < e``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``d:real->real->real`` THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o MATCH_MP HEINE_BOREL_LEMMA) THEN
  DISCH_THEN(MP_TAC o SPEC
    ``{ ball(x:real,d x (e / &2:real)) | x IN s}``) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, OPEN_BALL, BIGUNION_GSPEC, SUBSET_DEF, GSPECIFICATION] THEN
  KNOW_TAC ``(!(x :real).
        x IN (s :real -> bool) ==>
        ?(x' :real).
          x' IN s /\
          x IN
          ball
            (x',
             (d :real -> real -> real) x'
               ((e :real) / (2 :real))))`` THENL
  [ASM_MESON_TAC[CENTRE_IN_BALL, REAL_HALF], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``k:real``) THEN EXISTS_TAC ``k:real`` THEN
  POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  MAP_EVERY X_GEN_TAC [``f:real->real``, ``u:real``, ``v:real``] THEN
  STRIP_TAC THEN FIRST_X_ASSUM(fn th => MP_TAC(SPEC ``v:real`` th) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(CHOOSE_THEN MP_TAC)) THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN(fn th =>
    MP_TAC(SPEC ``u:real`` th) THEN MP_TAC(SPEC ``v:real`` th)) THEN
  ASM_SIMP_TAC std_ss [DIST_REFL] THEN POP_ASSUM MP_TAC THEN
  DISCH_THEN (X_CHOOSE_TAC ``w:real``) THEN ASM_REWRITE_TAC [] THEN
  ASM_REWRITE_TAC[CENTRE_IN_BALL] THEN ASM_REWRITE_TAC[IN_BALL] THEN
  ONCE_REWRITE_TAC[DIST_SYM] THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real``, ``e / &2:real``]) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(MP_TAC o SPEC ``f:real->real`` o CONJUNCT2) THEN
  DISCH_THEN(fn th => MP_TAC(SPEC ``u:real`` th) THEN
                        MP_TAC(SPEC ``v:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN GEN_REWR_TAC (LAND_CONV o LAND_CONV) [DIST_SYM] THEN
  REWRITE_TAC [dist] THEN GEN_REWR_TAC (RAND_CONV o RAND_CONV o RAND_CONV) [GSYM REAL_HALF] THEN
  REAL_ARITH_TAC);

val COMPACT_UNIFORMLY_CONTINUOUS = store_thm ("COMPACT_UNIFORMLY_CONTINUOUS",
 ``!f:real->real s.
        f continuous_on s /\ compact s ==> f uniformly_continuous_on s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous_on, uniformly_continuous_on] THEN
  STRIP_TAC THEN
  MP_TAC(ISPECL [``{f:real->real}``, ``s:real->bool``]
        COMPACT_UNIFORMLY_EQUICONTINUOUS) THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP, IN_SING, UNWIND_FORALL_THM2] THEN
  ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* A uniformly convergent limit of continuous functions is continuous.       *)
(* ------------------------------------------------------------------------- *)

val ABS_TRIANGLE_LE = store_thm ("ABS_TRIANGLE_LE",
 ``!x y. abs(x) + abs(y) <= e ==> abs(x + y) <= e:real``,
  METIS_TAC[REAL_LE_TRANS, ABS_TRIANGLE]);

val CONTINUOUS_UNIFORM_LIMIT = store_thm ("CONTINUOUS_UNIFORM_LIMIT",
 ``!net f:'a->real->real g s.
        ~(trivial_limit net) /\
        eventually (\n. (f n) continuous_on s) net /\
        (!e. &0 < e
             ==> eventually (\n. !x. x IN s ==> abs(f n x - g x) < e) net)
        ==> g continuous_on s``,
  REWRITE_TAC[continuous_on] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  X_GEN_TAC ``x:real`` THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &3:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  UNDISCH_TAC ``eventually
        (\n. !x. x IN s ==>
             !e. 0 < e ==>
               ?d. 0 < d /\
                 !x'. x' IN s /\ dist (x',x) < d ==>
                   dist (f n x',f n x) < e) net`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th => MP_TAC th THEN REWRITE_TAC[AND_IMP_INTRO] THEN
        GEN_REWR_TAC LAND_CONV [GSYM EVENTUALLY_AND]) THEN
  DISCH_THEN(MP_TAC o MATCH_MP EVENTUALLY_HAPPENS) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``a:'a`` THEN
  DISCH_THEN(CONJUNCTS_THEN2 (MP_TAC o SPEC ``x:real``) ASSUME_TAC) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``e / &3:real``) THEN
  ASM_SIMP_TAC arith_ss [REAL_LT_DIV, REAL_LT] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN POP_ASSUM (MP_TAC o Q.SPEC `y:real`) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(fn th =>
   MP_TAC(SPEC ``x:real`` th) THEN MP_TAC(SPEC ``y:real`` th)) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 3:real``] THEN
  MATCH_MP_TAC(REAL_ARITH ``w <= x + y + z
    ==> x * &3 < e ==> y * &3 < e ==> z * &3 < e ==> w < e:real``) THEN
  REWRITE_TAC[dist] THEN
  SUBST1_TAC(REAL_ARITH
   ``(g:real->real) y - g x =
    -(f (a:'a) y - g y) + (f a x - g x) + (f a y - f a x)``) THEN
  MATCH_MP_TAC ABS_TRIANGLE_LE THEN SIMP_TAC std_ss [ABS_NEG, REAL_LE_LADD] THEN
  MATCH_MP_TAC REAL_LE_ADD2 THEN SIMP_TAC std_ss [REAL_LE_REFL] THEN
  MATCH_MP_TAC ABS_TRIANGLE_LE THEN REWRITE_TAC[ABS_NEG, REAL_LE_REFL]);

(* ------------------------------------------------------------------------- *)
(* Topological stuff lifted from and dropped to R                            *)
(* ------------------------------------------------------------------------- *)

val OPEN = store_thm ("OPEN",
 ``!s. open s <=>
        !x. x IN s ==> ?e. &0 < e /\ !x'. abs(x' - x) < e ==> x' IN s``,
  REWRITE_TAC[open_def, dist]);

val CLOSED = store_thm ("CLOSED",
 ``!s. closed s <=>
        !x. (!e. &0 < e ==> ?x'. x' IN s /\ ~(x' = x) /\ abs(x' - x) < e)
            ==> x IN s``,
   SIMP_TAC std_ss [open_def, closed_def, dist, IN_DIFF, IN_UNIV] THEN
   SET_TAC []);

val CONTINUOUS_AT_RANGE = store_thm ("CONTINUOUS_AT_RANGE",
 ``!f x. f continuous (at x) <=>
                !e. &0 < e
                    ==> ?d. &0 < d /\
                            (!x'. abs(x' - x) < d
                                  ==> abs(f x' - f x) < e)``,
  REWRITE_TAC[continuous_at, o_THM, dist] THEN REWRITE_TAC[dist]);

val CONTINUOUS_ON_RANGE = store_thm ("CONTINUOUS_ON_RANGE",
 ``!f s. f continuous_on s <=>
         !x. x IN s
             ==> !e. &0 < e
                     ==> ?d. &0 < d /\
                             (!x'. x' IN s /\ abs(x' - x) < d
                                   ==> abs(f x' - f x) < e)``,
  REWRITE_TAC[continuous_on, o_THM, dist] THEN REWRITE_TAC[dist]);

val CONTINUOUS_ABS_COMPOSE = store_thm ("CONTINUOUS_ABS_COMPOSE",
 ``!net f:'a->real.
        f continuous net
        ==> (\x. abs(f x)) continuous net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[continuous, tendsto] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `e:real`) THEN
  MATCH_MP_TAC MONO_IMP THEN
  REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] EVENTUALLY_MONO) THEN
  SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_ON_ABS_COMPOSE = store_thm ("CONTINUOUS_ON_ABS_COMPOSE",
 ``!f:real->real s.
        f continuous_on s
        ==> (\x. abs(f x)) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_ABS_COMPOSE]);

val CONTINUOUS_AT_ABS = store_thm ("CONTINUOUS_AT_ABS",
 ``!x. abs continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT_RANGE] THEN
  METIS_TAC [ABS_SUB_ABS, REAL_LET_TRANS]);

val CONTINUOUS_AT_DIST = store_thm ("CONTINUOUS_AT_DIST",
 ``!a:real x. (\x. dist(a,x)) continuous (at x)``,
  REWRITE_TAC[CONTINUOUS_AT_RANGE, dist] THEN
  METIS_TAC[REAL_ARITH ``abs(abs(a:real - x) - abs(a - y)) <= abs(x - y)``,
            REAL_LET_TRANS]);

val CONTINUOUS_ON_DIST = store_thm ("CONTINUOUS_ON_DIST",
 ``!a s. (\x. dist(a,x)) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_RANGE, dist] THEN
  METIS_TAC [REAL_ARITH ``abs(abs(a:real - x) - abs(a - y)) <= abs(x - y)``,
            REAL_LET_TRANS]);

(* ------------------------------------------------------------------------- *)
(* Hence some handy theorems on distance, diameter etc. of/from a set.       *)
(* ------------------------------------------------------------------------- *)

val COMPACT_ATTAINS_SUP = store_thm ("COMPACT_ATTAINS_SUP",
 ``!s. compact s /\ ~(s = {})
       ==> ?x. x IN s /\ !y. y IN s ==> y <= x``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``s:real->bool`` BOUNDED_HAS_SUP) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``sup (s:real->bool)`` THEN ASM_SIMP_TAC std_ss [] THEN
  METIS_TAC [CLOSED, REAL_ARITH ``s <= s - e <=> ~(&0 < e:real)``,
             REAL_ARITH ``x <= s /\ ~(x <= s - e) ==> abs(x - s) < e:real``]);

val COMPACT_ATTAINS_INF = store_thm ("COMPACT_ATTAINS_INF",
 ``!s. compact s /\ ~(s = {})
       ==> ?x. x IN s /\ !y. y IN s ==> x <= y``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED] THEN REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``s:real->bool`` BOUNDED_HAS_INF) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``inf (s:real->bool)`` THEN ASM_REWRITE_TAC[] THEN
  METIS_TAC[ CLOSED, REAL_ARITH ``s + e <= s <=> ~(&0 < e:real)``,
                REAL_ARITH ``s <= x /\ ~(s + e <= x) ==> abs(x - s) < e:real``]);

val CONTINUOUS_ATTAINS_SUP = store_thm ("CONTINUOUS_ATTAINS_SUP",
 ``!f:real->real s.
        compact s /\ ~(s = {}) /\ (f) continuous_on s
        ==> ?x. x IN s /\ !y. y IN s ==> f(y) <= f(x)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``IMAGE (f:real->real) s`` COMPACT_ATTAINS_SUP) THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, COMPACT_CONTINUOUS_IMAGE, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[IN_IMAGE]);

val CONTINUOUS_ATTAINS_INF = store_thm ("CONTINUOUS_ATTAINS_INF",
 ``!f:real->real s.
        compact s /\ ~(s = {}) /\ (f) continuous_on s
        ==> ?x. x IN s /\ !y. y IN s ==> f(x) <= f(y)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPEC ``IMAGE (f:real->real) s`` COMPACT_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, COMPACT_CONTINUOUS_IMAGE, IMAGE_EQ_EMPTY] THEN
  MESON_TAC[IN_IMAGE]);

val DISTANCE_ATTAINS_SUP = store_thm ("DISTANCE_ATTAINS_SUP",
 ``!s a. compact s /\ ~(s = {})
         ==> ?x. x IN s /\ !y. y IN s ==> dist(a,y) <= dist(a,x)``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (a,x) = (\x. dist (a,x)) x:real``] THEN
  MATCH_MP_TAC CONTINUOUS_ATTAINS_SUP THEN
  ASM_REWRITE_TAC[CONTINUOUS_ON_RANGE] THEN REWRITE_TAC[dist] THEN
  ASM_MESON_TAC[REAL_LET_TRANS, ABS_SUB_ABS, ABS_NEG,
                REAL_ARITH ``(a - x) - (a - y) = -(x - y):real``]);

(* ------------------------------------------------------------------------- *)
(* For *minimal* distance, we only need closure, not compactness.            *)
(* ------------------------------------------------------------------------- *)

val DISTANCE_ATTAINS_INF = store_thm ("DISTANCE_ATTAINS_INF",
 ``!s a:real.
        closed s /\ ~(s = {})
        ==> ?x. x IN s /\ !y. y IN s ==> dist(a,x) <= dist(a,y)``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  DISCH_THEN(X_CHOOSE_TAC ``b:real``) THEN
  MP_TAC(ISPECL [``\x:real. dist(a,x)``, ``cball(a:real,dist(b,a)) INTER s``]
                CONTINUOUS_ATTAINS_INF) THEN
  KNOW_TAC ``compact
   (cball ((a :real),(dist ((b :real),a) :real)) INTER
    (s :real -> bool)) /\
    cball (a,(dist (b,a) :real)) INTER s <> ({} :real -> bool) /\
    (\(x :real). (dist (a,x) :real)) continuous_on
    cball (a,(dist (b,a) :real)) INTER s`` THENL
   [ASM_SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_INTER, BOUNDED_INTER,
                 BOUNDED_CBALL, CLOSED_CBALL, GSYM MEMBER_NOT_EMPTY] THEN
    SIMP_TAC std_ss [dist, CONTINUOUS_ON_RANGE, IN_INTER, IN_CBALL] THEN
    METIS_TAC[REAL_LET_TRANS, ABS_SUB_ABS, ABS_NEG, REAL_LE_REFL,
            ABS_SUB, REAL_ARITH ``(a - x) - (a - y) = -(x - y:real):real``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``x:real``) THEN EXISTS_TAC ``x:real`` THEN
    POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, IN_CBALL] THEN
    METIS_TAC[DIST_SYM, REAL_LE_TOTAL, REAL_LE_TRANS]]);

(* ------------------------------------------------------------------------- *)
(* We can now extend limit compositions to consider the scalar multiplier.   *)
(* ------------------------------------------------------------------------- *)

val LIM_MUL = store_thm ("LIM_MUL",
 ``!net:('a)net f l:real c d.
        (c --> d) net /\ (f --> l) net
        ==> ((\x. c(x) * f(x)) --> (d * l)) net``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``net:('a)net``, ``\x y:real. x * y``, ``c:'a->real``,
  ``f:'a->real``, ``d:real``, ``l:real``] LIM_BILINEAR) THEN
  BETA_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_THEN MATCH_MP_TAC THEN
  REWRITE_TAC[bilinear, linear] THEN BETA_TAC THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val LIM_VMUL = store_thm ("LIM_VMUL",
 ``!net:('a)net c d v:real.
  (c --> d) net ==> ((\x. c(x) * v) --> (d * v)) net``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``(((\(x :'a). (c :'a -> real) x * (v :real)) -->
                             ((d :real) * v)) (net :'a net)) =
             (((\(x :'a). (c :'a -> real) x * (\x. v :real) x) -->
                             ((d :real) * v)) (net :'a net))`` THENL
 [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
 MATCH_MP_TAC LIM_MUL THEN ASM_REWRITE_TAC[LIM_CONST]);

val CONTINUOUS_VMUL = store_thm ("CONTINUOUS_VMUL",
 ``!net c v. c continuous net ==> (\x. c(x) * v) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_VMUL, o_THM]);

val CONTINUOUS_MUL = store_thm ("CONTINUOUS_MUL",
 ``!net f c. c continuous net /\ f continuous net
             ==> (\x. c(x) * f(x)) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_MUL, o_THM]);

val CONTINUOUS_ON_VMUL = store_thm ("CONTINUOUS_ON_VMUL",
 ``!s c v. c continuous_on s ==> (\x. c(x) * v) continuous_on s``,
  REWRITE_TAC [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  SIMP_TAC std_ss [CONTINUOUS_VMUL]);

val CONTINUOUS_ON_MUL = store_thm ("CONTINUOUS_ON_MUL",
 ``!s c f. c continuous_on s /\ f continuous_on s
           ==> (\x. c(x) * f(x)) continuous_on s``,
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  SIMP_TAC std_ss [CONTINUOUS_MUL]);

val CONTINUOUS_POW = store_thm ("CONTINUOUS_POW",
 ``!net f:'a->real n.
        (\x. f x) continuous net
        ==> (\x. f x pow n) continuous net``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  INDUCT_TAC THEN ASM_SIMP_TAC std_ss [pow, CONTINUOUS_CONST] THEN
  KNOW_TAC ``((\x:'a. f x * f x pow n) continuous net) =
             ((\x:'a. f x * (\x. f x pow n) x)  continuous net)`` THENL
  [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC CONTINUOUS_MUL THEN METIS_TAC [o_DEF, ETA_AX]);

val CONTINUOUS_ON_POW = store_thm ("CONTINUOUS_ON_POW",
 ``!f:real->real s n.
        (\x. f x) continuous_on s
        ==> (\x. f x pow n) continuous_on s``,
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM] THEN REPEAT GEN_TAC THEN
  DISCH_TAC THEN INDUCT_TAC THEN
  ASM_SIMP_TAC std_ss[pow, CONTINUOUS_ON_CONST] THEN
  KNOW_TAC ``((\x. (f:real->real) x * f x pow n) continuous_on s:real->bool) =
             ((\x. f x * (\x. f x pow n) x)  continuous_on s)`` THENL
  [SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN METIS_TAC [o_DEF, ETA_AX]);

val CONTINUOUS_PRODUCT = store_thm ("CONTINUOUS_PRODUCT",
 ``!net:('a)net f (t:'b->bool).
        FINITE t /\
        (!i. i IN t ==> (\x. (f x i)) continuous net)
        ==> (\x. (product t (f x))) continuous net``,
  GEN_TAC THEN GEN_TAC THEN REWRITE_TAC[CONJ_EQ_IMP] THEN
  ONCE_REWRITE_TAC [METIS []
    ``!t. ((!i. i IN t ==> (\x. f x i) continuous net) ==>
  (\x. product t (f x)) continuous net) =
     (\t. (!i. i IN t ==> (\x. f x i) continuous net) ==>
  (\x. product t (f x)) continuous net) t``] THEN
  MATCH_MP_TAC FINITE_INDUCT THEN BETA_TAC THEN SIMP_TAC std_ss [PRODUCT_CLAUSES] THEN
  SIMP_TAC std_ss [CONTINUOUS_CONST, FORALL_IN_INSERT] THEN
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. f x e * product s (f x)) =
                  (\x. (\x. f x e) x * (\x. product s (f x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_MUL THEN ASM_SIMP_TAC std_ss [o_DEF]);

val CONTINUOUS_ON_PRODUCT = store_thm ("CONTINUOUS_ON_PRODUCT",
 ``!f:real->'a->real s t.
        FINITE t /\
        (!i. i IN t ==> (\x. (f x i)) continuous_on s)
        ==> (\x. (product t (f x))) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_PRODUCT]);

(* ------------------------------------------------------------------------- *)
(* And so we have continuity of inverse.                                     *)
(* ------------------------------------------------------------------------- *)

val LIM_INV = store_thm ("LIM_INV",
 ``!net:('a)net f l.
        (f --> l) net /\ ~(l = &0)
        ==> ((inv o f) --> (inv l)) net``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LIM] THEN
  ASM_CASES_TAC ``trivial_limit(net:('a)net)`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[o_THM, dist] THEN STRIP_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``min (abs(l) / &2) ((l pow 2 * e) / &2:real)``) THEN
  REWRITE_TAC[REAL_LT_MIN] THEN
  KNOW_TAC ``0 < abs l / 2 /\ 0 < l pow 2 * e / 2:real`` THENL
   [ASM_SIMP_TAC arith_ss [GSYM ABS_NZ, REAL_LT_DIV, REAL_LT] THEN
    MATCH_MP_TAC REAL_LT_DIV THEN SIMP_TAC arith_ss [REAL_LT] THEN
    ONCE_REWRITE_TAC[GSYM REAL_POW2_ABS] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MUL, GSYM ABS_NZ, REAL_POW_LT],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:'a``) THEN EXISTS_TAC ``a:'a`` THEN
  POP_ASSUM MP_TAC THEN
  MATCH_MP_TAC MONO_AND THEN REWRITE_TAC[] THEN
  DISCH_TAC THEN X_GEN_TAC ``b:'a`` THEN POP_ASSUM (MP_TAC o Q.SPEC `b:'a`) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  SIMP_TAC arith_ss [REAL_LT_RDIV_EQ, REAL_LT] THEN STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP (REAL_ARITH
   ``abs(x - l) * &2 < abs l ==> ~(x = &0:real)``)) THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_INV2, ABS_DIV, REAL_LT_LDIV_EQ,
               GSYM ABS_NZ, REAL_ENTIRE] THEN
  FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``abs(x - y) * &2 < b * c ==> c * b <= d * &2 ==> abs(y - x) < d:real``)) THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_MUL_ASSOC, REAL_LE_LMUL] THEN
  ONCE_REWRITE_TAC[GSYM REAL_POW2_ABS] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, POW_2, REAL_MUL_ASSOC, GSYM ABS_NZ,
               REAL_LE_RMUL] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``abs(x - y) * &2 < abs y ==> abs y <= &2 * abs x:real``]);

val CONTINUOUS_INV = store_thm ("CONTINUOUS_INV",
 ``!net f. f continuous net /\ ~(f(netlimit net) = &0)
           ==> (inv o f) continuous net``,
  SIMP_TAC std_ss [continuous, LIM_INV, o_THM]);

val CONTINUOUS_AT_WITHIN_INV = store_thm ("CONTINUOUS_AT_WITHIN_INV",
 ``!f s a:real.
        f continuous (at a within s) /\ ~(f a = &0)
        ==> (inv o f) continuous (at a within s)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``trivial_limit (at (a:real) within s)`` THENL
   [ASM_REWRITE_TAC[continuous, LIM],
    ASM_SIMP_TAC std_ss [NETLIMIT_WITHIN, CONTINUOUS_INV]]);

val CONTINUOUS_AT_INV = store_thm ("CONTINUOUS_AT_INV",
 ``!f a. f continuous at a /\ ~(f a = &0)
         ==> (inv o f) continuous at a``,
  ONCE_REWRITE_TAC[GSYM WITHIN_UNIV] THEN
  REWRITE_TAC[CONTINUOUS_AT_WITHIN_INV]);

val CONTINUOUS_ON_INV = store_thm ("CONTINUOUS_ON_INV",
 ``!f s. f continuous_on s /\ (!x. x IN s ==> ~(f x = &0))
         ==> (inv o f) continuous_on s``,
  SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN, CONTINUOUS_AT_WITHIN_INV]);

(* ------------------------------------------------------------------------- *)
(* Hence some useful properties follow quite easily.                         *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_SCALING = store_thm ("CONNECTED_SCALING",
 ``!s:real->bool c. connected s ==> connected (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val CONNECTED_NEGATIONS = store_thm ("CONNECTED_NEGATIONS",
 ``!s:real->bool. connected s ==> connected (IMAGE (\x. -x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_SCALING = store_thm ("COMPACT_SCALING",
 ``!s:real->bool c. compact s ==> compact (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_NEGATIONS = store_thm ("COMPACT_NEGATIONS",
 ``!s:real->bool. compact s ==> compact (IMAGE (\x. -x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LINEAR_CONTINUOUS_AT THEN
  REWRITE_TAC[linear] THEN CONJ_TAC THEN SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val COMPACT_AFFINITY = store_thm ("COMPACT_AFFINITY",
 ``!s a:real c.
        compact s ==> compact (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [IMAGE_COMPOSE, COMPACT_TRANSLATION, COMPACT_SCALING]);

(* ------------------------------------------------------------------------- *)
(* We can state this in terms of diameter of a set.                          *)
(* ------------------------------------------------------------------------- *)

(* This is a generalized ‘diameter’ with a metric parameter d *)
Definition set_diameter_def :
    set_diameter (d :'a metric) (s :'a set) =
      if s = {} then (0 :real)
      else sup {dist d (x,y) | x IN s /\ y IN s}
End

(* New definition of ‘diameter’ *)
Overload diameter = “set_diameter mr1”

(* Old definition of ‘diameter’ (now becomes a theorem) *)
Theorem diameter :
    !s. diameter s =
        if s = {} then (&0:real)
        else sup {abs(x - y) | x IN s /\ y IN s}
Proof
    RW_TAC std_ss [GSYM dist_def, dist, set_diameter_def]
QED

val DIAMETER_BOUNDED = store_thm ("DIAMETER_BOUNDED",
 ``!s. bounded s
       ==> (!x:real y. x IN s /\ y IN s ==> abs(x - y) <= diameter s) /\
           (!d. &0 <= d /\ d < diameter s
                ==> ?x y. x IN s /\ y IN s /\ abs(x - y) > d)``,
  GEN_TAC THEN DISCH_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[diameter, NOT_IN_EMPTY, REAL_LET_ANTISYM] THENL
  [SIMP_TAC std_ss [REAL_NOT_LE, REAL_NOT_LT, REAL_LTE_TOTAL], ALL_TAC] THEN
  MP_TAC(SPEC ``{abs(x - y:real) | x IN s /\ y IN s}`` SUP) THEN
  ABBREV_TAC ``b = sup {abs(x - y:real) | x IN s /\ y IN s}`` THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[NOT_IN_EMPTY, real_gt] THEN
  KNOW_TAC ``(?(x :real) (p_1 :real) (p_2 :real).
    (x = abs (p_1 - p_2)) /\ p_1 IN (s :real -> bool) /\ p_2 IN s) /\
 (?(b :real).
    !(x :real).
      (?(p_1 :real) (p_2 :real).
         (x = abs (p_1 - p_2)) /\ p_1 IN s /\ p_2 IN s) ==>
      x <= b)`` THENL
   [CONJ_TAC THENL [METIS_TAC[MEMBER_NOT_EMPTY], ALL_TAC],
    METIS_TAC[REAL_NOT_LE]] THEN
  SIMP_TAC std_ss [REAL_SUB, LEFT_IMP_EXISTS_THM] THEN
  UNDISCH_TAC ``bounded s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [bounded_def]) THEN
  REWRITE_TAC [real_sub] THEN
  METIS_TAC [REAL_ARITH ``x <= y + z /\ y <= b /\ z <= b ==> x <= b + b:real``,
            ABS_TRIANGLE, ABS_NEG]);

val DIAMETER_BOUNDED_BOUND = store_thm ("DIAMETER_BOUNDED_BOUND",
 ``!s x y. bounded s /\ x IN s /\ y IN s ==> abs(x - y) <= diameter s``,
  MESON_TAC[DIAMETER_BOUNDED]);

val DIAMETER_LINEAR_IMAGE = store_thm ("DIAMETER_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x. abs(f x) = abs x)
        ==> (diameter(IMAGE f s) = diameter s)``,
  REWRITE_TAC[diameter] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[diameter, IMAGE_EQ_EMPTY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC [CONJ_SYM] THEN
  SIMP_TAC std_ss [GSYM CONJ_ASSOC, RIGHT_EXISTS_AND_THM, EXISTS_IN_IMAGE] THEN
  METIS_TAC[LINEAR_SUB]);

val DIAMETER_EMPTY = store_thm ("DIAMETER_EMPTY",
 ``diameter {} = &0``,
  REWRITE_TAC[diameter]);

val DIAMETER_SING = store_thm ("DIAMETER_SING",
 ``!a. diameter {a} = &0``,
  REWRITE_TAC[diameter, NOT_INSERT_EMPTY, IN_SING] THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y:real) = (\x y. abs (x - y:real)) x y``] THEN
  KNOW_TAC ``!a:real f x:real y:real. {f x y | (x = a) /\ (y = a)} = {(f a a):real }`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_SING],
   DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  SIMP_TAC std_ss [REAL_SUB_REFL, ABS_0] THEN
  MATCH_MP_TAC REAL_SUP_UNIQUE THEN
  REWRITE_TAC [METIS [SPECIFICATION] ``{0:real} x <=> x IN {0}``] THEN
  SET_TAC [REAL_LE_LT]);

val DIAMETER_POS_LE = store_thm ("DIAMETER_POS_LE",
 ``!s:real->bool. bounded s ==> &0 <= diameter s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[REAL_LE_REFL] THEN
  MP_TAC(SPEC ``{abs(x - y:real) | x IN s /\ y IN s}`` SUP) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{abs (x - y) | x IN (s :real -> bool) /\ y IN s} <>
      ({} :real -> bool) /\ (?(b :real).
    !(x :real) (y :real). x IN s /\ y IN s ==> abs (x - y) <= b)`` THENL
   [CONJ_TAC THENL [FULL_SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
     EXISTS_PROD, NOT_IN_EMPTY] THEN METIS_TAC [MEMBER_NOT_EMPTY], ALL_TAC] THEN
    UNDISCH_TAC ``bounded s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC ``B:real`` o REWRITE_RULE [BOUNDED_POS]) THEN
    EXISTS_TAC ``&2 * B:real`` THEN
    ASM_SIMP_TAC std_ss [REAL_ARITH
      ``abs x <= B /\ abs y <= B ==> abs(x - y) <= &2 * B:real``],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN
    DISCH_THEN(MP_TAC o SPECL [``a:real``, ``a:real``] o CONJUNCT1) THEN
    ASM_REWRITE_TAC[REAL_SUB_REFL, ABS_0]]);

val DIAMETER_SUBSET = store_thm ("DIAMETER_SUBSET",
 ``!s t:real->bool. s SUBSET t /\ bounded t ==> diameter s <= diameter t``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [DIAMETER_EMPTY, DIAMETER_POS_LE] THEN
  ASM_REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MATCH_MP_TAC REAL_SUP_LE_SUBSET THEN
  REPEAT(CONJ_TAC THENL
  [FULL_SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, SUBSET_DEF,
     EXISTS_PROD, NOT_IN_EMPTY] THEN METIS_TAC [MEMBER_NOT_EMPTY], ALL_TAC]) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  UNDISCH_TAC ``bounded t`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(X_CHOOSE_TAC ``B:real`` o REWRITE_RULE [BOUNDED_POS]) THEN
  EXISTS_TAC ``&2 * B:real`` THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH
    ``abs x <= B /\ abs y <= B ==> abs(x - y) <= &2 * B:real``]);

val DIAMETER_CLOSURE = store_thm ("DIAMETER_CLOSURE",
 ``!s:real->bool. bounded s ==> (diameter(closure s) = diameter s)``,
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [DIAMETER_SUBSET, BOUNDED_CLOSURE, CLOSURE_SUBSET] THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN
  DISCH_TAC THEN MP_TAC(ISPEC ``closure s:real->bool`` DIAMETER_BOUNDED) THEN
  ABBREV_TAC ``d = diameter(closure s) - diameter(s:real->bool)`` THEN
  ASM_SIMP_TAC std_ss [BOUNDED_CLOSURE] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  POP_ASSUM (MP_TAC o
    SPEC ``diameter(closure(s:real->bool)) - d / &2:real``) THEN
  SIMP_TAC std_ss [NOT_IMP, GSYM CONJ_ASSOC, NOT_EXISTS_THM] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(x:real) NOTIN y <=> ~(x IN y)``, GSYM DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(x:real) NOTIN y <=> ~(x IN y)``, GSYM DE_MORGAN_THM] THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP DIAMETER_POS_LE) THEN
  CONJ_TAC THENL
  [SIMP_TAC std_ss [REAL_SUB_LE, REAL_LE_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   EXPAND_TAC "d" THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
   SIMP_TAC std_ss [GSYM REAL_DOUBLE, real_sub] THEN
   MATCH_MP_TAC REAL_LE_ADD2 THEN SIMP_TAC std_ss [REAL_LE_REFL] THEN
   FULL_SIMP_TAC std_ss [REAL_ARITH ``(a - b = c) <=> (a = c + b:real)``] THEN
   ONCE_REWRITE_TAC [GSYM REAL_SUB_LE] THEN
   REWRITE_TAC [REAL_ARITH ``0 < a + b - -c <=> 0 + 0 < a + (b + c):real``, REAL_LE_LT] THEN
   DISJ1_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN ASM_REWRITE_TAC [] THEN
   ONCE_REWRITE_TAC [REAL_ARITH ``0 = 0 + 0:real``] THEN
   MATCH_MP_TAC REAL_LE_ADD2 THEN ASM_REWRITE_TAC [], ALL_TAC] THEN
  CONJ_TAC THENL
  [ONCE_REWRITE_TAC [REAL_ARITH ``a - b < c <=> a - c < b:real``] THEN
   SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   ASM_REWRITE_TAC [REAL_SUB_REFL, REAL_MUL_LZERO], ALL_TAC] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, CONJ_ASSOC, GSYM FORALL_AND_THM] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``!e. ~(0 < e) \/ ?y'. y' IN s /\ dist (y',y) < e:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `d / 4:real`) THEN
  UNDISCH_TAC ``!e. ~(0 < e) \/ ?y. y IN s /\ dist (y,x) < e:real`` THEN DISCH_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPEC `d / 4:real`) THEN REWRITE_TAC [AND_IMP_INTRO] THEN
  ASM_REWRITE_TAC[METIS [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 4:real``, REAL_MUL_LZERO]
                         ``&0 < d / &4 <=> &0 < d:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``u:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC))
   (X_CHOOSE_THEN ``v:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC))) THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP DIAMETER_BOUNDED) THEN
  DISCH_THEN(MP_TAC o SPECL [``u:real``, ``v:real``] o CONJUNCT1) THEN
  ASM_REWRITE_TAC[dist] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [real_gt]) THEN
  RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``a - b < c <=> a - c < b:real``]) THEN
  RULE_ASSUM_TAC (SIMP_RULE std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``]) THEN
  UNDISCH_TAC `` (diameter (closure s) - abs (x - y)) * 2 < d:real`` THEN
  EXPAND_TAC "d" THEN SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 4:real``] THEN
  REAL_ARITH_TAC);

val DIAMETER_SUBSET_CBALL_NONEMPTY = store_thm ("DIAMETER_SUBSET_CBALL_NONEMPTY",
 ``!s:real->bool.
       bounded s /\ ~(s = {}) ==> ?z. z IN s /\ s SUBSET cball(z,diameter s)``,
   REPEAT STRIP_TAC THEN
   FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
   DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
   ASM_REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``b:real`` THEN
   DISCH_TAC THEN REWRITE_TAC[IN_CBALL, dist] THEN
   ASM_MESON_TAC[DIAMETER_BOUNDED]);

val DIAMETER_SUBSET_CBALL = store_thm ("DIAMETER_SUBSET_CBALL",
 ``!s:real->bool. bounded s ==> ?z. s SUBSET cball(z,diameter s)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_MESON_TAC[DIAMETER_SUBSET_CBALL_NONEMPTY, EMPTY_SUBSET]);

val DIAMETER_EQ_0 = store_thm ("DIAMETER_EQ_0",
 ``!s:real->bool.
        bounded s ==> ((diameter s = &0) <=> (s = {}) \/ ?a. (s = {a}))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[DIAMETER_EMPTY, DIAMETER_SING] THEN
  REWRITE_TAC[SET_RULE
   ``(s = {}) \/ (?a. s = {a}) <=> !a b. a IN s /\ b IN s ==> (a = b)``] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN STRIP_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``a:real``, ``b:real``]
        DIAMETER_BOUNDED_BOUND) THEN
  ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC);

val DIAMETER_LE = store_thm ("DIAMETER_LE",
 ``!s:real->bool d.
        (~(s = {}) \/ &0 <= d) /\
        (!x y. x IN s /\ y IN s ==> abs(x - y) <= d) ==> diameter s <= d``,
  NTAC 2 GEN_TAC THEN REWRITE_TAC[diameter] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_SUP_LE' THEN
  CONJ_TAC THENL [
   SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[],
   SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC []]);

val DIAMETER_CBALL = store_thm ("DIAMETER_CBALL",
 ``!a:real r. diameter(cball(a,r)) = if r < &0 then &0 else &2 * r``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THENL
   [ASM_MESON_TAC[CBALL_EQ_EMPTY, DIAMETER_EMPTY], ALL_TAC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[REAL_NOT_LT]) THEN
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [MATCH_MP_TAC DIAMETER_LE THEN
    ASM_SIMP_TAC std_ss [CBALL_EQ_EMPTY, REAL_LE_MUL, REAL_POS, REAL_NOT_LT] THEN
    REWRITE_TAC[IN_CBALL, dist] THEN REAL_ARITH_TAC,
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``abs((a + r) - (a - r):real)`` THEN
    CONJ_TAC THENL
     [REWRITE_TAC[REAL_ARITH ``(a + r) - (a - r) = (&2 * r:real)``] THEN
      ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC DIAMETER_BOUNDED_BOUND THEN
      REWRITE_TAC[BOUNDED_CBALL, IN_CBALL, dist] THEN
      REWRITE_TAC[REAL_ARITH
       ``(abs(a - (a + b)) = abs b) /\ (abs(a - (a - b)) = abs b:real)``] THEN
      ASM_REAL_ARITH_TAC]]);

val DIAMETER_BALL = store_thm ("DIAMETER_BALL",
 ``!a:real r. diameter(ball(a,r)) = if r < &0 then &0 else &2 * r``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THENL
   [ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LT_IMP_LE, DIAMETER_EMPTY], ALL_TAC] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN
  ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LE_REFL, DIAMETER_EMPTY, REAL_MUL_RZERO] THEN
  MATCH_MP_TAC EQ_TRANS THEN
  EXISTS_TAC ``diameter(cball(a:real,r))`` THEN CONJ_TAC THENL
   [SUBGOAL_THEN ``&0 < r:real`` ASSUME_TAC THENL [ASM_REAL_ARITH_TAC, ALL_TAC] THEN
    ASM_SIMP_TAC std_ss [GSYM CLOSURE_BALL, DIAMETER_CLOSURE, BOUNDED_BALL],
    ASM_SIMP_TAC std_ss [DIAMETER_CBALL]]);

val DIAMETER_SUMS = store_thm ("DIAMETER_SUMS",
 ``!s t:real->bool.
        bounded s /\ bounded t
        ==> diameter {x + y | x IN s /\ y IN t} <= diameter s + diameter t``,
  REPEAT STRIP_TAC THEN
  KNOW_TAC ``!x y:real. {x + y| F} = {}:real->bool`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [], DISCH_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, DIAMETER_EMPTY, REAL_ADD_LID, DIAMETER_POS_LE] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, DIAMETER_EMPTY, REAL_ADD_RID, DIAMETER_POS_LE] THEN
  MATCH_MP_TAC DIAMETER_LE THEN CONJ_TAC THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, NOT_IN_EMPTY] THEN
   ASM_SET_TAC [], ALL_TAC] THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP, FORALL_IN_GSPEC] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC(REAL_ARITH
   ``abs(x - x') <= s /\ abs(y - y') <= t
    ==> abs((x + y) - (x' + y'):real) <= s + t``) THEN
  ASM_SIMP_TAC std_ss [DIAMETER_BOUNDED_BOUND]);

val LEBESGUE_COVERING_LEMMA = store_thm ("LEBESGUE_COVERING_LEMMA",
 ``!s:real->bool c.
        compact s /\ ~(c = {}) /\ s SUBSET BIGUNION c /\ (!b. b IN c ==> open b)
        ==> ?d. &0 < d /\
                !t. t SUBSET s /\ diameter t <= d
                    ==> ?b. b IN c /\ t SUBSET b``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP HEINE_BOREL_LEMMA) THEN
  DISCH_THEN(MP_TAC o SPEC ``c:(real->bool)->bool``) THEN ASM_SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``e:real`` THEN
  STRIP_TAC THEN EXISTS_TAC ``e / &2:real`` THEN ASM_REWRITE_TAC[REAL_HALF] THEN
  X_GEN_TAC ``t:real->bool`` THEN STRIP_TAC THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPEC ``t:real->bool`` DIAMETER_SUBSET_CBALL_NONEMPTY) THEN
  KNOW_TAC ``(bounded (t :real -> bool) :bool) /\ t <> ({} :real -> bool)`` THENL
   [ASM_MESON_TAC[BOUNDED_SUBSET, COMPACT_IMP_BOUNDED],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
  KNOW_TAC ``(x :real) IN (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``b:real->bool``) THEN EXISTS_TAC ``b:real->bool`` THEN
  STRIP_TAC THEN ASM_REWRITE_TAC[] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``cball(x:real,diameter(t:real->bool))`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``ball(x:real,e)`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_BALL] THEN
  MAP_EVERY UNDISCH_TAC [``&0 < e:real``, ``diameter(t:real->bool) <= e / &2:real``] THEN
  SIMP_TAC std_ss [dist, REAL_LE_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Related results with closure as the conclusion.                           *)
(* ------------------------------------------------------------------------- *)

val CLOSED_SCALING = store_thm ("CLOSED_SCALING",
 ``!s:real->bool c. closed s ==> closed (IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``s :real->bool = {}`` THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY, IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_CASES_TAC ``c = &0:real`` THENL
   [SUBGOAL_THEN ``IMAGE (\x:real. c * x) s = {(0)}``
     (fn th => REWRITE_TAC[th, CLOSED_SING]) THEN
    ASM_REWRITE_TAC[EXTENSION, IN_IMAGE, IN_SING, REAL_MUL_LZERO] THEN
    ASM_MESON_TAC[MEMBER_NOT_EMPTY],
    ALL_TAC] THEN
  SIMP_TAC std_ss [CLOSED_SEQUENTIAL_LIMITS, IN_IMAGE, SKOLEM_THM] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:num->real`` THEN X_GEN_TAC ``l:real`` THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:num->real`` MP_TAC) THEN
  SIMP_TAC std_ss [FORALL_AND_THM] THEN STRIP_TAC THEN
  EXISTS_TAC ``inv(c) * l :real`` THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``\n:num. inv(c) * x n:real`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_LID],
    ONCE_REWRITE_TAC [METIS [] ``(\n:num. inv c * (c * (y:num->real) n)) =
                                 (\n. inv c:real * (\n. (c * y n)) n)``] THEN
    MATCH_MP_TAC LIM_CMUL THEN
    FIRST_ASSUM(fn th => REWRITE_TAC[SYM(SPEC_ALL th)]) THEN
    ASM_SIMP_TAC std_ss [ETA_AX]]);

val CLOSED_NEGATIONS = store_thm ("CLOSED_NEGATIONS",
 ``!s:real->bool. closed s ==> closed (IMAGE (\x. -x) s)``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``IMAGE (\x. -x) s = IMAGE (\x:real. -(&1) * x) s``
  SUBST1_TAC THEN SIMP_TAC std_ss [CLOSED_SCALING] THEN
  REWRITE_TAC[REAL_ARITH ``-(&1) * x = -x:real``] THEN SIMP_TAC std_ss [ETA_AX]);

val COMPACT_CLOSED_SUMS = store_thm ("COMPACT_CLOSED_SUMS",
 ``!s:real->bool t.
        compact s /\ closed t ==> closed {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [compact, GSPECIFICATION, CLOSED_SEQUENTIAL_LIMITS, EXISTS_PROD] THEN
  STRIP_TAC THEN X_GEN_TAC ``f:num->real`` THEN X_GEN_TAC ``l:real`` THEN
  SIMP_TAC std_ss [SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:num->real`` MP_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:num->real`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC `` !f:num->real.
        (!n. f n IN s) ==>
        ?l r.
          l IN s /\ (!m n. m < n ==> r m < r n) /\
          (f o r --> l) sequentially`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``a:num->real``) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``la:real`` (X_CHOOSE_THEN ``sub:num->num``
        STRIP_ASSUME_TAC)) THEN
  MAP_EVERY EXISTS_TAC [``la:real``, ``l - la:real``] THEN
  ASM_REWRITE_TAC[REAL_ARITH ``a + (b - a) = b:real``] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN
  EXISTS_TAC ``\n. (f o (sub:num->num)) n - (a o sub) n:real`` THEN
  CONJ_TAC THENL [ASM_SIMP_TAC std_ss [REAL_ADD_SUB, o_THM], ALL_TAC] THEN
  MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [LIM_SUBSEQUENCE, ETA_AX]);

val CLOSED_COMPACT_SUMS = store_thm ("CLOSED_COMPACT_SUMS",
 ``!s:real->bool t.
        closed s /\ compact t ==> closed {x + y | x IN s /\ y IN t}``,
  REPEAT GEN_TAC THEN
  SUBGOAL_THEN ``{x + y:real | x IN s /\ y IN t} = {y + x | y IN t /\ x IN s}``
  SUBST1_TAC THEN  SIMP_TAC std_ss [COMPACT_CLOSED_SUMS] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN METIS_TAC [REAL_ADD_SYM]);

val CLOSURE_SUMS = store_thm ("CLOSURE_SUMS",
 ``!s t:real->bool.
        bounded s \/ bounded t
        ==> (closure {x + y | x IN s /\ y IN t} =
             {x + y | x IN closure s /\ y IN closure t})``,
  REWRITE_TAC[TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC std_ss [FORALL_AND_THM] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SUMS_SYM] THEN
  MATCH_MP_TAC(TAUT `(p ==> q) /\ p ==> p /\ q`) THEN
  SIMP_TAC std_ss [] THEN
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [EXTENSION, CLOSURE_SEQUENTIAL] THEN
  X_GEN_TAC ``z:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD] THEN EQ_TAC THENL
   [GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [CONJ_SYM] THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_DELETE, SKOLEM_THM, GSYM LEFT_EXISTS_AND_THM] THEN
    SIMP_TAC std_ss [FORALL_AND_THM] THEN
    ONCE_REWRITE_TAC[TAUT `(p /\ q) /\ r <=> q /\ p /\ r`] THEN
    KNOW_TAC ``(?(x' :num -> real) (f :num -> real) (f' :num -> real).
   (\x' f f'. ((!(n :num). f n IN (s :real -> bool)) /\
    !(n :num). f' n IN (t :real -> bool)) /\
   (!(n :num). x' n = f n + f' n) /\
   ((x' --> (z :real)) sequentially :bool)) x' f f') ==>
?(p_1 :real) (p_2 :real) (x' :num -> real).
  (\p_1 p_2 x'. (?(x :num -> real).
     (!(n :num). x n IN t) /\ ((x --> p_2) sequentially :bool)) /\
  ((!(n :num). x' n IN s) /\ ((x' --> p_1) sequentially :bool)) /\
  (z = p_1 + p_2)) p_1 p_2 x'`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    ONCE_REWRITE_TAC[MESON[] ``(?f x y. P f x y) <=> (?x y f. P f x y)``] THEN
    SIMP_TAC std_ss [GSYM FUN_EQ_THM] THEN
    SIMP_TAC std_ss [ETA_AX, UNWIND_THM2] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:num->real``, ``b:num->real``] THEN
    STRIP_TAC THEN
    MP_TAC(ISPEC ``closure s:real->bool`` compact) THEN
    ASM_SIMP_TAC std_ss [COMPACT_CLOSURE] THEN
    DISCH_THEN(MP_TAC o SPEC ``a:num->real``) THEN
    ASM_SIMP_TAC std_ss [SIMP_RULE std_ss [SUBSET_DEF] CLOSURE_SUBSET, LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real``, ``r:num->num``] THEN STRIP_TAC THEN
    EXISTS_TAC ``z - u:real`` THEN
    EXISTS_TAC ``(a:num->real) o (r:num->num)`` THEN EXISTS_TAC ``u:real`` THEN
    ASM_SIMP_TAC std_ss [o_THM] THEN
    CONJ_TAC THENL [ALL_TAC, REAL_ARITH_TAC] THEN
    EXISTS_TAC ``(\n. ((\n. a n + b n) o (r:num->num)) n - (a o r) n)
                :num->real`` THEN
    CONJ_TAC THENL
     [ASM_SIMP_TAC real_ss [o_DEF, REAL_ARITH ``(a + b) - a:real = b``],
      MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [ETA_AX] THEN
      MATCH_MP_TAC LIM_SUBSEQUENCE THEN ASM_REWRITE_TAC[]],
    SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, GSYM LEFT_EXISTS_AND_THM,
                GSYM RIGHT_EXISTS_AND_THM] THEN
    MAP_EVERY X_GEN_TAC
     [``x:real``, ``y:real``, ``a:num->real``, ``b:num->real``] THEN
    STRIP_TAC THEN EXISTS_TAC ``(\n. a n + b n):num->real`` THEN
    ASM_SIMP_TAC std_ss [LIM_ADD] THEN ASM_MESON_TAC[]]);

val COMPACT_CLOSED_DIFFERENCES = store_thm ("COMPACT_CLOSED_DIFFERENCES",
 ``!s:real->bool t.
        compact s /\ closed t ==> closed {x - y | x IN s /\ y IN t}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x - y | x:real IN s /\ y IN t} =
                 {x + y | x IN s /\ y IN (IMAGE (\x. -x) t)}``
    (fn th => ASM_SIMP_TAC std_ss [th, COMPACT_CLOSED_SUMS, CLOSED_NEGATIONS]) THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = -y) <=> (y = -x:real)``] THEN
  SIMP_TAC std_ss [real_sub, GSYM CONJ_ASSOC, UNWIND_THM2] THEN
  METIS_TAC[REAL_NEG_NEG]);

val CLOSED_COMPACT_DIFFERENCES = store_thm ("CLOSED_COMPACT_DIFFERENCES",
 ``!s:real->bool t.
        closed s /\ compact t ==> closed {x - y | x IN s /\ y IN t}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x - y | x:real IN s /\ y IN t} =
                 {x + y | x IN s /\ y IN (IMAGE (\x. -x) t)}``
    (fn th => ASM_SIMP_TAC std_ss [th, CLOSED_COMPACT_SUMS, COMPACT_NEGATIONS]) THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = -y) <=> (y = -x)``] THEN
  SIMP_TAC std_ss [real_sub, GSYM CONJ_ASSOC, UNWIND_THM2] THEN
  METIS_TAC[REAL_NEG_NEG]);

val TRANSLATION_DIFF = store_thm ("TRANSLATION_DIFF",
 ``!s t:real->bool.
        IMAGE (\x. a + x) (s DIFF t) =
        (IMAGE (\x. a + x) s) DIFF (IMAGE (\x. a + x) t)``,
  SIMP_TAC std_ss [EXTENSION, IN_DIFF, IN_IMAGE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(x:real = a + y) <=> (y = x - a)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2]);

(* ------------------------------------------------------------------------- *)
(* Separation between points and sets.                                       *)
(* ------------------------------------------------------------------------- *)

val SEPARATE_POINT_CLOSED = store_thm ("SEPARATE_POINT_CLOSED",
 ``!s a:real.
        closed s /\ ~(a IN s)
        ==> ?d. &0 < d /\ !x. x IN s ==> d <= dist(a,x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [EXISTS_TAC ``&1:real`` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY, REAL_LT_01],
    ALL_TAC] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``a:real``] DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN X_GEN_TAC ``b:real`` THEN
  STRIP_TAC THEN EXISTS_TAC ``dist(a:real,b)`` THEN
  METIS_TAC[DIST_POS_LT]);

Theorem SEPARATE_COMPACT_CLOSED :
   !s t:real->bool.
        compact s /\ closed t /\ (s INTER t = {})
        ==> ?d. &0 < d /\ !x y. x IN s /\ y IN t ==> d <= dist(x,y)
Proof
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
                SEPARATE_POINT_CLOSED) THEN
  ASM_SIMP_TAC std_ss' [COMPACT_CLOSED_DIFFERENCES, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[REAL_ARITH ``(0 = x - y) <=> (x = y:real)``] THEN
  KNOW_TAC ``(!(p_1 :real) (p_2 :real).
    p_1 <> p_2 \/ p_1 NOTIN (s :real -> bool) \/
    p_2 NOTIN (t :real -> bool))`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``d:real``) THEN EXISTS_TAC ``d:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  REWRITE_TAC [dist] THEN
  METIS_TAC[REAL_ARITH ``abs(0 - (x - y)) = abs(x - y:real)``]
QED

val SEPARATE_CLOSED_COMPACT = store_thm ("SEPARATE_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t /\ (s INTER t = {})
        ==> ?d. &0 < d /\ !x y. x IN s /\ y IN t ==> d <= dist(x,y)``,
  ONCE_REWRITE_TAC[DIST_SYM, INTER_COMM] THEN
  MESON_TAC[SEPARATE_COMPACT_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* Representing sets as the union of a chain of compact sets.                *)
(* ------------------------------------------------------------------------- *)

val CLOSED_UNION_COMPACT_SUBSETS = store_thm ("CLOSED_UNION_COMPACT_SUBSETS",
 ``!s. closed s
       ==> ?f:num->real->bool.
                (!n. compact(f n)) /\
                (!n. (f n) SUBSET s) /\
                (!n. (f n) SUBSET f(n + 1)) /\
                (BIGUNION {f n | n IN univ(:num)} = s) /\
                (!k. compact k /\ k SUBSET s
                     ==> ?N. !n. n >= N ==> k SUBSET (f n))``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``\n. s INTER cball(0:real,&n)`` THEN
  ASM_SIMP_TAC std_ss [INTER_SUBSET, COMPACT_CBALL, CLOSED_INTER_COMPACT] THEN
  REPEAT CONJ_TAC THENL
   [GEN_TAC THEN MATCH_MP_TAC(SET_RULE
     ``t SUBSET u ==> s INTER t SUBSET s INTER u``) THEN
    REWRITE_TAC[SUBSET_BALLS, DIST_REFL, GSYM REAL_OF_NUM_ADD] THEN
    REAL_ARITH_TAC,
    SIMP_TAC std_ss [EXTENSION, BIGUNION_GSPEC, GSPECIFICATION, IN_UNIV, IN_INTER] THEN
    X_GEN_TAC ``x:real`` THEN REWRITE_TAC[IN_CBALL_0] THEN
    MESON_TAC[SIMP_REAL_ARCH],
    X_GEN_TAC ``k:real->bool`` THEN SIMP_TAC std_ss [SUBSET_INTER] THEN
    REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP COMPACT_IMP_BOUNDED) THEN DISCH_THEN
     (MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_CBALL) THEN
    DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPEC ``r:real`` SIMP_REAL_ARCH) THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM REAL_OF_NUM_GE] THEN
    REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
    REWRITE_TAC[SUBSET_BALLS, DIST_REFL] THEN ASM_REAL_ARITH_TAC]);

val OPEN_UNION_COMPACT_SUBSETS = store_thm ("OPEN_UNION_COMPACT_SUBSETS",
 ``!s. open s
       ==> ?f:num->real->bool.
                (!n. compact(f n)) /\
                (!n. (f n) SUBSET s) /\
                (!n. (f n) SUBSET interior(f(n + 1))) /\
                (BIGUNION {f n | n IN univ(:num)} = s) /\
                (!k. compact k /\ k SUBSET s
                     ==> ?N. !n. n >= N ==> k SUBSET (f n))``,
  GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [DISCH_TAC THEN EXISTS_TAC ``(\n. {}):num->real->bool`` THEN
    ASM_SIMP_TAC std_ss [EMPTY_SUBSET, SUBSET_EMPTY, COMPACT_EMPTY] THEN
    SIMP_TAC std_ss [EXTENSION, BIGUNION_GSPEC, GSPECIFICATION, NOT_IN_EMPTY],
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN STRIP_TAC] THEN
  KNOW_TAC ``?(f :num -> real -> bool).
           (\f. !(n :num). compact (f n)) f /\
           (\f. !(n :num). f n SUBSET (s :real -> bool)) f /\
           (\f. !(n :num). f n SUBSET interior (f (n +  1n))) f /\
           (\f. BIGUNION {f n | n IN univ((:num) :num itself)} = s) f /\
  (\f. !(k :real -> bool).
    compact k /\ k SUBSET s ==>
    ?(N :num). !(n :num). n >= N ==> k SUBSET f n) f`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS[]
  ``(!f. p1 f /\ p3 f /\ p4 f ==> p5 f) /\
    (?f. p1 f /\ p2 f /\ p3 f /\ (p2 f ==> p4 f))
    ==> ?f. p1 f /\ p2 f /\ p3 f /\ p4 f /\ p5 f``) THEN
  CONJ_TAC THENL
   [BETA_TAC THEN X_GEN_TAC ``f:num->real->bool`` THEN STRIP_TAC THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
    UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [COMPACT_EQ_HEINE_BOREL]) THEN
    DISCH_THEN(MP_TAC o SPEC ``{interior(f n):real->bool | n IN univ(:num)}``) THEN
    SIMP_TAC std_ss [FORALL_IN_GSPEC, OPEN_INTERIOR] THEN
    KNOW_TAC ``(k :real -> bool) SUBSET
        BIGUNION {interior ((f :num -> real -> bool) n) |
                               n IN univ((:num) :num itself)}`` THENL
     [FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
      SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, GSPECIFICATION] THEN ASM_SET_TAC[],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
      ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
      ONCE_REWRITE_TAC [METIS [] ``interior (f n) = (\n. interior (f n)) (n:num)``] THEN
      SIMP_TAC std_ss [GSYM IMAGE_DEF, EXISTS_FINITE_SUBSET_IMAGE] THEN
      REWRITE_TAC[SUBSET_UNIV] THEN
      DISCH_THEN(X_CHOOSE_THEN ``i:num->bool`` STRIP_ASSUME_TAC) THEN
      FIRST_ASSUM(MP_TAC o SPEC ``\n:num. n`` o
        MATCH_MP UPPER_BOUND_FINITE_SET) THEN
      DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
      POP_ASSUM MP_TAC THEN
      REWRITE_TAC[GE] THEN DISCH_TAC THEN X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        SUBSET_TRANS)) THEN
      SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_IMAGE] THEN
      X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN MATCH_MP_TAC SUBSET_TRANS THEN
      EXISTS_TAC ``(f:num->real->bool) m`` THEN
      REWRITE_TAC[INTERIOR_SUBSET] THEN
      SUBGOAL_THEN ``!m n. m <= n ==> (f:num->real->bool) m SUBSET f n``
       (fn th => METIS_TAC[th, LESS_EQ_TRANS]) THEN
      ONCE_REWRITE_TAC [METIS [] ``f m SUBSET f n <=> (\m n. f m SUBSET f n) m n``] THEN
      MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
      METIS_TAC[SUBSET_DEF, ADD1, INTERIOR_SUBSET]],
    BETA_TAC THEN EXISTS_TAC ``\n. cball(a,&n) DIFF
         {x + e | x IN univ(:real) DIFF s /\ e IN ball(0,inv(&n + &1))}`` THEN
    SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL
     [X_GEN_TAC ``n:num`` THEN MATCH_MP_TAC COMPACT_DIFF THEN
      SIMP_TAC std_ss [COMPACT_CBALL, OPEN_SUMS, OPEN_BALL],
      GEN_TAC THEN MATCH_MP_TAC(SET_RULE
       ``(UNIV DIFF s) SUBSET t ==> c DIFF t SUBSET s``) THEN
      SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      MAP_EVERY EXISTS_TAC [``x:real``, ``0:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_ADD_RID, CENTRE_IN_BALL, REAL_LT_INV_EQ] THEN
      SIMP_TAC std_ss [REAL_LT, REAL_OF_NUM_ADD] THEN ARITH_TAC,
      GEN_TAC THEN REWRITE_TAC[INTERIOR_DIFF] THEN MATCH_MP_TAC(SET_RULE
       ``s SUBSET s' /\ t' SUBSET t ==> (s DIFF t) SUBSET (s' DIFF t')``) THEN
      CONJ_TAC THENL
       [REWRITE_TAC[INTERIOR_CBALL, SUBSET_DEF, IN_BALL, IN_CBALL] THEN
        SIMP_TAC std_ss [GSYM REAL_OF_NUM_ADD] THEN REAL_ARITH_TAC,
        MATCH_MP_TAC SUBSET_TRANS THEN
        EXISTS_TAC ``{x + e | x IN univ(:real) DIFF s /\
                             e IN cball(0,inv(&n + &2))}`` THEN
        CONJ_TAC THENL
         [MATCH_MP_TAC CLOSURE_MINIMAL THEN
          ASM_SIMP_TAC std_ss [CLOSED_COMPACT_SUMS, COMPACT_CBALL,
                       GSYM OPEN_CLOSED] THEN
          KNOW_TAC ``ball (0,inv (&n + 1)) SUBSET ball (0,inv (&n + 1))`` THENL
          [SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
           SIMP_TAC std_ss [ball, cball, dist, GSYM REAL_OF_NUM_ADD,
                            REAL_ARITH ``n + 1 + 1:real = n + 2``,
                            GSPECIFICATION] THEN
           METIS_TAC [REAL_LE_LT], ALL_TAC] THEN
          SIMP_TAC std_ss [SUBSET_DEF, IN_BALL, IN_CBALL, GSYM REAL_OF_NUM_ADD] THEN
          SIMP_TAC std_ss [GSPECIFICATION, EXISTS_PROD, dist,
                           REAL_ARITH ``n + 1 + 1:real = n + 2``] THEN
          METIS_TAC [REAL_LE_LT],
          KNOW_TAC ``cball (0,inv (&n + &2)) SUBSET ball (0,inv (&n + &1))`` THENL
          [ALL_TAC,
           SIMP_TAC std_ss [cball, ball, dist, SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
           METIS_TAC [REAL_LE_LT]] THEN
          REWRITE_TAC[SUBSET_DEF, IN_BALL, IN_CBALL, GSYM REAL_OF_NUM_ADD] THEN
          GEN_TAC THEN MATCH_MP_TAC(REAL_ARITH
           ``a < b ==> x <= a ==> x < b:real``) THEN
          MATCH_MP_TAC REAL_LT_INV2 THEN
          SIMP_TAC arith_ss [REAL_LT, REAL_OF_NUM_ADD]]],
      DISCH_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
      ASM_SIMP_TAC std_ss [BIGUNION_SUBSET, FORALL_IN_GSPEC] THEN
      SIMP_TAC std_ss [SUBSET_DEF, BIGUNION_GSPEC, IN_UNIV, GSPECIFICATION] THEN
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_DIFF] THEN
      SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, IN_BALL_0, EXISTS_PROD] THEN
      REWRITE_TAC[REAL_ARITH ``(x:real = y + e) <=> (e = x - y)``] THEN
      SIMP_TAC std_ss [TAUT `(p /\ q) /\ r <=> r /\ p /\ q`, UNWIND_THM2] THEN
      ONCE_REWRITE_TAC [METIS [DE_MORGAN_THM]
           ``(!p_1:real. p_1 IN s \/ ~(abs (x - p_1) < inv (&n + 1))) <=>
             ~(?p_1:real. (~(\p_1. (p_1 IN s)) p_1 /\
                            (\p_1. abs (x - p_1) < inv (&n + 1)) p_1))``] THEN
      REWRITE_TAC[METIS [] ``~(?x. ~P x /\ Q x) <=> !x. Q x ==> P x``] THEN
      UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN BETA_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_BALL]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
      ASM_REWRITE_TAC[SUBSET_DEF, IN_BALL, dist] THEN
      DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
      UNDISCH_TAC ``0 < e:real`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC o ONCE_REWRITE_RULE [REAL_ARCH_INV]) THEN
      DISCH_THEN(X_CHOOSE_THEN ``N1:num`` STRIP_ASSUME_TAC) THEN
      MP_TAC(ISPEC ``abs(x - a:real)`` SIMP_REAL_ARCH) THEN
      DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN EXISTS_TAC ``N1 + N2:num`` THEN
      CONJ_TAC THENL
       [REWRITE_TAC[IN_CBALL] THEN ONCE_REWRITE_TAC[DIST_SYM, dist] THEN
        UNDISCH_TAC ``abs(x - a:real) <= &N2`` THEN
        REWRITE_TAC[dist, GSYM REAL_OF_NUM_ADD] THEN
        FULL_SIMP_TAC std_ss [REAL_LT_INV_EQ] THEN
        DISCH_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN
        EXISTS_TAC ``&N2:real`` THEN ASM_REWRITE_TAC [] THEN
        SIMP_TAC arith_ss [REAL_OF_NUM_LE, REAL_OF_NUM_ADD],
        REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
        SUBGOAL_THEN ``inv(&(N1 + N2) + &1) <= inv(&N1:real)`` MP_TAC THENL
         [MATCH_MP_TAC REAL_LE_INV2 THEN
          ASM_SIMP_TAC arith_ss [REAL_LT, LE_1] THEN
          REWRITE_TAC[GSYM REAL_OF_NUM_ADD] THEN
          SIMP_TAC arith_ss [REAL_OF_NUM_LE, REAL_OF_NUM_ADD],
          METIS_TAC [REAL_LTE_TRANS, REAL_LET_TRANS, REAL_LE_TRANS, REAL_LT_TRANS]]]]]);

(* ------------------------------------------------------------------------- *)
(* A cute way of denoting open and closed intervals using overloading.       *)
(* ------------------------------------------------------------------------- *)

Definition OPEN_interval :
    OPEN_interval ((a:real),(b:real)) = {x:real | a < x /\ x < b}
End

Definition CLOSED_interval :
    CLOSED_interval (l :(real # real) list) =
      {x:real | FST (HD l) <= x /\ x <= SND (HD l)}
End

val _ = overload_on ("interval", ``OPEN_interval``);
val _ = overload_on ("interval", ``CLOSED_interval``);

val interval = store_thm ("interval",
 ``(interval (a,b) = {x:real | a < x /\ x < b}) /\
   (interval [a,b] = {x:real | a <= x /\ x <= b})``,
  REWRITE_TAC [OPEN_interval, CLOSED_interval, HD]);

val IN_INTERVAL = store_thm ("IN_INTERVAL",
 ``(x IN interval (a,b) <=> a < x /\ x < b) /\
   (x IN interval [a,b] <=> a <= x /\ x <= b)``,
  SIMP_TAC std_ss [interval, GSPECIFICATION]);

val IN_INTERVAL_REFLECT = store_thm ("IN_INTERVAL_REFLECT",
 ``(!a b x. (-x) IN interval[-b,-a] <=> x IN interval[a,b]) /\
   (!a b x. (-x) IN interval(-b,-a) <=> x IN interval(a,b))``,
  SIMP_TAC std_ss [IN_INTERVAL, REAL_LT_NEG, REAL_LE_NEG] THEN
  METIS_TAC[]);

val REFLECT_INTERVAL = store_thm ("REFLECT_INTERVAL",
 ``(!a b:real. IMAGE (\x. -x) (interval[a,b]) = interval[-b,-a]) /\
   (!a b:real. IMAGE (\x. -x) (interval(a,b)) = interval(-b,-a))``,
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_INTERVAL,
   IN_IMAGE] THEN REPEAT STRIP_TAC THEN EQ_TAC THEN
  METIS_TAC [REAL_LE_NEG, REAL_LT_NEG, REAL_NEG_NEG]);

val INTERVAL_EQ_EMPTY = store_thm ("INTERVAL_EQ_EMPTY",
 ``!a b. (b < a <=> (interval [a,b] = {})) /\
         (b <= a <=> (interval (a,b) = {}))``,
  REPEAT GEN_TAC THEN CONJ_TAC THENL
  [EQ_TAC THENL [RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN EQ_TAC THENL
  [SIMP_TAC std_ss [NOT_IN_EMPTY] THEN CCONTR_TAC THEN
   FULL_SIMP_TAC std_ss [REAL_NEG_NEG] THEN UNDISCH_TAC (Term `b < a:real`) THEN
   FULL_SIMP_TAC std_ss [REAL_NOT_LT] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
   EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC [], SIMP_TAC std_ss [NOT_IN_EMPTY]],
   RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN
   CCONTR_TAC THEN UNDISCH_TAC (Term `!x:real. a <= x /\ x <= b <=> x IN {}`) THEN
   FULL_SIMP_TAC std_ss [NOT_IN_EMPTY, REAL_NOT_LT] THEN EXISTS_TAC ``a:real``
   THEN FULL_SIMP_TAC std_ss [REAL_LE_LT]],
   EQ_TAC THENL [RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN EQ_TAC THENL
    [SIMP_TAC std_ss [NOT_IN_EMPTY] THEN CCONTR_TAC THEN
     FULL_SIMP_TAC std_ss [REAL_NEG_NEG] THEN UNDISCH_TAC (Term `b <= a:real`) THEN
     FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
     EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC [], SIMP_TAC std_ss [NOT_IN_EMPTY]],
     RW_TAC std_ss [EXTENSION, IN_INTERVAL] THEN
     CCONTR_TAC THEN UNDISCH_TAC (Term `!x:real. a < x /\ x < b <=> x IN {}`) THEN
     FULL_SIMP_TAC std_ss [NOT_IN_EMPTY, REAL_NOT_LE, REAL_MEAN]]]);

val INTERVAL_NE_EMPTY = store_thm ("INTERVAL_NE_EMPTY",
 ``(~(interval [a:real,b] = {}) <=> a <= b) /\
   (~(interval (a:real,b) = {}) <=> a < b)``,
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, NOT_IN_EMPTY, IN_INTERVAL] THEN
  CONJ_TAC THEN EQ_TAC THENL [SIMP_TAC std_ss [REAL_LE_TRANS],
  DISCH_TAC THEN EXISTS_TAC ``a:real`` THEN ASM_SIMP_TAC std_ss [REAL_LE_LT],
  SIMP_TAC std_ss [REAL_LT_TRANS], FULL_SIMP_TAC std_ss [REAL_MEAN]]);

val SUBSET_INTERVAL_IMP = store_thm ("SUBSET_INTERVAL_IMP",
 ``((a <= c /\ d <= b) ==> interval[c,d] SUBSET interval[a:real,b]) /\
   ((a < c  /\ d < b)  ==> interval[c,d] SUBSET interval(a:real,b)) /\
   ((a <= c /\ d <= b) ==> interval(c,d) SUBSET interval[a:real,b]) /\
   ((a <= c /\ d <= b) ==> interval(c,d) SUBSET interval(a:real,b))``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN REPEAT CONJ_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM MP_TAC THEN REPEAT STRIP_TAC THEN
  METIS_TAC [REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS, REAL_LT_IMP_LE]);

val INTERVAL_SING = store_thm ("INTERVAL_SING",
 ``(interval[a,a] = {a}) /\ (interval(a,a) = {})``,
  REWRITE_TAC[EXTENSION, IN_SING, NOT_IN_EMPTY, IN_INTERVAL] THEN
  REWRITE_TAC[REAL_LE_ANTISYM, REAL_LT_ANTISYM] THEN
  MESON_TAC[EQ_SYM_EQ]);

val SUBSET_INTERVAL = store_thm ("SUBSET_INTERVAL",
 ``(interval[c,d] SUBSET interval[a:real,b] <=>
        (c <= d) ==> (a <= c /\ d <= b)) /\
   (interval[c,d] SUBSET interval(a:real,b) <=>
        (c <= d) ==> (a < c /\ d < b)) /\
   (interval(c,d) SUBSET interval[a:real,b] <=>
        (c < d) ==> (a <= c /\ d <= b)) /\
   (interval(c,d) SUBSET interval(a:real,b) <=>
        (c < d) ==> (a <= c /\ d <= b))``,
  REPEAT STRIP_TAC THEN
  (MATCH_MP_TAC(TAUT
    `(~q ==> p) /\ (q ==> (p <=> r)) ==> (p <=> q ==> r)`) THEN
   CONJ_TAC THENL
    [DISCH_TAC THEN MATCH_MP_TAC(SET_RULE ``(s = {}) ==> s SUBSET t``) THEN
     ASM_MESON_TAC[INTERVAL_EQ_EMPTY, REAL_NOT_LE], ALL_TAC] THEN
   DISCH_TAC THEN EQ_TAC THEN REWRITE_TAC[SUBSET_INTERVAL_IMP] THEN
   REWRITE_TAC[SUBSET_DEF, IN_INTERVAL]) THENL
   [KNOW_TAC ``((?y. c <= y /\ y <= d)
           ==> (!y. c <= y /\ y <= d
                ==> a <= y /\ y <= b))
          ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c <= y /\ y <= d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL],
    KNOW_TAC ``((?y. c <= y /\ y <= d)
           ==> (!y. c <= y /\ y <= d
                 ==> a < y /\ y < b))
           ==> (a < c:real /\ d < b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c <= y /\ y <= d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    STRIP_TAC THEN ASM_MESON_TAC[REAL_LE_TRANS, REAL_LE_REFL],
    KNOW_TAC ``((?y. c < y /\ y < d)
           ==> (!y. c < y /\ y < d
               ==> a <= y /\ y <= b))
         ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c < y /\ y < d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    REPEAT STRIP_TAC THENL
    [CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a <= y /\ y <= b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``((c:real) + min ((a:real)) ((d:real))) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE],
    CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a <= y /\ y <= b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``(max ((b:real)) ((c:real)) + (d:real)) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE]],
    KNOW_TAC ``((?y. c < y /\ y < d)
           ==> (!y. c < y /\ y < d
                ==> a < y /\ y < b))
         ==> (a <= c:real /\ d <= b:real)`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    KNOW_TAC ``(?y:real. c < y /\ y < d)`` THENL
    [ASM_MESON_TAC[REAL_MEAN, REAL_LE_BETWEEN], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
    REPEAT STRIP_TAC THENL
    [CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a < y /\ y < b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``((c:real) + min ((a:real)) ((d:real))) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE, REAL_NOT_LT, REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
               REAL_LE_LADD, REAL_LE_ADD2, REAL_LE_RADD, REAL_LE_LT],
    CCONTR_TAC THEN UNDISCH_TAC ``!y:real. c < y /\ y < d ==> a < y /\ y < b`` THEN
    FULL_SIMP_TAC std_ss [REAL_NOT_LE] THEN
    EXISTS_TAC ``(max ((b:real)) ((c:real)) + (d:real)) / &2:real`` THEN
    METIS_TAC [min_def, max_def, REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``, REAL_LT_LDIV_EQ,
               GSYM REAL_DOUBLE, REAL_LT_LADD, REAL_ADD_SYM, REAL_MUL_SYM, REAL_LT_ADD2,
               REAL_LTE_ADD2, REAL_NOT_LE, REAL_NOT_LT, REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
               REAL_LE_LADD, REAL_LE_ADD2, REAL_LE_RADD, REAL_LE_LT]]]);

val DISJOINT_INTERVAL = store_thm ("DISJOINT_INTERVAL",
  ``!a b c d:real.
        ((interval[a,b] INTER interval[c,d] = {}) <=>
          b < a \/ d < c \/
          b < c \/ d < a) /\
        ((interval[a,b] INTER interval(c,d) = {}) <=>
          b < a \/ d <= c \/
          b <= c \/ d <= a) /\
        ((interval(a,b) INTER interval[c,d] = {}) <=>
          b <= a \/ d < c \/
          b <= c \/ d <= a) /\
        ((interval(a,b) INTER interval(c,d) = {}) <=>
          b <= a \/ d <= c \/
          b <= c \/ d <= a)``,
  REWRITE_TAC [EXTENSION, IN_INTER, IN_INTERVAL, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, NOT_FORALL_THM] THEN
  REWRITE_TAC [TAUT `~((p ==> q) /\ (p ==> r)) <=> p /\ (~q \/ ~r)`] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  REPEAT STRIP_TAC THEN (* 4 subgoals *)
  (EQ_TAC THENL
    [DISCH_THEN (MP_TAC o SPEC ``(@f. f = (max ((a:real)) ((c:real)) +
                                           min ((b:real)) ((d:real))) / &2):real``) THEN
     DISCH_TAC THEN
     FULL_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ,
                           REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ,
                           REAL_ARITH ``0 < 2:real``] THEN (* 4 subgoals *)
     FULL_SIMP_TAC bool_ss [REAL_NOT_LE, min_def, max_def] THEN
     POP_ASSUM MP_TAC THEN
     REPEAT COND_CASES_TAC THEN ASM_REAL_ARITH_TAC,

     DISCH_THEN (fn th => GEN_TAC THEN MP_TAC th) THEN
     SIMP_TAC std_ss [] THEN REAL_ARITH_TAC ]));

val ENDS_IN_INTERVAL = store_thm ("ENDS_IN_INTERVAL",
 ``(!a b. a IN interval[a,b] <=> ~(interval[a,b] = {})) /\
   (!a b. b IN interval[a,b] <=> ~(interval[a,b] = {})) /\
   (!a b. ~(a IN interval(a,b))) /\
   (!a b. ~(b IN interval(a,b)))``,
  REWRITE_TAC[IN_INTERVAL, INTERVAL_NE_EMPTY] THEN
  REWRITE_TAC[REAL_LE_REFL, REAL_LT_REFL] THEN
  MESON_TAC[REAL_LE_REFL]);

val ENDS_IN_UNIT_INTERVAL = store_thm ("ENDS_IN_UNIT_INTERVAL",
 ``0 IN interval[0,1] /\ 1 IN interval[0,1] /\
   ~(0 IN interval(0,1)) /\ ~(1 IN interval(0,1))``,
  REWRITE_TAC[ENDS_IN_INTERVAL, INTERVAL_NE_EMPTY] THEN
  REWRITE_TAC[REAL_POS]);

val INTER_INTERVAL = store_thm ("INTER_INTERVAL",
 ``interval[a,b] INTER interval[c,d] =
        interval[(max (a) (c)),(min (b) (d))]``,
  REWRITE_TAC[EXTENSION, IN_INTER, IN_INTERVAL] THEN
  SIMP_TAC std_ss [REAL_MAX_LE, REAL_LE_MIN] THEN MESON_TAC[]);

val INTERVAL_OPEN_SUBSET_CLOSED = store_thm ("INTERVAL_OPEN_SUBSET_CLOSED",
 ``!a b. interval(a,b) SUBSET interval[a,b]``,
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN MESON_TAC[REAL_LT_IMP_LE]);

val OPEN_INTERVAL_LEMMA = store_thm ("OPEN_INTERVAL_LEMMA",
 ``!a b x. a < x /\ x < b
           ==> ?d. (0:real) < d /\ !x'. abs(x' - x) < d ==> a < x' /\ x' < b``,
  REPEAT STRIP_TAC THEN
  EXISTS_TAC ``min (x - a) (b - x:real)`` THEN REWRITE_TAC[REAL_LT_MIN] THEN
  REPEAT (POP_ASSUM MP_TAC) THEN REAL_ARITH_TAC);

val OPEN_INTERVAL = store_thm ("OPEN_INTERVAL",
 ``!a:real b. open(interval (a,b))``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [open_def, interval, GSPECIFICATION, dist, OPEN_INTERVAL_LEMMA]);

val CLOSED_INTERVAL = store_thm ("CLOSED_INTERVAL",
 ``!a:real b. closed(interval [a,b])``,
  REWRITE_TAC[CLOSED_LIMPT, LIMPT_APPROACHABLE, IN_INTERVAL] THEN
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``(a:real) - (x:real)``),
    FIRST_X_ASSUM(MP_TAC o SPEC ``(x:real) - (b:real)``)] THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` MP_TAC) THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[dist, REAL_NOT_LT] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``abs((z - x :real))`` THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``x < a /\ a <= z ==> a - x:real <= abs(z - x)``,
                       REAL_ARITH ``z <= b /\ b < x ==> x - b:real <= abs(z - x)``,
                       REAL_LE_REFL]);

val INTERIOR_CLOSED_INTERVAL = store_thm ("INTERIOR_CLOSED_INTERVAL",
 ``!a:real b. interior(interval [a,b]) = interval (a,b)``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [ALL_TAC,
    MATCH_MP_TAC INTERIOR_MAXIMAL THEN
    REWRITE_TAC[INTERVAL_OPEN_SUBSET_CLOSED, OPEN_INTERVAL]] THEN
  SIMP_TAC std_ss [interior, SUBSET_DEF, IN_INTERVAL, GSPECIFICATION] THEN
  X_GEN_TAC ``x:real`` THEN
  DISCH_THEN(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LE] THEN REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``open s`` THEN REWRITE_TAC [open_def] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THENL
  [DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x - (e / 2:real)`),
   DISCH_TAC THEN POP_ASSUM (MP_TAC o Q.SPEC `x + (e / 2:real)`)] THEN
   ASM_SIMP_TAC std_ss [dist, REAL_ADD_SUB, REAL_ARITH ``x - y - x = -y:real``,
                                   REAL_ARITH ``x + y - x =  y:real``] THEN
   ASM_SIMP_TAC std_ss [ABS_MUL, ABS_NEG, REAL_MUL_RID] THENL [CONJ_TAC THENL
   [METIS_TAC [ABS_REFL, REAL_LT_HALF1, REAL_LT_HALF2, REAL_LE_LT], ALL_TAC],
    CONJ_TAC THENL [METIS_TAC [ABS_REFL, REAL_LT_HALF1, REAL_LT_HALF2, REAL_LE_LT],
   ALL_TAC]] THEN CCONTR_TAC THEN
   UNDISCH_TAC ``!x. x IN s ==> a <= x /\ x <= b:real`` THEN DISCH_TAC THENL
   [POP_ASSUM (MP_TAC o Q.SPEC `x - e / 2:real`),
    POP_ASSUM (MP_TAC o Q.SPEC `x + e / 2:real`)] THEN FULL_SIMP_TAC std_ss [] THENL
   [DISJ1_TAC THEN REWRITE_TAC[REAL_ARITH ``a <= a - b <=> ~(&0 < b:real)``],
    DISJ2_TAC THEN REWRITE_TAC[REAL_ARITH ``a + b <= a <=> ~(&0 < b:real)``]] THEN
   FULL_SIMP_TAC std_ss [REAL_LT_HALF1]);

val INTERIOR_INTERVAL = store_thm ("INTERIOR_INTERVAL",
 ``(!a b. interior(interval[a,b]) = interval(a,b)) /\
   (!a b. interior(interval(a,b)) = interval(a,b))``,
  SIMP_TAC std_ss [INTERIOR_CLOSED_INTERVAL, INTERIOR_OPEN, OPEN_INTERVAL]);

val BOUNDED_CLOSED_INTERVAL = store_thm ("BOUNDED_CLOSED_INTERVAL",
 ``!a b:real. bounded (interval [a,b])``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[bounded_def, interval] THEN
  SIMP_TAC std_ss [GSPECIFICATION] THEN
  EXISTS_TAC ``abs(a) + abs(b:real)`` THEN REAL_ARITH_TAC);

val BOUNDED_INTERVAL = store_thm ("BOUNDED_INTERVAL",
 ``(!a b. bounded (interval [a,b])) /\ (!a b. bounded (interval (a,b)))``,
  MESON_TAC[BOUNDED_CLOSED_INTERVAL, BOUNDED_SUBSET,
            INTERVAL_OPEN_SUBSET_CLOSED]);

val NOT_INTERVAL_UNIV = store_thm ("NOT_INTERVAL_UNIV",
 ``(!a b. ~(interval[a,b] = UNIV)) /\
   (!a b. ~(interval(a,b) = UNIV))``,
  MESON_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val COMPACT_INTERVAL = store_thm ("COMPACT_INTERVAL",
 ``!a b. compact (interval [a,b])``,
  SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTERVAL, CLOSED_INTERVAL]);

val OPEN_INTERVAL_MIDPOINT = store_thm ("OPEN_INTERVAL_MIDPOINT",
 ``!a b:real.
        ~(interval(a,b) = {}) ==> (inv(&2) * (a + b)) IN interval(a,b)``,
  REWRITE_TAC[INTERVAL_NE_EMPTY, IN_INTERVAL] THEN
  ONCE_REWRITE_TAC [REAL_MUL_COMM] THEN ONCE_REWRITE_TAC [GSYM real_div] THEN
  KNOW_TAC ``0 < 2:real`` THENL [REAL_ARITH_TAC, ALL_TAC] THEN
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_LT_LDIV_EQ] THEN
  REWRITE_TAC [REAL_MUL_COMM, GSYM REAL_DOUBLE] THEN
  FULL_SIMP_TAC std_ss [REAL_LT_LADD, REAL_LT_RADD]);

val OPEN_CLOSED_INTERVAL_CONVEX = store_thm ("OPEN_CLOSED_INTERVAL_CONVEX",
 ``!a b x y:real e.
        x IN interval(a,b) /\ y IN interval[a,b] /\ &0 < e /\ e <= &1
        ==> (e * x + (&1 - e) * y) IN interval(a,b)``,
  REPEAT GEN_TAC THEN MATCH_MP_TAC(TAUT
   `(c /\ d ==> a /\ b ==> e) ==> a /\ b /\ c /\ d ==> e`) THEN
  STRIP_TAC THEN REWRITE_TAC[IN_INTERVAL] THEN STRIP_TAC THEN
  SUBST1_TAC(REAL_ARITH ``(a:real) = e * a + (&1 - e) * a``) THEN
  SUBST1_TAC(REAL_ARITH ``(b:real) = e * b + (&1 - e) * b``) THEN
  KNOW_TAC ``0:real <= 1 - e`` THENL
 [FULL_SIMP_TAC std_ss [REAL_SUB_LE], ALL_TAC] THEN
  REWRITE_TAC [REAL_LE_LT] THEN STRIP_TAC THENL
  [CONJ_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LMUL, REAL_LE_LMUL, REAL_SUB_LE],
  POP_ASSUM MP_TAC THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
  DISCH_TAC THEN CONJ_TAC THEN MATCH_MP_TAC REAL_LTE_ADD2 THEN
  ASM_SIMP_TAC std_ss [REAL_LT_LMUL, REAL_LE_LMUL, REAL_SUB_LE, REAL_MUL_LZERO, REAL_LE_REFL]]);

val CLOSURE_OPEN_INTERVAL = store_thm ("CLOSURE_OPEN_INTERVAL",
 ``!a b:real.
     ~(interval(a,b) = {}) ==> (closure(interval(a,b)) = interval[a,b])``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN CONJ_TAC THENL
   [MATCH_MP_TAC CLOSURE_MINIMAL THEN
    REWRITE_TAC[INTERVAL_OPEN_SUBSET_CLOSED, CLOSED_INTERVAL],
    ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, closure, IN_UNION] THEN X_GEN_TAC ``x:real`` THEN
  DISCH_TAC THEN MATCH_MP_TAC(TAUT `(~b ==> c) ==> b \/ c`) THEN DISCH_TAC THEN
  SIMP_TAC std_ss [GSPECIFICATION, LIMPT_SEQUENTIAL] THEN
  ABBREV_TAC ``(c:real) = inv(&2:real) * (a + b)`` THEN
  EXISTS_TAC ``\n. (x:real) + inv(&n + &1:real) * (c - x)`` THEN CONJ_TAC THENL
   [X_GEN_TAC ``n:num`` THEN REWRITE_TAC[IN_DELETE] THEN BETA_TAC THEN
    REWRITE_TAC[REAL_ARITH ``(x + a = x) <=> (a = 0:real)``] THEN
    REWRITE_TAC[REAL_ENTIRE, REAL_INV_EQ_0] THEN
    SIMP_TAC std_ss [REAL_SUB_0, REAL_OF_NUM_SUC, SUC_NOT, REAL_OF_NUM_EQ, EQ_SYM_EQ] THEN
    CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[OPEN_INTERVAL_MIDPOINT]] THEN
    REWRITE_TAC[REAL_ARITH ``x + a * (y - x) = a * y + (&1 - a) * x:real``] THEN
    MATCH_MP_TAC OPEN_CLOSED_INTERVAL_CONVEX THEN
    CONJ_TAC THENL [ASM_MESON_TAC[OPEN_INTERVAL_MIDPOINT], ALL_TAC] THEN
    KNOW_TAC ``&0:real < &n + &1`` THENL [SIMP_TAC std_ss [REAL_OF_NUM_SUC] THEN
    ASM_REWRITE_TAC[REAL_LT_INV_EQ, REAL_OF_NUM_SUC, REAL_LT, LESS_0], ALL_TAC] THEN
    DISCH_TAC THEN ASM_REWRITE_TAC[REAL_LT_INV_EQ, REAL_OF_NUM_SUC, REAL_LT, LESS_0] THEN
    MATCH_MP_TAC REAL_INV_LE_1 THEN REWRITE_TAC [REAL_LE, ONE, LESS_EQ_MONO,
    ZERO_LESS_EQ], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [REAL_ARITH ``x:real = x + &0 * (c - x)``] THEN
  KNOW_TAC ``!n:num x:real. (\n. x + inv (&n + 1) * (c - x)) =
                     (\n. (\n. x) n + (\n. inv (&n + 1) * (c - x)) n)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LIM_ADD THEN REWRITE_TAC[LIM_CONST] THEN
  KNOW_TAC ``!n:num. (\n. inv (&n + 1) * (c - x:real)) =
                     (\n. (\n. inv (&n + 1)) n * (\n. (c - x)) n)`` THENL
  [FULL_SIMP_TAC std_ss [], ALL_TAC] THEN DISC_RW_KILL THEN
  MATCH_MP_TAC LIM_MUL THEN REWRITE_TAC[LIM_CONST] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY, o_THM, REAL_SUB_RZERO] THEN BETA_TAC THEN
  X_GEN_TAC ``e:real`` THEN GEN_REWR_TAC LAND_CONV [REAL_ARCH_INV] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  KNOW_TAC ``&n + 1 <> 0:real`` THENL
  [ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   SIMP_TAC arith_ss [REAL_OF_NUM_SUC, REAL_LT, ADD1], ALL_TAC] THEN DISCH_TAC THEN
  ASM_SIMP_TAC std_ss [DIST_0, ABS_INV] THEN MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``inv(&N:real)`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LE_INV2 THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``N:num <= n`` THEN UNDISCH_TAC ``N <> 0:num`` THEN
  REWRITE_TAC[NOT_ZERO_LT_ZERO, GSYM REAL_OF_NUM_LE, GSYM REAL_LT] THEN
  REAL_ARITH_TAC);

val CLOSURE_INTERVAL = store_thm ("CLOSURE_INTERVAL",
 ``(!a b. closure(interval[a,b]) = interval[a,b]) /\
   (!a b. closure(interval(a,b)) =
          if interval(a,b) = {} then {} else interval[a,b])``,
  SIMP_TAC std_ss [CLOSURE_CLOSED, CLOSED_INTERVAL] THEN REPEAT GEN_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [CLOSURE_OPEN_INTERVAL, CLOSURE_EMPTY]);

val BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC = store_thm ("BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC",
 ``!s:real->bool. bounded s ==> ?a. s SUBSET interval(-a,a)``,
  SIMP_TAC std_ss [BOUNDED_POS, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``s:real->bool``, ``B:real``] THEN STRIP_TAC THEN
  EXISTS_TAC ``(B + &1):real`` THEN
  REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [IN_INTERVAL, REAL_BOUNDS_LT] THEN
  METIS_TAC[REAL_LE_REFL, REAL_ARITH ``x <= y ==> a <= x ==> a < y + &1:real``]);

val BOUNDED_SUBSET_OPEN_INTERVAL = store_thm ("BOUNDED_SUBSET_OPEN_INTERVAL",
 ``!s:real->bool. bounded s ==> ?a b. s SUBSET interval(a,b)``,
  MESON_TAC[BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC]);

val BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC = store_thm ("BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC",
 ``!s:real->bool. bounded s ==> ?a. s SUBSET interval[-a,a]``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP BOUNDED_SUBSET_OPEN_INTERVAL_SYMMETRIC) THEN
  STRIP_TAC THEN EXISTS_TAC ``a:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC std_ss [IN_BALL, IN_INTERVAL, SUBSET_DEF, REAL_LT_IMP_LE]);

val BOUNDED_SUBSET_CLOSED_INTERVAL = store_thm ("BOUNDED_SUBSET_CLOSED_INTERVAL",
 ``!s:real->bool. bounded s ==> ?a b. s SUBSET interval[a,b]``,
  MESON_TAC[BOUNDED_SUBSET_CLOSED_INTERVAL_SYMMETRIC]);

val FRONTIER_CLOSED_INTERVAL = store_thm ("FRONTIER_CLOSED_INTERVAL",
 ``!a b. frontier(interval[a,b]) = interval[a,b] DIFF interval(a,b)``,
  SIMP_TAC std_ss [frontier, INTERIOR_CLOSED_INTERVAL, CLOSURE_CLOSED,
           CLOSED_INTERVAL]);

val FRONTIER_OPEN_INTERVAL = store_thm ("FRONTIER_OPEN_INTERVAL",
 ``!a b. frontier(interval(a,b)) =
                if interval(a,b) = {} then {}
                else interval[a,b] DIFF interval(a,b)``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[FRONTIER_EMPTY] THEN
  ASM_SIMP_TAC std_ss [frontier, CLOSURE_OPEN_INTERVAL, INTERIOR_OPEN,
               OPEN_INTERVAL]);

val INTER_INTERVAL_MIXED_EQ_EMPTY = store_thm ("INTER_INTERVAL_MIXED_EQ_EMPTY",
 ``!a b c d:real.
        ~(interval(c,d) = {})
        ==> ((interval(a,b) INTER interval[c,d] = {}) <=>
             (interval(a,b) INTER interval(c,d) = {}))``,
  SIMP_TAC std_ss [GSYM CLOSURE_OPEN_INTERVAL, OPEN_INTER_CLOSURE_EQ_EMPTY,
           OPEN_INTERVAL]);

val INTERVAL_TRANSLATION = store_thm ("INTERVAL_TRANSLATION",
 ``(!c a b. interval[c + a,c + b] = IMAGE (\x. c + x) (interval[a,b])) /\
   (!c a b. interval(c + a,c + b) = IMAGE (\x. c + x) (interval(a,b)))``,
  REWRITE_TAC[interval] THEN CONJ_TAC THEN
  (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
   REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
   TRY (EXISTS_TAC ``-c + x:real``) THEN ASM_REAL_ARITH_TAC));

val EMPTY_AS_INTERVAL = store_thm ("EMPTY_AS_INTERVAL",
 ``{} = interval[1,0]``,
  SIMP_TAC std_ss [EXTENSION, NOT_IN_EMPTY, IN_INTERVAL] THEN
  REAL_ARITH_TAC);

val UNIT_INTERVAL_NONEMPTY = store_thm ("UNIT_INTERVAL_NONEMPTY",
 ``~(interval[0:real,1] = {}) /\
   ~(interval(0:real,1) = {})``,
  SIMP_TAC std_ss [INTERVAL_NE_EMPTY, REAL_LT_01, REAL_POS]);

val IMAGE_STRETCH_INTERVAL = store_thm
  ("IMAGE_STRETCH_INTERVAL",
 ``!a b:real m.
    IMAGE (\x. @f. f = m 1n * x) (interval[a,b]) =
        if interval[a,b] = {} then {}
        else interval[(@f. f = min (m 1n * a) (m 1n * b)):real,
                      (@f. f = max (m 1n * a) (m 1n * b))]``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_SIMP_TAC std_ss [EXTENSION, IN_IMAGE, IN_INTERVAL, GSYM FORALL_AND_THM,
               TAUT `(a ==> b) /\ (a ==> c) <=> a ==> b /\ c`] THEN
  X_GEN_TAC ``x:real`` THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INTERVAL_NE_EMPTY]) THEN
  ASM_CASES_TAC ``(m:num->real)  1n = &0`` THENL
   [ASM_SIMP_TAC std_ss [REAL_MUL_LZERO, REAL_MAX_ACI, REAL_MIN_ACI] THEN
    METIS_TAC[REAL_LE_ANTISYM, REAL_LE_REFL],
    ALL_TAC] THEN
  KNOW_TAC ``!m x y:real. ~(m = 0:real) ==> ((x = m * y) <=> (y = x / m))`` THENL
  [REPEAT GEN_TAC THEN DISCH_TAC THEN ASSUME_TAC REAL_LE_TOTAL THEN
   GEN_REWR_TAC RAND_CONV [EQ_SYM_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
   POP_ASSUM (MP_TAC o Q.SPECL [`m':real`,`0:real`]) THEN
   ASM_SIMP_TAC std_ss [REAL_LE_LT] THEN STRIP_TAC THENL
   [ALL_TAC, METIS_TAC [REAL_EQ_LDIV_EQ]] THEN
   ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN REWRITE_TAC [real_div] THEN
   REWRITE_TAC [REAL_ARITH ``-(a * b) = a * -b:real``] THEN
   ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN POP_ASSUM MP_TAC THEN
   GEN_REWR_TAC LAND_CONV [GSYM REAL_LT_NEG] THEN REWRITE_TAC [REAL_NEG_0] THEN
   DISCH_TAC THEN REWRITE_TAC [REAL_ARITH ``(-x = y * -m) <=> (x = -y * -m:real)``] THEN
   METIS_TAC [REAL_EQ_LDIV_EQ], DISCH_TAC THEN ASM_SIMP_TAC std_ss []] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP
   (REAL_ARITH ``~(z = &0) ==> &0 < z \/ &0 < -z:real``))
  >- ( ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ] \\
       DISCH_TAC \\
       `(m 1) * a <= (m 1) * b` by PROVE_TAC [REAL_LE_LMUL] \\
       ASM_SIMP_TAC std_ss [min_def, max_def] \\
       METIS_TAC [REAL_MUL_SYM] )
  >> ONCE_REWRITE_TAC[GSYM REAL_LE_NEG2]
  >> ONCE_REWRITE_TAC[REAL_MUL_SYM]
  >> KNOW_TAC ``!a b. -(max a b) = min (-a) (-b:real)``
  >- PROVE_TAC [REAL_MAX_MIN, REAL_NEG_NEG] >> DISCH_TAC
  >> KNOW_TAC ``!a b. -(min a b) = max (-a) (-b:real)``
  >- PROVE_TAC [REAL_MIN_MAX, REAL_NEG_NEG] >> DISCH_TAC
  >> ASM_SIMP_TAC std_ss [real_div, GSYM REAL_MUL_RNEG, REAL_NEG_INV]
  >> REWRITE_TAC [GSYM real_div]
  >> ASM_SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ]
  >> ONCE_REWRITE_TAC [REAL_LE_NEG2]
  >> DISCH_TAC
  >> `a * -(m 1) <= b * -(m 1)` by PROVE_TAC [REAL_LE_RMUL]
  >> ASM_SIMP_TAC std_ss [min_def, max_def]
  >> REAL_ARITH_TAC);

val INTERVAL_IMAGE_STRETCH_INTERVAL = store_thm ("INTERVAL_IMAGE_STRETCH_INTERVAL",
 ``!a b:real m. ?u v:real.
     IMAGE (\x. @f. f = m  1n * x) (interval[a,b]) = interval[u,v]``,
  SIMP_TAC std_ss [IMAGE_STRETCH_INTERVAL] THEN METIS_TAC[EMPTY_AS_INTERVAL]);

val CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL = store_thm ("CLOSED_INTERVAL_IMAGE_UNIT_INTERVAL",
 ``!a b:real.
        ~(interval[a,b] = {})
        ==> (interval[a,b] = IMAGE (\x:real. a + x)
                                  (IMAGE (\x. (@f. f = (b - a) * x))
                                         (interval[0:real,1])))``,
  REWRITE_TAC[INTERVAL_NE_EMPTY] THEN REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. @f. f = (b - a) * x) =
                               (\x. @f. f = (\x. (b - a))  1n * x:real)``] THEN
  REWRITE_TAC[IMAGE_STRETCH_INTERVAL] THEN
  SIMP_TAC std_ss [REAL_MUL_RZERO, REAL_MUL_RID, UNIT_INTERVAL_NONEMPTY] THEN
  REWRITE_TAC[EXTENSION, IN_INTERVAL] THEN
  GEN_TAC THEN SIMP_TAC std_ss [IN_IMAGE, IN_INTERVAL, min_def, max_def] THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LE] THEN EQ_TAC THENL
  [DISCH_TAC THEN EXISTS_TAC ``x - a:real`` THEN ASM_REAL_ARITH_TAC, ASM_REAL_ARITH_TAC]);

val SUMS_INTERVALS = store_thm ("SUMS_INTERVALS",
 ``(!a b c d:real.
        ~(interval[a,b] = {}) /\ ~(interval[c,d] = {})
        ==> ({x + y | x IN interval[a,b] /\ y IN interval[c,d]} =
             interval[a+c,b+d])) /\
   (!a b c d:real.
        ~(interval(a,b) = {}) /\ ~(interval(c,d) = {})
        ==> ({x + y | x IN interval(a,b) /\ y IN interval(c,d)} =
             interval(a+c,b+d)))``,
  CONJ_TAC THEN REPEAT GEN_TAC THEN REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
  STRIP_TAC THEN SIMP_TAC std_ss [EXTENSION, IN_INTERVAL, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC[TAUT `(a /\ b) /\ c <=> c /\ a /\ b`] THEN
  REWRITE_TAC[REAL_ARITH ``(x:real = y + z) <=> (z = x - y)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN (* 2 subgoals *)
  ( X_GEN_TAC ``x:real`` THEN EQ_TAC
 >- ( DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) >> ASM_REAL_ARITH_TAC )
 >> STRIP_TAC
 >> ONCE_REWRITE_TAC [CONJ_SYM]
 >> KNOW_TAC
    ``(!y. (a <= y /\ y <= b) /\ c <= x - y /\ x - y <= d <=>
       ((if a <= x - d then x - d else a) <= y /\
    y <= if b <= x - c then b else x - c:real)) /\
      (!y. (a < y /\ y < b) /\ c < x - y /\ x - y < d <=>
       ((if a <= x - d then x - d else a) < y /\
    y < if b <= x - c then b else x - c:real))``
 >- ( CONJ_TAC >> GEN_TAC >> rpt COND_CASES_TAC >> ASM_REAL_ARITH_TAC )
 >> STRIP_TAC >> ASM_REWRITE_TAC []
 >> REWRITE_TAC [GSYM min_def, GSYM max_def, GSYM REAL_LE_BETWEEN, GSYM REAL_LT_BETWEEN]
 >> ASM_REWRITE_TAC [min_def, max_def]
 >> rpt COND_CASES_TAC (* 4 subgoals *)
 >> METIS_TAC [REAL_LE_SUB_LADD, REAL_LE_SUB_RADD, REAL_LE_LADD, REAL_LE_NEG, real_sub,
               REAL_LT_SUB_LADD, REAL_LT_SUB_RADD, REAL_LT_LADD, REAL_LT_NEG] ));

val OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL = store_thm ("OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval[a,b] SUBSET s) /\
   (!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval(a,b) SUBSET s)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN GEN_TAC THEN
  MATCH_MP_TAC(TAUT
   `(q ==> r) /\ (r ==> p) /\ (p ==> q) ==> (p <=> q) /\ (p <=> r)`) THEN
  REPEAT CONJ_TAC THENL
   [MESON_TAC[SUBSET_TRANS, INTERVAL_OPEN_SUBSET_CLOSED],
    DISCH_TAC THEN REWRITE_TAC[OPEN_CONTAINS_BALL] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN STRIP_TAC THEN
    MP_TAC(ISPEC ``interval(a:real,b)`` OPEN_CONTAINS_BALL) THEN
    REWRITE_TAC[OPEN_INTERVAL] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
        REPEAT STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
    ASM_MESON_TAC[SUBSET_TRANS, INTERVAL_OPEN_SUBSET_CLOSED],
    DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o SPEC ``x:real`` o
      REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``x - e:real`` THEN
    EXISTS_TAC ``x + e:real`` THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
     ``b SUBSET s ==> x IN i /\ j SUBSET b ==> x IN i /\ j SUBSET s``)) THEN
    SIMP_TAC std_ss [IN_INTERVAL, IN_CBALL, SUBSET_DEF, REAL_MUL_RID] THEN
    REWRITE_TAC[REAL_ARITH ``x - e < x /\ x < x + e <=> &0 < e:real``,
                REAL_ARITH ``x - e <= y /\ y <= x + e <=> abs(x - y) <= e:real``] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT, LE_1] THEN
    X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN ASM_REWRITE_TAC[dist]]);

val OPEN_CONTAINS_INTERVAL = store_thm ("OPEN_CONTAINS_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval[a,b] SUBSET s)``,
   REWRITE_TAC [OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL]);

val OPEN_CONTAINS_OPEN_INTERVAL = store_thm ("OPEN_CONTAINS_OPEN_INTERVAL",
 ``(!s:real->bool.
        open s <=>
        !x. x IN s ==> ?a b. x IN interval(a,b) /\ interval(a,b) SUBSET s)``,
   METIS_TAC [OPEN_CONTAINS_INTERVAL_OPEN_INTERVAL]);

val DIAMETER_INTERVAL = store_thm ("DIAMETER_INTERVAL",
 ``(!a b:real.
        diameter(interval[a,b]) =
        if interval[a,b] = {} then &0 else abs(b - a)) /\
   (!a b:real.
        diameter(interval(a,b)) =
        if interval(a,b) = {} then &0 else abs(b - a))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``interval[a:real,b] = {}`` THENL
   [METIS_TAC[INTERVAL_OPEN_SUBSET_CLOSED, SUBSET_EMPTY, DIAMETER_EMPTY],
    ASM_REWRITE_TAC[]] THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
   [REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
    ASM_SIMP_TAC std_ss [DIAMETER_BOUNDED_BOUND,
                 ENDS_IN_INTERVAL, BOUNDED_INTERVAL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
     ``diameter(cball(inv(&2) * (a + b):real,abs(b - a) / &2))`` THEN
    CONJ_TAC THENL
     [MATCH_MP_TAC DIAMETER_SUBSET THEN REWRITE_TAC[BOUNDED_CBALL] THEN
      REWRITE_TAC[SUBSET_DEF, IN_INTERVAL, IN_CBALL] THEN
      GEN_TAC THEN DISCH_TAC THEN REWRITE_TAC[dist] THEN
      KNOW_TAC ``x = x * (2 / 2:real)`` THENL
      [METIS_TAC [REAL_DIV_REFL, REAL_MUL_RID, REAL_ARITH ``2 <> 0:real``],
       DISCH_TAC THEN ONCE_ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
       REWRITE_TAC [real_div]] THEN
      REWRITE_TAC [REAL_ARITH ``a * (b * inv b) = inv b * (a * b:real)``] THEN
      REWRITE_TAC [GSYM REAL_SUB_LDISTRIB, ABS_MUL] THEN
      SIMP_TAC std_ss [ABS_INV, REAL_ARITH ``2 <> 0:real``, ABS_N] THEN
      GEN_REWR_TAC RAND_CONV [REAL_MUL_SYM] THEN MATCH_MP_TAC REAL_LE_MUL2 THEN
      SIMP_TAC std_ss [ABS_POS, REAL_LE_REFL, REAL_INV_1OVER, REAL_HALF_BETWEEN] THEN
      ASM_REAL_ARITH_TAC,
      REWRITE_TAC[DIAMETER_CBALL] THEN COND_CASES_TAC THEN
      REWRITE_TAC [ABS_POS, real_div] THEN
      ONCE_REWRITE_TAC [REAL_ARITH ``a * (b * c) = (a * c) * b:real``] THEN
      SIMP_TAC std_ss [REAL_MUL_RINV, REAL_ARITH ``2 <> 0:real``] THEN
      REAL_ARITH_TAC],
    DISCH_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[DIAMETER_EMPTY] THEN
    SUBGOAL_THEN ``interval[a:real,b] = closure(interval(a,b))``
    SUBST_ALL_TAC THEN ASM_REWRITE_TAC[CLOSURE_INTERVAL] THEN
    ASM_MESON_TAC[DIAMETER_CLOSURE, BOUNDED_INTERVAL]]);

val IMAGE_TWIZZLE_INTERVAL = store_thm ("IMAGE_TWIZZLE_INTERVAL",
 ``!p a b. IMAGE ((\x. x):real->real) (interval[a,b]) =
               interval[a,b]``,
  SET_TAC [interval]);

val EQ_INTERVAL = store_thm ("EQ_INTERVAL",
 ``(!a b c d:real.
        (interval[a,b] = interval[c,d]) <=>
        ((interval[a,b] = {}) /\ (interval[c,d] = {})) \/ ((a = c) /\ (b = d))) /\
   (!a b c d:real.
        (interval[a,b] = interval(c,d)) <=>
        (interval[a,b] = {}) /\ (interval(c,d) = {})) /\
   (!a b c d:real.
        (interval(a,b) = interval[c,d]) <=>
        (interval(a,b) = {}) /\ (interval[c,d] = {})) /\
   (!a b c d:real.
        (interval(a,b) = interval(c,d)) <=>
        ((interval(a,b) = {}) /\ (interval(c,d) = {})) \/ ((a = c) /\ (b = d)))``,
  REPEAT CONJ_TAC THEN REPEAT GEN_TAC THEN
  (EQ_TAC THENL [ALL_TAC, STRIP_TAC THEN ASM_REWRITE_TAC[]]) THEN
  MATCH_MP_TAC(MESON[]
   ``((p = {}) /\ (q = {}) ==> r) /\ (~(p = {}) /\ ~(q = {}) ==> (p = q) ==> r)
    ==> (p = q) ==> r``) THEN
  SIMP_TAC std_ss [] THENL
   [REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
    REWRITE_TAC[GSYM SUBSET_ANTISYM] THEN
    METIS_TAC [SUBSET_INTERVAL, GSYM REAL_LE_ANTISYM],
    STRIP_TAC THEN MATCH_MP_TAC(MESON[CLOPEN]
     ``closed s /\ open t /\ ~(s = {}) /\ ~(s = UNIV) ==> ~(s = t)``) THEN
    ASM_REWRITE_TAC[CLOSED_INTERVAL, OPEN_INTERVAL, NOT_INTERVAL_UNIV],
    STRIP_TAC THEN MATCH_MP_TAC(MESON[CLOPEN]
     ``closed s /\ open t /\ ~(s = {}) /\ ~(s = UNIV) ==> ~(t = s)``) THEN
    ASM_REWRITE_TAC[CLOSED_INTERVAL, OPEN_INTERVAL, NOT_INTERVAL_UNIV],
    REWRITE_TAC[INTERVAL_NE_EMPTY] THEN
    REWRITE_TAC[GSYM SUBSET_ANTISYM] THEN
    METIS_TAC [SUBSET_INTERVAL, GSYM REAL_LE_ANTISYM]]);

val CLOSED_INTERVAL_EQ = store_thm ("CLOSED_INTERVAL_EQ",
 ``(!a b:real. closed(interval[a,b])) /\
   (!a b:real. closed(interval(a,b)) <=> (interval(a,b) = {}))``,
  REWRITE_TAC[CLOSED_INTERVAL] THEN
  REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN
  MP_TAC(ISPEC ``interval(a:real,b)`` CLOPEN) THEN
  ASM_REWRITE_TAC[OPEN_INTERVAL] THEN
  METIS_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val OPEN_INTERVAL_EQ = store_thm ("OPEN_INTERVAL_EQ",
 ``(!a b:real. open(interval[a,b]) <=> (interval[a,b] = {})) /\
   (!a b:real. open(interval(a,b)))``,
  REWRITE_TAC[OPEN_INTERVAL] THEN
  REPEAT GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_REWRITE_TAC[CLOSED_EMPTY] THEN
  MP_TAC(ISPEC ``interval[a:real,b]`` CLOPEN) THEN
  ASM_REWRITE_TAC[CLOSED_INTERVAL] THEN
  METIS_TAC[BOUNDED_INTERVAL, NOT_BOUNDED_UNIV]);

val COMPACT_INTERVAL_EQ = store_thm ("COMPACT_INTERVAL_EQ",
 ``(!a b:real. compact(interval[a,b])) /\
   (!a b:real. compact(interval(a,b)) <=> (interval(a,b) = {}))``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTERVAL] THEN
  REWRITE_TAC[CLOSED_INTERVAL_EQ]);

val EQ_BALLS = store_thm ("EQ_BALLS",
 ``(!a a':real r r'.
      (ball(a,r) = ball(a',r')) <=> (a = a') /\ (r = r') \/ r <= &0 /\ r' <= &0) /\
   (!a a':real r r'.
      (ball(a,r) = cball(a',r')) <=> r <= &0 /\ r' < &0) /\
   (!a a':real r r'.
      (cball(a,r) = ball(a',r')) <=> r < &0 /\ r' <= &0) /\
   (!a a':real r r'.
      (cball(a,r) = cball(a',r')) <=> (a = a') /\ (r = r') \/ r < &0 /\ r' < &0)``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT STRIP_TAC THEN
  (EQ_TAC THENL
    [ALL_TAC, REWRITE_TAC[EXTENSION, IN_BALL, IN_CBALL, dist] THEN REAL_ARITH_TAC])
  THENL
   [SIMP_TAC std_ss [SET_EQ_SUBSET, SUBSET_BALLS, dist] THEN REAL_ARITH_TAC,
    ONCE_REWRITE_TAC[EQ_SYM_EQ],
    ALL_TAC,
    REWRITE_TAC[SET_EQ_SUBSET, SUBSET_BALLS, dist] THEN REAL_ARITH_TAC] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (METIS [CLOPEN, BOUNDED_BALL, NOT_BOUNDED_UNIV]
    ``(s = t) ==> closed s /\ open t /\ bounded t ==> (s = {}) /\ (t = {})``)) THEN
  REWRITE_TAC[OPEN_BALL, CLOSED_CBALL, BOUNDED_BALL,
              BALL_EQ_EMPTY, CBALL_EQ_EMPTY] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Some special cases for intervals in R^1.                                  *)
(* ------------------------------------------------------------------------- *)

val INTERVAL_CASES = store_thm ("INTERVAL_CASES",
 ``!x:real. x IN interval[a,b] ==> x IN interval(a,b) \/ (x = a) \/ (x = b)``,
  REWRITE_TAC[IN_INTERVAL] THEN REAL_ARITH_TAC);

val OPEN_CLOSED_INTERVAL = store_thm ("OPEN_CLOSED_INTERVAL",
 ``!a b:real. interval(a,b) = interval[a,b] DIFF {a;b}``,
  REWRITE_TAC[EXTENSION, IN_INTERVAL, IN_DIFF, IN_INSERT, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val CLOSED_OPEN_INTERVAL = store_thm ("CLOSED_OPEN_INTERVAL",
 ``!a b:real. a <= b ==> (interval[a,b] = interval(a,b) UNION {a;b})``,
  REWRITE_TAC[EXTENSION, IN_INTERVAL, IN_UNION, IN_INSERT, NOT_IN_EMPTY] THEN
  SIMP_TAC std_ss [] THEN REAL_ARITH_TAC);

val BALL = store_thm ("BALL",
 ``!x:real r. (cball(x,r) = interval[x - r,x + r]) /\
               (ball(x,r) = interval(x - r,x + r))``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_CBALL, IN_INTERVAL] THEN
  REWRITE_TAC[dist] THEN REAL_ARITH_TAC);

val SPHERE = store_thm ("SPHERE",
 ``!a:real r. sphere(a,r) = if r < (&0:real) then {} else {a - r;a + r}``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sphere] THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_INSERT, NOT_IN_EMPTY, GSPECIFICATION, dist] THEN
  ASM_REAL_ARITH_TAC);

val FINITE_SPHERE = store_thm ("FINITE_SPHERE",
 ``!a:real r. FINITE(sphere(a,r))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SPHERE] THEN
  METIS_TAC[FINITE_INSERT, FINITE_EMPTY]);

val FINITE_INTERVAL = store_thm ("FINITE_INTERVAL",
 ``(!a b. FINITE(interval[a,b]) <=> b <= a) /\
   (!a b. FINITE(interval(a,b)) <=> b <= a)``,
  REWRITE_TAC[OPEN_CLOSED_INTERVAL] THEN
  REWRITE_TAC[SET_RULE ``s DIFF {a;b} = s DELETE a DELETE b``] THEN
  REWRITE_TAC[FINITE_DELETE] THEN REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [interval, FINITE_IMAGE_INJ_EQ, FINITE_REAL_INTERVAL]);

val BALL_INTERVAL = store_thm ("BALL_INTERVAL",
 ``!x:real e. ball(x,e) = interval(x - e,x + e)``,
  REWRITE_TAC[EXTENSION, IN_BALL, IN_INTERVAL, dist] THEN
  REAL_ARITH_TAC);

val CBALL_INTERVAL = store_thm ("CBALL_INTERVAL",
 ``!x:real e. cball(x,e) = interval[x - e,x + e]``,
  REWRITE_TAC[EXTENSION, IN_CBALL, IN_INTERVAL, dist] THEN
  REAL_ARITH_TAC);

val BALL_INTERVAL_0 = store_thm ("BALL_INTERVAL_0",
 ``!e. ball(0:real,e) = interval(-e,e)``,
  GEN_TAC THEN REWRITE_TAC[BALL_INTERVAL] THEN AP_TERM_TAC THEN
  BINOP_TAC THEN REAL_ARITH_TAC);

val CBALL_INTERVAL_0 = store_thm ("CBALL_INTERVAL_0",
 ``!e. cball(0:real,e) = interval[-e,e]``,
  GEN_TAC THEN REWRITE_TAC[CBALL_INTERVAL] THEN AP_TERM_TAC THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN BINOP_TAC THEN REAL_ARITH_TAC);

val CLOSED_DIFF_OPEN_INTERVAL = store_thm ("CLOSED_DIFF_OPEN_INTERVAL",
 ``!a b:real.
        interval[a,b] DIFF interval(a,b) =
        if interval[a,b] = {} then {} else {a;b}``,
  REWRITE_TAC[EXTENSION, IN_DIFF, GSYM INTERVAL_EQ_EMPTY, IN_INTERVAL] THEN
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_REWRITE_TAC[NOT_IN_EMPTY, IN_INSERT, NOT_IN_EMPTY] THEN
  FULL_SIMP_TAC std_ss [NOT_IN_EMPTY] THEN
  ASM_REAL_ARITH_TAC);

val INTERVAL = store_thm ("INTERVAL",
 ``(!a b:real. interval[a,b] =
                 if a <= b then cball(midpoint(a,b),dist(a,b) / &2)
                 else {}) /\
   (!a b:real. interval(a,b) =
                 if a < b then ball(midpoint(a,b),dist(a,b) / &2)
                 else {})``,
  REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[REAL_NOT_LE, REAL_NOT_LT]) THEN
  ASM_REWRITE_TAC[INTERVAL_EQ_EMPTY] THEN
  REWRITE_TAC[BALL, dist] THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LE, REAL_LT_IMP_LE,
                       REAL_ARITH ``a <= b ==> (abs(a - b) = b - a:real)``] THEN
  REWRITE_TAC[METIS [real_div, REAL_MUL_SYM] ``x / &2 = inv(&2:real) * x``] THEN
  REWRITE_TAC[midpoint] THEN
  TRY AP_TERM_TAC THEN ASM_SIMP_TAC std_ss [PAIR_EQ, CONS_11, GSYM INTERVAL_EQ_EMPTY] THEN
  REWRITE_TAC [GSYM REAL_SUB_LDISTRIB, GSYM REAL_ADD_LDISTRIB] THEN
  REWRITE_TAC [REAL_ARITH ``a + b - (b - a) = 2 * a:real``] THEN
  REWRITE_TAC [REAL_ARITH ``a + b + (b - a) = 2 * b:real``] THEN
  SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_ARITH ``2 <> 0:real``, REAL_MUL_LINV] THEN REAL_ARITH_TAC);

val SEGMENT = store_thm ("SEGMENT",
 ``(!a b. segment[a,b] =
          if a <= b then interval[a,b] else interval[b,a]) /\
   (!a b. segment(a,b) =
          if a <= b then interval(a,b) else interval(b,a))``,
  CONJ_TAC THEN REPEAT GEN_TAC THEN REWRITE_TAC[open_segment] THEN
  COND_CASES_TAC THEN
  REWRITE_TAC[IN_DIFF, IN_INSERT, NOT_IN_EMPTY,
              EXTENSION, GSYM BETWEEN_IN_SEGMENT, between, IN_INTERVAL] THEN
  REWRITE_TAC[dist] THEN ASM_REAL_ARITH_TAC);

val OPEN_SEGMENT = store_thm ("OPEN_SEGMENT",
 ``!a b:real. open(segment(a,b))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SEGMENT] THEN
  COND_CASES_TAC THEN REWRITE_TAC[OPEN_INTERVAL]);

val SEGMENT_SCALAR_MULTIPLE = store_thm ("SEGMENT_SCALAR_MULTIPLE",
 ``(!a b v:real. segment[a * v,b * v] =
            {x * v:real | a <= x /\ x <= b \/ b <= x /\ x <= a}) /\
   (!a b v:real. ~(v = 0)
            ==> (segment(a * v,b * v) =
                 {x * v:real | a < x /\ x < b \/ b < x /\ x < a}))``,
  MATCH_MP_TAC(TAUT `a /\ (a ==> b) ==> a /\ b`) THEN REPEAT STRIP_TAC THENL
   [REPEAT GEN_TAC THEN
    MP_TAC(SPECL [``a * 1:real``, ``b * 1:real``]
     (CONJUNCT1 SEGMENT)) THEN
    REWRITE_TAC[segment, REAL_MUL_ASSOC, GSYM REAL_ADD_RDISTRIB] THEN
        ONCE_REWRITE_TAC [METIS [] ``((1 - u) * a + u * b:real) =
                                (\u. ((1 - u) * a + u * b)) u``] THEN
        ONCE_REWRITE_TAC [METIS [] ``(0 <= u /\ u <= 1:real) =
                                (\u.  0 <= u /\ u <= 1) u``] THEN
        ONCE_REWRITE_TAC [METIS []
        ``{x:real * v | a <= x /\ x <= b \/ b <= x /\ x <= a} =
          {(\x. x) x * v | (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x}``] THEN
    REWRITE_TAC [SET_RULE ``{f x * b:real | p (x:real)} =
                                IMAGE (\a. a * b) {f x | p x}``] THEN
    BETA_TAC THEN DISCH_TAC THEN AP_TERM_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [REAL_MUL_RID, IMAGE_ID]) THEN
    DISCH_THEN SUBST1_TAC THEN COND_CASES_TAC THEN
        SIMP_TAC std_ss [EXTENSION, IN_INTERVAL, GSPECIFICATION] THEN ASM_REAL_ARITH_TAC,
    ASM_REWRITE_TAC[open_segment] THEN
        ONCE_REWRITE_TAC [METIS [] ``{x * v | a <= x /\ x <= b \/ b <= x /\ x <= a:real} =
                        {(\x. x) x * v | (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x}``] THEN
    ASM_SIMP_TAC std_ss [REAL_EQ_RMUL, SET_RULE
     ``(!x y:real. (x * v = y * v) <=> (x = y))
      ==> ({x * v | P x} DIFF {a * v;b * v} =
           {x * v | P x /\ ~(x = a) /\ ~(x = b)})``] THEN
        ONCE_REWRITE_TAC [SET_RULE
        ``{x * v | (a <= x /\ x <= b \/ b <= x /\ x <= a) /\ x <> a /\ x <> b:real} =
     {(\x. x * v) x | x IN (\x. (a <= x /\ x <= b \/ b <= x /\ x <= a) /\ x <> a /\ x <> b)}``] THEN
        ONCE_REWRITE_TAC [SET_RULE
              ``{x * v | a < x /\ x < b \/ b < x /\ x < a:real} =
       {(\x. x * v) x | x IN (\x. (a < x /\ x < b \/ b < x /\ x < a))}``] THEN
    ONCE_REWRITE_TAC[GSYM IMAGE_DEF] THEN AP_TERM_TAC THEN
    ABS_TAC THEN REAL_ARITH_TAC]);

(* ------------------------------------------------------------------------- *)
(* Intervals in general, including infinite and mixtures of open and closed. *)
(* ------------------------------------------------------------------------- *)

val is_interval = new_definition ("is_interval",
  ``is_interval(s:real->bool) <=>
        !a b x. a IN s /\ b IN s
                     ==> (a <= x /\ x <= b) \/
                         (b <= x /\ x <= a)
                ==> x IN s``);

val IS_INTERVAL_INTERVAL = store_thm ("IS_INTERVAL_INTERVAL",
 ``!a:real b. is_interval(interval (a,b)) /\ is_interval(interval [a,b])``,
  REWRITE_TAC[is_interval, IN_INTERVAL] THEN
  METIS_TAC[REAL_LT_TRANS, REAL_LE_TRANS, REAL_LET_TRANS, REAL_LTE_TRANS]);

val IS_INTERVAL_EMPTY = store_thm ("IS_INTERVAL_EMPTY",
 ``is_interval {}``,
  REWRITE_TAC[is_interval, NOT_IN_EMPTY]);

val IS_INTERVAL_UNIV = store_thm ("IS_INTERVAL_UNIV",
 ``is_interval(UNIV:real->bool)``,
  REWRITE_TAC[is_interval, IN_UNIV]);

val IS_INTERVAL_POINTWISE = store_thm ("IS_INTERVAL_POINTWISE",
 ``!s:real->bool x.
        is_interval s ==> (?a. a IN s /\ (a = x))
        ==> x IN s``,
  METIS_TAC [is_interval]);

Theorem IS_INTERVAL_COMPACT :
    !s:real->bool. is_interval s /\ compact s <=> ?a b. s = interval[a,b]
Proof
  GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [IS_INTERVAL_INTERVAL, COMPACT_INTERVAL] THEN
  ASM_CASES_TAC ``s:real->bool = {}``
  >- ASM_MESON_TAC[EMPTY_AS_INTERVAL] THEN (* one goal left *)
  EXISTS_TAC ``(@f. f = inf { (x:real) | x IN s}):real`` THEN
  EXISTS_TAC ``(@f. f = sup { (x:real) | x IN s}):real`` THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTERVAL] THEN X_GEN_TAC ``x:real`` THEN
  EQ_TAC THENL (* 2 subgoals *)
  [ (* goal 1 (of 2) *)
    DISCH_TAC THEN
    MP_TAC(ISPEC ``{ (x:real) | x IN s}`` INF) THEN
    MP_TAC(ISPEC ``{ (x:real) | x IN s}`` SUP) THEN
    SIMP_TAC std_ss [METIS [] ``x = (\x. x) x``, GSYM IMAGE_DEF] THEN
    ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP COMPACT_IMP_BOUNDED) THEN
    REWRITE_TAC[bounded_def] THEN
    ASM_MESON_TAC[REAL_LE_TRANS, MEMBER_NOT_EMPTY,
                  REAL_ARITH ``abs(x) <= B ==> -B <= x /\ x <= B:real``],
    (* goal 2 (of 2) *)
    DISCH_TAC THEN
    SUFF_TAC ``?a:real. a IN s /\ (a = x)``
    >- (MATCH_MP_TAC IS_INTERVAL_POINTWISE >> ASM_REWRITE_TAC []) THEN
    SUBGOAL_THEN
     ``?a b:real. a IN s /\ b IN s /\ a <= (x:real) /\ x <= b``
    STRIP_ASSUME_TAC THENL (* 2 subgoals *)
    [ (* goal 2.1 (of 2) *)
      MP_TAC (ISPECL [``\x:real. x``, ``s:real->bool``]
                     CONTINUOUS_ATTAINS_INF) THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, o_DEF] THEN
      DISCH_THEN (X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC ``a:real`` THEN
      MP_TAC (ISPECL [``\x:real. x``, ``s:real->bool``]
                     CONTINUOUS_ATTAINS_SUP) THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ID, o_DEF] THEN
      DISCH_THEN (X_CHOOSE_THEN ``b:real`` STRIP_ASSUME_TAC) THEN
      EXISTS_TAC ``b:real`` THEN ASM_REWRITE_TAC [] THEN
      CONJ_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THENL (* 2 subgoals *)
      [ (* goal 2.1.1 (of 2) *)
        EXISTS_TAC ``inf {(x:real) | x IN s}`` THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC REAL_LE_INF THEN
        ONCE_REWRITE_TAC [METIS [SPECIFICATION] ``{x | x IN s} x <=> x IN {x | x IN s}``] THEN
        ASM_SET_TAC [],
        (* goal 2.1.2 (of 2) *)
        EXISTS_TAC ``sup {(x:real) | x IN s}`` THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC REAL_SUP_LE' THEN
        ONCE_REWRITE_TAC [METIS [SPECIFICATION] ``{x | x IN s} x <=> x IN {x | x IN s}``] THEN
        ASM_SET_TAC [] ],
      (* goal 2.2 (of 2) *)
      EXISTS_TAC ``x:real`` THEN ASM_SIMP_TAC std_ss [] THEN
      UNDISCH_TAC ``is_interval s`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE[is_interval, AND_IMP_INTRO]) THEN
      MAP_EVERY EXISTS_TAC [``a:real``, ``b:real``] THEN
      ASM_SIMP_TAC std_ss [] ] ]
QED

val IS_INTERVAL = store_thm ("IS_INTERVAL",
 ``!s:real->bool.
        is_interval s <=>
          !a b x. a IN s /\ b IN s /\ a <= x /\ x <= b
                  ==> x IN s``,
  REWRITE_TAC[is_interval] THEN MESON_TAC[]);

val IS_INTERVAL_CASES = store_thm ("IS_INTERVAL_CASES",
 ``!s:real->bool.
        is_interval s <=>
        (s = {}) \/
        (s = univ(:real)) \/
        (?a. s = {x | a < x}) \/
        (?a. s = {x | a <= x}) \/
        (?b. s = {x | x <= b}) \/
        (?b. s = {x | x < b}) \/
        (?a b. s = {x | a < x /\ x < b}) \/
        (?a b. s = {x | a < x /\ x <= b}) \/
        (?a b. s = {x | a <= x /\ x < b}) \/
        (?a b. s = {x | a <= x /\ x <= b})``,
  GEN_TAC THEN REWRITE_TAC[IS_INTERVAL] THEN EQ_TAC THENL
   [DISCH_TAC,
    STRIP_TAC THEN ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, NOT_IN_EMPTY] THEN
    REAL_ARITH_TAC] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPEC ``s:real->bool`` SUP) THEN
  MP_TAC(ISPEC ``s:real->bool`` INF) THEN
  ASM_SIMP_TAC std_ss [IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
  ASM_CASES_TAC ``?a. !x:real. x IN s ==> a <= x`` THEN
  ASM_CASES_TAC ``?b. !x:real. x IN s ==> x <= b`` THEN
  ASM_REWRITE_TAC[] THENL
   [STRIP_TAC THEN STRIP_TAC THEN
    MAP_EVERY ASM_CASES_TAC
     [``inf(s) IN s:real->bool``, ``sup(s) IN s:real->bool``]
    THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
      DISJ2_TAC THEN DISJ1_TAC] THEN
    MAP_EVERY EXISTS_TAC [``inf(s:real->bool)``, ``sup(s:real->bool)``],
    STRIP_TAC THEN ASM_CASES_TAC ``inf(s:real->bool) IN s`` THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ1_TAC] THEN
    EXISTS_TAC ``inf(s:real->bool)``,
    STRIP_TAC THEN ASM_CASES_TAC ``sup(s:real->bool) IN s`` THENL
     [DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ1_TAC,
      DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN DISJ2_TAC THEN
          DISJ1_TAC] THEN
    EXISTS_TAC ``sup(s:real->bool)``,
    DISJ1_TAC] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_UNIV] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[IN_IMAGE]) THEN
  REWRITE_TAC[GSYM REAL_NOT_LE] THEN
  ASM_MESON_TAC [REAL_LE_TRANS, REAL_LE_TOTAL, REAL_LE_ANTISYM]);

val IS_INTERVAL_INTER = store_thm ("IS_INTERVAL_INTER",
 ``!s t:real->bool.
        is_interval s /\ is_interval t ==> is_interval(s INTER t)``,
  REWRITE_TAC[is_interval, IN_INTER] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``x:real``] THEN
  REPEAT STRIP_TAC THENL
  [UNDISCH_TAC ``!a b x.
            a IN s /\ b IN s ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN s:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN t /\ b IN t ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN t:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN s /\ b IN s ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN s:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO]),
   UNDISCH_TAC ``!a b x.
            a IN t /\ b IN t ==>
            a <= x /\ x <= b \/ b <= x /\ x <= a ==>
            x IN t:real->bool`` THEN DISCH_TAC THEN
   FIRST_X_ASSUM (MATCH_MP_TAC o REWRITE_RULE [AND_IMP_INTRO])] THEN
  MAP_EVERY EXISTS_TAC [``a:real``, ``b:real``] THEN ASM_REWRITE_TAC[]);

val INTERVAL_SUBSET_IS_INTERVAL = store_thm ("INTERVAL_SUBSET_IS_INTERVAL",
 ``!s a b:real.
     is_interval s
     ==> (interval[a,b] SUBSET s <=> (interval[a,b] = {}) \/ a IN s /\ b IN s)``,
  REWRITE_TAC[is_interval] THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``interval[a:real,b] = {}`` THEN
  ASM_REWRITE_TAC[EMPTY_SUBSET] THEN
  EQ_TAC THENL [ASM_MESON_TAC[ENDS_IN_INTERVAL, SUBSET_DEF], ALL_TAC] THEN
  REWRITE_TAC[SUBSET_DEF, IN_INTERVAL] THEN ASM_MESON_TAC[]);

val INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD = store_thm
  ("INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD",
 ``!s x:real.
        is_interval s /\ x IN s
        ==> ?a b d. &0 < d /\ x IN interval[a,b] /\
                    interval[a,b] SUBSET s /\
                    ball(x,d) INTER s SUBSET interval[a,b]``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [INTERVAL_SUBSET_IS_INTERVAL] THEN
  SUBGOAL_THEN ``?a. (?y. y IN s /\ (y = a)) /\
                    (a < x \/ (a = (x:real)) /\
                        !y:real. y IN s ==> a <= y)``
  MP_TAC THENL [ASM_MESON_TAC[REAL_NOT_LT], SIMP_TAC std_ss []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  SUBGOAL_THEN
   ``?b. (?y. y IN s /\ (y = b)) /\
                (x < b \/ (b = (x:real)) /\
                            !y:real. y IN s ==> y <= b)``
  MP_TAC THENL [ASM_MESON_TAC[REAL_NOT_LT], SIMP_TAC std_ss []] THEN
  DISCH_THEN (X_CHOOSE_TAC ``b:real``) THEN EXISTS_TAC ``b:real`` THEN
  EXISTS_TAC ``min (if a < x then (x:real) - a else &1)
                   (if x < b then (b:real) - x else &1)`` THEN
  REWRITE_TAC[REAL_LT_MIN, SUBSET_DEF, IN_BALL, IN_INTER] THEN
  SIMP_TAC std_ss [REAL_LT_INF_FINITE, IMAGE_EQ_EMPTY, IMAGE_FINITE,
                   FINITE_NUMSEG, NUMSEG_EMPTY, GSYM NOT_LESS_EQUAL] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_INTERVAL] THEN REPEAT CONJ_TAC THENL
   [METIS_TAC[REAL_SUB_LT, REAL_LT_01],
    METIS_TAC[REAL_SUB_LT, REAL_LT_01],
    ASM_MESON_TAC[REAL_LE_LT],
    ASM_MESON_TAC[REAL_LE_LT],
        METIS_TAC [], ALL_TAC] THEN
    X_GEN_TAC ``y:real`` THEN
    DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
    MATCH_MP_TAC MONO_AND THEN CONJ_TAC THEN
    (COND_CASES_TAC THENL [REWRITE_TAC[dist], ASM_MESON_TAC[]]) THEN
        REWRITE_TAC [abs] THEN COND_CASES_TAC THEN DISCH_TAC THENL
        [FULL_SIMP_TAC std_ss [REAL_ARITH ``x - y < x - a <=> a < y:real``, REAL_LE_LT],
     FULL_SIMP_TAC std_ss [REAL_NOT_LE, REAL_ARITH ``x - y < 0 <=> x < y:real``] THEN
         METIS_TAC [REAL_LE_TRANS, REAL_LE_LT],
         FULL_SIMP_TAC std_ss [REAL_SUB_LE] THEN METIS_TAC [REAL_LE_TRANS, REAL_LE_LT],
         FULL_SIMP_TAC std_ss [REAL_NEG_SUB,
          REAL_ARITH ``y - x < b - x <=> y < b:real``, REAL_LE_LT]]);

Theorem IS_INTERVAL_SUMS :
    !s t:real->bool.
        is_interval s /\ is_interval t
        ==> is_interval {x + y | x IN s /\ y IN t}
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[is_interval] THEN
  SIMP_TAC std_ss [IMP_CONJ, RIGHT_FORALL_IMP_THM] THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN
  MAP_EVERY X_GEN_TAC
   [``a:real``, ``a':real``, ``b:real``, ``b':real``, ``y:real``] THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (MP_TAC o SPECL [``a:real``, ``b:real``]) MP_TAC) THEN
  DISCH_THEN(CONJUNCTS_THEN2
   (MP_TAC o SPECL [``a':real``, ``b':real``]) ASSUME_TAC) THEN
  ASM_SIMP_TAC std_ss [AND_IMP_INTRO, GSPECIFICATION, EXISTS_PROD] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(z:real = x + y) <=> (y = z - x)``] THEN
  SIMP_TAC std_ss [UNWIND_THM2] THEN
  ONCE_REWRITE_TAC [METIS []
   ``!a b s. (!x. a <= x /\ x <= b \/ b <= x /\ x <= a ==> x IN s:real->bool) =
             (!x. (\x. a <= x /\ x <= b \/ b <= x /\ x <= a) x ==> x IN s)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(y - p_1) = (\x. y - x) (p_1:real)``] THEN
  MATCH_MP_TAC(METIS []
   ``(?x. P x /\ Q(f x))
    ==> (!x. Q x ==> x IN t) /\ (!x. P x ==> x IN s)
        ==> ?x. x IN s /\ f x IN t``) THEN
  POP_ASSUM MP_TAC THEN DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  DISCH_THEN (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  SIMP_TAC std_ss [REAL_ARITH
   ``c <= y - x /\ y - x <= d <=> y - d <= x /\ x <= y - c:real``] THEN
  Know `!a b x. a <= x /\ x <= b \/ b <= x /\ x <= a:real <=>
                min a b <= x /\ x <= max a b`
  >- (KILL_TAC >> RW_TAC std_ss [max_def, min_def] \\
      REAL_ASM_ARITH_TAC) >> Rewr \\
  ONCE_REWRITE_TAC[TAUT `(p /\ q) /\ (r /\ s) <=> (p /\ r) /\ (q /\ s)`] THEN
  REWRITE_TAC[GSYM REAL_LE_MIN, GSYM REAL_MAX_LE] THEN
  REWRITE_TAC[GSYM REAL_LE_BETWEEN] THEN
  SIMP_TAC std_ss [min_def, max_def] THEN REPEAT COND_CASES_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN ASM_REAL_ARITH_TAC
QED

val IS_INTERVAL_SING = store_thm ("IS_INTERVAL_SING",
 ``!a:real. is_interval {a}``,
  SIMP_TAC std_ss [is_interval, IN_SING, CONJ_EQ_IMP, REAL_LE_ANTISYM]);

val IS_INTERVAL_SCALING = store_thm ("IS_INTERVAL_SCALING",
 ``!s:real->bool c. is_interval s ==> is_interval(IMAGE (\x. c * x) s)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO] THEN
    SUBGOAL_THEN ``(IMAGE ((\x. 0):real->real) (s:real->bool) = {}) \/
                   (IMAGE ((\x. 0):real->real) s = {0})``
    STRIP_ASSUME_TAC THENL
     [SET_TAC[],
      ASM_REWRITE_TAC[IS_INTERVAL_EMPTY],
      ASM_REWRITE_TAC[IS_INTERVAL_SING]],
    SIMP_TAC std_ss [is_interval, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN DISCH_TAC THEN
        SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN
        POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_FORALL_THM]) THEN
    REWRITE_TAC[AND_IMP_INTRO] THEN
        DISCH_TAC THEN MAP_EVERY X_GEN_TAC [``a:real``,``b:real``] THEN
        POP_ASSUM (MP_TAC o Q.SPECL [`a:real`,`b:real`]) THEN
    DISCH_THEN(fn th => X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
                         MP_TAC(SPEC ``inv(c) * x:real`` th)) THEN
    ASM_SIMP_TAC std_ss [IN_IMAGE] THEN
    KNOW_TAC ``a <= inv c * x /\ inv c * x <= b \/
               b <= inv c * x /\ inv c * x <= a:real`` THENL
     [FIRST_X_ASSUM(MP_TAC) THEN
          DISCH_THEN (CONJUNCTS_THEN2 STRIP_ASSUME_TAC MP_TAC) THEN
          ASM_REWRITE_TAC[] THEN
      ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN REWRITE_TAC[GSYM real_div] THEN
          UNDISCH_TAC ``c <> 0:real`` THEN DISCH_TAC THEN
      FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP (REAL_ARITH
       ``~(c = &0:real) ==> &0 < c \/ &0 < -c``)) THEN
      ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ] THEN
      GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [GSYM REAL_LE_NEG2] THEN
      ASM_SIMP_TAC std_ss [GSYM REAL_MUL_RNEG, GSYM REAL_LE_RDIV_EQ, GSYM
                   REAL_LE_LDIV_EQ] THEN
      ASM_SIMP_TAC std_ss [real_div, GSYM REAL_NEG_INV] THEN REAL_ARITH_TAC,
          DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
      DISCH_TAC THEN EXISTS_TAC ``inv c * x:real`` THEN
      ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_RINV, REAL_MUL_LID]]]);

val IS_INTERVAL_SCALING_EQ = store_thm ("IS_INTERVAL_SCALING_EQ",
 ``!s:real->bool c.
        is_interval(IMAGE (\x. c * x) s) <=> (c = &0) \/ is_interval s``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``c = &0:real`` THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO] THEN
    SUBGOAL_THEN ``(IMAGE ((\x. 0):real->real) s = {}) \/
                   (IMAGE ((\x. 0):real->real) s = {0})``
    STRIP_ASSUME_TAC THENL
     [SET_TAC[],
      ASM_REWRITE_TAC[IS_INTERVAL_EMPTY],
      ASM_REWRITE_TAC[IS_INTERVAL_SING]],
    ASM_REWRITE_TAC[] THEN EQ_TAC THEN REWRITE_TAC[IS_INTERVAL_SCALING] THEN
    DISCH_THEN(MP_TAC o SPEC ``inv c:real`` o MATCH_MP IS_INTERVAL_SCALING) THEN
    ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, REAL_MUL_ASSOC, o_DEF, REAL_MUL_LINV,
                 REAL_MUL_LID, IMAGE_ID]]);

val lemma0 = prove ((* unused *)
  ``!c. &0 < c
       ==> !s:real->bool. is_interval(IMAGE (\x. c * x) s) <=>
                            is_interval s``,
  SIMP_TAC std_ss [IS_INTERVAL_SCALING_EQ, REAL_LT_IMP_NE]);

val lemma = prove (
  ``~(?a b c:real. a < b /\ b < c /\
               a IN s /\ b IN s /\ c IN s)
     ==> FINITE s /\ CARD(s) <= 2``,
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    REWRITE_TAC[TAUT `~(p /\ q) <=> p ==> ~q`] THEN
    REWRITE_TAC[ARITH_PROVE ``~(n <= 2) <=> 3 <= n:num``] THEN
    DISCH_THEN(MP_TAC o MATCH_MP CHOOSE_SUBSET_STRONG) THEN
    REWRITE_TAC [ARITH_PROVE ``3 = SUC 2``, TWO, ONE,  HAS_SIZE_CLAUSES] THEN
    DISCH_TAC THEN KNOW_TAC ``(?a b c:real.
      ((~(b = c) /\ ~(a = c)) /\ ~(a = b)) /\ {a; b; c} SUBSET s)`` THENL
    [POP_ASSUM MP_TAC THEN
     REWRITE_TAC [ARITH_PROVE ``3 = SUC 2``, TWO, ONE,  HAS_SIZE_CLAUSES] THEN
     SET_TAC [], POP_ASSUM K_TAC] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM, GSYM CONJ_ASSOC] THEN
    REWRITE_TAC[INSERT_SUBSET, EMPTY_SUBSET] THEN
    ONCE_REWRITE_TAC [METIS []
     ``(b <> c /\ a <> c /\ a <> b /\ a IN s /\ b IN s /\ c IN s ==>
     ?a b c:real. a < b /\ b < c /\ a IN s /\ b IN s /\ c IN s) =
    (\a b c. b <> c /\ a <> c /\ a <> b /\ a IN s /\ b IN s /\ c IN s ==>
     ?a b c:real. a < b /\ b < c /\ a IN s /\ b IN s /\ c IN s) a b c``] THEN
    MATCH_MP_TAC(METIS [REAL_LE_TOTAL]
     ``(!m n p:real. P m n p ==> P n p m /\ P n m p) /\
       (!m n p. m <= n /\ n <= p ==> P m n p)
       ==> !m n p. P m n p``) THEN
    CONJ_TAC THENL [METIS_TAC[], ALL_TAC] THEN
    SIMP_TAC std_ss [REAL_LT_LE] THEN METIS_TAC[]);

val CARD_FRONTIER_INTERVAL = store_thm ("CARD_FRONTIER_INTERVAL",
 ``!s:real->bool.
        is_interval s ==> FINITE(frontier s) /\ CARD(frontier s) <= 2``,
  GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC lemma THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM, FRONTIER_CLOSURES, IN_INTER] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``c:real``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  MAP_EVERY UNDISCH_TAC
   [``b IN closure (univ(:real) DIFF s)``,
    ``(a:real) IN closure s``, ``(c:real) IN closure s``] THEN
  SIMP_TAC std_ss [CLOSURE_APPROACHABLE, IN_DIFF, IN_UNIV, dist] THEN
  DISCH_THEN(MP_TAC o SPEC ``(c - b) / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``v:real`` STRIP_ASSUME_TAC) THEN
  DISCH_THEN(MP_TAC o SPEC ``(b - a) / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``u:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min ((b - a) / &2:real) ((c - b) / &2:real)`` THEN
  ASM_REWRITE_TAC[REAL_HALF, REAL_SUB_LT, REAL_LT_MIN] THEN
  X_GEN_TAC ``w:real`` THEN CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  UNDISCH_TAC ``is_interval s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [IS_INTERVAL]) THEN
  DISCH_THEN(MP_TAC o SPECL [``u:real``, ``v:real``, ``w:real``]) THEN
  ASM_REWRITE_TAC[] THEN FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  ASM_REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Limit component bounds.                                                   *)
(* ------------------------------------------------------------------------- *)

val LIM_COMPONENT_UBOUND = store_thm ("LIM_COMPONENT_UBOUND",
 ``!net:('a)net f (l:real) b k.
        ~(trivial_limit net) /\ (f --> l) net /\
        eventually (\x. f x <= b) net
        ==> l <= b``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``net:('a)net``, ``f:'a->real``, ``{y:real | y <= b}``, ``l:real``]
   LIM_IN_CLOSED_SET) THEN
  ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, GSPECIFICATION]);

val LIM_COMPONENT_LBOUND = store_thm ("LIM_COMPONENT_LBOUND",
 ``!net:('a)net f (l:real) b.
        ~(trivial_limit net) /\ (f --> l) net /\
        eventually (\x. b <= (f x)) net
        ==> b <= l``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``net:('a)net``, ``f:'a->real``, ``{y:real | b <= y}``, ``l:real``]
   LIM_IN_CLOSED_SET) THEN
  ASM_SIMP_TAC std_ss [REWRITE_RULE[real_ge] CLOSED_HALFSPACE_COMPONENT_GE,
    GSPECIFICATION]);

val LIM_COMPONENT_EQ = store_thm ("LIM_COMPONENT_EQ",
 ``!net f:'a->real i l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. f(x) = b) net
        ==> (l = b)``,
  SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, EVENTUALLY_AND] THEN
  METIS_TAC [LIM_COMPONENT_UBOUND, LIM_COMPONENT_LBOUND]);

val LIM_COMPONENT_LE = store_thm ("LIM_COMPONENT_LE",
 ``!net:('a)net f:'a->real g:'a->real l m.
         ~(trivial_limit net) /\ (f --> l) net /\ (g --> m) net /\
        eventually (\x. (f x) <= (g x)) net
        ==> (l <= m)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM REAL_SUB_LE] THEN
  SIMP_TAC std_ss [LIM_COMPONENT_LBOUND] THEN
  DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  ONCE_REWRITE_TAC[TAUT `a /\ b /\ c ==> d <=> b /\ a ==> c ==> d`] THEN
  DISCH_THEN(MP_TAC o MATCH_MP LIM_SUB) THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_LBOUND THEN EXISTS_TAC ``net:'a net`` THEN
  EXISTS_TAC ``(\(x :'a). (g :'a -> real) x - (f :'a -> real) x)`` THEN
  METIS_TAC []);

val LIM_DROP_LE = store_thm ("LIM_DROP_LE",
 ``!net:('a)net f g l m.
         ~(trivial_limit net) /\ (f --> l) net /\ (g --> m) net /\
        eventually (\x. f x <= g x) net
        ==> l <= m``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``net:('a)net`` LIM_COMPONENT_LE) THEN
  MAP_EVERY EXISTS_TAC [``f:'a->real``, ``g:'a->real``] THEN
  ASM_REWRITE_TAC[LESS_EQ_REFL]);

val LIM_DROP_UBOUND = store_thm ("LIM_DROP_UBOUND",
 ``!net f:'a->real l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. f x <= b) net
        ==> l <= b``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_UBOUND THEN
  REWRITE_TAC[LESS_EQ_REFL] THEN METIS_TAC[]);

val LIM_DROP_LBOUND = store_thm ("LIM_DROP_LBOUND",
 ``!net f:'a->real l b.
        (f --> l) net /\
        ~(trivial_limit net) /\ eventually (\x. b <= f x) net
        ==> b <= l``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LIM_COMPONENT_LBOUND THEN
  REWRITE_TAC[LESS_EQ_REFL] THEN METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Also extending closed bounds to closures.                                 *)
(* ------------------------------------------------------------------------- *)

val IMAGE_CLOSURE_SUBSET = store_thm ("IMAGE_CLOSURE_SUBSET",
 ``!f (s:real->bool) (t:real->bool).
      f continuous_on closure s /\ closed t /\ IMAGE f s SUBSET t
      ==> IMAGE f (closure s) SUBSET t``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``closure s SUBSET {x | (f:real->real) x IN t}`` MP_TAC
  THENL [MATCH_MP_TAC SUBSET_TRANS, SET_TAC []]  THEN
  EXISTS_TAC ``{x | x IN closure s /\ (f:real->real) x IN t}`` THEN
  CONJ_TAC THENL
  [MATCH_MP_TAC CLOSURE_MINIMAL, SET_TAC[]] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_CLOSED_PREIMAGE, CLOSED_CLOSURE] THEN
  MP_TAC (ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]);

val CLOSURE_IMAGE_CLOSURE = store_thm ("CLOSURE_IMAGE_CLOSURE",
 ``!f:real->real s.
        f continuous_on closure s
        ==> (closure(IMAGE f (closure s)) = closure(IMAGE f s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  SIMP_TAC std_ss [SUBSET_CLOSURE, IMAGE_SUBSET, CLOSURE_SUBSET] THEN
  SIMP_TAC std_ss [CLOSURE_MINIMAL_EQ, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC IMAGE_CLOSURE_SUBSET THEN
  ASM_REWRITE_TAC[CLOSED_CLOSURE, CLOSURE_SUBSET]);

val CLOSURE_IMAGE_BOUNDED = store_thm ("CLOSURE_IMAGE_BOUNDED",
 ``!f:real->real s.
        f continuous_on closure s /\ bounded s
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC EQ_TRANS THEN EXISTS_TAC ``closure(IMAGE (f:real->real) (closure s))`` THEN
  CONJ_TAC THENL [ASM_MESON_TAC[CLOSURE_IMAGE_CLOSURE], ALL_TAC] THEN
  MATCH_MP_TAC CLOSURE_CLOSED THEN MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE]);

val CONTINUOUS_ON_CLOSURE_ABS_LE = store_thm ("CONTINUOUS_ON_CLOSURE_ABS_LE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> abs(f y) <= b) /\
      x IN (closure s)
      ==> abs(f x) <= b``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET cball(0,b)``
    MP_TAC THENL
  [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC []] THEN
  ASM_REWRITE_TAC [CLOSED_CBALL] THEN ASM_SET_TAC []);

val CONTINUOUS_ON_CLOSURE_COMPONENT_LE = store_thm ("CONTINUOUS_ON_CLOSURE_COMPONENT_LE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> (f y) <= b) /\
      x IN (closure s)
      ==> (f x) <= b``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET {x | x <= b}``
  MP_TAC THENL
   [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC []] THEN
  ASM_REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_LE] THEN ASM_SET_TAC[]);

val CONTINUOUS_ON_CLOSURE_COMPONENT_GE = store_thm ("CONTINUOUS_ON_CLOSURE_COMPONENT_GE",
 ``!f:real->real s x b.
      f continuous_on (closure s) /\
      (!y. y IN s ==> b <= (f y)) /\
      x IN (closure s)
      ==> b <= (f x)``,
  REWRITE_TAC [GSYM IN_CBALL_0] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) (closure s) SUBSET {x | x >= b}``
  MP_TAC THENL
   [MATCH_MP_TAC IMAGE_CLOSURE_SUBSET, ASM_SET_TAC [real_ge]] THEN
  ASM_REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_GE] THEN ASM_SET_TAC[real_ge]);

val CONTINUOUS_MAP_CLOSURES = store_thm ("CONTINUOUS_MAP_CLOSURES",
 ``!f:real->real.
        f continuous_on UNIV <=>
        !s. IMAGE f (closure s) SUBSET closure(IMAGE f s)``,
  GEN_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [GEN_TAC THEN MATCH_MP_TAC(MESON[SUBSET_DEF, CLOSURE_SUBSET]
     ``(closure s = t) ==> s SUBSET t``) THEN
    MATCH_MP_TAC CLOSURE_IMAGE_CLOSURE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_UNIV],
    REWRITE_TAC[CONTINUOUS_CLOSED_IN_PREIMAGE_EQ] THEN
    REWRITE_TAC[GSYM CLOSED_IN, SUBTOPOLOGY_UNIV, IN_UNIV] THEN
    X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``{x | (f:real->real) x IN t}``) THEN
    REWRITE_TAC[GSYM CLOSURE_SUBSET_EQ] THEN
    SUBGOAL_THEN
     ``closure(IMAGE (f:real->real) {x | f x IN t}) SUBSET t``
    MP_TAC THENL
     [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SET_TAC[], SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Limits relative to a union.                                               *)
(* ------------------------------------------------------------------------- *)

val LIM_WITHIN_UNION = store_thm ("LIM_WITHIN_UNION",
 ``(f --> l) (at x within (s UNION t)) <=>
   (f --> l) (at x within s) /\ (f --> l) (at x within t)``,
  SIMP_TAC std_ss [LIM_WITHIN, IN_UNION, GSYM FORALL_AND_THM] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THENL [MESON_TAC[], ALL_TAC] THEN DISCH_THEN
   (CONJUNCTS_THEN2 (X_CHOOSE_TAC ``d:real``) (X_CHOOSE_TAC ``k:real``)) THEN
  EXISTS_TAC ``min d k:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  ASM_MESON_TAC[]);

val CONTINUOUS_ON_UNION = store_thm ("CONTINUOUS_ON_UNION",
 ``!f s t. closed s /\ closed t /\ f continuous_on s /\ f continuous_on t
           ==> f continuous_on (s UNION t)``,
  REWRITE_TAC[CONTINUOUS_ON, CLOSED_LIMPT, IN_UNION, LIM_WITHIN_UNION] THEN
  MESON_TAC[LIM, TRIVIAL_LIMIT_WITHIN]);

val CONTINUOUS_ON_CASES = store_thm ("CONTINUOUS_ON_CASES",
 ``!P f g:real->real s t.
        closed s /\ closed t /\ f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_UNION_LOCAL = store_thm ("CONTINUOUS_ON_UNION_LOCAL",
 ``!f:real->real s.
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ f continuous_on t
        ==> f continuous_on (s UNION t)``,
  REWRITE_TAC[CONTINUOUS_ON, CLOSED_IN_LIMPT, IN_UNION, LIM_WITHIN_UNION] THEN
  MESON_TAC[LIM, TRIVIAL_LIMIT_WITHIN]);

val CONTINUOUS_ON_CASES_LOCAL = store_thm ("CONTINUOUS_ON_CASES_LOCAL",
 ``!P f g:real->real s t.
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t /\
        f continuous_on s /\ g continuous_on t /\
        (!x. x IN s /\ ~P x \/ x IN t /\ P x ==> (f x = g x))
        ==> (\x. if P x then f x else g x) continuous_on (s UNION t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_UNION_LOCAL THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_EQ THENL
   [EXISTS_TAC ``f:real->real``, EXISTS_TAC ``g:real->real``] THEN
  METIS_TAC[]);

val CONTINUOUS_ON_CASES_LE = store_thm ("CONTINUOUS_ON_CASES_LE",
 ``!f g:real->real h s a.
        f continuous_on {t | t IN s /\ h t <= a} /\
        g continuous_on {t | t IN s /\ a <= h t} /\
        (h) continuous_on s /\
        (!t. t IN s /\ (h t = a) ==> (f t = g t))
        ==> (\t. if h t <= a then f(t) else g(t)) continuous_on s``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_ON_SUBSET THEN EXISTS_TAC
   ``{t | t IN s /\ (h:real->real) t <= a} UNION
     {t | t IN s /\ a <= h t}`` THEN
  CONJ_TAC THENL
   [ALL_TAC, SIMP_TAC std_ss [SUBSET_DEF, IN_UNION, GSPECIFICATION, REAL_LE_TOTAL]] THEN
  ONCE_REWRITE_TAC [METIS [] ``h t <= a <=> (\t:real. h t <= a:real) t``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN ASM_SIMP_TAC std_ss [] THEN
  SIMP_TAC std_ss [GSPECIFICATION, GSYM CONJ_ASSOC, REAL_LE_ANTISYM] THEN
  REWRITE_TAC[CONJ_ASSOC] THEN CONJ_TAC THENL
   [ALL_TAC, METIS_TAC[]] THEN
  CONJ_TAC THENL
   [SUBGOAL_THEN
     ``{t | t IN s /\ (h:real->real) t <= a} =
       {t | t IN ({t | t IN s /\ h t <= a} UNION {t | t IN s /\ a <= h t}) /\
           (h) t IN {x | x <= a}}``
     (fn th => GEN_REWR_TAC RAND_CONV [th])
    THENL
     [SIMP_TAC std_ss [o_THM, GSPECIFICATION, EXTENSION, IN_UNION] THEN
      GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN ASM_SIMP_TAC std_ss [],
      MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, ETA_AX] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN SET_TAC[]],
    SUBGOAL_THEN
     ``{t | t IN s /\ a <= (h:real->real) t} =
       {t | t IN ({t | t IN s /\ h t <= a} UNION {t | t IN s /\ a <= h t}) /\
           (h) t IN {x | x >= a}}``
     (fn th => GEN_REWR_TAC RAND_CONV [th])
    THENL
     [SIMP_TAC std_ss [o_THM, GSPECIFICATION, EXTENSION, IN_UNION] THEN
      GEN_TAC THEN EQ_TAC THEN STRIP_TAC THEN ASM_SIMP_TAC std_ss [real_ge] THEN
      ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC CONTINUOUS_CLOSED_IN_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_GE, ETA_AX] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN
      SET_TAC[]]]);

val CONTINUOUS_ON_CASES_1 = store_thm ("CONTINUOUS_ON_CASES_1",
 ``!f g:real->real s a.
        f continuous_on {t | t IN s /\ t <= a} /\
        g continuous_on {t | t IN s /\ a <= t} /\
        (a IN s ==> (f(a) = g(a)))
        ==> (\t. if t <= a then f(t) else g(t)) continuous_on s``,
  REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``t <= a <=> (\t. t) t <= a:real``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_CASES_LE THEN
  ASM_SIMP_TAC std_ss [o_DEF, CONTINUOUS_ON_ID] THEN
  METIS_TAC[]);

val EXTENSION_FROM_CLOPEN = store_thm ("EXTENSION_FROM_CLOPEN",
 ``!f:real->real s t u.
        open_in (subtopology euclidean s) t /\
        closed_in (subtopology euclidean s) t /\
        f continuous_on t /\ IMAGE f t SUBSET u /\ ((u = {}) ==> (s = {}))
        ==> ?g. g continuous_on s /\ IMAGE g s SUBSET u /\
                !x. x IN t ==> (g x = f x)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_EMPTY, IMAGE_EMPTY, IMAGE_INSERT, SUBSET_EMPTY,
               IMAGE_EQ_EMPTY, NOT_IN_EMPTY] THEN
  STRIP_TAC THEN UNDISCH_TAC ``u <> {}:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``a:real``) THEN
  EXISTS_TAC ``\x. if x IN t then (f:real->real) x else a`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN
  SUBGOAL_THEN ``s:real->bool = t UNION (s DIFF t)`` SUBST1_TAC THENL
   [ASM_SET_TAC[],
    ONCE_REWRITE_TAC [METIS [] ``(\x. if x IN t then f x else a) =
                                 (\x. if (\x. x IN t) x then f x else (\x. a) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``t SUBSET s ==> (t UNION (s DIFF t) = s)``] THEN
  REWRITE_TAC[CONTINUOUS_ON_CONST, IN_DIFF] THEN
  CONJ_TAC THENL [MATCH_MP_TAC CLOSED_IN_DIFF, MESON_TAC[]] THEN
  ASM_REWRITE_TAC[CLOSED_IN_REFL]);

(* ------------------------------------------------------------------------- *)
(* Some more convenient intermediate-value theorem formulations.             *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_IVT_HYPERPLANE = store_thm ("CONNECTED_IVT_HYPERPLANE",
 ``!s x y:real a b.
        connected s /\
        x IN s /\ y IN s /\ a * x <= b /\ b <= a * y
        ==> ?z. z IN s /\ (a * z = b)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``connected s`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [connected]) THEN
  SIMP_TAC std_ss [NOT_EXISTS_THM] THEN DISCH_THEN(MP_TAC o SPECL
   [``{x:real | a * x < b}``, ``{x:real | a * x > b}``]) THEN
  SIMP_TAC std_ss [OPEN_HALFSPACE_LT, OPEN_HALFSPACE_GT] THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN SIMP_TAC std_ss [] THEN STRIP_TAC THEN
  SIMP_TAC real_ss [EXTENSION, GSPECIFICATION, IN_INTER, NOT_IN_EMPTY, SUBSET_DEF,
              IN_UNION, REAL_LT_LE, real_gt] THEN
  METIS_TAC[REAL_LE_TOTAL, REAL_LE_ANTISYM]);

val CONNECTED_IVT_COMPONENT = store_thm ("CONNECTED_IVT_COMPONENT",
 ``!s x y:real a.
        connected s /\ x IN s /\ y IN s /\ x <= a /\ a <= y
        ==> ?z. z IN s /\ (z = a)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
   [``s:real->bool``, ``x:real``, ``y:real``, ``1:real``,
    ``a:real``] CONNECTED_IVT_HYPERPLANE) THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_LID]);

(* This theorem is inspired by limTheory.IVT *)
Theorem CONTINUOUS_ON_IVT :
    !f a b y. a <= b /\ f(a) <= y /\ y <= f(b) /\
              f continuous_on (interval [a,b])
          ==> ?x. x IN interval [a,b] /\ (f(x) = y)
Proof
    rpt STRIP_TAC
 >> ‘connected (interval [a,b])’ by METIS_TAC [CONNECTED_SEGMENT, SEGMENT]
 >> ‘connected (IMAGE f (interval [a,b]))’
      by PROVE_TAC [CONNECTED_CONTINUOUS_IMAGE]
 >> MP_TAC (Q.SPECL [‘IMAGE f (interval [a,b])’,
                     ‘(f :real->real) a’, ‘(f :real->real) b’, ‘y’]
                    CONNECTED_IVT_COMPONENT)
 >> Know ‘f a IN IMAGE f (interval [a,b]) /\
          f b IN IMAGE f (interval [a,b])’
 >- (rw [IN_IMAGE, IN_INTERVAL] >| (* 2 subgoals *)
     [ Q.EXISTS_TAC ‘a’ >> rw [],
       Q.EXISTS_TAC ‘b’ >> rw [] ])
 >> RW_TAC std_ss []
 >> POP_ASSUM MP_TAC
 >> rw [IN_IMAGE]
 >> Q.EXISTS_TAC ‘x’ >> art []
QED

(* ------------------------------------------------------------------------- *)
(* Rather trivial observation that we can map any connected set on segment.  *)
(* ------------------------------------------------------------------------- *)

val MAPPING_CONNECTED_ONTO_SEGMENT = store_thm ("MAPPING_CONNECTED_ONTO_SEGMENT",
 ``!s:real->bool a b:real.
        connected s /\ ~(?a. s SUBSET {a})
        ==> ?f. f continuous_on s /\ (IMAGE f s = segment[a,b])``,
  REPEAT STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o MATCH_MP (SET_RULE
   ``~(?a. s SUBSET {a}) ==> ?a b. a IN s /\ b IN s /\ ~(a = b)``)) THEN
  SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real``, ``v:real``] THEN STRIP_TAC THEN EXISTS_TAC
   ``\x:real. a + dist(u,x) / (dist(u,x) + dist(v,x)) * (b - a:real)`` THEN
  CONJ_TAC THEN SIMP_TAC std_ss [] THENL
   [ONCE_REWRITE_TAC [METIS []
     ``(\x. a + dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
       (\x. (\x. a) x + (\x. dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
    ONCE_REWRITE_TAC [METIS []
    ``(\x. dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
      (\x. (\x. dist (u,x) / (dist (u,x) + dist (v,x))) x * (\x. (b - a)) x)``] THEN
    MATCH_MP_TAC CONTINUOUS_ON_MUL THEN SIMP_TAC std_ss [o_DEF, CONTINUOUS_ON_CONST],

    REWRITE_TAC[segment, REAL_ARITH
     ``(&1 - u) * a + u * b:real = a + u * (b - a)``] THEN
    ONCE_REWRITE_TAC [METIS []
    ``(\x. a + dist (u,x) / (dist (u,x) + dist (v,x)) * (b - a)) =
      (\x. a + (\x. dist (u,x) / (dist (u,x) + dist (v,x))) x * (b - a))``] THEN
    ONCE_REWRITE_TAC [METIS [] ``(0 <= u /\ u <= 1:real) <=> (\u. 0 <= u /\ u <= 1) u``] THEN
    MATCH_MP_TAC(SET_RULE
     ``(IMAGE f s = {x | P x})
      ==> (IMAGE (\x. a + f x * b) s = {a + u * b:real | P u})``) THEN
    SIMP_TAC std_ss [GSYM SUBSET_ANTISYM_EQ, SUBSET_DEF, FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC real_ss [dist, GSPECIFICATION, REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ,
      REAL_ARITH ``~(u:real = v) ==> &0 < abs(u - x) + abs(v - x)``] THEN
    CONJ_TAC THENL [REAL_ARITH_TAC, REWRITE_TAC[IN_IMAGE]] THEN
    X_GEN_TAC ``t:real`` THEN STRIP_TAC THEN
    MP_TAC(ISPECL
     [``IMAGE (\x:real. dist(u,x) / (dist(u,x) + dist(v,x))) s``,
      ``0:real``, ``1:real``, ``t:real``]
        CONNECTED_IVT_COMPONENT) THEN
    ASM_SIMP_TAC arith_ss [] THEN
    SIMP_TAC std_ss [EXISTS_IN_IMAGE] THEN
    KNOW_TAC ``connected
   (IMAGE
      (\(x :real).
         (dist ((u :real),x) :real) /
         ((dist (u,x) :real) + (dist ((v :real),x) :real)))
      (s :real -> bool)) /\
 (0 :real) IN
 IMAGE
   (\(x :real).
      (dist (u,x) :real) / ((dist (u,x) :real) + (dist (v,x) :real)))
   s /\
 (1 :real) IN
 IMAGE
   (\(x :real).
      (dist (u,x) :real) / ((dist (u,x) :real) + (dist (v,x) :real)))
   s`` THENL
   [REWRITE_TAC[IN_IMAGE], DISCH_TAC THEN ASM_REWRITE_TAC [IN_IMAGE] THEN
    BETA_TAC THEN MESON_TAC[dist]] THEN
    REPEAT CONJ_TAC THENL
     [MATCH_MP_TAC CONNECTED_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[],
      EXISTS_TAC ``u:real`` THEN ASM_REWRITE_TAC[DIST_REFL, real_div, dist] THEN
      BETA_TAC THEN REAL_ARITH_TAC,
      EXISTS_TAC ``v:real`` THEN ASM_REWRITE_TAC[DIST_REFL] THEN
      ASM_SIMP_TAC std_ss [REAL_DIV_REFL, DIST_EQ_0, REAL_ADD_RID] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE
       [REAL_ARITH ``(u <> v) = (abs (u - v) <> 0:real)``]) THEN
      ASM_SIMP_TAC real_ss [REAL_DIV_REFL]]] THEN
  REWRITE_TAC[real_div] THENL
  [ONCE_REWRITE_TAC [METIS [] ``(\x. dist (u,x) * inv (dist (u,x) + dist (v,x))) =
                  (\x. (\x. dist (u,x)) x * (\x. inv (dist (u,x) + dist (v,x))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  REWRITE_TAC[CONTINUOUS_ON_DIST] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. inv (dist (u,x) + dist (v,x))) =
                          (\x. inv ((\x. (dist (u,x) + dist (v,x))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [dist, REAL_ARITH
   ``~(u:real = v) ==> ~(abs(u - x) + abs(v - x) = &0)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x:real. abs (u - x) + abs (v - x)) =
                       (\x. (\x. abs (u - x)) x + (\x. abs (v - x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
  SIMP_TAC std_ss [GSYM dist, REWRITE_RULE[o_DEF] CONTINUOUS_ON_DIST],
   ONCE_REWRITE_TAC [METIS [] ``(\x. dist (u,x) * inv (dist (u,x) + dist (v,x))) =
                  (\x. (\x. dist (u,x)) x * (\x. inv (dist (u,x) + dist (v,x))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  REWRITE_TAC[CONTINUOUS_ON_DIST] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x. inv (dist (u,x) + dist (v,x))) =
                          (\x. inv ((\x. (dist (u,x) + dist (v,x))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [dist, REAL_ARITH
   ``~(u:real = v) ==> ~(abs(u - x) + abs(v - x) = &0)``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(\x:real. abs (u - x) + abs (v - x)) =
                       (\x. (\x. abs (u - x)) x + (\x. abs (v - x)) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
  SIMP_TAC std_ss [GSYM dist, REWRITE_RULE[o_DEF] CONTINUOUS_ON_DIST],
  ALL_TAC] THEN
  FULL_SIMP_TAC std_ss [GSYM dist, DIST_REFL, REAL_ADD_RID] THEN
  REWRITE_TAC [GSYM real_div] THEN METIS_TAC [REAL_DIV_REFL]);

(* ------------------------------------------------------------------------- *)
(* Also more convenient formulations of monotone convergence.                *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_INCREASING_CONVERGENT = store_thm ("BOUNDED_INCREASING_CONVERGENT",
 ``!s:num->real.
        bounded {s n | n IN univ(:num)} /\ (!n. (s n) <= (s(SUC n)))
        ==> ?l. (s --> l) sequentially``,
  GEN_TAC THEN
  SIMP_TAC std_ss [bounded_def, GSPECIFICATION, LIM_SEQUENTIALLY, dist,
              IN_UNIV] THEN
  DISCH_TAC THEN MATCH_MP_TAC CONVERGENT_BOUNDED_MONOTONE THEN
  SIMP_TAC std_ss [LEFT_EXISTS_AND_THM] THEN
  CONJ_TAC THENL [METIS_TAC[], ALL_TAC] THEN DISJ1_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``!m n. ((s:num->real) m <= s n) = (\m n. s m <= s n) m n``] THEN
  MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN
  METIS_TAC [REAL_LE_TRANS, REAL_LE_REFL]);

val BOUNDED_DECREASING_CONVERGENT = store_thm ("BOUNDED_DECREASING_CONVERGENT",
 ``!s:num->real.
        bounded {s n | n IN univ(:num)} /\ (!n. (s(SUC n)) <= (s(n)))
        ==> ?l. (s --> l) sequentially``,
  GEN_TAC THEN SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC] THEN
  DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  MP_TAC(ISPEC ``\n. -((s:num->real) n)`` BOUNDED_INCREASING_CONVERGENT) THEN
  ASM_SIMP_TAC std_ss [bounded_def, FORALL_IN_GSPEC, ABS_NEG, REAL_LE_NEG2] THEN
  GEN_REWR_TAC (LAND_CONV o BINDER_CONV) [GSYM LIM_NEG_EQ] THEN
  SIMP_TAC std_ss [REAL_NEG_NEG, ETA_AX] THEN METIS_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Basic homeomorphism definitions.                                          *)
(* ------------------------------------------------------------------------- *)

val homeomorphism = new_definition ("homeomorphism",
  ``homeomorphism (s,t) (f,g) <=>
     (!x. x IN s ==> (g(f(x)) = x)) /\ (IMAGE f s = t) /\ f continuous_on s /\
     (!y. y IN t ==> (f(g(y)) = y)) /\ (IMAGE g t = s) /\ g continuous_on t``);

val _ = set_fixity "homeomorphic" (Infix(NONASSOC, 450));

val homeomorphic = new_definition ("homeomorphic",
  ``s homeomorphic t <=> ?f g. homeomorphism (s,t) (f,g)``);

val HOMEOMORPHISM = store_thm ("HOMEOMORPHISM",
 ``!s:real->bool t:real->bool f g.
        homeomorphism (s,t) (f,g) <=>
         f continuous_on s /\ IMAGE f s SUBSET t /\
         g continuous_on t /\ IMAGE g t SUBSET s /\
         (!x. x IN s ==> (g (f x) = x)) /\
         (!y. y IN t ==> (f (g y) = y))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphism] THEN
  EQ_TAC THEN SIMP_TAC std_ss [] THEN SET_TAC[]);

val HOMEOMORPHISM_OF_SUBSETS = store_thm ("HOMEOMORPHISM_OF_SUBSETS",
 ``!f g s t s' t'.
    homeomorphism (s,t) (f,g) /\ s' SUBSET s /\ t' SUBSET t /\ (IMAGE f s' = t')
    ==> homeomorphism (s',t') (f,g)``,
  REWRITE_TAC[homeomorphism] THEN
  REPEAT STRIP_TAC THEN
  TRY(MATCH_MP_TAC CONTINUOUS_ON_SUBSET) THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_ID = store_thm ("HOMEOMORPHISM_ID",
 ``!s:real->bool. homeomorphism (s,s) ((\x. x),(\x. x))``,
  SIMP_TAC std_ss [homeomorphism, IMAGE_ID, CONTINUOUS_ON_ID]);

val HOMEOMORPHIC_REFL = store_thm ("HOMEOMORPHIC_REFL",
 ``!s:real->bool. s homeomorphic s``,
  REWRITE_TAC[homeomorphic] THEN MESON_TAC[HOMEOMORPHISM_ID]);

val HOMEOMORPHISM_SYM = store_thm ("HOMEOMORPHISM_SYM",
 ``!f:real->real g s t.
        homeomorphism (s,t) (f,g) <=> homeomorphism (t,s) (g,f)``,
  REWRITE_TAC[homeomorphism] THEN MESON_TAC[]);

val HOMEOMORPHIC_SYM = store_thm ("HOMEOMORPHIC_SYM",
 ``!s t. s homeomorphic t <=> t homeomorphic s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic, homeomorphism] THEN
  ONCE_REWRITE_TAC [METIS []
       ``((!x. x IN t ==> (g (f x) = x)) /\ (IMAGE f t = s) /\
     f continuous_on t /\ (!y. y IN s ==> (f (g y) = y)) /\
     (IMAGE g s = t) /\ g continuous_on s) =
   (\f g. (!x. x IN t ==> (g (f x) = x)) /\ (IMAGE f t = s) /\
     f continuous_on t /\ (!y. y IN s ==> (f (g y) = y)) /\
     (IMAGE g s = t) /\ g continuous_on s) f g``] THEN
  GEN_REWR_TAC RAND_CONV [SWAP_EXISTS_THM] THEN
  REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN SIMP_TAC std_ss [] THEN
  TAUT_TAC);

val HOMEOMORPHISM_COMPOSE = store_thm ("HOMEOMORPHISM_COMPOSE",
 ``!f:real->real g h:real->real k s t u.
        homeomorphism (s,t) (f,g) /\ homeomorphism (t,u) (h,k)
        ==> homeomorphism (s,u) (h o f,g o k)``,
  SIMP_TAC std_ss [homeomorphism, CONTINUOUS_ON_COMPOSE, IMAGE_COMPOSE, o_THM] THEN
  SET_TAC[]);

val HOMEOMORPHIC_TRANS = store_thm ("HOMEOMORPHIC_TRANS",
 ``!s:real->bool t:real->bool u:real->bool.
        s homeomorphic t /\ t homeomorphic u ==> s homeomorphic u``,
  REWRITE_TAC[homeomorphic] THEN MESON_TAC[HOMEOMORPHISM_COMPOSE]);

val HOMEOMORPHIC_IMP_CARD_EQ = store_thm ("HOMEOMORPHIC_IMP_CARD_EQ",
 ``!s:real->bool t:real->bool. s homeomorphic t ==> s =_c t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphic, homeomorphism, eq_c] THEN
  STRIP_TAC THEN EXISTS_TAC ``f:real->real`` THEN ASM_SET_TAC []);

val HOMEOMORPHIC_FINITENESS = store_thm ("HOMEOMORPHIC_FINITENESS",
 ``!s:real->bool t:real->bool.
        s homeomorphic t ==> (FINITE s <=> FINITE t)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
  DISCH_THEN(ACCEPT_TAC o MATCH_MP CARD_FINITE_CONG));

val HOMEOMORPHIC_EMPTY = store_thm ("HOMEOMORPHIC_EMPTY",
 ``(!s. (s:real->bool) homeomorphic ({}:real->bool) <=> (s = {})) /\
   (!s. ({}:real->bool) homeomorphic (s:real->bool) <=> (s = {}))``,
  REWRITE_TAC[homeomorphic, homeomorphism, IMAGE_EMPTY, IMAGE_INSERT, IMAGE_EQ_EMPTY] THEN
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC std_ss [continuous_on, NOT_IN_EMPTY]);

val HOMEOMORPHIC_MINIMAL = store_thm ("HOMEOMORPHIC_MINIMAL",
 ``!s t. s homeomorphic t <=>
            ?f g. (!x. x IN s ==> f(x) IN t /\ (g(f(x)) = x)) /\
                  (!y. y IN t ==> g(y) IN s /\ (f(g(y)) = y)) /\
                  f continuous_on s /\ g continuous_on t``,
  REWRITE_TAC[homeomorphic, homeomorphism, EXTENSION, IN_IMAGE] THEN
  REPEAT GEN_TAC THEN REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN MESON_TAC[]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (IMAGE f s) homeomorphic s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_LEFT_INVERSE]) THEN
  STRIP_TAC THEN EXISTS_TAC ``g:real->real`` THEN
  EXISTS_TAC ``f:real->real`` THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON, FORALL_IN_IMAGE, FUN_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [continuous_on, CONJ_EQ_IMP, FORALL_IN_IMAGE] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_BOUNDED_BELOW_POS) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e * B:real`` THEN ASM_SIMP_TAC real_ss [REAL_LT_MUL] THEN
  X_GEN_TAC ``y:real`` THEN ASM_SIMP_TAC std_ss [dist, GSYM LINEAR_SUB] THEN
  DISCH_TAC THEN ASM_SIMP_TAC real_ss [GSYM REAL_LT_LDIV_EQ] THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> b < x ==> a < x:real``) THEN
  ASM_SIMP_TAC real_ss [REAL_LE_RDIV_EQ]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ",
 ``!f:real->real s t.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> ((IMAGE f s) homeomorphic t <=> s homeomorphic t)``,
  REPEAT GEN_TAC THEN DISCH_THEN(ASSUME_TAC o SPEC ``s:real->bool`` o
    MATCH_MP HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_SELF) THEN
  EQ_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o ONCE_REWRITE_RULE [HOMEOMORPHIC_SYM]),
    POP_ASSUM MP_TAC] THEN
  METIS_TAC[AND_IMP_INTRO, HOMEOMORPHIC_TRANS]);

val HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ = store_thm ("HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ",
 ``!f:real->real s t.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (s homeomorphic (IMAGE f t) <=> s homeomorphic t)``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  REWRITE_TAC[HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ]);

val HOMEOMORPHIC_TRANSLATION_SELF = store_thm ("HOMEOMORPHIC_TRANSLATION_SELF",
 ``!a:real s. (IMAGE (\x. a + x) s) homeomorphic s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  EXISTS_TAC ``\x:real. x - a`` THEN
  EXISTS_TAC ``\x:real. a + x`` THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, CONTINUOUS_ON_SUB, CONTINUOUS_ON_ID,
           CONTINUOUS_ON_CONST, CONTINUOUS_ON_ADD, REAL_ADD_SUB] THEN
  REWRITE_TAC[IN_IMAGE] THEN MESON_TAC[]);

val HOMEOMORPHIC_TRANSLATION_LEFT_EQ = store_thm ("HOMEOMORPHIC_TRANSLATION_LEFT_EQ",
 ``!a:real s t.
      (IMAGE (\x. a + x) s) homeomorphic t <=> s homeomorphic t``,
  METIS_TAC[HOMEOMORPHIC_TRANSLATION_SELF,
            HOMEOMORPHIC_SYM, HOMEOMORPHIC_TRANS]);

val HOMEOMORPHIC_TRANSLATION_RIGHT_EQ = store_thm ("HOMEOMORPHIC_TRANSLATION_RIGHT_EQ",
 ``!a:real s t.
      s homeomorphic (IMAGE (\x. a + x) t) <=> s homeomorphic t``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  REWRITE_TAC[HOMEOMORPHIC_TRANSLATION_LEFT_EQ]);

val HOMEOMORPHISM_IMP_QUOTIENT_MAP = store_thm ("HOMEOMORPHISM_IMP_QUOTIENT_MAP",
 ``!f:real->real g s t.
    homeomorphism (s,t) (f,g)
    ==> !u. u SUBSET t
            ==> (open_in (subtopology euclidean s) {x | x IN s /\ f x IN u} <=>
                 open_in (subtopology euclidean t) u)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[homeomorphism] THEN
  STRIP_TAC THEN MATCH_MP_TAC CONTINUOUS_RIGHT_INVERSE_IMP_QUOTIENT_MAP THEN
  EXISTS_TAC ``g:real->real`` THEN ASM_REWRITE_TAC[SUBSET_REFL]);

val HOMEOMORPHIC_SCALING_LEFT = store_thm ("HOMEOMORPHIC_SCALING_LEFT",
 ``!c. &0 < c
       ==> (!s t. (IMAGE (\x. c * x) s) homeomorphic t <=> s homeomorphic t)``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_LEFT_EQ THEN
  ASM_SIMP_TAC std_ss [REAL_EQ_LMUL, REAL_LT_IMP_NE, LINEAR_SCALING]);

val HOMEOMORPHIC_SCALING_RIGHT = store_thm ("HOMEOMORPHIC_SCALING_RIGHT",
 ``!c. &0 < c
       ==> (!s t. s homeomorphic (IMAGE (\x. c * x) t) <=> s homeomorphic t)``,
  SIMP_TAC std_ss [RIGHT_IMP_FORALL_THM] THEN REPEAT GEN_TAC THEN DISCH_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_INJECTIVE_LINEAR_IMAGE_RIGHT_EQ THEN
  ASM_SIMP_TAC std_ss [REAL_EQ_LMUL, REAL_LT_IMP_NE, LINEAR_SCALING]);

val HOMEOMORPHIC_FINITE = store_thm ("HOMEOMORPHIC_FINITE",
 ``!s:real->bool t:real->bool.
        FINITE s /\ FINITE t ==> (s homeomorphic t <=> (CARD s = CARD t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
    ASM_SIMP_TAC std_ss [CARD_EQ_CARD],
    STRIP_TAC THEN REWRITE_TAC[homeomorphic, HOMEOMORPHISM] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
        CARD_EQ_BIJECTIONS) THEN
    ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN POP_ASSUM MP_TAC THEN
    DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN
    MAP_EVERY EXISTS_TAC [``f:real->real``,``g:real->real``] THEN
    POP_ASSUM MP_TAC THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_ON_FINITE] THEN ASM_SET_TAC[]]);

val HOMEOMORPHIC_FINITE_STRONG = store_thm ("HOMEOMORPHIC_FINITE_STRONG",
 ``!s:real->bool t:real->bool.
        FINITE s \/ FINITE t
        ==> (s homeomorphic t <=> FINITE s /\ FINITE t /\ (CARD s = CARD t))``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN EQ_TAC THEN
  SIMP_TAC std_ss [HOMEOMORPHIC_FINITE] THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CARD_FINITE_CONG o MATCH_MP
    HOMEOMORPHIC_IMP_CARD_EQ) THEN
  FIRST_X_ASSUM DISJ_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[HOMEOMORPHIC_FINITE]);

val HOMEOMORPHIC_SING = store_thm ("HOMEOMORPHIC_SING",
 ``!a:real b:real. {a} homeomorphic {b}``,
  SIMP_TAC std_ss [HOMEOMORPHIC_FINITE, FINITE_SING, CARD_SING]);

val LIFT_TO_QUOTIENT_SPACE_UNIQUE = store_thm ("LIFT_TO_QUOTIENT_SPACE_UNIQUE",
 ``!f:real->real g:real->real s t u.
        (IMAGE f s = t) /\
        (IMAGE g s = u) /\
        (!v. v SUBSET t
             ==> (open_in (subtopology euclidean s)
                  {x | x IN s /\ f x IN v} <=>
                  open_in (subtopology euclidean t) v)) /\
         (!v. v SUBSET u
             ==> (open_in (subtopology euclidean s)
                  {x | x IN s /\ g x IN v} <=>
                  open_in (subtopology euclidean u) v)) /\
        (!x y. x IN s /\ y IN s ==> ((f x = f y) <=> (g x = g y)))
        ==> t homeomorphic u``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL
   [``f:real->real``, ``g:real->real``, ``s:real->bool``,
    ``t:real->bool``, ``u:real->bool``] LIFT_TO_QUOTIENT_SPACE) THEN
  MP_TAC(ISPECL
   [``g:real->real``, ``f:real->real``, ``s:real->bool``,
    ``u:real->bool``, ``t:real->bool``] LIFT_TO_QUOTIENT_SPACE) THEN
  ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``, ``t:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN DISCH_THEN SUBST1_TAC THEN
  KNOW_TAC ``(!(u :real -> bool).
    open_in (subtopology euclidean (t :real -> bool)) u ==>
    open_in (subtopology euclidean (s :real -> bool))
      {x | x IN s /\ (f :real -> real) x IN u})`` THENL
   [METIS_TAC[OPEN_IN_IMP_SUBSET],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``h:real->real`` STRIP_ASSUME_TAC)] THEN
  MP_TAC(ISPECL [``g:real->real``, ``s:real->bool``, ``u:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  ASM_SIMP_TAC std_ss [SUBSET_REFL] THEN DISCH_THEN SUBST1_TAC THEN
  KNOW_TAC ``(!(u' :real -> bool).
    open_in (subtopology euclidean (u :real -> bool)) u' ==>
    open_in (subtopology euclidean (s :real -> bool))
      {x | x IN s /\ (g :real -> real) x IN u'}) /\
 (!(x :real) (y :real).
    x IN s /\ y IN s /\ ((f :real -> real) x = f y) ==> (g x = g y))`` THENL
   [METIS_TAC[OPEN_IN_IMP_SUBSET],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``k:real->real`` STRIP_ASSUME_TAC)] THEN
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MAP_EVERY EXISTS_TAC
   [``k:real->real``, ``h:real->real``] THEN
  ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Inverse function property for open/closed maps.                           *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_ON_INVERSE_OPEN_MAP = store_thm ("CONTINUOUS_ON_INVERSE_OPEN_MAP",
 ``!f:real->real g s t.
        f continuous_on s /\ (IMAGE f s = t) /\ (!x. x IN s ==> (g(f x) = x)) /\
        (!u. open_in (subtopology euclidean s) u
             ==> open_in (subtopology euclidean t) (IMAGE f u))
        ==> g continuous_on t``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``g:real->real``, ``t:real->bool``, ``s:real->bool``]
        CONTINUOUS_ON_OPEN_GEN) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (t :real -> bool) SUBSET (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   DISCH_THEN SUBST1_TAC] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
  ASM_SET_TAC[]);

val CONTINUOUS_ON_INVERSE_CLOSED_MAP = store_thm ("CONTINUOUS_ON_INVERSE_CLOSED_MAP",
 ``!f:real->real g s t.
        f continuous_on s /\ (IMAGE f s = t) /\ (!x. x IN s ==> (g(f x) = x)) /\
        (!u. closed_in (subtopology euclidean s) u
             ==> closed_in (subtopology euclidean t) (IMAGE f u))
        ==> g continuous_on t``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``g:real->real``, ``t:real->bool``, ``s:real->bool``]
        CONTINUOUS_ON_CLOSED_GEN) THEN
  KNOW_TAC ``IMAGE (g :real -> real) (t :real -> bool) SUBSET (s :real -> bool)`` THENL
  [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
   DISCH_THEN SUBST1_TAC] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``u:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
  FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [closed_in]) THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_INJECTIVE_OPEN_MAP = store_thm ("HOMEOMORPHISM_INJECTIVE_OPEN_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) /\
        (!u. open_in (subtopology euclidean s) u
             ==> open_in (subtopology euclidean t) (IMAGE f u))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``!(x :real) (y :real).
        x IN (s :real -> bool) /\ y IN s /\
        ((f :real -> real) x = f y) ==>
        (x = y)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [homeomorphism] THEN
  REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_ON_INVERSE_OPEN_MAP THEN ASM_MESON_TAC[]);

val HOMEOMORPHISM_INJECTIVE_CLOSED_MAP = store_thm ("HOMEOMORPHISM_INJECTIVE_CLOSED_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y)) /\
        (!u. closed_in (subtopology euclidean s) u
             ==> closed_in (subtopology euclidean t) (IMAGE f u))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN
  UNDISCH_TAC ``!(x :real) (y :real).
        x IN (s :real -> bool) /\ y IN s /\
        ((f :real -> real) x = f y) ==>
        (x = y)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [homeomorphism] THEN
  REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
  MATCH_MP_TAC CONTINUOUS_ON_INVERSE_CLOSED_MAP THEN ASM_MESON_TAC[]);

val HOMEOMORPHISM_IMP_OPEN_MAP = store_thm ("HOMEOMORPHISM_IMP_OPEN_MAP",
 ``!f:real->real g s t u.
        homeomorphism (s,t) (f,g) /\ open_in (subtopology euclidean s) u
        ==> open_in (subtopology euclidean t) (IMAGE f u)``,
  REWRITE_TAC[homeomorphism] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) u =
                 {y | y IN t /\ g(y) IN u}``
  SUBST1_TAC THENL
   [FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
    ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_IMP_CLOSED_MAP = store_thm ("HOMEOMORPHISM_IMP_CLOSED_MAP",
 ``!f:real->real g s t u.
        homeomorphism (s,t) (f,g) /\ closed_in (subtopology euclidean s) u
        ==> closed_in (subtopology euclidean t) (IMAGE f u)``,
  REWRITE_TAC[homeomorphism] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) u =
                  {y | y IN t /\ g(y) IN u}``
  SUBST1_TAC THENL
   [FIRST_ASSUM(MP_TAC o CONJUNCT1 o REWRITE_RULE [closed_in]) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONTINUOUS_ON_IMP_CLOSED_IN THEN ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ = store_thm ("HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((?g. homeomorphism (s,t) (f,g)) <=>
             !u. open_in (subtopology euclidean s) u
                 ==> open_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN ASM_MESON_TAC[],
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    ASM_REWRITE_TAC[]]);

val HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ = store_thm ("HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((?g. homeomorphism (s,t) (f,g)) <=>
             !u. closed_in (subtopology euclidean s) u
                 ==> closed_in (subtopology euclidean t) (IMAGE f u))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_IMP_CLOSED_MAP THEN ASM_MESON_TAC[],
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_CLOSED_MAP THEN
    ASM_REWRITE_TAC[]]);

val INJECTIVE_MAP_OPEN_IFF_CLOSED = store_thm ("INJECTIVE_MAP_OPEN_IFF_CLOSED",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
        ==> ((!u. open_in (subtopology euclidean s) u
                  ==> open_in (subtopology euclidean t) (IMAGE f u)) <=>
             (!u. closed_in (subtopology euclidean s) u
                  ==> closed_in (subtopology euclidean t) (IMAGE f u)))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC EQ_TRANS THEN
  EXISTS_TAC ``?g:real->real. homeomorphism (s,t) (f,g)`` THEN
  CONJ_TAC THENL
   [CONV_TAC SYM_CONV THEN MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP_EQ,
    MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_CLOSED_MAP_EQ] THEN
  ASM_REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Relatively weak hypotheses if the domain of the function is compact.      *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_IMP_CLOSED_MAP = store_thm ("CONTINUOUS_IMP_CLOSED_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\ compact s
        ==> !u. closed_in (subtopology euclidean s) u
                ==> closed_in (subtopology euclidean t) (IMAGE f u)``,
  SIMP_TAC std_ss [CLOSED_IN_CLOSED_EQ, COMPACT_IMP_CLOSED] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC CLOSED_SUBSET THEN
  ASM_SIMP_TAC std_ss [IMAGE_SUBSET] THEN
  MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
  ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_TRANS,
                BOUNDED_SUBSET, CONTINUOUS_ON_SUBSET]);

val CONTINUOUS_IMP_QUOTIENT_MAP = store_thm ("CONTINUOUS_IMP_QUOTIENT_MAP",
 ``!f:real->real s t.
        f continuous_on s /\ (IMAGE f s = t) /\ compact s
        ==> !u. u SUBSET t
                ==> (open_in (subtopology euclidean s)
                             {x | x IN s /\ f x IN u} <=>
                     open_in (subtopology euclidean t) u)``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  MATCH_MP_TAC CLOSED_MAP_IMP_QUOTIENT_MAP THEN
  ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC CONTINUOUS_IMP_CLOSED_MAP THEN
  ASM_REWRITE_TAC[]);

val CONTINUOUS_ON_INVERSE = store_thm ("CONTINUOUS_ON_INVERSE",
 ``!f:real->real g s.
        f continuous_on s /\ compact s /\ (!x. x IN s ==> (g(f(x)) = x))
        ==> g continuous_on (IMAGE f s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[CONTINUOUS_ON_CLOSED] THEN
  SUBGOAL_THEN ``IMAGE g (IMAGE (f:real->real) s) = s`` SUBST1_TAC THENL
   [REWRITE_TAC[EXTENSION, IN_IMAGE] THEN ASM_MESON_TAC[], ALL_TAC] THEN
  X_GEN_TAC ``t:real->bool`` THEN DISCH_TAC THEN
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN
  EXISTS_TAC ``IMAGE (f:real->real) t`` THEN CONJ_TAC THENL
   [MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
    MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET) THEN
    REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
    ASM_MESON_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_IN_CLOSED_TRANS,
                  BOUNDED_SUBSET, CONTINUOUS_ON_SUBSET],
    SIMP_TAC std_ss [EXTENSION, IN_INTER, GSPECIFICATION, IN_IMAGE] THEN
    ASM_MESON_TAC[CLOSED_IN_SUBSET, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, SUBSET_DEF]]);

val HOMEOMORPHISM_COMPACT = store_thm ("HOMEOMORPHISM_COMPACT",
 ``!s f t. compact s /\ f continuous_on s /\ (IMAGE f s = t) /\
           (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
           ==> ?g. homeomorphism(s,t) (f,g)``,
  REWRITE_TAC[INJECTIVE_ON_LEFT_INVERSE] THEN REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  DISCH_THEN (X_CHOOSE_TAC ``g:real->real``) THEN EXISTS_TAC ``g:real->real`` THEN
  ASM_SIMP_TAC std_ss [EXTENSION, homeomorphism] THEN
  FIRST_X_ASSUM(SUBST_ALL_TAC o SYM) THEN
  ASM_MESON_TAC[CONTINUOUS_ON_INVERSE, IN_IMAGE]);

val HOMEOMORPHIC_COMPACT = store_thm ("HOMEOMORPHIC_COMPACT",
 ``!s f t. compact s /\ f continuous_on s /\ (IMAGE f s = t) /\
           (!x y. x IN s /\ y IN s /\ (f x = f y) ==> (x = y))
           ==> s homeomorphic t``,
  REWRITE_TAC[homeomorphic] THEN METIS_TAC[HOMEOMORPHISM_COMPACT]);

(* ------------------------------------------------------------------------- *)
(* Lemmas about composition of homeomorphisms.                               *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE = store_thm ("HOMEOMORPHISM_FROM_COMPOSITION_SURJECTIVE",
 ``!f:real->real g:real->real s t u.
        f continuous_on s /\ (IMAGE f s = t) /\
        g continuous_on t /\ IMAGE g t SUBSET u /\
        (?h. homeomorphism (s,u) (g o f,h))
        ==> (?f'. homeomorphism (s,t) (f,f')) /\
            (?g'. homeomorphism (t,u) (g,g'))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[homeomorphism, o_THM]) THEN
  MATCH_MP_TAC(TAUT `q /\ (q ==> p) ==> p /\ q`) THEN CONJ_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC OPEN_MAP_FROM_COMPOSITION_SURJECTIVE THEN
    MAP_EVERY EXISTS_TAC [``f:real->real``, ``s:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN
    MAP_EVERY EXISTS_TAC [``h:real->real``, ``s:real->bool``] THEN
    ASM_SIMP_TAC std_ss [homeomorphism, o_THM],
    REWRITE_TAC[homeomorphism, o_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``g':real->real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``((h:real->real) o (g:real->real))`` THEN
    ASM_SIMP_TAC std_ss [o_THM, IMAGE_COMPOSE] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]);

val HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE = store_thm ("HOMEOMORPHISM_FROM_COMPOSITION_INJECTIVE",
 ``!f:real->real g:real->real s t u.
        f continuous_on s /\ IMAGE f s SUBSET t /\
        g continuous_on t /\ IMAGE g t SUBSET u /\
        (!x y. x IN t /\ y IN t /\ (g x = g y) ==> (x = y)) /\
        (?h. homeomorphism (s,u) (g o f,h))
        ==> (?f'. homeomorphism (s,t) (f,f')) /\
            (?g'. homeomorphism (t,u) (g,g'))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  RULE_ASSUM_TAC(REWRITE_RULE[homeomorphism, o_THM]) THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
   [MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC OPEN_MAP_FROM_COMPOSITION_INJECTIVE THEN
    MAP_EVERY EXISTS_TAC [``g:real->real``, ``u:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC HOMEOMORPHISM_IMP_OPEN_MAP THEN
    MAP_EVERY EXISTS_TAC [``h:real->real``, ``s:real->bool``] THEN
    ASM_REWRITE_TAC[homeomorphism, o_THM],
    REWRITE_TAC[homeomorphism, o_THM] THEN
    DISCH_THEN(X_CHOOSE_THEN ``f':real->real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(f:real->real) o (h:real->real)`` THEN
    ASM_SIMP_TAC std_ss [o_THM, IMAGE_COMPOSE] THEN
    REPEAT(CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC]) THEN
    MATCH_MP_TAC CONTINUOUS_ON_COMPOSE THEN
    ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]);

(* ------------------------------------------------------------------------- *)
(* Preservation of topological properties.                                   *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_COMPACTNESS = store_thm ("HOMEOMORPHIC_COMPACTNESS",
 ``!s t. s homeomorphic t ==> (compact s <=> compact t)``,
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MESON_TAC[COMPACT_CONTINUOUS_IMAGE]);

val HOMEOMORPHIC_CONNECTEDNESS = store_thm ("HOMEOMORPHIC_CONNECTEDNESS",
 ``!s t. s homeomorphic t ==> (connected s <=> connected t)``,
  REWRITE_TAC[homeomorphic, homeomorphism] THEN
  MESON_TAC[CONNECTED_CONTINUOUS_IMAGE]);

(* ------------------------------------------------------------------------- *)
(* Results on translation, scaling etc.                                      *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_SCALING = store_thm ("HOMEOMORPHIC_SCALING",
 ``!s:real->bool c. ~(c = &0) ==> s homeomorphic (IMAGE (\x. c * x) s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  MAP_EVERY EXISTS_TAC [``\x:real. c * x``, ``\x:real. inv(c) * x``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CMUL, CONTINUOUS_ON_ID, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_RINV] THEN
  SIMP_TAC std_ss [REAL_MUL_LID, IN_IMAGE, REAL_MUL_LID] THEN MESON_TAC[]);

val HOMEOMORPHIC_TRANSLATION = store_thm ("HOMEOMORPHIC_TRANSLATION",
 ``!s a:real. s homeomorphic (IMAGE (\x. a + x) s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  MAP_EVERY EXISTS_TAC [``\x:real. a +  x``, ``\x:real. -a + x``] THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID] THEN
  SIMP_TAC std_ss [REAL_ADD_ASSOC, REAL_ADD_LINV, REAL_ADD_RINV,
           FORALL_IN_IMAGE, REAL_ADD_LID] THEN
  REWRITE_TAC[IN_IMAGE] THEN MESON_TAC[]);

val HOMEOMORPHIC_AFFINITY = store_thm ("HOMEOMORPHIC_AFFINITY",
 ``!s a:real c. ~(c = &0) ==> s homeomorphic (IMAGE (\x. a + c * x) s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_TRANS THEN
  EXISTS_TAC ``IMAGE (\x:real. c * x) s`` THEN
  ASM_SIMP_TAC std_ss [HOMEOMORPHIC_SCALING] THEN
  SUBGOAL_THEN ``(\x:real. a + c * x) = (\x. a + x) o (\x. c * x)``
  SUBST1_TAC THENL [REWRITE_TAC[o_DEF], ALL_TAC] THEN
  SIMP_TAC std_ss [IMAGE_COMPOSE, HOMEOMORPHIC_TRANSLATION]);

val HOMEOMORPHIC_BALLS_CBALL_SPHERE = store_thm ("HOMEOMORPHIC_BALLS_CBALL_SPHERE",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> ball(a,d) homeomorphic ball(b,e)) /\
   (!a:real b:real d e.
      &0 < d /\ &0 < e ==> cball(a,d) homeomorphic cball(b,e)) /\
   (!a:real b:real d e.
      &0 < d /\ &0 < e ==> sphere(a,d) homeomorphic sphere(b,e))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
  EXISTS_TAC ``\x:real. b + (e / d) * (x - a)`` THEN
  EXISTS_TAC ``\x:real. a + (d / e) * (x - b)`` THEN
  ASM_SIMP_TAC std_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_SUB, CONTINUOUS_ON_CMUL,
    CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID, IN_BALL, IN_CBALL, IN_SPHERE] THEN
  REWRITE_TAC[dist, REAL_ARITH ``a - (a + b) = -b:real``, ABS_NEG] THEN
  REWRITE_TAC[real_div, REAL_ARITH
   ``a + d * ((b + e * (x - a)) - b) = (&1 - d * e) * a + (d * e) * x:real``] THEN
  ONCE_REWRITE_TAC[REAL_ARITH
    ``(e * d') * (d * e') = (d * d') * (e * e':real)``] THEN
  ASM_SIMP_TAC std_ss [REAL_MUL_RINV, REAL_LT_IMP_NE, REAL_MUL_LID, REAL_SUB_REFL] THEN
  REWRITE_TAC[ABS_MUL, REAL_MUL_LZERO, REAL_MUL_LID, REAL_ADD_LID] THEN
  ASM_SIMP_TAC std_ss [ABS_MUL, ABS_INV, REAL_ARITH
   ``&0 < x ==> (abs x = x:real)``, REAL_LT_IMP_NE] THEN
  GEN_REWR_TAC(BINOP_CONV o BINDER_CONV o funpow 2 RAND_CONV)
        [GSYM REAL_MUL_RID] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``(a * b) * c = (a * c) * b:real``] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL, GSYM real_div, REAL_LE_LDIV_EQ, REAL_MUL_LID,
    GSYM REAL_MUL_ASSOC, REAL_LT_LMUL, REAL_LT_LDIV_EQ, ABS_SUB] THEN
  ASM_SIMP_TAC std_ss [REAL_DIV_REFL, REAL_LT_IMP_NE, REAL_MUL_RID]);

val HOMEOMORPHIC_BALLS = store_thm ("HOMEOMORPHIC_BALLS",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> ball(a,d) homeomorphic ball(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

val HOMEOMORPHIC_CBALL = store_thm ("HOMEOMORPHIC_CBALL",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> cball(a,d) homeomorphic cball(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

val HOMEOMORPHIC_SPHERE = store_thm ("HOMEOMORPHIC_SPHERE",
 ``(!a:real b:real d e.
      &0 < d /\ &0 < e ==> sphere(a,d) homeomorphic sphere(b,e))``,
 REWRITE_TAC [HOMEOMORPHIC_BALLS_CBALL_SPHERE]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphism of one-point compactifications.                             *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS = store_thm ("HOMEOMORPHIC_ONE_POINT_COMPACTIFICATIONS",
 ``!s:real->bool t:real->bool a b.
        compact s /\ compact t /\ a IN s /\ b IN t /\
        (s DELETE a) homeomorphic (t DELETE b)
        ==> s homeomorphic t``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HOMEOMORPHIC_COMPACT THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [homeomorphic]) THEN
  SIMP_TAC std_ss [HOMEOMORPHISM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``f:real->real``, ``g:real->real``] THEN
  STRIP_TAC THEN
  EXISTS_TAC ``\x. if x = a then b else (f:real->real) x`` THEN
  ASM_SIMP_TAC std_ss [] THEN CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  REWRITE_TAC[CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``x:real = a`` THEN ASM_REWRITE_TAC[] THENL
   [REWRITE_TAC[continuous_within] THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
    MP_TAC(ISPECL [``b:real``, ``e:real``] CENTRE_IN_BALL) THEN
    ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
    SUBGOAL_THEN
      ``closed_in (subtopology euclidean s)
                 { x | x IN (s DELETE a) /\
                       (f:real->real)(x) IN t DIFF ball(b,e)}``
    MP_TAC THENL
     [MATCH_MP_TAC CLOSED_SUBSET THEN CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
      MATCH_MP_TAC COMPACT_IMP_CLOSED THEN SUBGOAL_THEN
       ``{x | x IN s DELETE a /\ f x IN t DIFF ball(b,e)} =
        IMAGE (g:real->real) (t DIFF ball (b,e))``
      SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
      MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
      ASM_SIMP_TAC std_ss [COMPACT_DIFF, OPEN_BALL] THEN
      FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
        CONTINUOUS_ON_SUBSET)) THEN ASM_SET_TAC[],
      REWRITE_TAC[closed_in, open_in, TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN
      DISCH_THEN(MP_TAC o SPEC ``a:real`` o last o CONJUNCTS) THEN
      ASM_SIMP_TAC std_ss [GSPECIFICATION, IN_DIFF, IN_DELETE] THEN
      SIMP_TAC std_ss [CONJ_EQ_IMP, DE_MORGAN_THM] THEN
      STRIP_TAC THEN EXISTS_TAC ``e':real`` THEN
      ASM_REWRITE_TAC[] THEN GEN_TAC THEN COND_CASES_TAC THEN
      ASM_REWRITE_TAC[DIST_REFL] THEN
      GEN_REWR_TAC (RAND_CONV o RAND_CONV o LAND_CONV) [DIST_SYM] THEN
      RULE_ASSUM_TAC(REWRITE_RULE[IN_BALL]) THEN ASM_SET_TAC[]],
    UNDISCH_TAC ``(f:real->real) continuous_on (s DELETE a)`` THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    REWRITE_TAC[continuous_within] THEN
    DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
    ASM_CASES_TAC ``&0 < e:real`` THEN ASM_REWRITE_TAC[IN_DELETE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``min d (dist(a:real,x))`` THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MIN, GSYM DIST_NZ] THEN
    METIS_TAC[REAL_LT_REFL]]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphisms between open intervals in real and then in real.       *)
(* Could prove similar things for closed intervals, but they drop out of     *)
(* later stuff in "convex.ml" even more easily.                              *)
(* ------------------------------------------------------------------------- *)

val HOMEOMORPHIC_OPEN_INTERVALS = store_thm ("HOMEOMORPHIC_OPEN_INTERVALS",
 ``!a b c d.
        a < b /\ c < d
        ==> interval(a,b) homeomorphic interval(c,d)``,
  SUBGOAL_THEN
   ``!a b. a < b
          ==> interval(0:real,1) homeomorphic interval(a,b)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN REWRITE_TAC[HOMEOMORPHIC_MINIMAL] THEN
    EXISTS_TAC ``(\x. a + x * (b - a)):real->real`` THEN
    EXISTS_TAC ``(\x. inv(b - a) * (x - a)):real->real`` THEN
    ASM_SIMP_TAC std_ss [IN_INTERVAL] THEN
    REWRITE_TAC[METIS [REAL_MUL_SYM, GSYM real_div] ``inv b * a:real = a / b``] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ, REAL_SUB_LT,
       REAL_LT_ADDR, REAL_EQ_LDIV_EQ, REAL_DIV_RMUL, REAL_LT_IMP_NE,
       REAL_LT_MUL, REAL_MUL_LZERO, REAL_ADD_SUB, REAL_LT_RMUL,
       REAL_ARITH ``a + x < b <=> x < &1 * (b - a:real)``] THEN
    REPEAT CONJ_TAC THENL
     [REAL_ARITH_TAC,
      ONCE_REWRITE_TAC [METIS [] ``(\x. a + x * (b - a)) =
                      (\x. (\x. a) x + (\x. x * (b - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. x * (b - a)) =
                      (\x. (\x. x) x * (\x. (b - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
      REWRITE_TAC[o_DEF, CONTINUOUS_ON_ID, CONTINUOUS_ON_CONST],
      ONCE_REWRITE_TAC [METIS [real_div, REAL_MUL_SYM] ``(\x. (x - a) / (b - a))  =
                                       (\x. inv(b - a) * (\x. (x - a)) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CMUL THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]],
    REPEAT STRIP_TAC THEN
    FIRST_ASSUM(MP_TAC o SPECL [``a:real``, ``b:real``]) THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``c:real``, ``d:real``]) THEN
    ASM_REWRITE_TAC[GSYM IMP_CONJ_ALT] THEN
    GEN_REWR_TAC (LAND_CONV o LAND_CONV) [HOMEOMORPHIC_SYM] THEN
    REWRITE_TAC[HOMEOMORPHIC_TRANS]]);

val HOMEOMORPHIC_OPEN_INTERVAL_UNIV = store_thm ("HOMEOMORPHIC_OPEN_INTERVAL_UNIV",
 ``!a b. a < b ==> interval(a,b) homeomorphic univ(:real)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``a:real``, ``b:real``, ``-1:real``, ``1:real``]
        HOMEOMORPHIC_OPEN_INTERVALS) THEN
  ASM_REWRITE_TAC[] THEN REWRITE_TAC [REAL_ARITH ``-1 < 1:real``] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] HOMEOMORPHIC_TRANS) THEN
  POP_ASSUM_LIST(K ALL_TAC) THEN
  REWRITE_TAC[HOMEOMORPHIC_MINIMAL, IN_UNIV] THEN
  EXISTS_TAC ``\x:real. inv(&1 - abs x) * x`` THEN
  EXISTS_TAC ``\y:real. if &0 <= y then inv(&1 + y) * y
                  else inv(&1 - y) * y`` THEN
  SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL
   [X_GEN_TAC ``x:real`` THEN REWRITE_TAC[IN_INTERVAL] THEN
    SIMP_TAC std_ss [REAL_LE_MUL, REAL_LT_INV_EQ, REAL_LE_MUL, REAL_ARITH
     ``-a < x /\ x < a ==> &0 < a - abs x:real``] THEN
    SIMP_TAC std_ss [abs, REAL_MUL_ASSOC] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN COND_CASES_TAC THEN
    (Cases_on `x = 0:real` THENL
     [ASM_REWRITE_TAC [REAL_INV1, REAL_NEG_0, REAL_SUB_RZERO,
      REAL_ADD_RID, REAL_MUL_RZERO] THEN REAL_ARITH_TAC, ALL_TAC]) THEN
     (KNOW_TAC ``!y. y <> 0:real ==> ((1 + inv y * x) = (y + x) / y:real) /\
                                     ((1 - inv y * x) = (y - x) / y:real)`` THENL
     [ASM_SIMP_TAC real_ss [real_div, REAL_ADD_RDISTRIB, REAL_MUL_RINV, REAL_SUB_RDISTRIB] THEN
      REAL_ARITH_TAC, STRIP_TAC] THEN
     KNOW_TAC ``(1 - x) <> 0 /\ (1 - -x) <> 0:real`` THENL
     [METIS_TAC [REAL_ARITH ``x < 1 ==> 1 - x <> 0:real``,
                 REAL_ARITH ``-1 < x ==> 1 - -x <> 0:real``],
      STRIP_TAC] THEN ASM_SIMP_TAC real_ss []) THENL
     [METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV],
      FULL_SIMP_TAC real_ss [REAL_LT_IMP_LE] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN
      FULL_SIMP_TAC real_ss [GSYM real_div, REAL_LE_RDIV_EQ,
       REAL_ARITH ``(-1 < x) =  (0 < 1 + x:real)``],
      FULL_SIMP_TAC real_ss [REAL_LT_IMP_LE, REAL_NOT_LE] THEN
      RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_MUL_SYM]) THEN
      FULL_SIMP_TAC real_ss [GSYM real_div, REAL_LT_LDIV_EQ,
       REAL_ARITH ``(x < 1) =  (0 < 1 - x:real)``] THEN
      METIS_TAC [REAL_ARITH ``~(x < 0 /\ 0 <= x:real)``],
      FULL_SIMP_TAC real_ss [] THEN
      METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV]],
    X_GEN_TAC ``y:real`` THEN COND_CASES_TAC THEN
    ASM_SIMP_TAC real_ss [IN_INTERVAL, REAL_BOUNDS_LT] THEN
    ASM_SIMP_TAC real_ss [ABS_MUL, ABS_INV, REAL_ARITH
     ``(0 <= y ==> 1 + y <> 0:real) /\ (~(0 <= y) ==> 1 - y <> 0:real)``] THEN
    REWRITE_TAC[GSYM(ONCE_REWRITE_RULE[REAL_MUL_SYM] real_div)] THEN
    ASM_SIMP_TAC real_ss [REAL_LT_LDIV_EQ, REAL_ARITH ``&0 <= x ==> &0 < abs(&1 + x:real)``,
                 REAL_ARITH ``~(&0 <= x) ==> &0 < abs(&1 - x:real)``] THEN
    (CONJ_TAC THENL [ASM_REAL_ARITH_TAC, ALL_TAC]) THEN
    REWRITE_TAC [real_div] THEN
    ONCE_REWRITE_TAC [REAL_ARITH ``a * b * c = c * b * a:real``] THEN
    REWRITE_TAC[REAL_MUL_ASSOC] THEN REWRITE_TAC[ABS_MUL] THEN
    ASM_REWRITE_TAC[abs,  REAL_LE_INV_EQ] THEN
    ASM_SIMP_TAC real_ss [REAL_ARITH ``&0 <= x ==> &0 <= &1 + x:real``,
                 REAL_ARITH ``~(&0 <= x) ==> &0 <= &1 - x:real``] THEN
    GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN
    (KNOW_TAC ``!x. x <> 0:real ==> ((1 + y * inv x) = (x + y) / x:real) /\
                                   ((1 - y * inv x) = (x - y) / x:real)`` THENL
     [ASM_SIMP_TAC real_ss [real_div, REAL_ADD_RDISTRIB, REAL_MUL_RINV, REAL_SUB_RDISTRIB],
      STRIP_TAC]) THENL
     [KNOW_TAC ``(1 + y) <> 0:real`` THENL
      [METIS_TAC [REAL_ARITH ``(0 <= x) ==> 1 + x <> 0:real``],
       STRIP_TAC] THEN ASM_SIMP_TAC real_ss [],
      KNOW_TAC ``(1 - y) <> 0:real`` THENL
      [METIS_TAC [REAL_ARITH ``~(0 <= x) ==> 1 - x <> 0:real``],
       STRIP_TAC] THEN ASM_SIMP_TAC real_ss []] THEN
     METIS_TAC [REAL_INV_1OVER, REAL_MUL_RINV, REAL_INV_INV],
    MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
    X_GEN_TAC ``x:real`` THEN
    REWRITE_TAC[IN_INTERVAL] THEN DISCH_TAC THEN
    ONCE_REWRITE_TAC [METIS [] ``(\x. inv (1 - abs x) * x) =
                    (\x. (\x. inv (1 - abs x)) x * (\x. x) x:real)``] THEN
    MATCH_MP_TAC CONTINUOUS_MUL THEN
    REWRITE_TAC[CONTINUOUS_AT_ID] THEN
    ONCE_REWRITE_TAC [METIS [] ``(\x. inv (1 - abs x)) =
                             (\x. inv ((\x. 1 - abs x) x:real))``] THEN
    ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
    SIMP_TAC real_ss [NETLIMIT_AT, o_DEF] THEN
    CONJ_TAC THENL
     [ONCE_REWRITE_TAC [METIS []
      ``(\x. 1 - abs x) = (\x. (\x. 1) x - (\x. abs x) x:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_SUB THEN
      SIMP_TAC std_ss [CONTINUOUS_CONST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. abs x) = (\x. abs ((\x. x) x:real))``] THEN
      METIS_TAC [REWRITE_RULE[o_DEF] CONTINUOUS_AT_ABS], ASM_REAL_ARITH_TAC],
    SUBGOAL_THEN ``univ(:real) = {x | x >= &0} UNION {x | x <= &0}``
    SUBST1_TAC THENL
     [SIMP_TAC std_ss [EXTENSION, IN_UNION, IN_UNION, GSPECIFICATION, IN_UNIV] THEN
      REAL_ARITH_TAC,
      ONCE_REWRITE_TAC [METIS []
      ``(\y. if 0 <= y then inv (1 + y) * y else inv (1 - y) * y) =
        (\y. if (\y. 0 <= y) y then (\y. inv (1 + y) * y) y
                               else (\y. inv (1 - y) * y) y:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CASES THEN
      SIMP_TAC std_ss [CLOSED_HALFSPACE_COMPONENT_LE, CLOSED_HALFSPACE_COMPONENT_GE,
                  GSPECIFICATION] THEN
      REWRITE_TAC[REAL_NOT_LE, real_ge, REAL_LET_ANTISYM] THEN
      SIMP_TAC std_ss [REAL_LE_ANTISYM, REAL_SUB_RZERO, REAL_ADD_RID] THEN
      CONJ_TAC THENL
      [MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
       X_GEN_TAC ``y:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, real_ge] THEN
       DISCH_TAC THEN ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 + y) * y) =
                                      (\y. (\y. inv (1 + y)) y * (\y. y) y:real)``] THEN
      MATCH_MP_TAC CONTINUOUS_MUL THEN
      REWRITE_TAC[CONTINUOUS_AT_ID] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 + y)) = (\y. inv ((\y. (1 + y)) y:real))``] THEN
      ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
      SIMP_TAC std_ss [NETLIMIT_AT, o_DEF] THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_AT_ID, CONTINUOUS_SUB,
                   CONTINUOUS_CONST] THEN
      ASM_REAL_ARITH_TAC, ALL_TAC] THEN CONJ_TAC THENL
      [MATCH_MP_TAC CONTINUOUS_AT_IMP_CONTINUOUS_ON THEN
       X_GEN_TAC ``y:real`` THEN SIMP_TAC std_ss [GSPECIFICATION, real_ge] THEN
       DISCH_TAC THEN ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 - y) * y) =
                                      (\y. (\y. inv (1 - y)) y * (\y. y) y:real)``] THEN
       MATCH_MP_TAC CONTINUOUS_MUL THEN
       REWRITE_TAC[CONTINUOUS_AT_ID] THEN
       ONCE_REWRITE_TAC [METIS [] ``(\y. inv (1 - y)) = (\y. inv ((\y. (1 - y)) y:real))``] THEN
       ONCE_REWRITE_TAC[GSYM o_DEF] THEN MATCH_MP_TAC CONTINUOUS_INV THEN
       SIMP_TAC std_ss [NETLIMIT_AT, o_DEF] THEN
       ASM_SIMP_TAC std_ss [CONTINUOUS_ADD, CONTINUOUS_AT_ID, CONTINUOUS_SUB,
                   CONTINUOUS_CONST] THEN
       ASM_REAL_ARITH_TAC,
       REPEAT STRIP_TAC THENL [METIS_TAC [REAL_ARITH ``~(0 <= x /\ x < 0:real)``],
        ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC]]]]);

(* ------------------------------------------------------------------------- *)
(* Cardinality of the reals. This is done in a rather laborious way to avoid *)
(* any dependence on the theories of analysis.                               *)
(* ------------------------------------------------------------------------- *)

Triviality lemma:
  !s m n. sum (s INTER {m..n}) (\i. inv(&3 pow i)) < &3 / &2 / &3 pow m
Proof
    REPEAT GEN_TAC THEN MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``sum {m..n} (\i. inv(&3 pow i))`` THEN CONJ_TAC THENL
    [ (* goal 1 (of 2) *)
      MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
      SIMP_TAC std_ss [FINITE_NUMSEG, INTER_SUBSET, REAL_LE_INV_EQ,
               POW_POS, REAL_POS],
      (* goal 2 (of 2) *)
      completeInduct_on `n - m:num` THEN GEN_TAC THEN GEN_TAC THEN
      DISCH_TAC THEN FULL_SIMP_TAC std_ss [] THEN POP_ASSUM K_TAC THEN
      KNOW_TAC ``(!m'. m' < n - m ==>
        !n m''. (m' = n - m'') ==>
          sum {m'' .. n} (\i. inv (3 pow i)) < 3 / 2 / 3 pow m'') ==>
       (!n' m''. (n' - m'' < n - m) ==>
          sum {m'' .. n'} (\i. inv (3 pow i)) < 3 / 2 / 3 pow m'')`` THENL
      [ METIS_TAC [], ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN DISCH_TAC ] THEN
      ASM_CASES_TAC ``m:num <= n`` THENL
      [ (* goal 2.1 (of 2) *)
        ASM_SIMP_TAC std_ss [SUM_CLAUSES_LEFT] THEN ASM_CASES_TAC ``m + 1 <= n:num`` THENL
        [ (* goal 2.1.1 (of 2) *)
          FIRST_X_ASSUM (MP_TAC o SPECL [``n:num``, ``SUC m``]) THEN
          KNOW_TAC ``n - SUC m < n - m`` THENL
          [ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
           ASM_SIMP_TAC arith_ss [ADD1, REAL_POW_ADD]] THEN
          MATCH_MP_TAC (REAL_ARITH
                        ``a + j:real <= k ==> x < j ==> a + x < k:real``) THEN
          KNOW_TAC ``3 pow m <> 0:real`` THENL
          [MATCH_MP_TAC POW_NZ THEN REAL_ARITH_TAC, DISCH_TAC] THEN
          ASM_SIMP_TAC real_ss [real_div, REAL_INV_MUL, POW_1] THEN
          ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
          GEN_REWR_TAC (LAND_CONV o LAND_CONV) [GSYM REAL_MUL_RID] THEN
          REWRITE_TAC [GSYM REAL_ADD_LDISTRIB, GSYM REAL_MUL_ASSOC] THEN
          MATCH_MP_TAC REAL_LE_LMUL_IMP THEN CONJ_TAC THENL
          [REWRITE_TAC [REAL_LE_INV_EQ] THEN MATCH_MP_TAC POW_POS THEN
           REAL_ARITH_TAC, ALL_TAC] THEN REWRITE_TAC [GSYM real_div] THEN
           SIMP_TAC real_ss [REAL_LE_RDIV_EQ, REAL_ADD_RDISTRIB, real_div] THEN
           REWRITE_TAC [REAL_MUL_ASSOC] THEN SIMP_TAC real_ss [REAL_MUL_LINV],
          ALL_TAC], ALL_TAC] THEN
      RULE_ASSUM_TAC (REWRITE_RULE[NOT_LESS_EQUAL, GSYM NUMSEG_EMPTY]) THEN
      ASM_REWRITE_TAC [SUM_CLAUSES, REAL_ADD_RID] THEN
      (KNOW_TAC ``0:real < 3 pow m`` THENL
          [MATCH_MP_TAC REAL_POW_LT THEN REAL_ARITH_TAC, DISCH_TAC] THEN
       ASM_SIMP_TAC real_ss [REAL_LT_RDIV_EQ, REAL_MUL_LINV, REAL_LT_IMP_NE])]
QED

Theorem CARD_EQ_REAL:   univ(:real) =_c univ(:num->bool)
Proof
  REWRITE_TAC [GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
  [ (* goal 1 (of 2) *)
    KNOW_TAC ``univ(:real) <=_c (univ(:num) *_c univ(:num->bool)) /\
               (univ(:num) *_c univ(:num->bool)) <=_c univ(:num -> bool)`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    CONJ_TAC THENL
     [ALL_TAC,
      MATCH_MP_TAC CARD_MUL2_ABSORB_LE THEN REWRITE_TAC[INFINITE_Unum] THEN
      SIMP_TAC std_ss [CANTOR_THM_UNIV, CARD_LT_IMP_LE, CARD_LE_REFL]] THEN
    `univ(:real) <=_c (univ(:num) *_c {x:real | &0 <= x}) /\
     univ(:num) *_c {x:real | &0 <= x} <=_c univ(:num) *_c univ(:num -> bool)`
       suffices_by METIS_TAC[CARD_LE_TRANS] THEN
    CONJ_TAC THENL
     [SIMP_TAC std_ss [LE_C, mul_c, EXISTS_PROD, IN_ELIM_PAIR_THM, IN_UNIV] THEN
      EXISTS_TAC ``\(n,x:real). -(&1) pow n * x`` THEN X_GEN_TAC ``x:real`` THEN
      `?p_2. (p_2 IN {x | 0r <= x} /\ ((\ (n,x). -1 pow n * x) (0,p_2) = x)) \/
             (p_2 IN {x | 0r <= x} /\ ((\ (n,x). -1 pow n * x) (1,p_2) = x))`
        suffices_by METIS_TAC[OR_EXISTS_THM] THEN EXISTS_TAC ``abs x:real`` THEN
      SIMP_TAC std_ss [GSPECIFICATION, pow, POW_1] THEN REAL_ARITH_TAC,
      ALL_TAC] THEN
    MATCH_MP_TAC CARD_LE_MUL THEN SIMP_TAC std_ss [CARD_LE_REFL] THEN
    MP_TAC(ISPECL [``univ(:num)``, ``univ(:num)``] CARD_MUL_ABSORB_LE) THEN
    SIMP_TAC std_ss [CARD_LE_REFL, num_INFINITE] THEN
    SIMP_TAC std_ss [le_c, mul_c, IN_UNIV, FORALL_PROD, IN_ELIM_PAIR_THM] THEN
    REWRITE_TAC [GSYM PAIR_EQ] THEN
    SIMP_TAC std_ss [GSYM FORALL_PROD, INJECTIVE_LEFT_INVERSE] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]

    THEN
    MAP_EVERY X_GEN_TAC [``Pair:num#num->num``, ``Unpair:num->num#num``] THEN
    DISCH_TAC THEN
    EXISTS_TAC ``\x:real n:num. &(FST(Unpair n)) * x <= &(SND(Unpair n))`` THEN
    SIMP_TAC std_ss [] THEN
    HO_MATCH_MP_TAC REAL_WLOG_LT THEN
    SIMP_TAC std_ss [GSPECIFICATION, FUN_EQ_THM] THEN
    CONJ_TAC THENL [SIMP_TAC std_ss [EQ_SYM_EQ, CONJ_ACI], ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN REPEAT STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o GENL [``p:num``, ``q:num``] o
      SPEC ``(Pair:num#num->num) (p,q)``) THEN
    ASM_REWRITE_TAC[] THEN MATCH_MP_TAC(TAUT `~p ==> p ==> q`) THEN
    MP_TAC(SPEC ``y - x:real`` REAL_ARCH) THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LT, NOT_FORALL_THM] THEN
    DISCH_THEN(MP_TAC o SPEC ``&2:real``) THEN
    DISCH_THEN (X_CHOOSE_TAC ``p:num``) THEN EXISTS_TAC ``p:num`` THEN
    MP_TAC(ISPEC ``&p * x:real`` REAL_BIGNUM) THEN
    ONCE_REWRITE_TAC [METIS [] ``(?n. &p * x < &n:real) = (?n. (\n. &p * x < &n) n)``] THEN
    DISCH_THEN (MP_TAC o MATCH_MP WOP) THEN SIMP_TAC std_ss [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``n:num``) THEN EXISTS_TAC ``n:num`` THEN
    POP_ASSUM MP_TAC THEN SPEC_TAC (``n:num``,``n:num``) THEN
    KNOW_TAC ``!n. (\n. &p * x < &n:real /\ (!m. m < n ==> ~(&p * x < &m)) ==>
                      ~(&p * x <= &n <=> &p * y <= &n:real)) n`` THENL
    [ALL_TAC, METIS_TAC []] THEN MATCH_MP_TAC INDUCTION THEN

    ASM_SIMP_TAC std_ss [REAL_LE_MUL, REAL_POS,
      REAL_ARITH ``x:real < &0 <=> ~(&0 <= x)``]

    THEN
    X_GEN_TAC ``q:num`` THEN REWRITE_TAC[GSYM REAL_OF_NUM_SUC] THEN
    DISCH_THEN(K ALL_TAC) THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``q:num``) THEN
    SIMP_TAC arith_ss [LT] THEN POP_ASSUM MP_TAC THEN
    POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN
    POP_ASSUM MP_TAC THEN POP_ASSUM MP_TAC THEN REAL_ARITH_TAC,

    (* goal 2 (of 2) *)
    REWRITE_TAC[le_c, IN_UNIV] THEN
    EXISTS_TAC ``\s:num->bool. sup { sum (s INTER { 0n..n}) (\i. inv(&3 pow i)) |
                                    n IN univ(:num) }`` THEN
    MAP_EVERY X_GEN_TAC [``x:num->bool``, ``y:num->bool``] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [EXTENSION, NOT_FORALL_THM] THEN
    ONCE_REWRITE_TAC [METIS [] ``(?x':num. x' IN x <=/=> x' IN y) =
                           (?x'. (\x'. x' IN x <=/=> x' IN y) x')``] THEN
    DISCH_THEN (MP_TAC o MATCH_MP WOP) THEN SIMP_TAC std_ss [] THEN
    MAP_EVERY (fn w => SPEC_TAC(w,w)) [``y:num->bool``, ``x:num->bool``] THEN
    KNOW_TAC ``!x y.
     (?n. ~(n IN x <=> n IN y) /\ (\x y n. !m. m < n ==> (m IN x <=> m IN y)) x y n) ==>
     (\x y. sup {sum (x INTER {0 .. n}) (\i. inv (3 pow i)) | n IN univ(:num)} <>
            sup {sum (y INTER {0 .. n}) (\i. inv (3 pow i)) | n IN univ(:num)}) x y`` THENL
    [ALL_TAC, METIS_TAC []] THEN
    MATCH_MP_TAC(MESON[]
     ``((!P Q n. R P Q n <=> R Q P n) /\ (!P Q. SS P Q <=> SS Q P)) /\
       (!P Q. (?n. n IN P /\ ~(n IN Q) /\ R P Q n) ==> SS P Q)
       ==> !P Q. (?n:num. ~(n IN P <=> n IN Q) /\ R P Q n) ==> SS P Q``) THEN
    SIMP_TAC std_ss [] THEN CONJ_TAC THENL
    [ONCE_REWRITE_TAC[EQ_SYM_EQ] THEN METIS_TAC [], SIMP_TAC std_ss []] THEN
    MAP_EVERY X_GEN_TAC [``x:num->bool``, ``y:num->bool``] THEN
    DISCH_THEN(X_CHOOSE_THEN ``n:num`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC(REAL_ARITH ``!z:real. y < z /\ z <= x ==> ~(x = y)``) THEN

    EXISTS_TAC ``sum (x INTER { 0n..n}) (\i. inv(&3 pow i))`` THEN CONJ_TAC THENL
    [ (* goal 2.1 (of 2) *)
      MATCH_MP_TAC REAL_LET_TRANS THEN
      EXISTS_TAC
       ``sum (y INTER { 0n..n}) (\i. inv(&3 pow i)) +
         &3 / &2 / &3 pow (SUC n)`` THEN

      CONJ_TAC THENL
       [MATCH_MP_TAC REAL_SUP_LE' THEN
        CONJ_TAC THENL [SET_TAC[], SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV]] THEN
        X_GEN_TAC ``p:num`` THEN ASM_CASES_TAC ``n:num <= p`` THENL
         [MATCH_MP_TAC(REAL_ARITH
           ``!d. (s:real = t + d) /\ d <= e ==> s <= t + e``) THEN
          EXISTS_TAC ``sum(y INTER {n+ 1n..p}) (\i. inv (&3 pow i))`` THEN
          CONJ_TAC THENL
           [ONCE_REWRITE_TAC[INTER_COMM] THEN
            SIMP_TAC std_ss [INTER_DEF, SUM_RESTRICT_SET] THEN
            ASM_SIMP_TAC std_ss [SUM_COMBINE_R, ZERO_LESS_EQ],
            SIMP_TAC std_ss [ADD1, lemma, REAL_LT_IMP_LE]],
          MATCH_MP_TAC(REAL_ARITH ``y:real <= x /\ &0 <= d ==> y <= x + d``) THEN
          SIMP_TAC real_ss [REAL_LE_DIV, REAL_POS, POW_POS] THEN
          MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
          SIMP_TAC real_ss [REAL_LE_INV_EQ, POW_POS, REAL_POS] THEN
          SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN MATCH_MP_TAC
           (SET_RULE ``s SUBSET t ==> u INTER s SUBSET u INTER t``) THEN
          REWRITE_TAC[SUBSET_NUMSEG] THEN ASM_SIMP_TAC arith_ss []],
        ONCE_REWRITE_TAC[INTER_COMM] THEN
        SIMP_TAC std_ss [INTER_DEF, SUM_RESTRICT_SET] THEN ASM_CASES_TAC ``n = 0:num`` THENL
         [FIRST_X_ASSUM SUBST_ALL_TAC THEN
          FULL_SIMP_TAC real_ss [SUM_SING, NUMSEG_SING, pow] THEN
          SIMP_TAC real_ss [REAL_LT_LDIV_EQ, REAL_INV1] THEN REAL_ARITH_TAC,
          ASM_SIMP_TAC std_ss [SUM_CLAUSES_RIGHT, LE_1, ZERO_LESS_EQ, REAL_ADD_RID] THEN
          MATCH_MP_TAC(REAL_ARITH ``(s:real = t) /\ d < e ==> s + d < t + e``) THEN
          CONJ_TAC THENL
           [MATCH_MP_TAC SUM_EQ_NUMSEG THEN
            ASM_SIMP_TAC std_ss [ARITH_PROVE ``~(n = 0:num) /\ m <= n - 1 ==> m < n``],
            SIMP_TAC real_ss [pow, real_div, REAL_INV_MUL, REAL_MUL_ASSOC] THEN
            KNOW_TAC ``3 pow n <> 0:real`` THENL
            [MATCH_MP_TAC POW_NZ THEN REAL_ARITH_TAC, DISCH_TAC] THEN
            KNOW_TAC ``0:real < 3 pow n`` THENL
            [MATCH_MP_TAC REAL_POW_LT THEN REAL_ARITH_TAC, DISCH_TAC] THEN
            ASM_SIMP_TAC real_ss [REAL_INV_MUL, REAL_MUL_ASSOC] THEN
            GEN_REWR_TAC RAND_CONV [GSYM REAL_MUL_LID] THEN
            MATCH_MP_TAC REAL_LT_RMUL_IMP THEN ASM_SIMP_TAC real_ss [REAL_LT_INV_EQ] THEN
            ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
            SIMP_TAC real_ss [REAL_MUL_ASSOC, REAL_MUL_LINV] THEN
            SIMP_TAC real_ss [REAL_INV_1OVER, REAL_LT_LDIV_EQ]]]],
      MP_TAC(ISPEC ``{ sum (x INTER { 0n..n}) (\i. inv(&3 pow i)) | n IN univ(:num) }``
          SUP) THEN SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV] THEN
      KNOW_TAC ``{sum (x INTER {0 .. n}) (\i. inv (3 pow i)) | n | T} <> {} /\
         (?b. !n. sum (x INTER {0 .. n}) (\i. inv (3 pow i)) <= b)`` THENL
      [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
       SIMP_TAC std_ss []] THEN
      CONJ_TAC THENL [SET_TAC[], ALL_TAC] THEN
      EXISTS_TAC ``&3 / &2 / (&3:real) pow 0`` THEN
      SIMP_TAC std_ss [lemma, REAL_LT_IMP_LE]]
  ]
QED

val UNCOUNTABLE_REAL = store_thm ("UNCOUNTABLE_REAL",
 ``~COUNTABLE univ(:real)``,
  REWRITE_TAC[COUNTABLE, ge_c] THEN
  KNOW_TAC ``univ(:num) <_c univ(:num->bool) /\
             univ(:num->bool) <=_c univ(:real)`` THENL
  [ALL_TAC, METIS_TAC [CARD_LTE_TRANS]] THEN
  REWRITE_TAC[CANTOR_THM_UNIV] THEN MATCH_MP_TAC CARD_EQ_IMP_LE THEN
  ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN REWRITE_TAC[CARD_EQ_REAL]);

Theorem CARD_EQ_REAL_IMP_UNCOUNTABLE :
    !s:real->bool. s =_c univ(:real) ==> ~COUNTABLE s
Proof
  GEN_TAC THEN STRIP_TAC THEN
  DISCH_THEN (MP_TAC o ISPEC ``univ(:real)`` o MATCH_MP
    (SIMP_RULE std_ss [CONJ_EQ_IMP] CARD_EQ_COUNTABLE)) THEN
  REWRITE_TAC[UNCOUNTABLE_REAL] THEN ASM_MESON_TAC[CARD_EQ_SYM]
QED

(* ------------------------------------------------------------------------- *)
(* Cardinalities of various useful sets.                                     *)
(* ------------------------------------------------------------------------- *)

val CARD_EQ_EUCLIDEAN = store_thm ("CARD_EQ_EUCLIDEAN",
 ``univ(:real) =_c univ(:real)``,
  REWRITE_TAC [eq_c, IN_UNIV] THEN EXISTS_TAC ``(\x. x:real)`` THEN
  METIS_TAC []);

val UNCOUNTABLE_EUCLIDEAN = store_thm ("UNCOUNTABLE_EUCLIDEAN",
 ``~COUNTABLE univ(:real)``,
  MATCH_MP_TAC CARD_EQ_REAL_IMP_UNCOUNTABLE THEN
  REWRITE_TAC[CARD_EQ_EUCLIDEAN]);

val CARD_EQ_INTERVAL = store_thm ("CARD_EQ_INTERVAL",
 ``(!a b:real. ~(interval(a,b) = {}) ==> (interval[a,b] =_c univ(:real))) /\
   (!a b:real. ~(interval(a,b) = {}) ==> (interval(a,b) =_c univ(:real)))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``interval(a:real,b) = {}`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    KNOW_TAC ``univ(:real) <=_c interval(a:real,b) /\
               interval(a:real,b) <=_c interval [(a,b)]`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    SIMP_TAC std_ss [CARD_LE_SUBSET, INTERVAL_OPEN_SUBSET_CLOSED],
    REWRITE_TAC[CARD_LE_UNIV],
    ALL_TAC] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [INTERVAL_NE_EMPTY]) THEN
  FIRST_X_ASSUM(MP_TAC o MATCH_MP HOMEOMORPHIC_OPEN_INTERVAL_UNIV) THEN
  DISCH_THEN(MP_TAC o MATCH_MP HOMEOMORPHIC_IMP_CARD_EQ) THEN
  MESON_TAC[CARD_EQ_IMP_LE, CARD_EQ_SYM]);

val UNCOUNTABLE_INTERVAL = store_thm ("UNCOUNTABLE_INTERVAL",
 ``(!a b. ~(interval(a,b) = {}) ==> ~COUNTABLE(interval[a,b])) /\
   (!a b. ~(interval(a,b) = {}) ==> ~COUNTABLE(interval(a,b)))``,
  SIMP_TAC std_ss [CARD_EQ_REAL_IMP_UNCOUNTABLE, CARD_EQ_INTERVAL]);

val COUNTABLE_OPEN_INTERVAL = store_thm ("COUNTABLE_OPEN_INTERVAL",
 ``!a b. COUNTABLE(interval(a,b)) <=> (interval(a,b) = {})``,
  MESON_TAC[COUNTABLE_EMPTY, UNCOUNTABLE_INTERVAL]);

val CARD_EQ_OPEN = store_thm ("CARD_EQ_OPEN",
 ``!s:real->bool. open s /\ ~(s = {}) ==> s =_c univ(:real)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_INTERVAL]) THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    DISCH_THEN(X_CHOOSE_TAC ``c:real``) THEN
    DISCH_THEN(MP_TAC o SPEC ``c:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``] THEN
    ASM_CASES_TAC ``interval(a:real,b) = {}`` THEN
    ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN STRIP_TAC THEN
    KNOW_TAC ``univ(:real) <=_c interval[a:real,b] /\
               interval[a:real,b] <=_c s:real->bool`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    ASM_SIMP_TAC std_ss [CARD_LE_SUBSET] THEN MATCH_MP_TAC CARD_EQ_IMP_LE THEN
    ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN ASM_SIMP_TAC std_ss [CARD_EQ_INTERVAL]]);

val UNCOUNTABLE_OPEN = store_thm ("UNCOUNTABLE_OPEN",
 ``!s:real->bool. open s /\ ~(s = {}) ==> ~(COUNTABLE s)``,
  SIMP_TAC std_ss [CARD_EQ_OPEN, CARD_EQ_REAL_IMP_UNCOUNTABLE]);

val CARD_EQ_BALL = store_thm ("CARD_EQ_BALL",
 ``!a:real r. &0 < r ==> ball(a,r) =_c  univ(:real)``,
  SIMP_TAC std_ss [CARD_EQ_OPEN, OPEN_BALL, BALL_EQ_EMPTY, GSYM REAL_NOT_LT]);

val CARD_EQ_CBALL = store_thm ("CARD_EQ_CBALL",
 ``!a:real r. &0 < r ==> cball(a,r) =_c univ(:real)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM CARD_LE_ANTISYM] THEN CONJ_TAC THENL
   [REWRITE_TAC[CARD_LE_UNIV],
    KNOW_TAC ``univ(:real) <=_c ball(a:real,r) /\
               ball(a:real,r) <=_c cball (a,r:real)`` THENL
    [ALL_TAC, METIS_TAC [CARD_LE_TRANS]] THEN
    SIMP_TAC std_ss [CARD_LE_SUBSET, BALL_SUBSET_CBALL] THEN
    MATCH_MP_TAC CARD_EQ_IMP_LE THEN
    ONCE_REWRITE_TAC[CARD_EQ_SYM] THEN ASM_SIMP_TAC std_ss [CARD_EQ_BALL]]);

val FINITE_IMP_NOT_OPEN = store_thm ("FINITE_IMP_NOT_OPEN",
 ``!s:real->bool. FINITE s /\ ~(s = {}) ==> ~(open s)``,
  MESON_TAC[UNCOUNTABLE_OPEN, FINITE_IMP_COUNTABLE]);

val OPEN_IMP_INFINITE = store_thm ("OPEN_IMP_INFINITE",
 ``!s. open s ==> (s = {}) \/ INFINITE s``,
  MESON_TAC[FINITE_IMP_NOT_OPEN]);

val EMPTY_INTERIOR_FINITE = store_thm ("EMPTY_INTERIOR_FINITE",
 ``!s:real->bool. FINITE s ==> (interior s = {})``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPEC ``s:real->bool`` OPEN_INTERIOR) THEN
  ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] FINITE_IMP_NOT_OPEN) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``s:real->bool`` THEN
  ASM_REWRITE_TAC[INTERIOR_SUBSET]);

val FINITE_CBALL = store_thm ("FINITE_CBALL",
 ``!a:real r. FINITE(cball(a,r)) <=> r <= &0``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``r < &0:real`` THEN
  ASM_SIMP_TAC std_ss [CBALL_EMPTY, REAL_LT_IMP_LE, FINITE_EMPTY] THEN
  ASM_CASES_TAC ``r = &0:real`` THEN
  ASM_REWRITE_TAC[CBALL_TRIVIAL, FINITE_SING, REAL_LE_REFL] THEN
  EQ_TAC THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  DISCH_THEN(MP_TAC o MATCH_MP EMPTY_INTERIOR_FINITE) THEN
  REWRITE_TAC[INTERIOR_CBALL, BALL_EQ_EMPTY] THEN ASM_REAL_ARITH_TAC);

val FINITE_BALL = store_thm ("FINITE_BALL",
 ``!a:real r. FINITE(ball(a,r)) <=> r <= &0``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``r <= &0:real`` THEN
  ASM_SIMP_TAC std_ss [BALL_EMPTY, REAL_LT_IMP_LE, FINITE_EMPTY] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (ONCE_REWRITE_RULE[CONJ_EQ_IMP]
        FINITE_IMP_NOT_OPEN)) THEN
  REWRITE_TAC[OPEN_BALL, BALL_EQ_EMPTY] THEN ASM_REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* "Iff" forms of constancy of function from connected set into a set that   *)
(* is smaller than R, or countable, or finite, or disconnected, or discrete. *)
(* ------------------------------------------------------------------------- *)

val CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ",
  ``(!s. connected s <=>
         !f:real->real t.
            f continuous_on s /\ IMAGE f s SUBSET t /\
            (!y. y IN t ==> (connected_component t y = {y}))
            ==> ?a. !x. x IN s ==> (f x = a)) /\
    (!s. connected s <=>
         !f:real->real.
            f continuous_on s /\
            (!x. x IN s
                 ==> ?e. &0 < e /\
                         !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
            ==> ?a. !x. x IN s ==> (f x = a)) /\
    (!s. connected s <=>
         !f:real->real.
            f continuous_on s /\ FINITE(IMAGE f s)
            ==> ?a. !x. x IN s ==> (f x = a))``,
  SIMP_TAC std_ss [GSYM FORALL_AND_THM] THEN X_GEN_TAC ``s:real->bool`` THEN
  MATCH_MP_TAC(TAUT
    `(s ==> t) /\ (t ==> u) /\ (u ==> v) /\ (v ==> s)
     ==> (s <=> t) /\ (s <=> u) /\ (s <=> v)`) THEN
  REPEAT CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
    ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
    FIRST_X_ASSUM(X_CHOOSE_TAC ``x:real`` o
        REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
    EXISTS_TAC ``(f:real->real) x`` THEN
    MATCH_MP_TAC(SET_RULE
     ``IMAGE f s SUBSET {a} ==> !y. y IN s ==> (f y = a)``) THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``(f:real->real) x``) THEN
    KNOW_TAC ``(f:real->real) x IN t`` THENL
    [ASM_SET_TAC [], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     DISCH_THEN(SUBST1_TAC o SYM)] THEN
    MATCH_MP_TAC CONNECTED_COMPONENT_MAXIMAL THEN
    ASM_SIMP_TAC std_ss [CONNECTED_CONTINUOUS_IMAGE] THEN ASM_SET_TAC [],
    REPEAT STRIP_TAC THEN FIRST_X_ASSUM MATCH_MP_TAC THEN
    EXISTS_TAC ``IMAGE (f:real->real) s`` THEN
    ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, SUBSET_REFL] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC(SET_RULE
     ``(!y. y IN s /\ f y IN connected_component (IMAGE f s) a ==> (f y = a)) /\
       connected_component (IMAGE f s) a SUBSET (IMAGE f s) /\
       connected_component (IMAGE f s) a a
       ==> (connected_component (IMAGE f s) a = {a})``) THEN
    SIMP_TAC std_ss [CONNECTED_COMPONENT_SUBSET, CONNECTED_COMPONENT_REFL_EQ] THEN
    ASM_SIMP_TAC std_ss [FUN_IN_IMAGE] THEN X_GEN_TAC ``y:real`` THEN STRIP_TAC THEN
    MP_TAC(ISPEC ``connected_component (IMAGE (f:real->real) s) (f x)``
        CONNECTED_CLOSED) THEN
    REWRITE_TAC[CONNECTED_CONNECTED_COMPONENT] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    ASM_REWRITE_TAC[] THEN MAP_EVERY EXISTS_TAC
     [``cball((f:real->real) x,e / &2)``,
      ``univ(:real) DIFF ball((f:real->real) x,e)``] THEN
    SIMP_TAC std_ss [GSYM OPEN_CLOSED, OPEN_BALL, CLOSED_CBALL] THEN
    REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN REPEAT CONJ_TAC THENL
     [REWRITE_TAC[SUBSET_DEF, IN_CBALL, IN_UNION, IN_DIFF, IN_BALL, IN_UNIV] THEN
      ONCE_REWRITE_TAC [METIS []
       ``(dist (f x,x') <= e / 2 \/ ~(dist (f x,x') < e)) =
         (\x'. dist (f x,x') <= e / 2 \/ ~(dist (f x,x') < e)) x'``] THEN
      MATCH_MP_TAC(MESON[SUBSET_DEF, CONNECTED_COMPONENT_SUBSET]
       ``(!x. x IN s ==> P x)
        ==> (!x. x IN connected_component s y ==> P x)``) THEN
      SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN X_GEN_TAC ``z:real`` THEN
      DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN
      ASM_SIMP_TAC real_ss [dist, REAL_LE_RDIV_EQ] THEN ASM_REAL_ARITH_TAC,
      MATCH_MP_TAC(SET_RULE
       ``(!x. x IN s /\ x IN t ==> F) ==> (s INTER t INTER u = {})``) THEN
      REWRITE_TAC[IN_BALL, IN_CBALL, IN_DIFF, IN_UNIV] THEN
      UNDISCH_TAC ``&0 < e:real`` THEN
      ASM_SIMP_TAC real_ss [dist, REAL_LE_RDIV_EQ] THEN REAL_ARITH_TAC,
      EXISTS_TAC ``(f:real->real) x`` THEN
      ASM_SIMP_TAC std_ss [CENTRE_IN_CBALL, REAL_HALF, REAL_LT_IMP_LE, IN_INTER] THEN
      SIMP_TAC std_ss [SPECIFICATION] THEN
      ASM_SIMP_TAC std_ss [CONNECTED_COMPONENT_REFL_EQ, FUN_IN_IMAGE],
      EXISTS_TAC ``(f:real->real) y`` THEN
      ASM_REWRITE_TAC[IN_INTER, IN_DIFF, IN_UNIV, IN_BALL, REAL_NOT_LT] THEN
      ASM_SIMP_TAC std_ss [ONCE_REWRITE_RULE[DIST_SYM] dist]],
    DISCH_TAC THEN X_GEN_TAC ``f:real->real`` THEN
    POP_ASSUM (MP_TAC o SPEC ``f:real->real``) THEN
    DISCH_THEN(fn th => STRIP_TAC THEN MATCH_MP_TAC th) THEN
    ASM_REWRITE_TAC[] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    ASM_CASES_TAC ``IMAGE (f:real->real) s DELETE (f x) = {}`` THENL
     [EXISTS_TAC ``&1:real`` THEN REWRITE_TAC[REAL_LT_01] THEN ASM_SET_TAC [],
      ALL_TAC] THEN
    EXISTS_TAC
     ``inf{abs(z - f x) |z| z IN IMAGE (f:real->real) s DELETE (f x)}`` THEN
    SIMP_TAC real_ss [GSYM IMAGE_DEF] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_INF_FINITE, REAL_INF_LE_FINITE, FINITE_DELETE,
                 IMAGE_FINITE, IMAGE_EQ_EMPTY] THEN
    SIMP_TAC std_ss [FORALL_IN_IMAGE, EXISTS_IN_IMAGE] THEN
    SIMP_TAC real_ss [IN_DELETE, GSYM ABS_NZ, REAL_SUB_0, IN_IMAGE] THEN
    MESON_TAC[REAL_LE_REFL],
    REWRITE_TAC[CONNECTED_CLOSED_IN_EQ] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``t:real->bool``, ``u:real->bool``] THEN
    STRIP_TAC THEN EXISTS_TAC
     ``(\x. if x IN t then 0 else 1:real):real->real`` THEN
    SIMP_TAC std_ss [NOT_IMP] THEN REPEAT CONJ_TAC THENL
     [EXPAND_TAC "s" THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x:real. if x IN t then 0 else 1:real) =
                   (\x. if (\x. x IN t) x then (\x. 0) x else (\x. 1) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_CASES_LOCAL THEN
      ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CONST] THEN ASM_SET_TAC [],
      MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``{0:real;1:real}`` THEN
      REWRITE_TAC[FINITE_INSERT, FINITE_EMPTY] THEN SET_TAC[],
      SUBGOAL_THEN ``?a b:real. a IN s /\ a IN t /\ b IN s /\ ~(b IN t)``
      STRIP_ASSUME_TAC THENL
       [ASM_SET_TAC [], GEN_TAC] THEN CCONTR_TAC THEN
      POP_ASSUM (MP_TAC o SIMP_RULE std_ss []) THEN
      DISCH_THEN(fn th => MP_TAC(SPEC ``a:real`` th) THEN
                           MP_TAC(SPEC ``b:real`` th)) THEN
      ASM_REWRITE_TAC[] THEN REAL_ARITH_TAC]]);

val CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real t.
            f continuous_on s /\ IMAGE f s SUBSET t /\
            (!y. y IN t ==> (connected_component t y = {y}))
            ==> ?a. !x. x IN s ==> (f x = a))``,
  REWRITE_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real.
            f continuous_on s /\
            (!x. x IN s
                 ==> ?e. &0 < e /\
                         !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
            ==> ?a. !x. x IN s ==> (f x = a)) ``,
  METIS_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_FINITE_RANGE_CONSTANT_EQ = store_thm
  ("CONTINUOUS_FINITE_RANGE_CONSTANT_EQ",
 ``(!s. connected s <=>
         !f:real->real.
            f continuous_on s /\ FINITE(IMAGE f s)
            ==> ?a. !x. x IN s ==> (f x = a))``,
  METIS_TAC [CONTINUOUS_DISCONNECTED_DISCRETE_FINITE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCONNECTED_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_DISCONNECTED_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\ IMAGE f s SUBSET t /\
        (!y. y IN t ==> (connected_component t y = {y}))
        ==> ?a. !x. x IN s ==> (f x = a)``,
  MESON_TAC[CONTINUOUS_DISCONNECTED_RANGE_CONSTANT_EQ]);

val CONTINUOUS_DISCRETE_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_DISCRETE_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\
        (!x. x IN s
             ==> ?e. &0 < e /\
                     !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
        ==> ?a. !x. x IN s ==> (f x = a)``,
  KNOW_TAC ``!s f:real->real.
        connected s /\
        f continuous_on s /\
        (!x. x IN s
             ==> ?e. &0 < e /\
                     !y. y IN s /\ ~(f y = f x) ==> e <= abs(f y - f x))
        ==> ?a. !x. x IN s ==> (f x = a)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]] THEN
  SIMP_TAC std_ss [RIGHT_FORALL_IMP_THM, CONJ_EQ_IMP] THEN
  SIMP_TAC std_ss [AND_IMP_INTRO, GSYM CONTINUOUS_DISCRETE_RANGE_CONSTANT_EQ]);

val CONTINUOUS_FINITE_RANGE_CONSTANT = store_thm
  ("CONTINUOUS_FINITE_RANGE_CONSTANT",
 ``!f:real->real s.
        connected s /\
        f continuous_on s /\
        FINITE(IMAGE f s)
        ==> ?a. !x. x IN s ==> (f x = a)``,
  MESON_TAC[CONTINUOUS_FINITE_RANGE_CONSTANT_EQ]);

(* ------------------------------------------------------------------------- *)
(* Homeomorphism of hyperplanes.                                             *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``~(a = 0)
     ==> {x:real | a * x = b} homeomorphic {x:real | x = &0}``,
    REPEAT STRIP_TAC THEN SUBGOAL_THEN ``?c:real. a * c = b``
    STRIP_ASSUME_TAC THENL
     [EXISTS_TAC ``inv a * b:real`` THEN
      ASM_SIMP_TAC real_ss [REAL_MUL_RINV, REAL_MUL_ASSOC], ALL_TAC] THEN
     REWRITE_TAC [homeomorphic, homeomorphism] THEN
     EXISTS_TAC ``(\x. 0):real->real`` THEN
     EXISTS_TAC ``(\x:real. inv a * b:real)`` THEN
     SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
     SIMP_TAC std_ss [CONTINUOUS_ON_CONST] THEN
     REPEAT STRIP_TAC THENL
     [ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
      ASM_CASES_TAC ``0 < a:real`` THENL
      [ASM_SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN ASM_REAL_ARITH_TAC, ALL_TAC] THEN
      FULL_SIMP_TAC real_ss [REAL_NOT_LT, REAL_LE_LT] THENL [ALL_TAC, METIS_TAC []] THEN
      KNOW_TAC ``a < 0 ==> 0 < -a:real`` THENL [REAL_ARITH_TAC, ASM_REWRITE_TAC []] THEN
      DISCH_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN
      REWRITE_TAC [real_div, REAL_ARITH ``-(a * b) = a * -b:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN
      ASM_SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN ASM_REAL_ARITH_TAC,
      METIS_TAC [],
      ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
      ASM_CASES_TAC ``0 < a:real`` THENL
      [ASM_SIMP_TAC real_ss [REAL_EQ_RDIV_EQ] THEN ASM_REAL_ARITH_TAC, ALL_TAC] THEN
      FULL_SIMP_TAC real_ss [REAL_NOT_LT, REAL_LE_LT] THENL [ALL_TAC, METIS_TAC []] THEN
      KNOW_TAC ``a < 0 ==> 0 < -a:real`` THENL [REAL_ARITH_TAC, ASM_REWRITE_TAC []] THEN
      DISCH_TAC THEN ONCE_REWRITE_TAC [GSYM REAL_EQ_NEG] THEN
      REWRITE_TAC [real_div, REAL_ARITH ``-(a * b) = a * -b:real``] THEN
      ASM_SIMP_TAC std_ss [REAL_NEG_INV, GSYM real_div] THEN
      ASM_SIMP_TAC real_ss [REAL_EQ_RDIV_EQ] THEN ASM_REAL_ARITH_TAC]);

val HOMEOMORPHIC_HYPERPLANES = store_thm ("HOMEOMORPHIC_HYPERPLANES",
 ``!a:real b c:real d.
        ~(a = 0) /\ ~(c = 0)
        ==> {x | a * x = b} homeomorphic {x | c * x = d}``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC HOMEOMORPHIC_TRANS THEN EXISTS_TAC ``{x:real | x = &0}`` THEN
  ASM_SIMP_TAC std_ss [lemma] THEN ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  ASM_SIMP_TAC std_ss [lemma]);

val HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE = store_thm
  ("HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE",
 ``!a:real b c.
        ~(a = 0)
        ==> {x | a * x = b} homeomorphic {x:real | x = c}``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``{x:real | x = c} = {x | 1 * x = c}`` SUBST1_TAC
  THENL [ASM_SIMP_TAC real_ss [], MATCH_MP_TAC HOMEOMORPHIC_HYPERPLANES] THEN
  ASM_SIMP_TAC real_ss []);

val HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE = store_thm
  ("HOMEOMORPHIC_STANDARD_HYPERPLANE_HYPERPLANE",
 ``!a:real b c.
        ~(a = 0)
        ==> {x:real | x = c} homeomorphic {x | a * x = b}``,
  ONCE_REWRITE_TAC[HOMEOMORPHIC_SYM] THEN
  SIMP_TAC std_ss [HOMEOMORPHIC_HYPERPLANE_STANDARD_HYPERPLANE]);

(* ------------------------------------------------------------------------- *)
(* "Isometry" (up to constant bounds) of injective linear map etc.           *)
(* ------------------------------------------------------------------------- *)

val CAUCHY_ISOMETRIC = store_thm ("CAUCHY_ISOMETRIC",
 ``!f s e x.
        &0 < e /\ subspace s /\
        linear f /\ (!x. x IN s ==> abs(f x) >= e * abs(x)) /\
        (!n. x(n) IN s) /\ cauchy(f o x)
        ==> cauchy x``,
  REPEAT GEN_TAC THEN REWRITE_TAC[real_ge] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SIMP_TAC std_ss [CAUCHY, dist, o_THM] THEN
  FIRST_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_SUB th)]) THEN
  DISCH_THEN(fn th => X_GEN_TAC ``d:real`` THEN DISCH_TAC THEN MP_TAC th) THEN
  DISCH_THEN(MP_TAC o SPEC ``d * e:real``) THEN ASM_SIMP_TAC std_ss [REAL_LT_MUL] THEN
  METIS_TAC[REAL_LE_RDIV_EQ, REAL_MUL_SYM, REAL_LET_TRANS, SUBSPACE_SUB,
                REAL_LT_LDIV_EQ]);

val COMPLETE_ISOMETRIC_IMAGE = store_thm ("COMPLETE_ISOMETRIC_IMAGE",
 ``!f:real->real s e.
        &0 < e /\ subspace s /\
        linear f /\ (!x. x IN s ==> abs(f x) >= e * abs(x)) /\
        complete s
        ==> complete(IMAGE f s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [complete, EXISTS_IN_IMAGE] THEN
  STRIP_TAC THEN X_GEN_TAC ``g:num->real`` THEN
  SIMP_TAC std_ss [IN_IMAGE, SKOLEM_THM, FORALL_AND_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC ASSUME_TAC) THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` MP_TAC) THEN
  ONCE_REWRITE_TAC [METIS [] ``(!n. g n = f (x n)) = (!n. g n = (\n. f (x n)) n)``] THEN
  GEN_REWR_TAC (LAND_CONV o LAND_CONV) [GSYM FUN_EQ_THM] THEN
  REWRITE_TAC[GSYM o_DEF] THEN
  DISCH_THEN(CONJUNCTS_THEN2 SUBST_ALL_TAC ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:num->real``) THEN
  ASM_MESON_TAC[CAUCHY_ISOMETRIC, LINEAR_CONTINUOUS_AT,
                CONTINUOUS_AT_SEQUENTIALLY]);

val INJECTIVE_IMP_ISOMETRIC = store_thm ("INJECTIVE_IMP_ISOMETRIC",
 ``!f:real->real s.
        closed s /\ subspace s /\
        linear f /\ (!x. x IN s /\ (f x = 0) ==> (x = 0))
        ==> ?e. &0 < e /\ !x. x IN s ==> abs(f x) >= e * abs(x)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s SUBSET {0 :real}`` THENL
   [EXISTS_TAC ``&1:real`` THEN REWRITE_TAC[REAL_LT_01, REAL_MUL_LID, real_ge] THEN
    ASM_MESON_TAC[SUBSET_DEF, IN_SING, ABS_0, LINEAR_0, REAL_LE_REFL],
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
  SIMP_TAC std_ss [NOT_FORALL_THM, NOT_IMP, IN_SING] THEN
  DISCH_THEN(X_CHOOSE_THEN ``a:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL
   [``{(f:real->real) x | x IN s /\ (abs(x) = abs(a:real))}``,
    ``0:real``] DISTANCE_ATTAINS_INF) THEN
  KNOW_TAC ``closed {(f:real->real) x | x IN s /\ (abs x = abs a)} /\
   {f x | x IN s /\ (abs x = abs a)} <> {}`` THENL
   [SIMP_TAC std_ss [GSYM MEMBER_NOT_EMPTY, GSPECIFICATION] THEN
    CONJ_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
    MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
    SUBST1_TAC(SET_RULE
     ``{f x | x IN s /\ (abs(x) = abs(a:real))} =
       IMAGE (f:real->real) (s INTER {x | abs x = abs a})``) THEN
    MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN
    ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON] THEN
    MATCH_MP_TAC CLOSED_INTER_COMPACT THEN ASM_REWRITE_TAC[] THEN
    SUBGOAL_THEN
     ``{x:real | abs x = abs(a:real)} = frontier(cball(0,abs a))``
    SUBST1_TAC THENL
     [ASM_SIMP_TAC real_ss [FRONTIER_CBALL, GSYM ABS_NZ, dist, REAL_SUB_LZERO,
                   ABS_NEG, sphere],
      ASM_SIMP_TAC std_ss [COMPACT_FRONTIER, COMPACT_CBALL]],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``{(f:real->real) x | x IN s /\ (abs x = abs a)} =
                          {f x | (\x. x IN s /\ (abs x = abs a)) x}``] THEN
  ONCE_REWRITE_TAC[SET_RULE ``{f x | P x} = IMAGE f {x | P x}``] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, EXISTS_IN_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:real`` MP_TAC) THEN
  SIMP_TAC std_ss [GSPECIFICATION, dist, REAL_SUB_LZERO, ABS_NEG] THEN
  STRIP_TAC THEN SIMP_TAC std_ss [CLOSED_LIMPT, LIMPT_APPROACHABLE] THEN
  EXISTS_TAC ``abs((f:real->real) b) / abs(b)`` THEN CONJ_TAC THENL
   [ASM_MESON_TAC[REAL_LT_DIV, GSYM ABS_NZ, ABS_ZERO], ALL_TAC] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``x:real = 0`` THENL
   [FIRST_ASSUM(fn th => ASM_REWRITE_TAC[MATCH_MP LINEAR_0 th]) THEN
    REWRITE_TAC[ABS_0, REAL_MUL_RZERO, real_ge, REAL_LE_REFL],
    ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``(abs(a:real) / abs(x)) * x:real``) THEN
  KNOW_TAC ``abs a / abs x * x IN s /\ (abs (abs a / abs x * x) = abs a:real)`` THENL
   [KNOW_TAC ``(abs x <> 0:real) /\ (abs a <> 0:real)`` THENL
    [UNDISCH_TAC ``a <> 0:real`` THEN POP_ASSUM MP_TAC THEN
     REAL_ARITH_TAC, STRIP_TAC] THEN
    ASM_SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS] THEN
    FULL_SIMP_TAC std_ss [subspace] THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL, ABS_ZERO],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  UNDISCH_TAC ``linear f`` THEN DISCH_TAC THEN
  FIRST_ASSUM(fn th => SIMP_TAC std_ss [MATCH_MP LINEAR_CMUL th]) THEN
  KNOW_TAC ``(abs x <> 0:real) /\ (abs a <> 0:real)`` THENL
    [UNDISCH_TAC ``a <> 0:real`` THEN UNDISCH_TAC ``x <> 0:real`` THEN
     REAL_ARITH_TAC, STRIP_TAC] THEN
  ASM_SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS, real_ge] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LE_RDIV_EQ, REAL_LE_LDIV_EQ, GSYM ABS_NZ] THEN
  SIMP_TAC std_ss [real_div, REAL_MUL_ASSOC] THEN REAL_ARITH_TAC);

val CLOSED_INJECTIVE_IMAGE_SUBSPACE = store_thm ("CLOSED_INJECTIVE_IMAGE_SUBSPACE",
 ``!f s. subspace s /\
         linear f /\
         (!x. x IN s /\ (f(x) = 0) ==> (x = 0)) /\
         closed s
         ==> closed(IMAGE f s)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM COMPLETE_EQ_CLOSED] THEN
  MATCH_MP_TAC COMPLETE_ISOMETRIC_IMAGE THEN
  ASM_SIMP_TAC std_ss [COMPLETE_EQ_CLOSED] THEN
  MATCH_MP_TAC INJECTIVE_IMP_ISOMETRIC THEN
  ASM_REWRITE_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Relating linear images to open/closed/interior/closure.                   *)
(* ------------------------------------------------------------------------- *)

val OPEN_SURJECTIVE_LINEAR_IMAGE = store_thm ("OPEN_SURJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!y. ?x. f x = y)
        ==> !s. open s ==> open(IMAGE f s)``,
  GEN_TAC THEN STRIP_TAC THEN
  SIMP_TAC std_ss [open_def, FORALL_IN_IMAGE] THEN
  FIRST_ASSUM(MP_TAC o GEN ``k:num`` o SPEC ``if (1 = k:num) then &1 else &0:real``) THEN
  SIMP_TAC std_ss [SKOLEM_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``b:num->real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``bounded(IMAGE (b:num->real) { 1n.. 1n})`` MP_TAC THENL
   [SIMP_TAC std_ss [FINITE_IMP_BOUNDED, IMAGE_FINITE, FINITE_NUMSEG], ALL_TAC] THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE, IN_NUMSEG] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
  X_GEN_TAC ``s:real->bool`` THEN DISCH_TAC THEN
  X_GEN_TAC ``x:real`` THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``e / B / &(1):real`` THEN
  ASM_SIMP_TAC real_ss [REAL_LT_DIV, REAL_LT, LE_1] THEN
  X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN REWRITE_TAC[IN_IMAGE] THEN
  ABBREV_TAC ``u = y - (f:real->real) x`` THEN
  EXISTS_TAC ``x + sum{1 .. 1} (\i. (u:real) * b i):real`` THEN
  ASM_SIMP_TAC std_ss [LINEAR_ADD, LINEAR_SUM, FINITE_NUMSEG, o_DEF,
               LINEAR_CMUL] THEN
  CONJ_TAC THENL [EXPAND_TAC "u" THEN SIMP_TAC std_ss [NUMSEG_SING, SUM_SING] THEN
                  REAL_ARITH_TAC, ALL_TAC] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN REWRITE_TAC [dist] THEN
  REWRITE_TAC[REAL_ARITH ``abs(x + y - x) = abs y:real``] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``(dist(y,(f:real->real) x) * &(1)) * B:real`` THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LT_RDIV_EQ, REAL_LT, LE_1] THEN
  MATCH_MP_TAC SUM_ABS_TRIANGLE THEN REWRITE_TAC[FINITE_NUMSEG] THEN
  EXPAND_TAC "u" THEN SIMP_TAC std_ss [NUMSEG_SING, SUM_SING] THEN
  REWRITE_TAC [ABS_MUL] THEN
  UNDISCH_TAC ``!x. 1 <= x /\ x <= 1 ==> abs ((b:num->real) x) <= B`` THEN
  DISCH_THEN (MP_TAC o SPEC ``1:num``) THEN ASM_SIMP_TAC real_ss [dist] THEN
  DISCH_TAC THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
  ASM_SIMP_TAC std_ss [ABS_POS]);

val OPEN_BIJECTIVE_LINEAR_IMAGE_EQ = store_thm ("OPEN_BIJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y)) /\ (!y. ?x. f x = y)
        ==> (open(IMAGE f s) <=> open s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_TAC, ASM_MESON_TAC[OPEN_SURJECTIVE_LINEAR_IMAGE]] THEN
  SUBGOAL_THEN ``s = {x | (f:real->real) x IN IMAGE f s}``
  SUBST1_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE_UNIV THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_AT]);

val CLOSED_INJECTIVE_LINEAR_IMAGE = store_thm ("CLOSED_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> !s. closed s ==> closed(IMAGE f s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_LEFT_INVERSE) THEN
  ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC CLOSED_IN_CLOSED_TRANS THEN
  EXISTS_TAC ``IMAGE (f:real->real) univ(:real)`` THEN
  CONJ_TAC THENL
   [MP_TAC(ISPECL [``g:real->real``, ``IMAGE (f:real->real) univ(:real)``,
                   ``IMAGE (g:real->real) (IMAGE (f:real->real) s)``]
        CONTINUOUS_CLOSED_IN_PREIMAGE) THEN
    ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_ON] THEN
    KNOW_TAC ``closed (IMAGE (g:real->real) (IMAGE (f:real->real) s))`` THENL
     [ASM_REWRITE_TAC[GSYM IMAGE_COMPOSE, IMAGE_ID],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [FUN_EQ_THM]) THEN
    SIMP_TAC std_ss [EXTENSION, o_THM, I_THM] THEN SET_TAC[],
    MATCH_MP_TAC CLOSED_INJECTIVE_IMAGE_SUBSPACE THEN
    ASM_REWRITE_TAC[IN_UNIV, SUBSPACE_UNIV, CLOSED_UNIV] THEN
    X_GEN_TAC ``x:real`` THEN
    DISCH_THEN(MP_TAC o AP_TERM ``g:real->real``) THEN
    RULE_ASSUM_TAC(SIMP_RULE std_ss [FUN_EQ_THM, I_THM, o_THM]) THEN
    ASM_MESON_TAC[LINEAR_0]]);

val CLOSED_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("CLOSED_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (closed(IMAGE f s) <=> closed s)``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [DISCH_TAC, ASM_MESON_TAC[CLOSED_INJECTIVE_LINEAR_IMAGE]] THEN
  SUBGOAL_THEN ``s = {x | (f:real->real) x IN IMAGE f s}``
  SUBST1_TAC THENL [ASM_SET_TAC [], ALL_TAC] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE_UNIV THEN
  ASM_SIMP_TAC std_ss [LINEAR_CONTINUOUS_AT]);

val CLOSURE_LINEAR_IMAGE_SUBSET = store_thm ("CLOSURE_LINEAR_IMAGE_SUBSET",
 ``!f:real->real s.
        linear f ==> IMAGE f (closure s) SUBSET closure(IMAGE f s)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC IMAGE_CLOSURE_SUBSET THEN
  ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, CLOSURE_SUBSET, LINEAR_CONTINUOUS_ON]);

val CLOSURE_INJECTIVE_LINEAR_IMAGE  = store_thm ("CLOSURE_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_SIMP_TAC std_ss [CLOSURE_LINEAR_IMAGE_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
  ASM_MESON_TAC[CLOSED_INJECTIVE_LINEAR_IMAGE, CLOSED_CLOSURE]);

val CLOSURE_BOUNDED_LINEAR_IMAGE = store_thm ("CLOSURE_BOUNDED_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ bounded s
        ==> (closure(IMAGE f s) = IMAGE f (closure s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUBSET_ANTISYM THEN
  ASM_SIMP_TAC std_ss [CLOSURE_LINEAR_IMAGE_SUBSET] THEN
  MATCH_MP_TAC CLOSURE_MINIMAL THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
  MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
  MATCH_MP_TAC COMPACT_LINEAR_IMAGE THEN
  ASM_REWRITE_TAC[COMPACT_CLOSURE]);

val LINEAR_INTERIOR_IMAGE_SUBSET = store_thm ("LINEAR_INTERIOR_IMAGE_SUBSET",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
       ==> interior(IMAGE f s) SUBSET IMAGE f (interior s)``,
  MESON_TAC[INTERIOR_IMAGE_SUBSET, LINEAR_CONTINUOUS_AT]);

val LINEAR_IMAGE_SUBSET_INTERIOR = store_thm ("LINEAR_IMAGE_SUBSET_INTERIOR",
 ``!f:real->real s.
        linear f /\ (!y. ?x. f x = y)
        ==> IMAGE f (interior s) SUBSET interior(IMAGE f s)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_MAXIMAL THEN
  ASM_SIMP_TAC std_ss [OPEN_SURJECTIVE_LINEAR_IMAGE, OPEN_INTERIOR,
               IMAGE_SUBSET, INTERIOR_SUBSET]);

val INTERIOR_BIJECTIVE_LINEAR_IMAGE = store_thm ("INTERIOR_BIJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y)) /\ (!y. ?x. f x = y)
        ==> (interior(IMAGE f s) = IMAGE f (interior s))``,
  ONCE_REWRITE_TAC [GSYM SURJECTIVE_IMAGE] THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC [interior] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_IMAGE] THEN
  GEN_TAC THEN EQ_TAC THEN REPEAT STRIP_TAC THENL
  [FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
   STRIP_TAC THEN UNDISCH_TAC ``(t:real->bool) SUBSET IMAGE (f:real->real) s`` THEN
   DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SIMP_RULE std_ss [SUBSET_DEF, IN_IMAGE]) THEN
   DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [] THEN STRIP_TAC THEN
   EXISTS_TAC ``x':real`` THEN ASM_REWRITE_TAC [] THEN EXISTS_TAC ``s':real->bool`` THEN
   REPEAT CONJ_TAC THENL
   [UNDISCH_TAC ``open t`` THEN MATCH_MP_TAC EQ_IMPLIES THEN
    EXPAND_TAC "t" THEN MATCH_MP_TAC OPEN_BIJECTIVE_LINEAR_IMAGE_EQ THEN
    METIS_TAC [SURJECTIVE_IMAGE],
    UNDISCH_TAC ``IMAGE (f:real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``(f:real->real) x'``) THEN SIMP_TAC std_ss [IN_IMAGE] THEN
    METIS_TAC [],
    REWRITE_TAC [SUBSET_DEF] THEN X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``IMAGE (f:real->real) s' = t`` THEN REWRITE_TAC [EXTENSION] THEN
    DISCH_THEN (MP_TAC o SPEC ``(f:real->real) y``) THEN REWRITE_TAC [IN_IMAGE] THEN
    KNOW_TAC ``(?x. (f y = (f:real->real) x) /\ x IN s')`` THENL
    [METIS_TAC [], ALL_TAC] THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_TAC THEN UNDISCH_TAC ``t SUBSET IMAGE (f:real->real) s`` THEN
    REWRITE_TAC [SUBSET_DEF] THEN DISCH_THEN (MP_TAC o SPEC ``(f:real->real) y``) THEN
    ASM_REWRITE_TAC [] THEN REWRITE_TAC [IN_IMAGE] THEN STRIP_TAC THEN
    METIS_TAC []], ALL_TAC] THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [GSPECIFICATION] THEN
  STRIP_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``t:real->bool``) THEN
  STRIP_TAC THEN EXISTS_TAC ``IMAGE (f:real->real) t`` THEN
  REPEAT CONJ_TAC THENL
  [UNDISCH_TAC ``open t`` THEN MATCH_MP_TAC OPEN_SURJECTIVE_LINEAR_IMAGE THEN
   METIS_TAC [SURJECTIVE_IMAGE],
   REWRITE_TAC [IN_IMAGE] THEN EXISTS_TAC ``x':real`` THEN
   ASM_REWRITE_TAC [],
   MATCH_MP_TAC IMAGE_SUBSET THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* Corollaries, reformulations and special cases for M = N.                  *)
(* ------------------------------------------------------------------------- *)

val IN_INTERIOR_LINEAR_IMAGE = store_thm ("IN_INTERIOR_LINEAR_IMAGE",
 ``!f:real->real g s x.
        linear f /\ linear g /\ (f o g = I) /\ x IN interior s
        ==> (f x) IN interior (IMAGE f s)``,
  SIMP_TAC std_ss [FUN_EQ_THM, o_THM, I_THM] THEN REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``]
    LINEAR_IMAGE_SUBSET_INTERIOR) THEN
  ASM_SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  ASM_MESON_TAC[]);

val LINEAR_OPEN_MAPPING = store_thm ("LINEAR_OPEN_MAPPING",
 ``!f:real->real g.
        linear f /\ linear g /\ (f o g = I)
        ==> !s. open s ==> open(IMAGE f s)``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [FUN_EQ_THM, o_THM, I_THM] THEN DISCH_TAC THEN
  MATCH_MP_TAC OPEN_SURJECTIVE_LINEAR_IMAGE THEN
  ASM_MESON_TAC[]);

val INTERIOR_INJECTIVE_LINEAR_IMAGE = store_thm ("INTERIOR_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (interior(IMAGE f s) = IMAGE f (interior s))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INTERIOR_BIJECTIVE_LINEAR_IMAGE THEN
  METIS_TAC[LINEAR_INJECTIVE_IMP_SURJECTIVE]);

val COMPLETE_INJECTIVE_LINEAR_IMAGE = store_thm ("COMPLETE_INJECTIVE_LINEAR_IMAGE",
 ``!f:real->real.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> !s. complete s ==> complete(IMAGE f s)``,
  REWRITE_TAC[COMPLETE_EQ_CLOSED, CLOSED_INJECTIVE_LINEAR_IMAGE]);

val COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("COMPLETE_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> (complete(IMAGE f s) <=> complete s)``,
  REWRITE_TAC[COMPLETE_EQ_CLOSED, CLOSED_INJECTIVE_LINEAR_IMAGE_EQ]);

val LIMPT_INJECTIVE_LINEAR_IMAGE_EQ = store_thm ("LIMPT_INJECTIVE_LINEAR_IMAGE_EQ",
 ``!f:real->real s.
        linear f /\ (!x y. (f x = f y) ==> (x = y))
        ==> ((f x) limit_point_of (IMAGE f s) <=> x limit_point_of s)``,
  SIMP_TAC std_ss [LIMPT_APPROACHABLE, EXISTS_IN_IMAGE] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THENL
   [MP_TAC(ISPEC ``f:real->real`` LINEAR_INJECTIVE_BOUNDED_BELOW_POS),
    MP_TAC(ISPEC ``f:real->real`` LINEAR_BOUNDED_POS)] THEN
  ASM_REWRITE_TAC [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THENL
   [UNDISCH_TAC ``!(e :real).
        (0 :real) < e ==>
        ?(x' :real).
          x' IN (s :real -> bool) /\
          (f :real -> real) x' <> f (x :real) /\
          (dist (f x',f x) :real) < e`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e * B:real``),
    UNDISCH_TAC ``!(e :real).
        (0 :real) < e ==>
        ?(x' :real).
          x' IN (s :real -> bool) /\ x' <> (x :real) /\
          (dist (x',x) :real) < e`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``e / B:real``)] THEN
  ASM_SIMP_TAC real_ss [REAL_LT_DIV, REAL_LT_MUL, dist, GSYM LINEAR_SUB] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN
  POP_ASSUM MP_TAC THEN
  REPEAT(MATCH_MP_TAC MONO_AND THEN
         CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC]) THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LT_LDIV_EQ, REAL_LT_RDIV_EQ] THEN
  MATCH_MP_TAC(REAL_ARITH ``a <= b ==> b < x ==> a < x:real``) THEN
  ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN ASM_SIMP_TAC real_ss [REAL_LE_RDIV_EQ]);

(* ------------------------------------------------------------------------- *)
(* Even more special cases.                                                  *)
(* ------------------------------------------------------------------------- *)

val INTERIOR_NEGATIONS = store_thm ("INTERIOR_NEGATIONS",
 ``!s. interior(IMAGE (\x. -x) s) = IMAGE (\x. -x) (interior s)``,
  GEN_TAC THEN MATCH_MP_TAC INTERIOR_INJECTIVE_LINEAR_IMAGE THEN
  SIMP_TAC std_ss [linear] THEN REPEAT CONJ_TAC THEN REAL_ARITH_TAC);

val SYMMETRIC_INTERIOR = store_thm ("SYMMETRIC_INTERIOR",
 ``!s:real->bool.
        (!x. x IN s ==> -x IN s)
        ==> !x. x IN interior s ==> (-x) IN interior s``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP(ISPEC ``(\x. -x):real->real`` FUN_IN_IMAGE)) THEN
  SIMP_TAC std_ss [GSYM INTERIOR_NEGATIONS] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE] THEN METIS_TAC[REAL_NEG_NEG]);

val CLOSURE_NEGATIONS = store_thm ("CLOSURE_NEGATIONS",
 ``!s. closure(IMAGE (\x. -x) s) = IMAGE (\x. -x) (closure s)``,
  GEN_TAC THEN MATCH_MP_TAC CLOSURE_INJECTIVE_LINEAR_IMAGE THEN
  SIMP_TAC std_ss [linear] THEN REPEAT CONJ_TAC THEN REAL_ARITH_TAC);

val SYMMETRIC_CLOSURE = store_thm ("SYMMETRIC_CLOSURE",
 ``!s:real->bool.
        (!x. x IN s ==> -x IN s)
        ==> !x. x IN closure s ==> (-x) IN closure s``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP(ISPEC ``(\x. -x):real->real`` FUN_IN_IMAGE)) THEN
  SIMP_TAC std_ss [GSYM CLOSURE_NEGATIONS] THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, IN_IMAGE] THEN ASM_MESON_TAC[REAL_NEG_NEG]);

(* ------------------------------------------------------------------------- *)
(* Some properties of a canonical subspace.                                  *)
(* ------------------------------------------------------------------------- *)

val SUBSPACE_SUBSTANDARD = store_thm ("SUBSPACE_SUBSTANDARD",
 ``subspace {x:real | (x = &0)}``,
  SIMP_TAC std_ss [subspace, GSPECIFICATION, REAL_MUL_RZERO, REAL_ADD_LID]);

val CLOSED_SUBSTANDARD = store_thm ("CLOSED_SUBSTANDARD",
 ``closed {x:real | x = &0}``,
  REWRITE_TAC [GSPEC_EQ, CLOSED_SING]);

Theorem DIM_SUBSTANDARD :
    dim {x:real | x = &0} = 0
Proof
  REWRITE_TAC [dim, GSPEC_EQ] THEN MATCH_MP_TAC SELECT_UNIQUE THEN
  RW_TAC std_ss [] THEN EQ_TAC THENL
  [ONCE_REWRITE_TAC [MONO_NOT_EQ] THEN RW_TAC std_ss [] THEN
   ASM_CASES_TAC ``~(b SUBSET {0:real})`` THEN
   ASM_REWRITE_TAC [] THEN FULL_SIMP_TAC std_ss [SET_RULE
    ``b SUBSET {0:real} <=> (b = {}) \/ (b = {0})``] THENL
   [DISJ2_TAC THEN DISJ2_TAC THEN SIMP_TAC std_ss' [HAS_SIZE] THEN
    DISJ2_TAC THEN REWRITE_TAC [CARD_EMPTY] THEN METIS_TAC [],
    REWRITE_TAC [INDEPENDENT_SING]], ALL_TAC] THEN
  DISCH_TAC THEN EXISTS_TAC ``{}:real->bool`` THEN
  ASM_SIMP_TAC std_ss [SPAN_EMPTY, SUBSET_REFL, EMPTY_SUBSET, INDEPENDENT_EMPTY] THEN
  ASM_REWRITE_TAC [HAS_SIZE_0]
QED

(* ------------------------------------------------------------------------- *)
(* Affine transformations of intervals.                                      *)
(* ------------------------------------------------------------------------- *)

val AFFINITY_INVERSES = store_thm ("AFFINITY_INVERSES",
 ``!m c. ~(m = &0:real)
         ==> ((\x. m * x + c) o (\x. inv(m) * x + (-(inv(m) * c))) = (\x. x)) /\
             ((\x. inv(m) * x + (-(inv(m) * c))) o (\x. m * x + c) = (\x. x))``,
  SIMP_TAC std_ss [FUN_EQ_THM, o_THM] THEN
  SIMP_TAC std_ss [REAL_ADD_LDISTRIB, REAL_MUL_RNEG] THEN
  SIMP_TAC std_ss [REAL_MUL_ASSOC, REAL_MUL_LINV, REAL_MUL_RINV] THEN
  REPEAT STRIP_TAC THEN REAL_ARITH_TAC);

val REAL_AFFINITY_LE = store_thm ("REAL_AFFINITY_LE",
 ``!m c x y. &0:real < m ==> ((m * x + c <= y) <=> (x <= inv(m) * y + -(c / m)))``,
  REWRITE_TAC[REAL_ARITH ``(m * x + c <= y:real) <=> (x * m <= y - c)``] THEN
  SIMP_TAC std_ss [GSYM REAL_LE_RDIV_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, REAL_SUB_RDISTRIB]);

val REAL_LE_AFFINITY = store_thm ("REAL_LE_AFFINITY",
 ``!m c x y. &0:real < m ==> ((y <= m * x + c) <=> (inv(m) * y + -(c / m) <= x))``,
  REWRITE_TAC[REAL_ARITH ``(y <= m * x + c:real) <=> (y - c <= x * m)``] THEN
  SIMP_TAC std_ss [GSYM REAL_LE_LDIV_EQ] THEN ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, REAL_SUB_RDISTRIB]);

val REAL_AFFINITY_LT = store_thm ("REAL_AFFINITY_LT",
 ``!m c x y. &0:real < m ==> (m * x + c < y <=> x < inv(m) * y + -(c / m))``,
  SIMP_TAC std_ss [REAL_LE_AFFINITY, GSYM REAL_NOT_LE]);

val REAL_LT_AFFINITY = store_thm ("REAL_LT_AFFINITY",
 ``!m c x y. &0:real < m ==> (y < m * x + c <=> inv(m) * y + -(c / m) < x)``,
  SIMP_TAC std_ss [REAL_AFFINITY_LE, GSYM REAL_NOT_LE]);

val REAL_AFFINITY_EQ = store_thm ("REAL_AFFINITY_EQ",
 ``!m c x y. ~(m = &0:real) ==> ((m * x + c = y) <=> (x = inv(m) * y + -(c / m)))``,
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, GSYM REAL_SUB_RDISTRIB] THEN
  REWRITE_TAC [GSYM REAL_EQ_SUB_LADD, GSYM real_div] THEN
  REPEAT STRIP_TAC THEN EQ_TAC THENL
  [GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN
   ASM_SIMP_TAC arith_ss [real_div, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_MUL_RID], DISCH_TAC THEN METIS_TAC [REAL_DIV_RMUL]]);

val REAL_EQ_AFFINITY = store_thm ("REAL_EQ_AFFINITY",
 ``!m c x y. ~(m = &0:real) ==> ((y = m * x + c)  <=> (inv(m) * y + -(c / m) = x))``,
  ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
  REWRITE_TAC [real_div, GSYM real_sub, GSYM REAL_SUB_RDISTRIB] THEN
  REPEAT STRIP_TAC THEN GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN
  REWRITE_TAC [GSYM REAL_EQ_SUB_LADD, GSYM real_div] THEN EQ_TAC THENL
  [GEN_REWR_TAC LAND_CONV [EQ_SYM_EQ] THEN DISCH_TAC THEN
   ASM_SIMP_TAC arith_ss [real_div, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_MUL_RID], DISCH_TAC THEN METIS_TAC [REAL_DIV_RMUL]]);

val IMAGE_AFFINITY_INTERVAL = store_thm ("IMAGE_AFFINITY_INTERVAL",
 ``!a b:real m c.
        IMAGE (\x. m * x + c) (interval[a,b]) =
            if interval[a,b] = {} then {}
            else if &0 <= m then interval[m * a + c,m * b + c]
            else interval[m * b + c,m * a + c]``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN ASM_REWRITE_TAC[IMAGE_EMPTY, IMAGE_INSERT] THEN
  ASM_CASES_TAC ``m = &0:real`` THEN ASM_REWRITE_TAC[REAL_LE_LT] THENL
   [ASM_REWRITE_TAC[REAL_MUL_LZERO, REAL_ADD_LID, COND_ID] THEN
    REWRITE_TAC[INTERVAL_SING] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  FIRST_ASSUM(DISJ_CASES_TAC o MATCH_MP (REAL_ARITH
   ``~(x = &0:real) ==> &0 < x \/ &0 < -x``)) THEN
  ASM_SIMP_TAC std_ss [EXTENSION, IN_IMAGE, REAL_ARITH ``&0 < -x ==> ~(&0 < x:real)``] THENL
   [ALL_TAC,
    ONCE_REWRITE_TAC[REAL_ARITH ``(x = m * y + c:real) <=> (c = (-m) * y + x)``]] THEN
  (ASM_SIMP_TAC std_ss [REAL_EQ_AFFINITY, REAL_LT_IMP_NE, UNWIND_THM1] THEN
  SIMP_TAC std_ss [IN_INTERVAL] THEN
  POP_ASSUM(MP_TAC o ONCE_REWRITE_RULE [GSYM REAL_LT_INV_EQ]) THEN
  SIMP_TAC std_ss [REAL_AFFINITY_LE, REAL_LE_AFFINITY, real_div] THEN
  DISCH_THEN(K ALL_TAC) THEN REWRITE_TAC[REAL_INV_INV] THEN
  REWRITE_TAC[REAL_MUL_LNEG, REAL_NEGNEG] THEN
  KNOW_TAC ``-m <> 0:real`` THENL [ASM_REAL_ARITH_TAC, DISCH_TAC] THEN
  ASM_SIMP_TAC std_ss [METIS [REAL_MUL_RID, GSYM REAL_MUL_ASSOC, REAL_MUL_RINV,
   REAL_ARITH ``b * inv a * a = b * a * inv a:real``]
   ``m <> 0:real ==> (x * inv m * m = x)``] THEN
  GEN_TAC THEN ONCE_REWRITE_TAC [REAL_ADD_SYM] THEN REWRITE_TAC [GSYM real_sub] THEN
  REAL_ARITH_TAC));

(* ------------------------------------------------------------------------- *)
(* Infinite sums of vectors. Allow general starting point (and more).        *)
(* ------------------------------------------------------------------------- *)

val _ = hide "sums";
val _ = hide "summable";

val _ = set_fixity "sums" (Infix(NONASSOC, 450));

Definition sums_def : (* cf. seqTheory.sums *)
   (f sums l) s = ((\n. sum (s INTER { 0n..n}) f) --> l) sequentially
End
val sums = sums_def;

Definition suminf_def : (* cf. seqTheory.suminf *)
    infsum s f = @l. (f sums l) s
End
val _ = overload_on ("suminf", ``infsum``);
val infsum = suminf_def;

Definition summable_def : (* cf. seqTheory.summable *)
    summable s f = ?l. (f sums l) s
End
val summable = summable_def;

val SUMS_SUMMABLE = store_thm ("SUMS_SUMMABLE",
 ``!f l s. (f sums l) s ==> summable s f``,
  REWRITE_TAC[summable] THEN MESON_TAC[]);

val SUMS_INFSUM = store_thm ("SUMS_INFSUM",
 ``!f s. (f sums (infsum s f)) s <=> summable s f``,
  REWRITE_TAC[infsum, summable] THEN METIS_TAC[]);

val SUMS_LIM = store_thm ("SUMS_LIM",
 ``!f:num->real s.
      (f sums lim sequentially (\n. sum (s INTER { 0n..n}) f)) s
      <=> summable s f``,
  GEN_TAC THEN GEN_TAC THEN EQ_TAC THENL [MESON_TAC[summable],
  REWRITE_TAC[summable, sums] THEN STRIP_TAC THEN REWRITE_TAC[reallim] THEN
  METIS_TAC[]]);

val FINITE_INTER_NUMSEG = store_thm ("FINITE_INTER_NUMSEG",
 ``!s m n. FINITE(s INTER {m..n})``,
  MESON_TAC[SUBSET_FINITE_I, FINITE_NUMSEG, INTER_SUBSET]);

val SERIES_FROM = store_thm ("SERIES_FROM",
 ``!f l k. (f sums l) (from k) = ((\n. sum{k..n} f) --> l) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, numseg, from_def, GSPECIFICATION, IN_INTER] THEN ARITH_TAC);

val SERIES_UNIQUE = store_thm ("SERIES_UNIQUE",
 ``!f:num->real l l' s. (f sums l) s /\ (f sums l') s ==> (l = l')``,
  REWRITE_TAC[sums] THEN MESON_TAC[TRIVIAL_LIMIT_SEQUENTIALLY, LIM_UNIQUE]);

val INFSUM_UNIQUE = store_thm ("INFSUM_UNIQUE",
 ``!f:num->real l s. (f sums l) s ==> (infsum s f = l)``,
  MESON_TAC[SERIES_UNIQUE, SUMS_INFSUM, summable]);

val SERIES_TERMS_TOZERO = store_thm ("SERIES_TERMS_TOZERO",
 ``!f l n. (f sums l) (from n) ==> (f --> 0) sequentially``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [sums, LIM_SEQUENTIALLY, FROM_INTER_NUMSEG] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
  EXISTS_TAC ``N + n + 1:num`` THEN X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``m - 1:num`` th) THEN MP_TAC(SPEC ``m:num`` th)) THEN
  SUBGOAL_THEN ``0 < m:num /\ n <= m`` (fn th => SIMP_TAC std_ss [SUM_CLAUSES_RIGHT, th])
  THENL [CONJ_TAC THENL
   [MATCH_MP_TAC LESS_LESS_EQ_TRANS THEN EXISTS_TAC ``N + n + 1:num`` THEN
    ASM_REWRITE_TAC [] THEN ARITH_TAC,
    MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``N + n + 1:num`` THEN
    ASM_REWRITE_TAC [] THEN ARITH_TAC], ALL_TAC] THEN
  KNOW_TAC ``N <= m:num`` THENL [MATCH_MP_TAC LESS_EQ_TRANS THEN
   EXISTS_TAC ``N + n + 1:num`` THEN ASM_REWRITE_TAC [] THEN ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  KNOW_TAC ``N <= m:num - 1`` THENL [MATCH_MP_TAC LESS_EQ_TRANS THEN
   EXISTS_TAC ``N + n:num`` THEN CONJ_TAC THENL [ARITH_TAC, ALL_TAC] THEN
   ONCE_REWRITE_TAC [ARITH_PROVE ``(a <= b) = (a + 1 <= b + 1:num)``] THEN
   MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``m:num`` THEN
   ASM_REWRITE_TAC [] THEN ARITH_TAC,
  DISCH_TAC THEN ASM_REWRITE_TAC [] THEN DISCH_TAC] THEN
  REWRITE_TAC [DIST_0] THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  FULL_SIMP_TAC std_ss [dist] THEN ASM_REAL_ARITH_TAC);

val SERIES_FINITE = store_thm ("SERIES_FINITE",
 ``!f s. FINITE s ==> (f sums (sum s f)) s``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [num_FINITE, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``n:num`` THEN SIMP_TAC std_ss [sums, LIM_SEQUENTIALLY] THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN EXISTS_TAC ``n:num`` THEN
  X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``s INTER { 0n..m} = s``
   (fn th => ASM_REWRITE_TAC[th, DIST_REFL]) THEN
  SIMP_TAC std_ss [EXTENSION, IN_INTER, IN_NUMSEG, ZERO_LESS_EQ] THEN
  METIS_TAC[LESS_EQ_TRANS]);

val SERIES_LINEAR = store_thm ("SERIES_LINEAR",
 ``!f h l s. (f sums l) s /\ linear h ==> ((\n. h(f n)) sums h l) s``,
  SIMP_TAC std_ss [sums, LIM_LINEAR, FINITE_INTER, FINITE_NUMSEG,
           GSYM(REWRITE_RULE[o_DEF] LINEAR_SUM)]);

val SERIES_0 = store_thm ("SERIES_0",
 ``!s. ((\n. 0) sums (0)) s``,
  REWRITE_TAC[sums, SUM_0', LIM_CONST]);

val SERIES_ADD = store_thm ("SERIES_ADD",
 ``!x x0 y y0 s.
     (x sums x0) s /\ (y sums y0) s ==> ((\n. x n + y n) sums (x0 + y0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_ADD', LIM_ADD]);

val SERIES_SUB = store_thm ("SERIES_SUB",
 ``!x x0 y y0 s.
     (x sums x0) s /\ (y sums y0) s ==> ((\n. x n - y n) sums (x0 - y0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_SUB', LIM_SUB]);

val SERIES_CMUL = store_thm ("SERIES_CMUL",
 ``!x x0 c s. (x sums x0) s ==> ((\n. c * x n) sums (c * x0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_LMUL, LIM_CMUL]);

val SERIES_NEG = store_thm ("SERIES_NEG",
 ``!x x0 s. (x sums x0) s ==> ((\n. -(x n)) sums (-x0)) s``,
  SIMP_TAC std_ss [sums, FINITE_INTER_NUMSEG, SUM_NEG', LIM_NEG]);

val SUMS_IFF = store_thm ("SUMS_IFF",
 ``!f g k. (!x. x IN k ==> (f x = g x)) ==> ((f sums l) k <=> (g sums l) k)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  MATCH_MP_TAC SUM_EQ THEN ASM_SIMP_TAC std_ss [IN_INTER]);

val SUMS_EQ = store_thm ("SUMS_EQ",
 ``!f g k. (!x. x IN k ==> (f x = g x)) /\ (f sums l) k ==> (g sums l) k``,
  MESON_TAC[SUMS_IFF]);

val SUMS_0 = store_thm ("SUMS_0",
 ``!f:num->real s. (!n. n IN s ==> (f n = 0)) ==> (f sums 0) s``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMS_EQ THEN
  EXISTS_TAC ``\n:num. 0:real`` THEN ASM_SIMP_TAC std_ss [SERIES_0]);

val SERIES_FINITE_SUPPORT = store_thm ("SERIES_FINITE_SUPPORT",
 ``!f:num->real s k.
     FINITE (s INTER k) /\ (!x. x IN k /\ ~(x IN s) ==> (f x = 0))
     ==> (f sums sum (s INTER k) f) k``,
  REWRITE_TAC[sums, LIM_SEQUENTIALLY] THEN REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``\x:num. x`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN
  EXISTS_TAC ``N:num`` THEN POP_ASSUM MP_TAC THEN
  STRIP_TAC THEN X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``sum (k INTER { 0n..n}) (f:num->real) = sum(s INTER k) f``
   (fn th => ASM_SIMP_TAC std_ss [DIST_REFL, th]) THEN
  MATCH_MP_TAC SUM_SUPERSET THEN
  ASM_SIMP_TAC std_ss [SUBSET_DEF, IN_INTER, IN_NUMSEG, ZERO_LESS_EQ] THEN
  METIS_TAC[IN_INTER, LESS_EQ_TRANS]);

val SERIES_COMPONENT = store_thm ("SERIES_COMPONENT",
 ``!f s l:real. (f sums l) s
          ==> ((\i. f(i)) sums l) s``,
  METIS_TAC []);

val SERIES_DIFFS = store_thm ("SERIES_DIFFS",
 ``!f:num->real k. (f --> 0) sequentially
        ==> ((\n. f(n) - f(n + 1)) sums f(k)) (from k)``,
  REWRITE_TAC[sums, FROM_INTER_NUMSEG, SUM_DIFFS'] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LIM_TRANSFORM_EVENTUALLY THEN
  EXISTS_TAC ``\n. (f:num->real) k - f(n + 1)`` THEN CONJ_TAC THENL
   [REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC ``k:num`` THEN
    SIMP_TAC std_ss [],
    GEN_REWR_TAC LAND_CONV [GSYM REAL_SUB_RZERO] THEN
    KNOW_TAC ``((\n. (\n. f k) n - (\n. f (n + 1)) n)
                   --> ((f:num->real) k - 0)) sequentially`` THENL
    [ALL_TAC, SIMP_TAC std_ss []] THEN
    MATCH_MP_TAC LIM_SUB THEN REWRITE_TAC[LIM_CONST] THEN
    MATCH_MP_TAC SEQ_OFFSET THEN ASM_REWRITE_TAC[]]);

val SERIES_TRIVIAL = store_thm ("SERIES_TRIVIAL",
 ``!f. (f sums 0) {}``,
  SIMP_TAC std_ss [sums, INTER_EMPTY, SUM_CLAUSES, LIM_CONST]);

val SERIES_RESTRICT = store_thm ("SERIES_RESTRICT",
 ``!f k l:real.
        ((\n. if n IN k then f(n) else 0) sums l) univ(:num) <=>
        (f sums l) k``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM, INTER_UNIV] THEN GEN_TAC THEN
  SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC(METIS [] ``(sum s f = sum t f) /\ (sum t f = sum t g)
                        ==> (sum s f = sum t g)``) THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC SUM_SUPERSET THEN SET_TAC[],
    MATCH_MP_TAC SUM_EQ THEN SIMP_TAC std_ss [IN_INTER]]);

val SERIES_SUM = store_thm ("SERIES_SUM",
 ``!f l k s. FINITE s /\ s SUBSET k /\ (!x. ~(x IN s) ==> (f x = 0)) /\
             (sum s f = l) ==> (f sums l) k``,
  REPEAT STRIP_TAC THEN EXPAND_TAC "l" THEN
  SUBGOAL_THEN ``s INTER k = s:num->bool`` ASSUME_TAC THENL
   [ASM_SET_TAC [], ASM_MESON_TAC [SERIES_FINITE_SUPPORT]]);

val SUMS_REINDEX = store_thm ("SUMS_REINDEX",
 ``!k a l:real n.
   ((\x. a(x + k)) sums l) (from n) <=> (a sums l) (from(n + k))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums, FROM_INTER_NUMSEG] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM SUM_OFFSET'] THEN
  REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  ASM_MESON_TAC[ARITH_PROVE ``N + k:num <= n ==> (n = (n - k) + k) /\ N <= n - k``,
                ARITH_PROVE ``N + k:num <= n ==> N <= n + k``]);

val SUMS_REINDEX_GEN = store_thm ("SUMS_REINDEX_GEN",
 ``!k a l:real s.
     ((\x. a(x + k)) sums l) s <=> (a sums l) (IMAGE (\i. i + k) s)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  MP_TAC(ISPECL
   [``k:num``,
    ``\i. if i IN IMAGE (\i. i + k) s then (a:num->real) i else 0``,
    ``l:real``, ``0:num``] SUMS_REINDEX) THEN
  REWRITE_TAC[FROM_0] THEN
  SIMP_TAC std_ss [EQ_ADD_RCANCEL, SET_RULE
   ``(!x y:num. (x + k = y + k) <=> (x = y))
         ==> ((x + k) IN IMAGE (\i. i + k) s <=> x IN s)``] THEN
  DISCH_THEN SUBST1_TAC THEN
  GEN_REWR_TAC LAND_CONV [GSYM SERIES_RESTRICT] THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM, IN_FROM, ADD_CLAUSES] THEN
  SUBGOAL_THEN ``!x:num. x IN IMAGE (\i. i + k) s ==> k <= x`` MP_TAC THENL
   [SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN ARITH_TAC, SET_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Similar combining theorems just for summability.                          *)
(* ------------------------------------------------------------------------- *)

val SUMMABLE_LINEAR = store_thm ("SUMMABLE_LINEAR",
 ``!f h s. summable s f /\ linear h ==> summable s (\n. h(f n))``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_LINEAR]);

val SUMMABLE_0 = store_thm ("SUMMABLE_0",
 ``!s. summable s (\n. 0)``,
  REWRITE_TAC[summable] THEN MESON_TAC[SERIES_0]);

val SUMMABLE_ADD = store_thm ("SUMMABLE_ADD",
 ``!x y s. summable s x /\ summable s y ==> summable s (\n. x n + y n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_ADD]);

val SUMMABLE_SUB = store_thm ("SUMMABLE_SUB",
 ``!x y s. summable s x /\ summable s y ==> summable s (\n. x n - y n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_SUB]);

val SUMMABLE_CMUL = store_thm ("SUMMABLE_CMUL",
 ``!s x c. summable s x ==> summable s (\n. c * x n)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_CMUL]);

val SUMMABLE_NEG = store_thm ("SUMMABLE_NEG",
 ``!x s. summable s x ==> summable s (\n. -(x n))``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_NEG]);

val SUMMABLE_IFF = store_thm ("SUMMABLE_IFF",
 ``!f g k. (!x. x IN k ==> (f x = g x)) ==> (summable k f <=> summable k g)``,
  REWRITE_TAC[summable] THEN METIS_TAC[SUMS_IFF]);

val SUMMABLE_EQ = store_thm ("SUMMABLE_EQ",
 ``!f g k. (!x. x IN k ==> (f x = g x)) /\ summable k f ==> summable k g``,
  REWRITE_TAC[summable] THEN METIS_TAC[SUMS_EQ]);

val SUMMABLE_COMPONENT = store_thm ("SUMMABLE_COMPONENT",
 ``!f:num->real s.
        summable s f ==> summable s (\i. f(i))``,
  METIS_TAC []);

val SERIES_SUBSET = store_thm ("SERIES_SUBSET",
 ``!x s t l.
        s SUBSET t /\
        ((\i. if i IN s then x i else 0) sums l) t
        ==> (x sums l) s``,
  REPEAT GEN_TAC THEN DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
  REWRITE_TAC[sums] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN ABS_TAC THEN
  ASM_SIMP_TAC std_ss [GSYM SUM_RESTRICT_SET, FINITE_INTER_NUMSEG] THEN
  AP_THM_TAC THEN AP_TERM_TAC THEN POP_ASSUM MP_TAC THEN SET_TAC[]);

val SUMMABLE_SUBSET = store_thm ("SUMMABLE_SUBSET",
 ``!x s t.
        s SUBSET t /\
        summable t (\i. if i IN s then x i else 0)
        ==> summable s x``,
  REWRITE_TAC[summable] THEN METIS_TAC[SERIES_SUBSET]);

val SUMMABLE_TRIVIAL = store_thm ("SUMMABLE_TRIVIAL",
 ``!f:num->real. summable {} f``,
  GEN_TAC THEN REWRITE_TAC[summable] THEN EXISTS_TAC ``0:real`` THEN
  REWRITE_TAC[SERIES_TRIVIAL]);

val SUMMABLE_RESTRICT = store_thm ("SUMMABLE_RESTRICT",
 ``!f:num->real k.
        summable univ(:num) (\n. if n IN k then f(n) else 0) <=>
        summable k f``,
  SIMP_TAC std_ss [summable, SERIES_RESTRICT]);

val SUMS_FINITE_DIFF = store_thm ("SUMS_FINITE_DIFF",
 ``!f:num->real t s l.
        t SUBSET s /\ FINITE t /\ (f sums l) s
        ==> (f sums (l - sum t f)) (s DIFF t)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``f:num->real`` o MATCH_MP SERIES_FINITE) THEN
  ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  DISCH_THEN(MP_TAC o MATCH_MP SERIES_SUB) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``x:num`` THEN REWRITE_TAC[IN_DIFF] THEN
  UNDISCH_TAC ``t SUBSET s:num->bool`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``x:num`` o REWRITE_RULE [SUBSET_DEF]) THEN
  MAP_EVERY ASM_CASES_TAC [``(x:num) IN s``, ``(x:num) IN t``] THEN
  ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC);

val SUMS_FINITE_UNION = store_thm ("SUMS_FINITE_UNION",
 ``!f:num->real s t l.
        FINITE t /\ (f sums l) s
        ==> (f sums (l + sum (t DIFF s) f)) (s UNION t)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``s:num->bool`` o MATCH_MP FINITE_DIFF) THEN
  DISCH_THEN(MP_TAC o ISPEC ``f:num->real`` o MATCH_MP SERIES_FINITE) THEN
  ONCE_REWRITE_TAC[GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[AND_IMP_INTRO] THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
  DISCH_THEN(MP_TAC o MATCH_MP SERIES_ADD) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC THEN
  REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``x:num`` THEN
  REWRITE_TAC[IN_DIFF, IN_UNION] THEN
  MAP_EVERY ASM_CASES_TAC [``(x:num) IN s``, ``(x:num) IN t``] THEN
  ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC);

val SUMS_OFFSET = store_thm ("SUMS_OFFSET",
 ``!f l:real m n.
           (f sums l) (from m) /\ 0 < n /\ m <= n
           ==> (f sums l - sum {m..n - 1} f) (from n)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``from n = from m DIFF {m..n-1}`` SUBST1_TAC THENL
   [SIMP_TAC std_ss [EXTENSION, IN_FROM, IN_DIFF, IN_NUMSEG] THEN
    GEN_TAC THEN EQ_TAC THENL [DISCH_TAC THEN CONJ_TAC THENL
     [MATCH_MP_TAC LESS_EQ_TRANS THEN EXISTS_TAC ``n:num`` THEN ASM_REWRITE_TAC [],
      REWRITE_TAC [NOT_LESS_EQUAL] THEN DISJ2_TAC THEN
      MATCH_MP_TAC LESS_LESS_EQ_TRANS THEN EXISTS_TAC ``n:num`` THEN ASM_REWRITE_TAC [] THEN
      MATCH_MP_TAC SUB_LESS THEN CONJ_TAC THENL [ARITH_TAC , ALL_TAC] THEN
      REWRITE_TAC [ONE] THEN ASM_REWRITE_TAC [GSYM LESS_EQ]], ARITH_TAC],
    MATCH_MP_TAC SUMS_FINITE_DIFF THEN ASM_REWRITE_TAC[FINITE_NUMSEG] THEN
    SIMP_TAC std_ss [SUBSET_DEF, IN_FROM, IN_NUMSEG]]);

val SUMS_OFFSET_REV = store_thm ("SUMS_OFFSET_REV",
 ``!f:num->real l m n.
        (f sums l) (from m) /\ 0 < m /\ n <= m
        ==> (f sums (l + sum{n..m-1} f)) (from n)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``from m``, ``{n..m-1}``, ``l:real``]
                SUMS_FINITE_UNION) THEN
  ASM_REWRITE_TAC[FINITE_NUMSEG] THEN MATCH_MP_TAC EQ_IMPLIES THEN
  BINOP_TAC THENL [AP_TERM_TAC THEN AP_THM_TAC THEN AP_TERM_TAC, ALL_TAC] THEN
  REWRITE_TAC[EXTENSION, IN_DIFF, IN_UNION, IN_FROM, IN_NUMSEG] THEN
  ASM_SIMP_TAC arith_ss []);

val SUMMABLE_REINDEX = store_thm ("SUMMABLE_REINDEX",
 ``!k a n. summable (from n) (\x. a (x + k)) <=> summable (from(n + k)) a``,
  REWRITE_TAC[summable, GSYM SUMS_REINDEX]);

val SERIES_DROP_LE = store_thm ("SERIES_DROP_LE",
 ``!f g s a b.
        (f sums a) s /\ (g sums b) s /\
        (!x. x IN s ==> (f x <= g x))
        ==> a <= b``,
  REWRITE_TAC[sums] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_DROP_LE) THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  EXISTS_TAC ``\n. sum (s INTER { 0n..n}) (f:num->real)`` THEN
  EXISTS_TAC ``\n. sum (s INTER { 0n..n}) (g:num->real)`` THEN
  ASM_REWRITE_TAC[] THEN EXISTS_TAC ``0:num`` THEN REPEAT STRIP_TAC THEN
  SIMP_TAC std_ss [] THEN MATCH_MP_TAC SUM_LE THEN
  ASM_SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG, IN_INTER, IN_NUMSEG]);

val SERIES_DROP_POS = store_thm ("SERIES_DROP_POS",
 ``!f s a.
        (f sums a) s /\ (!x. x IN s ==> &0 <= f x)
        ==> &0 <= a``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``(\n. 0):num->real``, ``f:num->real``, ``s:num->bool``,
                 ``0:real``, ``a:real``] SERIES_DROP_LE) THEN
  ASM_SIMP_TAC std_ss [SUMS_0]);

val SERIES_BOUND = store_thm ("SERIES_BOUND",
 ``!f:num->real g s a b.
        (f sums a) s /\ (g sums b) s /\
        (!i. i IN s ==> abs(f i) <= g i)
        ==> abs (a) <= b``,
  REWRITE_TAC[sums] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC(ISPEC ``sequentially`` LIM_ABS_UBOUND) THEN
  EXISTS_TAC ``\n. sum (s INTER { 0n..n}) (f:num->real)`` THEN
  ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN
  REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN EXISTS_TAC ``0:num`` THEN
  X_GEN_TAC ``m:num`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``sum (s INTER { 0n..m}) g`` THEN CONJ_TAC THEN
  ASM_SIMP_TAC std_ss [SUM_ABS_LE, IN_INTER, FINITE_NUMSEG, FINITE_INTER] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[GSYM sums]) THEN
  UNDISCH_TAC ``(g sums b) s`` THEN
  GEN_REWR_TAC LAND_CONV [GSYM SERIES_RESTRICT] THEN
  REWRITE_TAC[GSYM FROM_0] THEN DISCH_THEN(MP_TAC o SPEC ``m + 1:num`` o MATCH_MP
   (ONCE_REWRITE_RULE[CONJ_EQ_IMP] SUMS_OFFSET)) THEN
  KNOW_TAC ``0 < m + 1 /\ 0 <= m + 1:num`` THENL
  [ASM_SIMP_TAC arith_ss [], DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  REWRITE_TAC[ARITH_PROVE ``0 < m + 1:num``, o_DEF, ADD_SUB] THEN
  SIMP_TAC std_ss [GSYM SUM_RESTRICT_SET] THEN
  SIMP_TAC std_ss [ETA_AX] THEN
  DISCH_THEN(MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP] SERIES_DROP_POS)) THEN
  REWRITE_TAC[ONCE_REWRITE_RULE[INTER_COMM] (GSYM INTER_DEF),
              REAL_SUB_LE] THEN
  DISCH_THEN MATCH_MP_TAC THEN REPEAT STRIP_TAC THEN SIMP_TAC std_ss [] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [REAL_LE_REFL] THEN
  ASM_MESON_TAC[REAL_ARITH ``abs(x:real) <= y ==> &0 <= y``]);

(* ------------------------------------------------------------------------- *)
(* Similar combining theorems for infsum.                                    *)
(* ------------------------------------------------------------------------- *)

val INFSUM_LINEAR = store_thm ("INFSUM_LINEAR",
 ``!f h s. summable s f /\ linear h
           ==> (infsum s (\n. h(f n)) = h(infsum s f))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_LINEAR THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_0 = store_thm ("INFSUM_0",
 ``infsum s (\i. 0) = 0``,
  MATCH_MP_TAC INFSUM_UNIQUE THEN REWRITE_TAC[SERIES_0]);

val INFSUM_ADD = store_thm ("INFSUM_ADD",
 ``!x y s. summable s x /\ summable s y
           ==> (infsum s (\i. x i + y i) = infsum s x + infsum s y)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_ADD THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_SUB = store_thm ("INFSUM_SUB",
 ``!x y s. summable s x /\ summable s y
           ==> (infsum s (\i. x i - y i) = infsum s x - infsum s y)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_SUB THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_CMUL = store_thm ("INFSUM_CMUL",
 ``!s x c. summable s x ==> (infsum s (\n. c * x n) = c * infsum s x)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_CMUL THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_NEG = store_thm ("INFSUM_NEG",
 ``!s x. summable s x ==> (infsum s (\n. -(x n)) = -(infsum s x))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC INFSUM_UNIQUE THEN
  MATCH_MP_TAC SERIES_NEG THEN ASM_REWRITE_TAC[SUMS_INFSUM]);

val INFSUM_EQ = store_thm ("INFSUM_EQ",
 ``!f g k. summable k f /\ summable k g /\ (!x. x IN k ==> (f x = g x))
           ==> (infsum k f = infsum k g)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[infsum] THEN
  AP_TERM_TAC THEN ABS_TAC THEN ASM_MESON_TAC[SUMS_EQ, SUMS_INFSUM]);

val INFSUM_RESTRICT = store_thm ("INFSUM_RESTRICT",
 ``!k a:num->real.
        infsum univ(:num) (\n. if n IN k then a n else 0) = infsum k a``,
  REPEAT GEN_TAC THEN
  MP_TAC(ISPECL [``a:num->real``, ``k:num->bool``] SUMMABLE_RESTRICT) THEN
  ASM_CASES_TAC ``summable k (a:num->real)`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THENL
   [MATCH_MP_TAC INFSUM_UNIQUE THEN
    ASM_REWRITE_TAC[SERIES_RESTRICT, SUMS_INFSUM],
    FULL_SIMP_TAC std_ss [summable, NOT_EXISTS_THM] THEN
    ASM_REWRITE_TAC[infsum]]);

val PARTIAL_SUMS_COMPONENT_LE_INFSUM = store_thm ("PARTIAL_SUMS_COMPONENT_LE_INFSUM",
 ``!f:num->real s n.
        (!i. i IN s ==> &0 <= f i) /\ summable s f
        ==> (sum (s INTER { 0n..n}) f) <= (infsum s f)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[GSYM SUMS_INFSUM] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[sums, LIM_SEQUENTIALLY] THEN DISCH_TAC THEN
  REWRITE_TAC[GSYM REAL_NOT_LT] THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC
   ``sum (s INTER { 0n..n}) (f:num->real) - (infsum s f)``) THEN
  ASM_REWRITE_TAC[REAL_SUB_LT] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` (MP_TAC o SPEC ``N + n:num``)) THEN
  REWRITE_TAC[LE_ADD, REAL_NOT_LT, dist] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``abs((sum (s INTER { 0n..N + n}) f - infsum s f:real))`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_REFL] THEN
  MATCH_MP_TAC(REAL_ARITH ``s < a /\ a <= b ==> a - s <= abs(b - s:real)``) THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[ADD_SYM] THEN
  KNOW_TAC ``sum (s INTER { 0n..n}) f <=
              sum (s INTER { 0n..n} UNION s INTER {n +  1n..n + N}) f`` THENL
  [ALL_TAC, SIMP_TAC std_ss [GSYM NUMSEG_ADD_SPLIT, ZERO_LESS_EQ, GSYM UNION_OVER_INTER]] THEN
  KNOW_TAC ``(sum (s INTER { 0n..n} UNION s INTER {n +  1n..n + N}) f =
              sum (s INTER { 0n..n}) f + sum (s INTER {n +  1n..n + N}) f)`` THENL
  [MATCH_MP_TAC SUM_UNION THEN
   SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG, DISJOINT_DEF, EXTENSION] THEN
   SIMP_TAC arith_ss [IN_INTER, NOT_IN_EMPTY, IN_NUMSEG] THEN CCONTR_TAC THEN
   FULL_SIMP_TAC arith_ss [], ALL_TAC] THEN
  DISCH_THEN SUBST1_TAC THEN
  REWRITE_TAC[REAL_LE_ADDR] THEN
  ASM_SIMP_TAC std_ss [] THEN MATCH_MP_TAC SUM_POS_LE THEN
  ASM_SIMP_TAC std_ss [FINITE_INTER, IN_INTER, FINITE_NUMSEG]);

val PARTIAL_SUMS_DROP_LE_INFSUM = store_thm ("PARTIAL_SUMS_DROP_LE_INFSUM",
 ``!f s n.
        (!i. i IN s ==> &0 <= f i) /\
        summable s f
        ==> sum (s INTER { 0n..n}) f <= (infsum s f)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC PARTIAL_SUMS_COMPONENT_LE_INFSUM THEN
  ASM_REWRITE_TAC[LESS_EQ_REFL]);

(* ------------------------------------------------------------------------- *)
(* Cauchy criterion for series.                                              *)
(* ------------------------------------------------------------------------- *)

val SEQUENCE_CAUCHY_WLOG = store_thm ("SEQUENCE_CAUCHY_WLOG",
 ``!P s. (!m n:num. P m /\ P n ==> dist(s m,s n) < e) <=>
         (!m n. P m /\ P n /\ m <= n ==> dist(s m,s n) < e)``,
  MESON_TAC[DIST_SYM, LE_CASES]);

val SUM_DIFF_LEMMA = store_thm ("SUM_DIFF_LEMMA",
 ``!f:num->real k m n.
        m <= n
        ==> (sum (k INTER {0 .. n}) f - sum (k INTER { 0n..m}) f =
             sum (k INTER {m+1 .. n}) f)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``k INTER { 0n..n}``, ``k INTER { 0n..m}``]
    SUM_DIFF') THEN
  KNOW_TAC ``FINITE (k INTER { 0n .. n}) /\
             k INTER { 0n .. m} SUBSET k INTER { 0n .. n}`` THENL
   [SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN MATCH_MP_TAC
     (SET_RULE ``s SUBSET t ==> (u INTER s SUBSET u INTER t)``) THEN
    REWRITE_TAC[SUBSET_DEF, IN_NUMSEG] THEN POP_ASSUM MP_TAC THEN ARITH_TAC,
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(SUBST1_TAC o SYM) THEN AP_THM_TAC THEN AP_TERM_TAC THEN
    REWRITE_TAC[SET_RULE
     ``(k INTER s) DIFF (k INTER t) = k INTER (s DIFF t)``] THEN
    AP_TERM_TAC THEN REWRITE_TAC[EXTENSION, IN_DIFF, IN_NUMSEG] THEN
    POP_ASSUM MP_TAC THEN ARITH_TAC]);

val ABS_SUM_TRIVIAL_LEMMA = store_thm ("ABS_SUM_TRIVIAL_LEMMA",
 ``!e:real. &0 < e ==> (P ==> abs(sum(s INTER {m..n}) f) < e <=>
                        P ==> n < m \/ abs(sum(s INTER {m..n}) f) < e)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``n:num < m`` THEN ASM_REWRITE_TAC[] THEN
  FIRST_X_ASSUM(SUBST1_TAC o REWRITE_RULE [GSYM NUMSEG_EMPTY]) THEN
  ASM_REWRITE_TAC[SUM_CLAUSES, ABS_0, INTER_EMPTY]);

val SERIES_CAUCHY = store_thm ("SERIES_CAUCHY",
 ``!f s. (?l. (f sums l) s) =
         !e. &0 < e
             ==> ?N. !m n. m >= N
                           ==> abs(sum(s INTER {m..n}) f) < e``,
  REPEAT GEN_TAC THEN REWRITE_TAC[sums, CONVERGENT_EQ_CAUCHY, cauchy] THEN
  SIMP_TAC std_ss [SEQUENCE_CAUCHY_WLOG] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  SIMP_TAC std_ss [dist, SUM_DIFF_LEMMA, ABS_SUM_TRIVIAL_LEMMA] THEN
  REWRITE_TAC[GE, TAUT `a ==> b \/ c <=> a /\ ~b ==> c`] THEN
  REWRITE_TAC[NOT_LESS, ARITH_PROVE
   ``(N:num <= m /\ N <= n /\ m <= n) /\ m + 1 <= n <=>
    N + 1 <= m + 1 /\ m + 1 <= n``] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THENL
   [EXISTS_TAC ``N + 1:num``, EXISTS_TAC ``N:num``] THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= m + 1 ==> N <= m + 1:num``] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``m - 1:num``, ``n:num``]) THEN
  SUBGOAL_THEN ``m - 1 + 1 = m:num`` SUBST_ALL_TAC THENL
   [ALL_TAC,
    KNOW_TAC ``N <= m - 1 /\ m <= n:num`` THENL
    [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []]] THEN
  ASM_ARITH_TAC);

val SUMMABLE_CAUCHY = store_thm ("SUMMABLE_CAUCHY",
 ``!f s. summable s f <=>
         !e. &0 < e
             ==> ?N. !m n. m >= N ==> abs(sum(s INTER {m..n}) f) < e``,
  REWRITE_TAC[summable, GSYM SERIES_CAUCHY]);

val SUMMABLE_IFF_EVENTUALLY = store_thm ("SUMMABLE_IFF_EVENTUALLY",
 ``!f g k. (?N. !n. N <= n /\ n IN k ==> (f n = g n))
           ==> (summable k f <=> summable k g)``,
  REWRITE_TAC[summable, SERIES_CAUCHY] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``N0:num`` STRIP_ASSUME_TAC) THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  BETA_TAC THEN AP_TERM_TAC THEN EQ_TAC THEN
  DISCH_THEN(X_CHOOSE_THEN ``N1:num``
   (fn th => EXISTS_TAC ``N0 + N1:num`` THEN MP_TAC th)) THEN
  DISCH_TAC THEN GEN_TAC THEN GEN_TAC THEN
  POP_ASSUM (MP_TAC o Q.SPECL [`m:num`,`n:num`]) THEN
  DISCH_THEN(fn th => DISCH_TAC THEN MP_TAC th) THEN
  (KNOW_TAC ``m >= N1:num`` THENL [POP_ASSUM MP_TAC THEN ARITH_TAC,
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC]) THEN
  MATCH_MP_TAC EQ_IMPLIES THEN AP_THM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
  MATCH_MP_TAC SUM_EQ THEN ASM_SIMP_TAC std_ss [IN_INTER, IN_NUMSEG] THEN
  REPEAT STRIP_TAC THENL [ALL_TAC, CONV_TAC SYM_CONV] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_REWRITE_TAC[] THEN
  ASM_ARITH_TAC);

val SUMMABLE_EQ_EVENTUALLY = store_thm ("SUMMABLE_EQ_EVENTUALLY",
 ``!f g k. (?N. !n. N <= n /\ n IN k ==> (f n = g n)) /\ summable k f
           ==> summable k g``,
  MESON_TAC[SUMMABLE_IFF_EVENTUALLY]);

val SUMMABLE_IFF_COFINITE = store_thm ("SUMMABLE_IFF_COFINITE",
 ``!f s t. FINITE((s DIFF t) UNION (t DIFF s))
           ==> (summable s f <=> summable t f)``,
  REPEAT STRIP_TAC THEN ONCE_REWRITE_TAC[GSYM SUMMABLE_RESTRICT] THEN
  MATCH_MP_TAC SUMMABLE_IFF_EVENTUALLY THEN
  FIRST_ASSUM(MP_TAC o ISPEC ``\x:num.x`` o MATCH_MP UPPER_BOUND_FINITE_SET) THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` MP_TAC) THEN REWRITE_TAC[IN_UNIV] THEN
  DISCH_TAC THEN EXISTS_TAC ``N + 1:num`` THEN
  REWRITE_TAC[ARITH_PROVE ``N + 1 <= n <=> ~(n <= N:num)``] THEN ASM_SET_TAC[]);

val SUMMABLE_EQ_COFINITE = store_thm ("SUMMABLE_EQ_COFINITE",
 ``!f s t. FINITE((s DIFF t) UNION (t DIFF s)) /\ summable s f
           ==> summable t f``,
  MESON_TAC[SUMMABLE_IFF_COFINITE]);

val SUMMABLE_FROM_ELSEWHERE = store_thm ("SUMMABLE_FROM_ELSEWHERE",
 ``!f m n. summable (from m) f ==> summable (from n) f``,
  REPEAT GEN_TAC THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] SUMMABLE_EQ_COFINITE) THEN
  MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``{0n..m+n}`` THEN
  SIMP_TAC std_ss [FINITE_NUMSEG, SUBSET_DEF, IN_NUMSEG, IN_UNION, IN_DIFF, IN_FROM] THEN
  ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* Uniform vesion of Cauchy criterion.                                       *)
(* ------------------------------------------------------------------------- *)

val SERIES_CAUCHY_UNIFORM = store_thm ("SERIES_CAUCHY_UNIFORM",
 ``!P f:'a->num->real k.
        (?l. !e. &0 < e
                 ==> ?N. !n x. N <= n /\ P x
                               ==> dist(sum(k INTER { 0n..n}) (f x),
                                        l x) < e) <=>
        (!e. &0 < e ==> ?N. !m n x. N <= m /\ P x
                                    ==> abs(sum(k INTER {m..n}) (f x)) < e)``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [sums, UNIFORMLY_CONVERGENT_EQ_CAUCHY, cauchy] THEN
  ONCE_REWRITE_TAC [METIS [] ``(dist (sum (k INTER {0 .. n}) (f x),
                                      sum (k INTER {0 .. n'}) (f x)) < e) =
                      (\n n' x. dist (sum (k INTER {0 .. n}) (f x),
                                      sum (k INTER {0 .. n'}) (f x)) < e) n n' x``] THEN
  ONCE_REWRITE_TAC[MESON[]
   ``(!m n:num y. N <= m /\ N <= n /\ P y ==> Q m n y) <=>
     (!y. P y ==> !m n. N <= m /\ N <= n ==> Q m n y)``] THEN
  SIMP_TAC std_ss [SEQUENCE_CAUCHY_WLOG] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  SIMP_TAC std_ss [dist, SUM_DIFF_LEMMA, ABS_SUM_TRIVIAL_LEMMA] THEN
  REWRITE_TAC[GE, TAUT `a ==> b \/ c <=> a /\ ~b ==> c`] THEN
  REWRITE_TAC[NOT_LESS, ARITH_PROVE
   ``(N <= m /\ N <= n /\ m <= n) /\ m + 1 <= n <=>
      N + 1 <= m + 1 /\ m + 1 <= n:num``] THEN
  AP_TERM_TAC THEN REWRITE_TAC[FUN_EQ_THM] THEN X_GEN_TAC ``e:real`` THEN
  ASM_CASES_TAC ``&0 < e:real`` THEN ASM_SIMP_TAC std_ss [] THEN
  EQ_TAC THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THENL
   [EXISTS_TAC ``N + 1:num``, EXISTS_TAC ``N:num``] THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= m + 1 ==> N <= m + 1:num``] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:'a``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(MP_TAC o SPECL [``m - 1:num``, ``n:num``]) THEN
  SUBGOAL_THEN ``m - 1 + 1 = m:num`` SUBST_ALL_TAC THENL
   [ASM_ARITH_TAC, ALL_TAC] THEN
  KNOW_TAC ``N <= m - 1 /\ m <= n:num`` THENL
  [ASM_ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* So trivially, terms of a convergent series go to zero.                    *)
(* ------------------------------------------------------------------------- *)

val SERIES_GOESTOZERO = store_thm ("SERIES_GOESTOZERO",
 ``!s x. summable s x
         ==> !e. &0 < e
                 ==> eventually (\n. n IN s ==> abs(x n) < e) sequentially``,
  REPEAT GEN_TAC THEN REWRITE_TAC[summable, SERIES_CAUCHY] THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  X_GEN_TAC ``n:num`` THEN BETA_TAC THEN REPEAT STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``n:num``, ``n:num``]) THEN
  ASM_SIMP_TAC std_ss [NUMSEG_SING, GE, SET_RULE ``n IN s ==> (s INTER {n} = {n})``] THEN
  REWRITE_TAC[SUM_SING]);

val SUMMABLE_IMP_TOZERO = store_thm ("SUMMABLE_IMP_TOZERO",
 ``!f:num->real k.
       summable k f
       ==> ((\n. if n IN k then f(n) else 0) --> 0) sequentially``,
  REPEAT GEN_TAC THEN GEN_REWR_TAC LAND_CONV [GSYM SUMMABLE_RESTRICT] THEN
  REWRITE_TAC[summable, LIM_SEQUENTIALLY, INTER_UNIV, sums] THEN
  DISCH_THEN(X_CHOOSE_TAC ``l:real``) THEN X_GEN_TAC ``e:real`` THEN
  DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_HALF, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``N:num`` THEN DISCH_TAC THEN EXISTS_TAC ``N + 1:num`` THEN
  X_GEN_TAC ``n:num`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``!n:num. N <= n ==>
        dist (sum { 0n .. n} (\n. if n IN k then f n else 0),l) < e / 2:real`` THEN
  DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``n - 1:num`` th) THEN MP_TAC(SPEC ``n:num`` th)) THEN
  ASM_SIMP_TAC std_ss [ARITH_PROVE ``N + 1 <= n ==> N <= n /\ N <= n - 1:num``] THEN
  ABBREV_TAC ``m = n - 1:num`` THEN
  SUBGOAL_THEN ``n = SUC m`` SUBST1_TAC THENL
   [ASM_ARITH_TAC, ALL_TAC] THEN
  SIMP_TAC std_ss [SUM_CLAUSES_NUMSEG, ZERO_LESS_EQ, dist] THEN
  SIMP_TAC std_ss [REAL_ARITH ``abs(x - 0) = abs x:real``] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [ABS_0] THEN
  SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
  REAL_ARITH_TAC);

val SUMMABLE_IMP_BOUNDED = store_thm ("SUMMABLE_IMP_BOUNDED",
 ``!f:num->real k. summable k f ==> bounded (IMAGE f k)``,
  REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP SUMMABLE_IMP_TOZERO) THEN
  DISCH_THEN(MP_TAC o MATCH_MP CONVERGENT_IMP_BOUNDED) THEN
  SIMP_TAC std_ss [BOUNDED_POS, FORALL_IN_IMAGE, IN_UNIV] THEN
  METIS_TAC[REAL_LT_IMP_LE, ABS_0]);

val SUMMABLE_IMP_SUMS_BOUNDED = store_thm ("SUMMABLE_IMP_SUMS_BOUNDED",
 ``!f:num->real k.
       summable (from k) f ==> bounded { sum{k..n} f | n IN univ(:num) }``,
  SIMP_TAC std_ss [summable, sums, LEFT_IMP_EXISTS_THM] THEN REPEAT GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP CONVERGENT_IMP_BOUNDED) THEN
  SIMP_TAC std_ss [FROM_INTER_NUMSEG, GSYM IMAGE_DEF]);

(* ------------------------------------------------------------------------- *)
(* Comparison test.                                                          *)
(* ------------------------------------------------------------------------- *)

val SERIES_COMPARISON = store_thm ("SERIES_COMPARISON",
 ``!f g s. (?l. (g sums l) s) /\
           (?N. !n. n >= N /\ n IN s ==> abs(f n) <= g n)
           ==> ?l:real. (f sums l) s``,
  REPEAT GEN_TAC THEN REWRITE_TAC[SERIES_CAUCHY] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC (X_CHOOSE_TAC ``N1:num``)) THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
  EXISTS_TAC ``N1 + N2:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs (sum (s INTER {m .. n}) g)`` THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [FINITE_INTER_NUMSEG] THEN
    MATCH_MP_TAC(REAL_ARITH ``x <= a ==> x <= abs(a:real)``) THEN
    MATCH_MP_TAC SUM_ABS_LE THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, IN_INTER, IN_NUMSEG] THEN
    ASM_MESON_TAC[ARITH_PROVE ``m >= N1 + N2:num /\ m <= x ==> x >= N1``],
    ASM_MESON_TAC[ARITH_PROVE ``m >= N1 + N2:num ==> m >= N2``]]);

val SUMMABLE_COMPARISON = store_thm ("SUMMABLE_COMPARISON",
 ``!f g s. summable s g /\
           (?N. !n. n >= N /\ n IN s ==> abs(f n) <= g n)
           ==> summable s f``,
  REWRITE_TAC[summable, SERIES_COMPARISON]);

val SERIES_ABSCONV_IMP_CONV = store_thm ("SERIES_ABSCONV_IMP_CONV",
 ``!x:num->real k. summable k (\n. (abs(x n))) ==> summable k x``,
  REWRITE_TAC[summable] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SERIES_COMPARISON THEN
  EXISTS_TAC ``\n:num. abs(x n:real)`` THEN
  ASM_SIMP_TAC std_ss [o_DEF, REAL_LE_REFL] THEN ASM_MESON_TAC[]);

val SUMMABLE_SUBSET_ABSCONV = store_thm ("SUMMABLE_SUBSET_ABSCONV",
 ``!x:num->real s t.
        summable s (\n. abs(x n)) /\ t SUBSET s
        ==> summable t (\n. abs(x n))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMMABLE_SUBSET THEN
  EXISTS_TAC ``s:num->bool`` THEN ASM_REWRITE_TAC[] THEN
  REWRITE_TAC[summable] THEN MATCH_MP_TAC SERIES_COMPARISON THEN
  EXISTS_TAC ``\n:num. abs(x n:real)`` THEN
  ASM_SIMP_TAC std_ss [o_DEF, GSYM summable] THEN
  EXISTS_TAC ``0:num`` THEN REPEAT STRIP_TAC THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [REAL_LE_REFL, ABS_ABS, ABS_0, ABS_POS]);

val SERIES_COMPARISON_BOUND = store_thm ("SERIES_COMPARISON_BOUND",
 ``!f:num->real g s a.
        (g sums a) s /\ (!i. i IN s ==> abs(f i) <= (g i))
        ==> ?l. (f sums l) s /\ abs(l) <= a``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``g:num->real``, ``s:num->bool``]
        SUMMABLE_COMPARISON) THEN
  SIMP_TAC std_ss [o_DEF, GE, ETA_AX, summable] THEN
  KNOW_TAC ``(?l. ((g:num->real) sums l) s) /\
             (?N:num. !n. N <= n /\ n IN s ==> abs (f n) <= g n)`` THENL
  [ASM_MESON_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``l:real`` THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[FROM_0, INTER_UNIV, sums]) THEN
  MATCH_MP_TAC SERIES_BOUND THEN MAP_EVERY EXISTS_TAC
   [``f:num->real``, ``g:num->real``, ``s:num->bool``] THEN
  ASM_SIMP_TAC std_ss [sums, o_DEF, ETA_AX]);

(* ------------------------------------------------------------------------- *)
(* Uniform version of comparison test.                                       *)
(* ------------------------------------------------------------------------- *)

val SERIES_COMPARISON_UNIFORM = store_thm ("SERIES_COMPARISON_UNIFORM",
 ``!f g P s. (?l. (g sums l) s) /\
             (?N. !n x. N <= n /\ n IN s /\ P x ==> abs(f x n) <= g n)
             ==> ?l:'a->real.
                    !e. &0 < e
                        ==> ?N. !n x. N <= n /\ P x
                                      ==> dist(sum(s INTER { 0n..n}) (f x),
                                               l x) < e``,
  REPEAT GEN_TAC THEN SIMP_TAC std_ss [GE, SERIES_CAUCHY, SERIES_CAUCHY_UNIFORM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC (X_CHOOSE_TAC ``N1:num``)) THEN
  DISCH_TAC THEN X_GEN_TAC ``e:real`` THEN POP_ASSUM (MP_TAC o SPEC ``e:real``) THEN
  MATCH_MP_TAC MONO_IMP THEN REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_TAC ``N2:num``) THEN
  EXISTS_TAC ``N1 + N2:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``, ``x:'a``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs (sum (s INTER {m .. n}) g)`` THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [FINITE_INTER_NUMSEG] THEN
    MATCH_MP_TAC(REAL_ARITH ``x <= a ==> x <= abs(a:real)``) THEN
    MATCH_MP_TAC SUM_ABS_LE THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, IN_INTER, IN_NUMSEG] THEN
    ASM_MESON_TAC[ARITH_PROVE ``N1 + N2:num <= m /\ m <= x ==> N1 <= x``],
    ASM_MESON_TAC[ARITH_PROVE ``N1 + N2:num <= m ==> N2 <= m``]]);

(* ------------------------------------------------------------------------- *)
(* Ratio test.                                                               *)
(* ------------------------------------------------------------------------- *)

val SERIES_RATIO = store_thm ("SERIES_RATIO",
 ``!c a s N.
      c < &1 /\
      (!n. n >= N ==> abs(a(SUC n)) <= c * abs(a(n)))
      ==> ?l:real. (a sums l) s``,
  REWRITE_TAC[GE] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC SERIES_COMPARISON THEN
  DISJ_CASES_TAC(REAL_ARITH ``c <= &0 \/ &0 < c:real``) THENL
   [EXISTS_TAC ``\n:num. &0:real`` THEN REWRITE_TAC[o_DEF] THEN
    CONJ_TAC THENL [MESON_TAC[SERIES_0], ALL_TAC] THEN
    EXISTS_TAC ``N + 1:num`` THEN REWRITE_TAC[GE] THEN REPEAT STRIP_TAC THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``c * abs(a(n - 1:num):real)`` THEN
    CONJ_TAC THENL
     [ASM_MESON_TAC[ARITH_PROVE ``N + 1 <= n ==> (SUC(n - 1) = n) /\ N <= n - 1``],
      ALL_TAC] THEN
    MATCH_MP_TAC(REAL_ARITH ``&0 <= -c * x ==> c * x <= &0:real``) THEN
    MATCH_MP_TAC REAL_LE_MUL THEN REWRITE_TAC[ABS_POS] THEN
    UNDISCH_TAC ``c <= &0:real`` THEN REAL_ARITH_TAC,
    ASSUME_TAC(MATCH_MP REAL_LT_IMP_LE (ASSUME ``&0 < c:real``))] THEN
  EXISTS_TAC ``\n:num. abs(a(N):real) * c pow (n - N)`` THEN
  REWRITE_TAC[] THEN CONJ_TAC THENL
   [ALL_TAC,
    EXISTS_TAC ``N:num`` THEN
    SIMP_TAC std_ss [GE, LESS_EQ_EXISTS, CONJ_EQ_IMP, ADD_SUB2, LEFT_IMP_EXISTS_THM] THEN
    SUBGOAL_THEN ``!d:num. abs(a(N + d):real) <= abs(a N) * c pow d``
     (fn th => MESON_TAC[th]) THEN INDUCT_TAC THEN
    REWRITE_TAC[ADD_CLAUSES, pow, REAL_MUL_RID, REAL_LE_REFL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``c * abs((a:num->real) (N + d:num))`` THEN
    ASM_SIMP_TAC std_ss [LE_ADD] THEN
    ASM_MESON_TAC[REAL_LE_LMUL, REAL_MUL_ASSOC, REAL_MUL_COMM]] THEN
  GEN_REWR_TAC I [SERIES_CAUCHY] THEN X_GEN_TAC ``e:real`` THEN
  SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN
  DISCH_TAC THEN SIMP_TAC std_ss [SUM_LMUL, FINITE_INTER, FINITE_NUMSEG] THEN
  ASM_CASES_TAC ``(a:num->real) N = 0:real`` THENL
   [ASM_REWRITE_TAC[ABS_0, REAL_MUL_LZERO, ABS_N], ALL_TAC] THEN
  MP_TAC(SPECL [``c:real``, ``((&1 - c) * e) / abs((a:num->real) N)``]
               REAL_ARCH_POW_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_DIV, REAL_LT_MUL, REAL_SUB_LT, GSYM ABS_NZ, GE] THEN
  DISCH_THEN(X_CHOOSE_TAC ``M:num``) THEN EXISTS_TAC ``N + M:num`` THEN
  MAP_EVERY X_GEN_TAC [``m:num``, ``n:num``] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``abs(abs((a:num->real) N) *
                  sum{m..n} (\i. c pow (i - N)))`` THEN
  CONJ_TAC THENL
   [REWRITE_TAC[ABS_MUL] THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
    REWRITE_TAC[ABS_POS] THEN
    MATCH_MP_TAC(REAL_ARITH ``&0 <= x /\ x <= y ==> abs x <= abs y:real``) THEN
    ASM_SIMP_TAC std_ss [SUM_POS_LE, FINITE_INTER_NUMSEG, POW_POS] THEN
    MATCH_MP_TAC SUM_SUBSET THEN ASM_SIMP_TAC std_ss [POW_POS] THEN
    REWRITE_TAC[FINITE_INTER_NUMSEG, FINITE_NUMSEG] THEN
    REWRITE_TAC[IN_INTER, IN_DIFF] THEN MESON_TAC[],
    ALL_TAC] THEN
  REWRITE_TAC[ABS_MUL, ABS_ABS] THEN
  DISJ_CASES_TAC(ARITH_PROVE ``n:num < m \/ m <= n``) THENL
   [ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, ABS_N, REAL_MUL_RZERO], ALL_TAC] THEN
  SUBGOAL_THEN ``(m = 0 + m) /\ (n = (n - m) + m:num)`` (CONJUNCTS_THEN SUBST1_TAC) THENL
   [UNDISCH_TAC ``m:num <= n`` THEN ARITH_TAC, ALL_TAC] THEN
  REWRITE_TAC[SUM_OFFSET'] THEN UNDISCH_TAC ``N + M:num <= m`` THEN
  SIMP_TAC std_ss [LESS_EQ_EXISTS] THEN DISCH_THEN(X_CHOOSE_THEN ``d:num`` SUBST_ALL_TAC) THEN
  REWRITE_TAC[ARITH_PROVE ``(i + (N + M + d) - N:num) = (M + d) + i``] THEN
  ONCE_REWRITE_TAC[POW_ADD] THEN SIMP_TAC arith_ss [SUM_LMUL, SUM_GP] THEN
  ASM_SIMP_TAC std_ss [LT, REAL_LT_IMP_NE] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  FULL_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ, ABS_NZ, ABS_MUL] THEN
  REWRITE_TAC[GSYM POW_ABS] THEN ONCE_REWRITE_TAC[REAL_MUL_SYM] THEN
  KNOW_TAC ``1 - c:real <> 0`` THENL
  [UNDISCH_TAC ``c < 1:real`` THEN REAL_ARITH_TAC, DISCH_TAC] THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_LT_RDIV_EQ, ABS_DIV, REAL_POW_LT, ABS_NZ, REAL_ARITH
   ``&0 < c /\ c < &1 ==> &0 < abs c /\ &0 < abs(&1 - c:real)``, REAL_LT_LDIV_EQ] THEN
  ONCE_REWRITE_TAC [METIS [pow] ``x pow 0 = 1:real``] THEN
  MATCH_MP_TAC(REAL_ARITH
   ``&0 < x /\ x <= &1 /\ &1 <= e ==> abs(1 - x) < e:real``) THEN
  ASM_SIMP_TAC std_ss [REAL_POW_LT, REAL_POW_1_LE, REAL_LT_IMP_LE] THEN
  ASM_SIMP_TAC std_ss [REAL_ARITH ``c < &1 ==> (x * abs(&1 - c) = (&1 - c) * x:real)``] THEN
  KNOW_TAC ``(abs (c pow M) <> 0:real) /\ (abs (c pow d) <> 0:real)`` THENL
  [CONJ_TAC THEN ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN MATCH_MP_TAC REAL_LT_IMP_NE THEN
   REWRITE_TAC [GSYM ABS_NZ] THEN ONCE_REWRITE_TAC [EQ_SYM_EQ] THEN
   MATCH_MP_TAC REAL_LT_IMP_NE THEN METIS_TAC [REAL_POW_LT], STRIP_TAC] THEN
  FULL_SIMP_TAC real_ss [real_div, REAL_INV_MUL, ABS_NZ, REAL_POW_LT, REAL_POW_ADD,
                        REAL_MUL_ASSOC, REAL_LT_IMP_NE, POW_ABS, ABS_MUL] THEN
  REWRITE_TAC[REAL_ARITH
   ``(a * b * c * d * e) = (e * ((a * b) * c)) * d:real``] THEN
  ASM_SIMP_TAC real_ss [GSYM real_div, REAL_LE_RDIV_EQ, REAL_POW_LT, REAL_MUL_LID,
               REAL_ARITH ``&0 < c ==> (abs c = c:real)``] THEN
  REWRITE_TAC [real_div] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``xm < e ==> &0 <= (d - &1) * e ==> xm <= d * e:real``)) THEN
  MATCH_MP_TAC REAL_LE_MUL THEN CONJ_TAC THENL
   [REWRITE_TAC[REAL_SUB_LE, GSYM REAL_POW_INV] THEN
    MATCH_MP_TAC REAL_POW_LE_1 THEN
    MATCH_MP_TAC REAL_INV_1_LE THEN ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE],
    MATCH_MP_TAC REAL_LT_IMP_LE THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LT, REAL_LT_MUL, REAL_LT_DIV, ABS_NZ, GSYM real_div]]);

(* ------------------------------------------------------------------------- *)
(* Ostensibly weaker versions of the boundedness of partial sums.            *)
(* ------------------------------------------------------------------------- *)

val BOUNDED_PARTIAL_SUMS = store_thm ("BOUNDED_PARTIAL_SUMS",
 ``!f:num->real k.
        bounded { sum{k..n} f | n IN univ(:num) }
        ==> bounded { sum{m..n} f | m IN univ(:num) /\ n IN univ(:num) }``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``bounded { sum{ 0n..n} f:real | n IN univ(:num) }`` MP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
    REWRITE_TAC[bounded_def] THEN
    SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IN_UNIV] THEN
    DISCH_THEN(X_CHOOSE_THEN ``B:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``sum { i:num | i < k} (\i. abs(f i:real)) + B`` THEN
    X_GEN_TAC ``i:num`` THEN ASM_CASES_TAC ``i:num < k`` THENL
     [MATCH_MP_TAC(REAL_ARITH
       ``!y. x <= y /\ y <= a /\ &0 < b ==> x <= a + b:real``) THEN
      EXISTS_TAC ``sum { 0n..i} (\i. abs(f i:real))`` THEN
      ASM_SIMP_TAC std_ss [SUM_ABS, FINITE_NUMSEG] THEN
      MATCH_MP_TAC SUM_SUBSET THEN
      REWRITE_TAC[FINITE_NUMSEG, FINITE_NUMSEG_LT, ABS_POS] THEN
      SIMP_TAC std_ss [IN_DIFF, IN_NUMSEG, GSPECIFICATION] THEN
      ASM_SIMP_TAC arith_ss [] THEN REAL_ARITH_TAC,
      ALL_TAC] THEN
    ASM_CASES_TAC ``k = 0:num`` THENL
     [FIRST_X_ASSUM SUBST_ALL_TAC THEN MATCH_MP_TAC(REAL_ARITH
       ``x <= B /\ &0 <= b ==> x <= b + B:real``) THEN
      ASM_SIMP_TAC std_ss [SUM_POS_LE, FINITE_NUMSEG_LT, ABS_POS],
      ALL_TAC] THEN
    MP_TAC(ISPECL [``f:num->real``, ``0:num``, ``k:num``, ``i:num``]
      SUM_COMBINE_L) THEN
    KNOW_TAC ``0 < k /\ 0 <= k /\ k <= i + 1:num`` THENL
    [ASM_SIMP_TAC arith_ss [],
     DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(SUBST1_TAC o SYM) THEN ASM_REWRITE_TAC[NUMSEG_LT] THEN
    MATCH_MP_TAC(REAL_ARITH
     ``abs(x) <= a /\ abs(y) <= b ==> abs(x + y) <= a + b:real``) THEN
    ASM_SIMP_TAC std_ss [SUM_ABS, FINITE_NUMSEG],
    ALL_TAC] THEN
  DISCH_THEN(fn th =>
    MP_TAC(MATCH_MP BOUNDED_DIFFS (W CONJ th)) THEN MP_TAC th) THEN
  REWRITE_TAC[AND_IMP_INTRO, GSYM BOUNDED_UNION] THEN
  MATCH_MP_TAC(REWRITE_RULE[TAUT `a /\ b ==> c <=> b ==> a ==> c`]
        BOUNDED_SUBSET) THEN
  KNOW_TAC ``!x:real m n:num.
     (x = sum {m..n} f)
     ==> (?n. x = sum { 0n..n} f) \/
         (?x' y.
              ((?n. x' = sum { 0n..n} f) /\ (?n. y = sum { 0n..n} f)) /\
              (x = x' - y))`` THENL
  [ALL_TAC, SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNION, LEFT_IMP_EXISTS_THM,
                             IN_UNIV, EXISTS_PROD] THEN METIS_TAC []] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``m:num``, ``n:num``] THEN
  DISCH_THEN SUBST1_TAC THEN
  ASM_CASES_TAC ``m = 0:num`` THENL [ASM_MESON_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``n:num < m`` THENL
   [DISJ2_TAC THEN REPEAT(EXISTS_TAC ``sum{ 0n.. 0n} (f:num->real)``) THEN
    ASM_SIMP_TAC std_ss [SUM_TRIV_NUMSEG, REAL_SUB_REFL] THEN MESON_TAC[],
    ALL_TAC] THEN
  DISJ2_TAC THEN MAP_EVERY EXISTS_TAC
   [``sum{0..n} (f:num->real)``, ``sum{0..m-1} (f:num->real)``] THEN
  CONJ_TAC THENL [MESON_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``f:num->real``, ``0:num``, ``m:num``, ``n:num``]
      SUM_COMBINE_L) THEN ASM_SIMP_TAC arith_ss [] THEN
  REAL_ARITH_TAC);

(* ------------------------------------------------------------------------- *)
(* General Dirichlet convergence test (could make this uniform on a set).    *)
(* ------------------------------------------------------------------------- *)

val SUMMABLE_BILINEAR_PARTIAL_PRE = store_thm ("SUMMABLE_BILINEAR_PARTIAL_PRE",
 ``!f g h:real->real->real l k.
        bilinear h /\
        ((\n. h (f(n + 1)) (g(n))) --> l) sequentially /\
        summable (from k) (\n. h (f(n + 1) - f(n)) (g(n)))
        ==> summable (from k) (\n. h (f n) (g(n) - g(n - 1)))``,
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss [summable, sums, FROM_INTER_NUMSEG] THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  FIRST_ASSUM(fn th =>
   REWRITE_TAC[MATCH_MP BILINEAR_SUM_PARTIAL_PRE th]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``l':real``) THEN
  EXISTS_TAC ``l - (h:real->real->real) ((f:num->real) k) (g(k - 1)) - l'`` THEN
  SIMP_TAC std_ss [LIM_CASES_SEQUENTIALLY] THEN
  KNOW_TAC  ``(((\(n :num).
     (\n. (h :real -> real -> real) ((f :num -> real) (n +  1n))
       ((g :num -> real) n) - h (f (k :num)) (g (k -  1n))) n -
     (\n. sum {k .. n} (\(k :num). h (f (k +  1n) - f k) (g k))) n) -->
  ((l :real) - h (f k) (g (k -  1n)) - (l' :real))) sequentially :
   bool)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC LIM_SUB THEN ASM_SIMP_TAC std_ss [LIM_CONST] THEN
  KNOW_TAC ``(((\(n :num).
     (\n. (h :real -> real -> real) ((f :num -> real) (n +  1n))
       ((g :num -> real) n)) n - (\n. h (f (k :num)) (g (k -  1n))) n) -->
  ((l :real) - h (f k) (g (k -  1n)))) sequentially :bool)`` THENL
  [ALL_TAC, METIS_TAC []] THEN MATCH_MP_TAC LIM_SUB THEN
  ASM_SIMP_TAC std_ss [LIM_CONST]);

val SERIES_DIRICHLET_BILINEAR = store_thm ("SERIES_DIRICHLET_BILINEAR",
 ``!f g h:real->real->real k m p l.
        bilinear h /\
        bounded {sum {m..n} f | n IN univ(:num)} /\
        summable (from p) (\n. abs(g(n + 1) - g(n))) /\
        ((\n. h (g(n + 1)) (sum{ 1n..n} f)) --> l) sequentially
        ==> summable (from k) (\n. h (g n) (f n))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SUMMABLE_FROM_ELSEWHERE THEN
  EXISTS_TAC ``1:num`` THEN
  FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP BOUNDED_PARTIAL_SUMS) THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
  SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, LEFT_IMP_EXISTS_THM, EXISTS_PROD] THEN
  X_GEN_TAC ``B:real`` THEN STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP BILINEAR_BOUNDED_POS) THEN
  DISCH_THEN(X_CHOOSE_THEN ``C:real`` STRIP_ASSUME_TAC) THEN
  MATCH_MP_TAC SUMMABLE_EQ THEN
  EXISTS_TAC ``\n. (h:real->real->real)
                   (g n) (sum { 1n..n} f - sum { 1n..n-1:num} f)`` THEN
  SIMP_TAC std_ss [IN_FROM, GSYM NUMSEG_RREC] THEN
  SIMP_TAC std_ss [SUM_CLAUSES, FINITE_NUMSEG, IN_NUMSEG,
           ARITH_PROVE ``1 <= n ==> ~(n <= n - 1:num)``] THEN
  CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN ASM_SIMP_TAC std_ss [BILINEAR_RADD, BILINEAR_RSUB] THEN
    REAL_ARITH_TAC,
    ALL_TAC] THEN
  MATCH_MP_TAC SUMMABLE_FROM_ELSEWHERE THEN EXISTS_TAC ``p:num`` THEN
  MP_TAC(ISPECL [``g:num->real``, ``\n. sum{ 1n..n} f:real``,
                 ``h:real->real->real``, ``l:real``, ``p:num``]
         SUMMABLE_BILINEAR_PARTIAL_PRE) THEN
  SIMP_TAC std_ss [] THEN DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[] THEN
  SUBGOAL_THEN
    ``summable (from p) ((\n. C * B * abs(g(n + 1) - g(n):real)))``
  MP_TAC THENL [ASM_SIMP_TAC std_ss [o_DEF, SUMMABLE_CMUL], ALL_TAC] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUMMABLE_COMPARISON) THEN
  EXISTS_TAC ``0:num`` THEN REWRITE_TAC[IN_FROM, GE, ZERO_LESS_EQ] THEN
  REPEAT STRIP_TAC THEN MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
   ``C * abs(g(n + 1:num) - g(n):real) * abs(sum { 1n..n} f:real)`` THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN
  REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL] THEN
  GEN_REWR_TAC RAND_CONV [REAL_MUL_SYM] THEN
  ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP, ABS_POS]);

val SERIES_DIRICHLET = store_thm ("SERIES_DIRICHLET",
 ``!f:num->real g N k m.
        bounded {sum {m..n} f | n IN univ(:num)} /\
        (!n. N <= n ==> g(n + 1) <= g(n)) /\
        (g --> 0) sequentially
        ==> summable (from k) (\n. g(n) * f(n))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:num->real``, ``g:num->real``,
                 ``\x y:real. x * y``] SERIES_DIRICHLET_BILINEAR) THEN
  SIMP_TAC std_ss [o_THM] THEN DISCH_THEN MATCH_MP_TAC THEN
  MAP_EVERY EXISTS_TAC [``m:num``, ``N:num``, ``0:real``] THEN CONJ_TAC THENL
   [SIMP_TAC std_ss [bilinear, linear] THEN
    REPEAT STRIP_TAC THEN REAL_ARITH_TAC,
    ALL_TAC] THEN
  ASM_REWRITE_TAC [] THEN
  FIRST_ASSUM(MP_TAC o SPEC ``1:num`` o MATCH_MP SEQ_OFFSET) THEN
  SIMP_TAC std_ss [o_THM] THEN DISCH_TAC THEN CONJ_TAC THENL
   [MATCH_MP_TAC SUMMABLE_EQ_EVENTUALLY THEN
    EXISTS_TAC ``(\n. (g:num->real)(n) - g(n + 1))`` THEN SIMP_TAC std_ss [] THEN
    CONJ_TAC THENL
     [EXISTS_TAC ``N:num`` THEN REPEAT STRIP_TAC THEN
      UNDISCH_TAC ``!n. N <= n ==> g (n + 1) <= (g:num->real) n`` THEN
      DISCH_THEN (MP_TAC o SPEC ``n:num``) THEN
      ASM_REWRITE_TAC [] THEN REAL_ARITH_TAC,
      SIMP_TAC std_ss [summable, sums, FROM_INTER_NUMSEG, SUM_DIFFS'] THEN
      SIMP_TAC std_ss [LIM_CASES_SEQUENTIALLY] THEN
      EXISTS_TAC ``(g(N:num)) - 0:real`` THEN
      ONCE_REWRITE_TAC [METIS [] ``((\n:num. g N - g (n + 1)) --> (g N - 0:real)) =
                       ((\n. (\n. g N) n - (\n. g (n + 1)) n) --> (g N - 0))``] THEN
      MATCH_MP_TAC LIM_SUB THEN ASM_REWRITE_TAC[LIM_CONST]],
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN
    ONCE_REWRITE_TAC [METIS []
        ``((\n. sum {1 .. n} f * (g:num->real) (n + 1)) --> 0) =
      ((\n. (\n. sum {1 .. n} f) n * (\n. g (n + 1)) n) --> 0)``] THEN
    MATCH_MP_TAC LIM_NULL_CMUL_BOUNDED THEN ASM_SIMP_TAC std_ss [o_DEF] THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN
    FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP BOUNDED_PARTIAL_SUMS) THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [BOUNDED_POS]) THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV, EXISTS_PROD] THEN METIS_TAC[]]);

(* ------------------------------------------------------------------------- *)
(* Rearranging absolutely convergent series.                                 *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``!f:'a->real s t.
          FINITE s /\ FINITE t
          ==> (sum s f - sum t f = sum (s DIFF t) f - sum (t DIFF s) f)``,
    REPEAT STRIP_TAC THEN
    ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s DIFF (s INTER t)``] THEN
    ASM_SIMP_TAC std_ss [SUM_DIFF', INTER_SUBSET] THEN
    GEN_REWR_TAC (RAND_CONV o RAND_CONV o ONCE_DEPTH_CONV) [INTER_COMM] THEN
    REAL_ARITH_TAC);

val SERIES_INJECTIVE_IMAGE_STRONG = store_thm ("SERIES_INJECTIVE_IMAGE_STRONG",
 ``!x:num->real s f.
        summable (IMAGE f s) (\n. abs(x n)) /\
        (!m n. m IN s /\ n IN s /\ (f m = f n) ==> (m = n))
        ==> ((\n. sum (IMAGE f s INTER { 0n..n}) x -
                  sum (s INTER { 0n..n}) (x o f)) --> 0)
            sequentially``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LIM_SEQUENTIALLY] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``(summable (IMAGE (f :num -> num) (s :num -> bool))
         (\(n :num). abs ((x :num -> real) n)) :bool)`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUMMABLE_CAUCHY]) THEN
  SIMP_TAC std_ss [FINITE_INTER, FINITE_NUMSEG] THEN
  GEN_REWR_TAC (LAND_CONV o ONCE_DEPTH_CONV) [o_DEF] THEN
  SIMP_TAC std_ss [SUM_POS_LE, ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
  DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
  ASM_REWRITE_TAC[dist, GE, REAL_SUB_RZERO, REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``N:num`` STRIP_ASSUME_TAC) THEN
  UNDISCH_TAC ``!(m :num) (n :num).
        m IN (s :num -> bool) /\ n IN s /\ ((f :num -> num) m = f n) ==>
        (m = n)`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [INJECTIVE_ON_LEFT_INVERSE]) THEN
  DISCH_THEN(X_CHOOSE_TAC ``g:num->num``) THEN
  MP_TAC(ISPECL [``g:num->num``, ``{ 0n..N}``] UPPER_BOUND_FINITE_SET) THEN
  REWRITE_TAC[FINITE_NUMSEG, IN_NUMSEG, ZERO_LESS_EQ] THEN
  DISCH_THEN(X_CHOOSE_TAC ``P:num``) THEN
  EXISTS_TAC ``MAX N P:num`` THEN X_GEN_TAC ``n:num`` THEN
  REWRITE_TAC [MAX_DEF] THEN
  SIMP_TAC std_ss [ARITH_PROVE ``(if a < b then b else a) <= c <=> a <= c /\ b <= c:num``] THEN
  DISCH_TAC THEN
  W(MP_TAC o PART_MATCH (rand o rand) SUM_IMAGE o rand o
    rand o lhand o snd) THEN
  KNOW_TAC ``(!(x :num) (y :num).
    x IN (s :num -> bool) INTER {0 .. n} /\
    y IN s INTER { 0 .. n} /\ ((f :num -> num) x = f y) ==>
    (x = y))`` THENL
   [ASM_MESON_TAC[FINITE_INTER, FINITE_NUMSEG, IN_INTER],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(SUBST1_TAC o SYM)] THEN
  W(MP_TAC o PART_MATCH (lhand o rand) lemma o rand o lhand o snd) THEN
  SIMP_TAC std_ss [FINITE_INTER, IMAGE_FINITE, FINITE_NUMSEG] THEN
  DISCH_THEN SUBST1_TAC THEN GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
   MATCH_MP_TAC(REAL_ARITH
   ``abs a < x /\ abs b < y ==> abs(a - b:real) < x + y:real``) THEN
  CONJ_TAC THEN
  W(MP_TAC o PART_MATCH (lhand o rand) SUM_ABS o lhand o snd) THEN
  SIMP_TAC std_ss [FINITE_DIFF, IMAGE_FINITE, FINITE_INTER, FINITE_NUMSEG] THEN
  MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] REAL_LET_TRANS) THEN
  MATCH_MP_TAC REAL_LET_TRANS THENL
   [EXISTS_TAC
     ``sum((IMAGE (f:num->num) s) INTER {N..n}) (\i. abs(x i :real))`` THEN
    CONJ_TAC THENL [ALL_TAC,
     MATCH_MP_TAC (REAL_ARITH ``abs x < y ==> x < y:real``) THEN
     ASM_SIMP_TAC real_ss []] THEN
    MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
    SIMP_TAC std_ss [ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
    MATCH_MP_TAC(SET_RULE
     ``(!x. x IN s /\ f(x) IN n /\ ~(x IN m) ==> f x IN t)
      ==> (IMAGE f s INTER n) DIFF (IMAGE f (s INTER m)) SUBSET
          IMAGE f s INTER t``) THEN
    ASM_SIMP_TAC std_ss [IN_NUMSEG, ZERO_LESS_EQ, NOT_LESS_EQUAL] THEN
    X_GEN_TAC ``i:num`` THEN STRIP_TAC THEN
    MATCH_MP_TAC LESS_IMP_LESS_OR_EQ THEN ONCE_REWRITE_TAC[GSYM NOT_LESS_EQUAL] THEN
    UNDISCH_TAC ``!(x :num). x <= (N :num) ==> (g :num -> num) x <= (P :num)`` THEN
    DISCH_TAC THEN POP_ASSUM(MATCH_MP_TAC o ONCE_REWRITE_RULE [MONO_NOT_EQ]) THEN
    ASM_SIMP_TAC arith_ss [],
    MP_TAC(ISPECL [``f:num->num``, ``{ 0n..n}``] UPPER_BOUND_FINITE_SET) THEN
    REWRITE_TAC[FINITE_NUMSEG, IN_NUMSEG, ZERO_LESS_EQ] THEN
    DISCH_THEN(X_CHOOSE_TAC ``p:num``) THEN
    EXISTS_TAC
     ``sum(IMAGE (f:num->num) s INTER {N..p}) (\i. abs(x i :real))`` THEN
    CONJ_TAC THENL [ALL_TAC,
     MATCH_MP_TAC (REAL_ARITH ``abs x < y ==> x < y:real``) THEN
     ASM_SIMP_TAC real_ss []] THEN MATCH_MP_TAC SUM_SUBSET_SIMPLE THEN
    SIMP_TAC std_ss [ABS_POS, FINITE_INTER, FINITE_NUMSEG] THEN
    MATCH_MP_TAC(SET_RULE
     ``(!x. x IN s /\ x IN n /\ ~(f x IN m) ==> f x IN t)
      ==> (IMAGE f (s INTER n) DIFF (IMAGE f s) INTER m) SUBSET
          (IMAGE f s INTER t)``) THEN
    ASM_SIMP_TAC arith_ss [IN_NUMSEG, ZERO_LESS_EQ]]);

val SERIES_INJECTIVE_IMAGE = store_thm ("SERIES_INJECTIVE_IMAGE",
 ``!x:num->real s f l.
        summable (IMAGE f s) (\n. abs(x n)) /\
        (!m n. m IN s /\ n IN s /\ (f m = f n) ==> (m = n))
        ==> (((x o f) sums l) s <=> (x sums l) (IMAGE f s))``,
  REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN REWRITE_TAC[sums] THEN
  MATCH_MP_TAC LIM_TRANSFORM_EQ THEN SIMP_TAC std_ss [] THEN
  MATCH_MP_TAC SERIES_INJECTIVE_IMAGE_STRONG THEN
  ASM_REWRITE_TAC[]);

val SERIES_REARRANGE_EQ = store_thm ("SERIES_REARRANGE_EQ",
 ``!x:num->real s p l.
        (summable s (\n. abs(x n))) /\ (p permutes s)
        ==> (((x o p) sums l) s <=> (x sums l) s)``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``x:num->real``, ``s:num->bool``, ``p:num->num``, ``l:real``]
        SERIES_INJECTIVE_IMAGE) THEN
  ASM_SIMP_TAC std_ss [PERMUTES_IMAGE] THEN
  ASM_MESON_TAC[PERMUTES_INJECTIVE]);

val SERIES_REARRANGE = store_thm ("SERIES_REARRANGE",
 ``!x:num->real s p l.
        summable s (\n. abs(x n)) /\ p permutes s /\ (x sums l) s
        ==> ((x o p) sums l) s``,
  METIS_TAC[SERIES_REARRANGE_EQ]);

val SUMMABLE_REARRANGE = store_thm ("SUMMABLE_REARRANGE",
 ``!x s p.
        summable s (\n. abs(x n)) /\ p permutes s
        ==> summable s (x o p)``,
  METIS_TAC[SERIES_ABSCONV_IMP_CONV, summable, SERIES_REARRANGE]);

(* ------------------------------------------------------------------------- *)
(* Banach fixed point theorem (not really topological...)                    *)
(* ------------------------------------------------------------------------- *)

val BANACH_FIX = store_thm ("BANACH_FIX",
 ``!f s c. complete s /\ ~(s = {}) /\
           &0 <= c /\ c < &1 /\
           (IMAGE f s) SUBSET s /\
           (!x y. x IN s /\ y IN s ==> dist(f(x),f(y)) <= c * dist(x,y))
           ==> ?!x:real. x IN s /\ (f x = x)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [EXISTS_UNIQUE_THM] THEN CONJ_TAC THENL
   [ALL_TAC,
    MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
    SUBGOAL_THEN ``dist((f:real->real) x,f y) <= c * dist(x,y)`` MP_TAC THENL
     [ASM_MESON_TAC[], ALL_TAC] THEN
    ASM_REWRITE_TAC[REAL_ARITH ``a <= c * a <=> &0 <= -a * (&1 - c:real)``] THEN
    ASM_SIMP_TAC std_ss [GSYM REAL_LE_LDIV_EQ, REAL_SUB_LT, real_div] THEN
    REWRITE_TAC[REAL_MUL_LZERO, REAL_ARITH ``&0:real <= -x <=> ~(&0 < x)``] THEN
    MESON_TAC[DIST_POS_LT]] THEN
  KNOW_TAC ``?z. (z 0 = @x:real. x IN s) /\ (!n. z(SUC n) = f(z n))`` THENL
  [RW_TAC std_ss [num_Axiom], STRIP_TAC] THEN
  SUBGOAL_THEN ``!n. (z:num->real) n IN s`` ASSUME_TAC THENL
   [INDUCT_TAC THEN ASM_SIMP_TAC std_ss [] THEN
    METIS_TAC[MEMBER_NOT_EMPTY, SUBSET_DEF, IN_IMAGE],
    ALL_TAC] THEN
  UNDISCH_THEN ``z  0n = @x:real. x IN s`` (K ALL_TAC) THEN
  SUBGOAL_THEN ``?x:real. x IN s /\ (z --> x) sequentially`` MP_TAC THENL
   [ALL_TAC,
    DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
    POP_ASSUM MP_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
    ABBREV_TAC ``e = dist(f(a:real),a)`` THEN
    SUBGOAL_THEN ``~(&0 < e:real)`` (fn th => METIS_TAC[th, DIST_POS_LT]) THEN
    DISCH_TAC THEN UNDISCH_TAC ``(z --> a) sequentially`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
    DISCH_THEN(MP_TAC o SPEC ``e / &2:real``) THEN
    ASM_REWRITE_TAC[REAL_HALF] THEN DISCH_THEN(X_CHOOSE_TAC ``N:num``) THEN
    SUBGOAL_THEN
     ``dist(f(z N),a:real) < e / &2 /\ dist(f(z(N:num)),f(a)) < e / &2``
     (fn th => ASM_MESON_TAC[th, DIST_TRIANGLE_HALF_R, REAL_LT_REFL]) THEN
    CONJ_TAC THENL [ASM_MESON_TAC[ARITH_PROVE ``N <= SUC N``], ALL_TAC] THEN
    MATCH_MP_TAC REAL_LET_TRANS THEN
    EXISTS_TAC ``c * dist((z:num->real) N,a)`` THEN ASM_SIMP_TAC std_ss [] THEN
    MATCH_MP_TAC(REAL_ARITH ``x < y /\ c * x <= &1 * x ==> c * x < y:real``) THEN
    ASM_SIMP_TAC std_ss [LESS_EQ_REFL, REAL_LE_RMUL_IMP, DIST_POS_LE, REAL_LT_IMP_LE]] THEN
  UNDISCH_TAC ``complete s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MATCH_MP_TAC o REWRITE_RULE [complete]) THEN
  ASM_REWRITE_TAC[CAUCHY] THEN
  SUBGOAL_THEN ``!n. dist(z(n):real,z(SUC n)) <= c pow n * dist(z(0),z(1))``
  ASSUME_TAC THENL
   [INDUCT_TAC THEN
    SIMP_TAC arith_ss [pow, REAL_MUL_LID, REAL_LE_REFL] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN
    EXISTS_TAC ``c * dist(z(n):real,z(SUC n))`` THEN
    CONJ_TAC THENL [ASM_MESON_TAC[], ALL_TAC] THEN
    REWRITE_TAC[GSYM REAL_MUL_ASSOC] THEN ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP],
    ALL_TAC] THEN
  SUBGOAL_THEN
   ``!m n:num. (&1 - c) * dist(z(m):real,z(m+n))
                <= c pow m * dist(z(0),z 1n) * (&1 - c pow n)``
  ASSUME_TAC THENL
   [GEN_TAC THEN INDUCT_TAC THENL
     [REWRITE_TAC[ADD_CLAUSES, DIST_REFL, REAL_MUL_RZERO, GSYM REAL_MUL_ASSOC] THEN
      MATCH_MP_TAC REAL_LE_MUL THEN
      ASM_SIMP_TAC std_ss [REAL_LE_MUL, POW_POS, DIST_POS_LE, REAL_SUB_LE,
                   REAL_POW_1_LE, REAL_LT_IMP_LE],
      ALL_TAC] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC
    ``(&1 - c) * (dist(z m:real,z(m + n)) + dist(z(m + n),z(m + SUC n)))`` THEN
    ASM_SIMP_TAC std_ss [REAL_LE_LMUL_IMP, REAL_SUB_LE, REAL_LT_IMP_LE, DIST_TRIANGLE] THEN
    FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
      ``c * x <= y ==> c * x' + y <= y' ==> c * (x + x') <= y':real``)) THEN
    REWRITE_TAC[REAL_ARITH
     ``q + a * b * (&1 - x) <= a * b * (&1 - y) <=> q <= a * b * (x - y:real)``] THEN
    REWRITE_TAC[ADD_CLAUSES, pow] THEN
    REWRITE_TAC[REAL_ARITH ``a * b * (d - c * d) = (&1 - c) * a * d * b:real``] THEN
    REWRITE_TAC [GSYM REAL_MUL_ASSOC] THEN MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_LE, REAL_LT_IMP_LE] THEN
    REWRITE_TAC[GSYM REAL_POW_ADD, REAL_MUL_ASSOC] THEN ASM_MESON_TAC[],
    ALL_TAC] THEN
  X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
  ASM_CASES_TAC ``(z:num->real) 0 = z 1`` THENL
   [FIRST_X_ASSUM SUBST_ALL_TAC THEN EXISTS_TAC ``0:num`` THEN
    REWRITE_TAC[GE, ZERO_LESS_EQ] THEN X_GEN_TAC ``n:num`` THEN
    FIRST_X_ASSUM(MP_TAC o SPECL [``0:num``, ``n:num``]) THEN
    REWRITE_TAC[ADD_CLAUSES, DIST_REFL, REAL_MUL_LZERO, REAL_MUL_RZERO] THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN
    ASM_CASES_TAC ``(z:num->real) 0 = z n`` THEN
    ASM_REWRITE_TAC[DIST_REFL, REAL_NOT_LE] THEN
    ASM_SIMP_TAC std_ss [REAL_LT_MUL, DIST_POS_LT, REAL_SUB_LT],
    ALL_TAC] THEN
  MP_TAC(SPECL [``c:real``, ``e * (&1 - c) / dist((z:num->real) 0,z 1)``]
   REAL_ARCH_POW_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_MUL, REAL_LT_DIV, REAL_SUB_LT, DIST_POS_LT] THEN
  DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[real_div, GE, REAL_MUL_ASSOC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, GSYM real_div, DIST_POS_LT] THEN
  ASM_SIMP_TAC std_ss [GSYM REAL_LT_LDIV_EQ, REAL_SUB_LT] THEN DISCH_TAC THEN
  SIMP_TAC std_ss [LESS_EQ_EXISTS, LEFT_IMP_EXISTS_THM] THEN
  X_GEN_TAC ``d:num`` THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
  FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP(REAL_ARITH
    ``d < e ==> x <= d ==> x < e:real``)) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_RDIV_EQ, REAL_SUB_LT] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``N:num``, ``d:num``]) THEN
  MATCH_MP_TAC(REAL_ARITH
  ``(c * d) * e <= (c * d) * &1 ==> x * y <= c * d * e ==> y * x <= c * d:real``) THEN
  MATCH_MP_TAC REAL_LE_LMUL_IMP THEN
  ASM_SIMP_TAC std_ss [REAL_LE_MUL, POW_POS, DIST_POS_LE, REAL_ARITH
   ``&0 <= x ==> &1 - x <= &1:real``]);

(* ------------------------------------------------------------------------- *)
(* Dini's theorem.                                                           *)
(* ------------------------------------------------------------------------- *)

val DINI = store_thm ("DINI",
 ``!f:num->real->real g s.
        compact s /\ (!n. (f n) continuous_on s) /\ g continuous_on s /\
        (!x. x IN s ==> ((\n. (f n x)) --> g x) sequentially) /\
        (!n x. x IN s ==> (f n x) <= (f (n + 1) x))
        ==> !e. &0 < e
                ==> eventually (\n. !x. x IN s ==> abs(f n x - g x) < e)
                               sequentially``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN
   ``!x:real m n:num. x IN s /\ m <= n ==> (f m x):real <= (f n x)``
  ASSUME_TAC THENL
   [GEN_TAC THEN ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
    ONCE_REWRITE_TAC [METIS [] ``!m n. (f:num->real->real) m x <= f n x <=>
                                       (\m n. f m x <= f n x) m n``] THEN
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM_SIMP_TAC std_ss [ADD1] THEN
    REAL_ARITH_TAC, ALL_TAC] THEN
  SUBGOAL_THEN ``!n:num x:real. x IN s ==> (f n x):real <= (g x)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN
    MATCH_MP_TAC(ISPEC ``sequentially`` LIM_DROP_LE) THEN
    EXISTS_TAC ``\m:num. (f:num->real->real) n x`` THEN
    EXISTS_TAC ``\m:num. (f:num->real->real) m x`` THEN
    ASM_SIMP_TAC std_ss [LIM_CONST, TRIVIAL_LIMIT_SEQUENTIALLY] THEN
    REWRITE_TAC[EVENTUALLY_SEQUENTIALLY] THEN ASM_MESON_TAC[],
    ALL_TAC] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[LIM_SEQUENTIALLY, dist]) THEN
  UNDISCH_TAC ``compact s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE
   [COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY]) THEN
  DISCH_THEN(MP_TAC o SPEC
   ``IMAGE (\n. { x | x IN s /\ abs((f:num->real->real) n x - g x) < e})
          univ(:num)``) THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE, IN_UNIV] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
  SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, SUBSET_UNION, BIGUNION_IMAGE] THEN
  SIMP_TAC std_ss [IN_UNIV, GSPECIFICATION, EVENTUALLY_SEQUENTIALLY] THEN
  SIMP_TAC std_ss [SUBSET_DEF, IN_UNIV, GSPECIFICATION] THEN
  KNOW_TAC ``(!(n :num).
    open_in (subtopology euclidean (s :real -> bool))
      {x |
       x IN s /\
       abs ((f :num -> real -> real) n x - (g :real -> real) x) <
       (e :real)}) /\
 (!(x :real). x IN s ==> ?(n :num). abs (f n x - g x) < e)`` THENL
   [CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[LESS_EQ_REFL]] THEN
    X_GEN_TAC ``n:num`` THEN REWRITE_TAC[GSYM IN_BALL_0] THEN
    ONCE_REWRITE_TAC [METIS [] ``f n x - g x =
          (\x. (f:num->real->real) n x - g x) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE THEN
    METIS_TAC [OPEN_BALL, CONTINUOUS_ON_SUB, ETA_AX],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    DISCH_THEN(X_CHOOSE_THEN ``k:num->bool`` (CONJUNCTS_THEN2
     (MP_TAC o SPEC ``\n:num. n`` o MATCH_MP UPPER_BOUND_FINITE_SET)
     ASSUME_TAC)) THEN
    DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN EXISTS_TAC ``N:num`` THEN
    POP_ASSUM MP_TAC THEN
    SIMP_TAC std_ss [] THEN STRIP_TAC THEN X_GEN_TAC ``n:num`` THEN
    DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``!x. x IN s ==> ?n. n IN k /\
                  abs ((f:num->real->real) n x - g x) < e`` THEN
    DISCH_TAC THEN
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``m:num`` (CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    MATCH_MP_TAC(REAL_ARITH
     ``m <= n /\ n <= g ==> abs(m - g) < e ==> abs(n - g) < e:real``) THEN
    METIS_TAC[LESS_EQ_TRANS]]);

(* ------------------------------------------------------------------------- *)
(* Closest point of a (closed) set to a point.                               *)
(* ------------------------------------------------------------------------- *)

val closest_point = new_definition ("closest_point",
 ``closest_point s a = @x. x IN s /\ !y. y IN s ==> dist(a,x) <= dist(a,y)``);

val CLOSEST_POINT_EXISTS = store_thm ("CLOSEST_POINT_EXISTS",
 ``!s a. closed s /\ ~(s = {})
         ==> (closest_point s a) IN s /\
             !y. y IN s ==> dist(a,closest_point s a) <= dist(a,y)``,
  REWRITE_TAC[closest_point] THEN CONV_TAC(ONCE_DEPTH_CONV SELECT_CONV) THEN
  REWRITE_TAC[DISTANCE_ATTAINS_INF]);

val CLOSEST_POINT_IN_SET = store_thm ("CLOSEST_POINT_IN_SET",
 ``!s a. closed s /\ ~(s = {}) ==> (closest_point s a) IN s``,
  MESON_TAC[CLOSEST_POINT_EXISTS]);

val CLOSEST_POINT_LE = store_thm ("CLOSEST_POINT_LE",
 ``!s a x. closed s /\ x IN s ==> dist(a,closest_point s a) <= dist(a,x)``,
  MESON_TAC[CLOSEST_POINT_EXISTS, MEMBER_NOT_EMPTY]);

val CLOSEST_POINT_SELF = store_thm ("CLOSEST_POINT_SELF",
 ``!s x:real. x IN s ==> (closest_point s x = x)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[closest_point] THEN
  MATCH_MP_TAC SELECT_UNIQUE THEN REWRITE_TAC[] THEN GEN_TAC THEN EQ_TAC THENL
   [BETA_TAC THEN STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [DIST_LE_0, DIST_REFL],
    BETA_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[DIST_REFL, DIST_POS_LE]]);

val CLOSEST_POINT_REFL = store_thm ("CLOSEST_POINT_REFL",
 ``!s x:real. closed s /\ ~(s = {}) ==> ((closest_point s x = x) <=> x IN s)``,
  MESON_TAC[CLOSEST_POINT_IN_SET, CLOSEST_POINT_SELF]);

val DIST_CLOSEST_POINT_LIPSCHITZ = store_thm ("DIST_CLOSEST_POINT_LIPSCHITZ",
 ``!s x y:real.
        closed s /\ ~(s = {})
        ==> abs(dist(x,closest_point s x) - dist(y,closest_point s y))
            <= dist(x,y)``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP CLOSEST_POINT_EXISTS) THEN
  DISCH_THEN(fn th =>
    CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC o SPEC ``closest_point s (y:real)``) (SPEC ``x:real`` th) THEN
    CONJUNCTS_THEN2 ASSUME_TAC
     (MP_TAC o SPEC ``closest_point s (x:real)``) (SPEC ``y:real`` th)) THEN
  ASM_SIMP_TAC std_ss [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_AT_DIST_CLOSEST_POINT = store_thm ("CONTINUOUS_AT_DIST_CLOSEST_POINT",
 ``!s x:real.
        closed s /\ ~(s = {})
        ==> (\x. (dist(x,closest_point s x))) continuous (at x)``,
  REPEAT STRIP_TAC THEN SIMP_TAC std_ss [continuous_at] THEN REWRITE_TAC [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] DIST_CLOSEST_POINT_LIPSCHITZ, REAL_LET_TRANS]);

val CONTINUOUS_ON_DIST_CLOSEST_POINT = store_thm ("CONTINUOUS_ON_DIST_CLOSEST_POINT",
 ``!s t. closed s /\ ~(s = {})
         ==> (\x. (dist(x,closest_point s x))) continuous_on t``,
  METIS_TAC[CONTINUOUS_AT_IMP_CONTINUOUS_ON,
            CONTINUOUS_AT_DIST_CLOSEST_POINT]);

val UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT = store_thm ("UNIFORMLY_CONTINUOUS_ON_DIST_CLOSEST_POINT",
 ``!s t:real->bool.
        closed s /\ ~(s = {})
        ==> (\x. (dist(x,closest_point s x))) uniformly_continuous_on t``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  REWRITE_TAC [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] DIST_CLOSEST_POINT_LIPSCHITZ, REAL_LET_TRANS]);

val SEGMENT_TO_CLOSEST_POINT = store_thm ("SEGMENT_TO_CLOSEST_POINT",
 ``!s a:real.
        closed s /\ ~(s = {})
        ==> (segment(a,closest_point s a) INTER s = {})``,
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[SET_RULE ``(s INTER t = {}) <=> !x. x IN s ==> ~(x IN t)``] THEN
  GEN_TAC THEN DISCH_THEN(MP_TAC o MATCH_MP DIST_IN_OPEN_SEGMENT) THEN
  MATCH_MP_TAC(TAUT `(r ==> ~p) ==> p /\ q ==> ~r`) THEN
  METIS_TAC [CLOSEST_POINT_EXISTS, REAL_NOT_LT, DIST_SYM]);

val SEGMENT_TO_POINT_EXISTS = store_thm ("SEGMENT_TO_POINT_EXISTS",
 ``!s a:real.
        closed s /\ ~(s = {}) ==> ?b. b IN s /\ (segment(a,b) INTER s = {})``,
  MESON_TAC[SEGMENT_TO_CLOSEST_POINT, CLOSEST_POINT_EXISTS]);

val CLOSEST_POINT_IN_INTERIOR = store_thm
  ("CLOSEST_POINT_IN_INTERIOR",
 ``!s x:real.
        closed s /\ ~(s = {})
        ==> ((closest_point s x) IN interior s <=> x IN interior s)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``(x:real) IN s`` THEN
  ASM_SIMP_TAC std_ss [CLOSEST_POINT_SELF] THEN
  MATCH_MP_TAC(TAUT `~q /\ ~p ==> (p <=> q)`) THEN
  CONJ_TAC THENL [METIS_TAC[INTERIOR_SUBSET, SUBSET_DEF], STRIP_TAC] THEN
  FIRST_ASSUM(MP_TAC o REWRITE_RULE [IN_INTERIOR_CBALL]) THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN ``closest_point s (x:real) IN s`` ASSUME_TAC THENL
   [METIS_TAC[INTERIOR_SUBSET, SUBSET_DEF], ALL_TAC] THEN
  SUBGOAL_THEN ``~(closest_point s (x:real) = x)`` ASSUME_TAC THENL
   [ASM_MESON_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``x:real``,
  ``closest_point s x -
    (min (&1) (e / abs(closest_point s x - x))) *
    (closest_point s x - x):real``]
    CLOSEST_POINT_LE) THEN
  ASM_REWRITE_TAC[dist, NOT_IMP, REAL_ARITH
   ``x - (y - e * (y - x)):real = (&1 - e) * (x - y:real)``] THEN
  CONJ_TAC THENL
  [ (* goal 1 (of 2) *)
    UNDISCH_TAC ``cball (closest_point s x,e) SUBSET s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
    REWRITE_TAC[dist, IN_CBALL, REAL_ARITH ``abs(a:real - a - x) = abs x``] THEN
    SIMP_TAC real_ss [ABS_MUL, ABS_DIV, ABS_ABS] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [GSYM REAL_SUB_0]) THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [ABS_NZ]) THEN

    ASM_SIMP_TAC std_ss [GSYM REAL_LE_RDIV_EQ, min_def] THEN
    KNOW_TAC ``!a:real. &0 <= a ==> abs (if 1 <= a then 1 else a) <= a``
    >- ( RW_TAC real_ss [] >> PROVE_TAC [abs, REAL_LE_REFL] ) THEN
    DISCH_THEN MATCH_MP_TAC THEN
    ASM_SIMP_TAC std_ss [REAL_LT_IMP_LE, REAL_LE_DIV, ABS_POS],
    (* goal 2 (of 2) *)
    REWRITE_TAC[ABS_MUL, REAL_ARITH
     ``~(n <= a * n) <=> &0 < (&1 - a) * n:real``] THEN
    MATCH_MP_TAC REAL_LT_MUL THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(a <> b) <=> (b - a <> 0:real)``]) THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [ABS_NZ]) THEN ASM_SIMP_TAC std_ss [] THEN
    KNOW_TAC ``!e:real. &0 < e /\ e <= &1 ==> &0 < &1 - abs(&1 - e)``
    >- ( RW_TAC real_ss [] \\
         `0 <= 1 - e'` by ASM_REAL_ARITH_TAC \\
         ASM_SIMP_TAC real_ss [abs] ) THEN
    DISCH_THEN MATCH_MP_TAC THEN
    REWRITE_TAC[REAL_MIN_LE, REAL_LT_MIN, REAL_LT_01, REAL_LE_REFL] THEN
    METIS_TAC [REAL_LT_DIV, ABS_SUB] ]);

val CLOSEST_POINT_IN_FRONTIER = store_thm ("CLOSEST_POINT_IN_FRONTIER",
 ``!s x:real.
        closed s /\ ~(s = {}) /\ ~(x IN interior s)
        ==> (closest_point s x) IN frontier s``,
  SIMP_TAC std_ss [frontier, IN_DIFF, CLOSEST_POINT_IN_INTERIOR] THEN
  SIMP_TAC std_ss [CLOSEST_POINT_IN_SET, CLOSURE_CLOSED]);

(* ------------------------------------------------------------------------- *)
(* More general infimum of distance between two sets.                        *)
(* ------------------------------------------------------------------------- *)

(* This is a generalized ‘setdist’ with a metric parameter d *)
Definition set_dist_def :
    set_dist (d :'a metric) ((s,t) :'a set # 'a set) =
      if (s = {}) \/ (t = {}) then (0 :real)
      else inf {dist d (x,y) | x IN s /\ y IN t}
End

(* New definition of ‘setdist’ *)
Overload setdist = “set_dist mr1”

(* Old definition of ‘diameter’ (now becomes a theorem) *)
Theorem setdist :
    !s t. setdist(s,t) =
          if (s = {}) \/ (t = {}) then (&0 :real)
          else inf {dist(x,y) | x IN s /\ y IN t}
Proof
    RW_TAC std_ss [GSYM dist_def, dist, set_dist_def]
QED

val SETDIST_EMPTY = store_thm ("SETDIST_EMPTY",
 ``(!t. setdist({},t) = &0) /\ (!s. setdist(s,{}) = &0)``,
  REWRITE_TAC[setdist]);

val SETDIST_POS_LE = store_thm ("SETDIST_POS_LE",
 ``!s t. &0 <= setdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_INF THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, DIST_POS_LE] THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_SUBSETS_EQ = store_thm ("SETDIST_SUBSETS_EQ",
 ``!s t s' t':real->bool.
     s' SUBSET s /\ t' SUBSET t /\
     (!x y. x IN s /\ y IN t
            ==> ?x' y'. x' IN s' /\ y' IN t' /\ dist(x',y') <= dist(x,y))
     ==> (setdist(s',t') = setdist(s,t))``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [ASM_CASES_TAC ``s':real->bool = {}`` THEN
    ASM_REWRITE_TAC[SETDIST_EMPTY] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [ASM_CASES_TAC ``t':real->bool = {}`` THEN
    ASM_REWRITE_TAC[SETDIST_EMPTY] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``s':real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  ASM_CASES_TAC ``t':real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  ASM_REWRITE_TAC[setdist] THEN MATCH_MP_TAC INF_EQ THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  CONJ_TAC >- (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
                                EXISTS_PROD, NOT_IN_EMPTY] \\
               fs [GSYM MEMBER_NOT_EMPTY] \\
               rename1 `a IN s'` >> Q.EXISTS_TAC `a` \\
               rename1 `b IN t'` >> Q.EXISTS_TAC `b` \\
               ASM_REWRITE_TAC []) \\
  CONJ_TAC >- (Q.EXISTS_TAC `0` >> rw [DIST_POS_LE]) \\
  CONJ_TAC >- (SIMP_TAC std_ss [EXTENSION, GSPECIFICATION,
                                EXISTS_PROD, NOT_IN_EMPTY] \\
               fs [GSYM MEMBER_NOT_EMPTY] \\
               rename1 `a IN s` >> Q.EXISTS_TAC `a` \\
               rename1 `b IN t` >> Q.EXISTS_TAC `b` \\
               ASM_REWRITE_TAC []) \\
  CONJ_TAC >- (Q.EXISTS_TAC `0` >> rw [DIST_POS_LE]) \\
  ASM_MESON_TAC[SUBSET_DEF, REAL_LE_TRANS]);

val REAL_LE_SETDIST = store_thm ("REAL_LE_SETDIST",
  ``!s t:real->bool d.
        ~(s = {}) /\ ~(t = {}) /\
        (!x y. x IN s /\ y IN t ==> d <= dist(x,y))
        ==> d <= setdist(s,t)``,
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[setdist] THEN
  MP_TAC(ISPEC ``{dist(x:real,y) | x IN s /\ y IN t}`` INF) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{dist (x,y) | x IN s /\ y IN t} <> {} /\
             (?b. !x y. x IN s /\ y IN t ==> b <= dist (x,y))`` THENL
   [CONJ_TAC THENL
    [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
     ASM_SET_TAC[], MESON_TAC[DIST_POS_LE]],
     DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_MESON_TAC[]);

val SETDIST_LE_DIST = store_thm ("SETDIST_LE_DIST",
 ``!s t x y:real. x IN s /\ y IN t ==> setdist(s,t) <= dist(x,y)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN
  COND_CASES_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPEC ``{dist(x:real,y) | x IN s /\ y IN t}`` INF) THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC] THEN
  KNOW_TAC ``{dist (x,y) | x IN s /\ y IN t} <> {} /\
             (?b. !x y. x IN s /\ y IN t ==> b <= dist (x,y))`` THENL
   [CONJ_TAC THENL
    [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
     ASM_SET_TAC[], MESON_TAC[DIST_POS_LE]],
     DISCH_TAC THEN ASM_REWRITE_TAC []] THEN
  ASM_MESON_TAC[]);

val REAL_LE_SETDIST_EQ = store_thm ("REAL_LE_SETDIST_EQ",
 ``!d s t:real->bool.
        d <= setdist(s,t) <=>
        (!x y. x IN s /\ y IN t ==> d <= dist(x,y)) /\
        ((s = {}) \/ (t = {}) ==> d <= &0)``,
  REPEAT GEN_TAC THEN MAP_EVERY ASM_CASES_TAC
   [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, NOT_IN_EMPTY] THEN
  ASM_MESON_TAC[REAL_LE_SETDIST, SETDIST_LE_DIST, REAL_LE_TRANS]);

val REAL_SETDIST_LT_EXISTS = store_thm ("REAL_SETDIST_LT_EXISTS",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\ setdist(s,t) < b
        ==> ?x y. x IN s /\ y IN t /\ dist(x,y) < b``,
  REWRITE_TAC[GSYM REAL_NOT_LE, REAL_LE_SETDIST_EQ] THEN MESON_TAC[]);

val SETDIST_REFL = store_thm ("SETDIST_REFL",
 ``!s:real->bool. setdist(s,s) = &0``,
  GEN_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM, SETDIST_POS_LE] THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [ASM_REWRITE_TAC[setdist, REAL_LE_REFL], ALL_TAC] THEN
  ASM_MESON_TAC[SETDIST_LE_DIST, MEMBER_NOT_EMPTY, DIST_REFL]);

val SETDIST_SYM = store_thm ("SETDIST_SYM",
 ``!s t. setdist(s,t) = setdist(t,s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[setdist] THEN ONCE_REWRITE_TAC [DISJ_SYM] THEN
  COND_CASES_TAC THEN ONCE_REWRITE_TAC [DISJ_SYM] THEN ASM_SIMP_TAC std_ss [] THEN
  AP_TERM_TAC THEN SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
  METIS_TAC[DIST_SYM]);

val SETDIST_TRIANGLE = store_thm ("SETDIST_TRIANGLE",
 ``!s a t:real->bool.
        setdist(s,t) <= setdist(s,{a}) + setdist({a},t)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_ADD_LID, SETDIST_POS_LE] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_ADD_RID, SETDIST_POS_LE] THEN
  ONCE_REWRITE_TAC[GSYM REAL_LE_SUB_RADD] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN
  ASM_SIMP_TAC std_ss [NOT_INSERT_EMPTY, IN_SING, CONJ_EQ_IMP,
                  RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``x - y <= z <=> x - z <= y:real``] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN
  ASM_REWRITE_TAC[NOT_INSERT_EMPTY, IN_SING, CONJ_EQ_IMP,
                  RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``y:real`` THEN REPEAT STRIP_TAC THEN
  REWRITE_TAC[REAL_LE_SUB_RADD] THEN MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``dist(x:real,y')`` THEN
  ASM_SIMP_TAC std_ss [SETDIST_LE_DIST, dist] THEN REAL_ARITH_TAC);

val SETDIST_SINGS = store_thm ("SETDIST_SINGS",
 ``!x y. setdist({x},{y}) = dist(x,y)``,
  REWRITE_TAC[setdist, NOT_INSERT_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (x,y) = (\x y. dist (x,y)) x y``] THEN
  KNOW_TAC ``!f:real->real->real x y a b. {f x y | x IN {a} /\ y IN {b}} = {f a b}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [],
   DISCH_TAC] THEN ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [INF_INSERT_FINITE, FINITE_EMPTY]);

val SETDIST_LIPSCHITZ = store_thm ("SETDIST_LIPSCHITZ",
 ``!s t x y:real. abs(setdist({x},s) - setdist({y},s)) <= dist(x,y)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM SETDIST_SINGS] THEN
  REWRITE_TAC[REAL_ARITH
   ``abs(x - y) <= z <=> x <= z + y /\ y <= z + x:real``] THEN
  MESON_TAC[SETDIST_TRIANGLE, SETDIST_SYM]);

val CONTINUOUS_AT_SETDIST = store_thm ("CONTINUOUS_AT_SETDIST",
 ``!s x:real. (\y. setdist({y},s)) continuous (at x)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[continuous_at] THEN
  SIMP_TAC std_ss [dist] THEN
  METIS_TAC[REWRITE_RULE [dist] SETDIST_LIPSCHITZ, REAL_LET_TRANS]);

val CONTINUOUS_ON_SETDIST = store_thm ("CONTINUOUS_ON_SETDIST",
 ``!s t:real->bool. (\y. setdist({y},s)) continuous_on t``,
  METIS_TAC[CONTINUOUS_AT_IMP_CONTINUOUS_ON,
            CONTINUOUS_AT_SETDIST]);

val UNIFORMLY_CONTINUOUS_ON_SETDIST = store_thm ("UNIFORMLY_CONTINUOUS_ON_SETDIST",
 ``!s t:real->bool.
         (\y. setdist({y},s)) uniformly_continuous_on t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[uniformly_continuous_on] THEN
  BETA_TAC THEN METIS_TAC[dist, SETDIST_LIPSCHITZ, REAL_LET_TRANS]);

val SETDIST_DIFFERENCES = store_thm ("SETDIST_DIFFERENCES",
 ``!s t. setdist(s,t) = setdist({0},{x - y:real | x IN s /\ y IN t})``,
  REPEAT GEN_TAC THEN
  KNOW_TAC ``!f:real->real->real x y s t.
   ({f x y | x IN s /\ y IN t} = {}) <=> (s = {}) \/ (t = {})`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN SET_TAC [],
   DISCH_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``x - y = (\x y. x - y) x y:real``] THEN
  ASM_REWRITE_TAC[setdist, NOT_INSERT_EMPTY] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [] THEN AP_TERM_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, IN_SING, EXISTS_PROD] THEN
  SIMP_TAC std_ss [GSYM CONJ_ASSOC, RIGHT_EXISTS_AND_THM, UNWIND_THM2, DIST_0] THEN
  REWRITE_TAC[dist] THEN MESON_TAC[]);

val SETDIST_SUBSET_RIGHT = store_thm ("SETDIST_SUBSET_RIGHT",
 ``!s t u:real->bool.
    ~(t = {}) /\ t SUBSET u ==> setdist(s,u) <= setdist(s,t)``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``u:real->bool = {}``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_EMPTY, SETDIST_POS_LE, REAL_LE_REFL] THEN
  ASM_REWRITE_TAC[setdist] THEN MATCH_MP_TAC REAL_LE_INF_SUBSET THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, SUBSET_DEF, EXISTS_PROD, GSPECIFICATION] THEN
  REPEAT(CONJ_TAC THENL
  [ASM_SIMP_TAC std_ss [EXTENSION, EXISTS_PROD, GSPECIFICATION] THEN ASM_SET_TAC[],
   ALL_TAC]) THEN METIS_TAC[DIST_POS_LE]);

val SETDIST_SUBSET_LEFT = store_thm ("SETDIST_SUBSET_LEFT",
 ``!s t u:real->bool.
    ~(s = {}) /\ s SUBSET t ==> setdist(t,u) <= setdist(s,u)``,
  MESON_TAC[SETDIST_SUBSET_RIGHT, SETDIST_SYM]);

val SETDIST_CLOSURE = store_thm ("SETDIST_CLOSURE",
 ``(!s t:real->bool. setdist(closure s,t) = setdist(s,t)) /\
   (!s t:real->bool. setdist(s,closure t) = setdist(s,t))``,
  REWRITE_TAC [METIS [SWAP_FORALL_THM]
   ``(!s t. setdist (s,closure t) = setdist (s,t)) =
     (!t s. setdist (s,closure t) = setdist (s,t))``] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SETDIST_SYM] THEN
  SIMP_TAC std_ss [] THEN
  REWRITE_TAC[MESON[REAL_LE_ANTISYM]
   ``(x:real = y) <=> !d. d <= x <=> d <= y``] THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[CLOSURE_EQ_EMPTY, CLOSURE_EMPTY, NOT_IN_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``d <= dist (x,y) <=> (\x y. d <= dist (x,y)) x y``] THEN
  ONCE_REWRITE_TAC [METIS [] ``x IN s /\ y IN t <=> x IN s /\ (\y. y IN t) y``] THEN
  MATCH_MP_TAC(SET_RULE
   ``s SUBSET c /\
    (!y. Q y /\ (!x. x IN s ==> P x y) ==> (!x. x IN c ==> P x y))
   ==> ((!x y. x IN c /\ Q y ==> P x y) <=>
        (!x y. x IN s /\ Q y ==> P x y))``) THEN
  SIMP_TAC std_ss [CLOSURE_SUBSET] THEN GEN_TAC THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``dist (x,y) = (\x. dist (x, y)) x``] THEN
  MATCH_MP_TAC CONTINUOUS_GE_ON_CLOSURE THEN ASM_SIMP_TAC std_ss [] THEN
  ASM_SIMP_TAC std_ss [o_DEF, dist] THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y) = abs ((\x. x - y) x:real)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_ABS_COMPOSE THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID]);

val SETDIST_FRONTIER = store_thm ("SETDIST_FRONTIER",
 ``(!s t:real->bool.
        DISJOINT s t ==> (setdist(frontier s,t) = setdist(s,t))) /\
   (!s t:real->bool.
        DISJOINT s t ==> (setdist(s,frontier t) = setdist(s,t)))``,
  MATCH_MP_TAC(TAUT `(p ==> q) /\ p ==> p /\ q`) THEN
  CONJ_TAC THENL [MESON_TAC[SETDIST_SYM, DISJOINT_SYM], ALL_TAC] THEN
  REPEAT STRIP_TAC THEN
  GEN_REWR_TAC RAND_CONV [GSYM(CONJUNCT1 SETDIST_CLOSURE)] THEN
  MATCH_MP_TAC SETDIST_SUBSETS_EQ THEN
  SIMP_TAC std_ss [frontier, IN_DIFF, DIFF_SUBSET, SUBSET_REFL] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  ASM_CASES_TAC  ``(x:real) IN interior s`` THENL
   [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN
  KNOW_TAC ``?y' x'. (x' IN closure s /\ x' NOTIN interior s) /\
                      y' IN t /\ dist (x',y') <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  EXISTS_TAC ``y:real`` THEN ASM_REWRITE_TAC[] THEN
  MP_TAC(ISPECL [``segment[x:real,y]``, ``s:real->bool``]
        CONNECTED_INTER_FRONTIER) THEN
  REWRITE_TAC[CONNECTED_SEGMENT, GSYM MEMBER_NOT_EMPTY] THEN
  KNOW_TAC ``(?x'. x' IN segment [(x,y)] INTER s) /\
             (?x'. x' IN segment [(x,y)] DIFF s)`` THENL
   [CONJ_TAC THENL [EXISTS_TAC ``x:real``, EXISTS_TAC ``y:real``] THEN
    ASM_SIMP_TAC std_ss [IN_INTER, IN_DIFF, ENDS_IN_SEGMENT] THEN
    MP_TAC(ISPEC ``s:real->bool`` INTERIOR_SUBSET) THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
    POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [IN_INTER, frontier, IN_DIFF] THEN
    MESON_TAC[DIST_IN_CLOSED_SEGMENT]]);

val SETDIST_COMPACT_CLOSED = store_thm ("SETDIST_COMPACT_CLOSED",
 ``!s t:real->bool.
        compact s /\ closed t /\ ~(s = {}) /\ ~(t = {})
        ==> ?x y. x IN s /\ y IN t /\ (dist(x,y) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
  KNOW_TAC ``?x y. (\x. x IN s) x /\ (\y. y IN t) y /\
                   (\x y. dist (x,y) <= setdist (s,t)) x y /\
                   (\x y. setdist (s,t) <= dist (x,y)) x y`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS []
   ``(!x y. P x /\ Q y ==> R' x y) /\ (?x y. (P x /\ Q y /\ R x y))
    ==> (?x y. P x /\ Q y /\ R x y /\ R' x y)``) THEN
  SIMP_TAC std_ss [SETDIST_LE_DIST] THEN
  ASM_REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
        DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [COMPACT_CLOSED_DIFFERENCES, EXISTS_IN_GSPEC, FORALL_IN_GSPEC,
               DIST_0, GSYM CONJ_ASSOC, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[dist] THEN DISCH_THEN MATCH_MP_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_CLOSED_COMPACT = store_thm ("SETDIST_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t /\ ~(s = {}) /\ ~(t = {})
        ==> ?x y. x IN s /\ y IN t /\ (dist(x,y) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN
   KNOW_TAC ``?x y. (\x. x IN s) x /\ (\y. y IN t) y /\
                   (\x y. dist (x,y) <= setdist (s,t)) x y /\
                   (\x y. setdist (s,t) <= dist (x,y)) x y`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  MATCH_MP_TAC(METIS[]
   ``(!x y. P x /\ Q y ==> R' x y) /\ (?x y. P x /\ Q y /\ R x y)
    ==> ?x y. P x /\ Q y /\ R x y /\ R' x y``) THEN
  SIMP_TAC std_ss [SETDIST_LE_DIST] THEN
  ASM_REWRITE_TAC[REAL_LE_SETDIST_EQ] THEN
  MP_TAC(ISPECL [``{x - y:real | x IN s /\ y IN t}``, ``0:real``]
        DISTANCE_ATTAINS_INF) THEN
  ASM_SIMP_TAC std_ss [CLOSED_COMPACT_DIFFERENCES, EXISTS_IN_GSPEC, FORALL_IN_GSPEC,
               DIST_0, GSYM CONJ_ASSOC, GSPECIFICATION, EXISTS_PROD] THEN
  REWRITE_TAC[dist] THEN DISCH_THEN MATCH_MP_TAC THEN
  SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN ASM_SET_TAC[]);

val SETDIST_EQ_0_COMPACT_CLOSED = store_thm ("SETDIST_EQ_0_COMPACT_CLOSED",
 ``!s t:real->bool.
        compact s /\ closed t
        ==> ((setdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ ~(s INTER t = {}))``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY] THEN EQ_TAC THENL
   [MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``]
      SETDIST_COMPACT_CLOSED) THEN ASM_REWRITE_TAC[] THEN
    REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN MESON_TAC[DIST_EQ_0],
    REWRITE_TAC[GSYM REAL_LE_ANTISYM, SETDIST_POS_LE] THEN
    REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN
    MESON_TAC[SETDIST_LE_DIST, DIST_EQ_0]]);

val SETDIST_EQ_0_CLOSED_COMPACT = store_thm ("SETDIST_EQ_0_CLOSED_COMPACT",
 ``!s t:real->bool.
        closed s /\ compact t
        ==> ((setdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ ~(s INTER t = {}))``,
  ONCE_REWRITE_TAC[SETDIST_SYM] THEN
  SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED] THEN SET_TAC[]);

val SETDIST_EQ_0_BOUNDED = store_thm ("SETDIST_EQ_0_BOUNDED",
 ``!s t:real->bool.
        (bounded s \/ bounded t)
        ==> ((setdist(s,t) = &0) <=>
             (s = {}) \/ (t = {}) \/ ~(closure(s) INTER closure(t) = {}))``,
  REPEAT GEN_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY] THEN STRIP_TAC THEN
  ONCE_REWRITE_TAC[MESON[SETDIST_CLOSURE]
   ``setdist(s,t) = setdist(closure s,closure t)``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED, SETDIST_EQ_0_CLOSED_COMPACT,
               COMPACT_CLOSURE, CLOSED_CLOSURE, CLOSURE_EQ_EMPTY]);

val SETDIST_TRANSLATION = store_thm ("SETDIST_TRANSLATION",
 ``!a:real s t.
        setdist(IMAGE (\x. a + x) s,IMAGE (\x. a + x) t) = setdist(s,t)``,
  REPEAT GEN_TAC THEN ONCE_REWRITE_TAC[SETDIST_DIFFERENCES] THEN
  AP_TERM_TAC THEN AP_TERM_TAC THEN
  KNOW_TAC ``!f:real->real->real x:real y:real g:real->real s:real->bool t:real->bool.
   {f x y | x IN IMAGE g s /\ y IN IMAGE g t} = {f (g x) (g y) | x IN s /\ y IN t}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
   ASM_SET_TAC[], DISCH_TAC] THEN
  ONCE_REWRITE_TAC [METIS [] ``x - y = (\x y. x - y) x y:real``] THEN
  ASM_REWRITE_TAC [] THEN
  SIMP_TAC std_ss [REAL_ARITH ``(a + x) - (a + y):real = x - y``]);

val SETDIST_LINEAR_IMAGE = store_thm ("SETDIST_LINEAR_IMAGE",
 ``!f:real->real s t.
        linear f /\ (!x. abs(f x) = abs x)
        ==> (setdist(IMAGE f s,IMAGE f t) = setdist(s,t))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[setdist, IMAGE_EQ_EMPTY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[dist] THEN AP_TERM_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``abs (x - y) = (\x y. abs (x - y)) x y:real``] THEN
  KNOW_TAC ``!f:real->real->real x:real y:real g:real->real s:real->bool t:real->bool.
   {f x y | x IN IMAGE g s /\ y IN IMAGE g t} = {f (g x) (g y) | x IN s /\ y IN t}`` THENL
  [SIMP_TAC std_ss [EXTENSION, GSPECIFICATION, EXISTS_PROD] THEN
   ASM_SET_TAC[], DISCH_TAC] THEN ASM_REWRITE_TAC [] THEN BETA_TAC THEN
  FIRST_X_ASSUM(fn th => REWRITE_TAC[GSYM(MATCH_MP LINEAR_SUB th)]) THEN
  ASM_SIMP_TAC std_ss []);

val SETDIST_UNIQUE = store_thm ("SETDIST_UNIQUE",
 ``!s t a b:real d.
        a IN s /\ b IN t /\ (dist(a,b) = d) /\
        (!x y. x IN s /\ y IN t ==> dist(a,b) <= dist(x,y))
        ==> (setdist(s,t) = d)``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [ASM_MESON_TAC[SETDIST_LE_DIST],
    MATCH_MP_TAC REAL_LE_SETDIST THEN ASM_SET_TAC[]]);

val SETDIST_UNIV = store_thm ("SETDIST_UNIV",
 ``(!s. setdist(s,univ(:real)) = &0) /\
   (!t. setdist(univ(:real),t) = &0)``,
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [SETDIST_SYM] THEN
  REWRITE_TAC[] THEN X_GEN_TAC ``s:real->bool`` THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[SETDIST_EMPTY] THEN
  MATCH_MP_TAC SETDIST_UNIQUE THEN
  SIMP_TAC std_ss [IN_UNIV, DIST_EQ_0, RIGHT_EXISTS_AND_THM] THEN
  ASM_REWRITE_TAC[UNWIND_THM1, DIST_REFL, DIST_POS_LE, MEMBER_NOT_EMPTY]);

val SETDIST_ZERO = store_thm ("SETDIST_ZERO",
 ``!s t:real->bool. ~(DISJOINT s t) ==> (setdist(s,t) = &0)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_UNIQUE THEN
  KNOW_TAC ``?a. a IN s /\ a IN t /\ (dist (a,a) = 0) /\
             !x y. x IN s /\ y IN t ==> dist (a,a) <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC []] THEN
  ONCE_REWRITE_TAC[TAUT `p /\ q /\ r /\ s <=> r /\ p /\ q /\ s`] THEN
  REWRITE_TAC[DIST_EQ_0, UNWIND_THM2, DIST_REFL, DIST_POS_LE] THEN
  ASM_SET_TAC[]);

val SETDIST_ZERO_STRONG = store_thm ("SETDIST_ZERO_STRONG",
 ``!s t:real->bool.
      ~(DISJOINT (closure s) (closure t)) ==> (setdist(s,t) = &0)``,
  MESON_TAC[SETDIST_CLOSURE, SETDIST_ZERO]);

val SETDIST_FRONTIERS = store_thm ("SETDIST_FRONTIERS",
 ``!s t:real->bool.
        setdist(s,t) =
        if DISJOINT s t then setdist(frontier s,frontier t) else &0``,
  REPEAT STRIP_TAC THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC std_ss [SETDIST_ZERO] THEN
  ASSUME_TAC SETDIST_FRONTIER THEN POP_ASSUM (MP_TAC o ONCE_REWRITE_RULE [EQ_SYM_EQ]) THEN
  DISCH_THEN (CONJUNCTS_THEN2 K_TAC ASSUME_TAC) THEN ASM_SIMP_TAC std_ss [] THEN
  POP_ASSUM K_TAC THEN
  ASM_CASES_TAC ``DISJOINT s (frontier t:real->bool)`` THENL
   [ASM_MESON_TAC[SETDIST_FRONTIER], ALL_TAC] THEN
  GEN_REWR_TAC LAND_CONV [GSYM(CONJUNCT1 SETDIST_CLOSURE)] THEN
  CONV_TAC SYM_CONV THEN MATCH_MP_TAC SETDIST_SUBSETS_EQ THEN
  SIMP_TAC std_ss [frontier, DIFF_SUBSET, SUBSET_REFL, IN_DIFF] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  KNOW_TAC ``?y' x'.
  (x' IN closure s /\ x' NOTIN interior s) /\
  (y' IN closure t /\ y' NOTIN interior t) /\ dist (x',y') <= dist (x,y)`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN EXISTS_TAC ``y:real`` THEN
  ASM_REWRITE_TAC[] THEN
  ASM_CASES_TAC ``(x:real) IN interior s`` THENL
   [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN
  MP_TAC(ISPECL [``segment[x:real,y]``, ``interior s:real->bool``]
        CONNECTED_INTER_FRONTIER) THEN
  REWRITE_TAC[CONNECTED_SEGMENT, GSYM MEMBER_NOT_EMPTY] THEN
  KNOW_TAC ``(?x'. x' IN segment [(x,y)] INTER interior s) /\
             (?x'. x' IN segment [(x,y)] DIFF interior s)`` THENL
   [CONJ_TAC THENL [EXISTS_TAC ``x:real``, EXISTS_TAC ``y:real``] THEN
    ASM_SIMP_TAC std_ss [IN_INTER, IN_DIFF, ENDS_IN_SEGMENT] THEN
    FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (SET_RULE
     ``y IN u ==> (u INTER v = {}) ==> ~(y IN v)``)) THEN
    REWRITE_TAC[INTERIOR_CLOSURE, SET_RULE
     ``(s INTER (UNIV DIFF t) = {}) <=> s SUBSET t``] THEN
    MATCH_MP_TAC SUBSET_CLOSURE THEN ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    DISCH_THEN (X_CHOOSE_TAC ``z:real``) THEN EXISTS_TAC ``z:real`` THEN
    POP_ASSUM MP_TAC THEN
    SIMP_TAC std_ss [IN_INTER, GSYM frontier, GSYM IN_DIFF] THEN
    MESON_TAC[FRONTIER_INTERIOR_SUBSET, SUBSET_DEF, DIST_IN_CLOSED_SEGMENT]]);

val SETDIST_SING_FRONTIER = store_thm ("SETDIST_SING_FRONTIER",
 ``!s x:real. ~(x IN s) ==> (setdist({x},frontier s) = setdist({x},s))``,
  MESON_TAC[SET_RULE ``DISJOINT {x} s <=> ~(x IN s)``, SETDIST_FRONTIER]);

val SETDIST_CLOSEST_POINT = store_thm ("SETDIST_CLOSEST_POINT",
 ``!a:real s.
      closed s /\ ~(s = {}) ==> (setdist({a},s) = dist(a,closest_point s a))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_UNIQUE THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, IN_SING, UNWIND_THM2] THEN
  EXISTS_TAC ``closest_point s (a:real)`` THEN
  ASM_MESON_TAC[CLOSEST_POINT_EXISTS, DIST_SYM]);

val SETDIST_EQ_0_SING = store_thm ("SETDIST_EQ_0_SING",
 ``(!s x:real. (setdist({x},s) = &0) <=> (s = {}) \/ x IN closure s) /\
   (!s x:real. (setdist(s,{x}) = &0) <=> (s = {}) \/ x IN closure s)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_BOUNDED, BOUNDED_SING, CLOSURE_SING] THEN SET_TAC[]);

val SETDIST_EQ_0_CLOSED = store_thm ("SETDIST_EQ_0_CLOSED",
 ``!s x. closed s ==> ((setdist({x},s) = &0) <=> (s = {}) \/ x IN s)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_COMPACT_CLOSED, COMPACT_SING] THEN SET_TAC[]);

val SETDIST_EQ_0_CLOSED_IN = store_thm ("SETDIST_EQ_0_CLOSED_IN",
 ``!u s x. closed_in (subtopology euclidean u) s /\ x IN u
           ==> ((setdist({x},s) = &0) <=> (s = {}) \/ x IN s)``,
  REWRITE_TAC[SETDIST_EQ_0_SING, CLOSED_IN_INTER_CLOSURE] THEN SET_TAC[]);

val SETDIST_SING_IN_SET = store_thm ("SETDIST_SING_IN_SET",
 ``!x s. x IN s ==> (setdist({x},s) = &0)``,
  SIMP_TAC std_ss [SETDIST_EQ_0_SING, REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET]);

val SETDIST_SING_FRONTIER_CASES = store_thm ("SETDIST_SING_FRONTIER_CASES",
 ``!s x:real.
        setdist({x},s) = if x IN s then &0 else setdist({x},frontier s)``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, SETDIST_SING_FRONTIER]);

val SETDIST_SING_TRIANGLE = store_thm ("SETDIST_SING_TRIANGLE",
 ``!s x y:real. abs(setdist({x},s) - setdist({y},s)) <= dist(x,y)``,
  REPEAT GEN_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, REAL_SUB_REFL, ABS_N, DIST_POS_LE] THEN
  REWRITE_TAC[ABS_BOUNDS, REAL_NEG_SUB] THEN REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a - b <= c <=> a - c <= b:real``,
                   REAL_ARITH ``-a <= b - c <=> c - a <= b:real``] THEN
  MATCH_MP_TAC REAL_LE_SETDIST THEN ASM_REWRITE_TAC[NOT_INSERT_EMPTY] THEN
  SIMP_TAC std_ss [IN_SING, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2] THEN
  X_GEN_TAC ``z:real`` THEN DISCH_TAC THEN REWRITE_TAC [dist] THENL
   [MATCH_MP_TAC(REAL_ARITH
     ``a <= abs(y:real - z) ==> a - abs(x - y) <= abs(x - z:real)``),
    MATCH_MP_TAC(REAL_ARITH
     ``a <= abs(x:real - z) ==> a - abs(x - y) <= abs(y - z)``)] THEN
  REWRITE_TAC [GSYM dist] THEN
  MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_REWRITE_TAC[IN_SING]);

val SETDIST_LE_SING = store_thm ("SETDIST_LE_SING",
 ``!s t x:real. x IN s ==> setdist(s,t) <= setdist({x},t)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC SETDIST_SUBSET_LEFT THEN ASM_SET_TAC[]);

val SETDIST_BALLS = store_thm ("SETDIST_BALLS",
 ``(!a b:real r s.
        setdist(ball(a,r),ball(b,s)) =
        if r <= &0 \/ s <= &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(ball(a,r),cball(b,s)) =
        if r <= &0 \/ s < &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(cball(a,r),ball(b,s)) =
        if r < &0 \/ s <= &0 then &0 else max (&0) (dist(a,b) - (r + s))) /\
   (!a b:real r s.
        setdist(cball(a,r),cball(b,s)) =
        if r < &0 \/ s < &0 then &0 else max (&0) (dist(a,b) - (r + s)))``,
  REWRITE_TAC[METIS[]
   ``(x = if p then y else z) <=> (p ==> (x = y)) /\ (~p ==> (x = z))``] THEN
  SIMP_TAC std_ss [TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC std_ss [BALL_EMPTY, CBALL_EMPTY, SETDIST_EMPTY, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[METIS[SETDIST_CLOSURE]
   ``setdist(s,t) = setdist(closure s,closure t)``] THEN
  SIMP_TAC std_ss [REAL_NOT_LE, REAL_NOT_LT, CLOSURE_BALL] THEN
  REWRITE_TAC[SETDIST_CLOSURE] THEN
  MATCH_MP_TAC(TAUT `(s ==> p /\ q /\ r) /\ s ==> p /\ q /\ r /\ s`) THEN
  CONJ_TAC THENL [METIS_TAC[REAL_LT_IMP_LE], REPEAT GEN_TAC] THEN
  REWRITE_TAC[max_def, REAL_SUB_LE] THEN COND_CASES_TAC THEN
  SIMP_TAC std_ss [SETDIST_EQ_0_BOUNDED, BOUNDED_CBALL, CLOSED_CBALL, CLOSURE_CLOSED,
           CBALL_EQ_EMPTY, INTER_BALLS_EQ_EMPTY]
  THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
  ASM_CASES_TAC ``b:real = a`` THENL
   [FIRST_X_ASSUM SUBST_ALL_TAC THEN
    RULE_ASSUM_TAC(REWRITE_RULE[DIST_REFL]) THEN
    ASM_CASES_TAC ``(r = &0:real) /\ (s = &0:real)`` THENL [ALL_TAC, ASM_REAL_ARITH_TAC] THEN
    ASM_SIMP_TAC std_ss [CBALL_SING, SETDIST_SINGS, dist] THEN REAL_ARITH_TAC,
    STRIP_TAC] THEN
  REWRITE_TAC[GSYM REAL_LE_ANTISYM] THEN CONJ_TAC THENL
   [ALL_TAC,
    MATCH_MP_TAC REAL_LE_SETDIST THEN
    ASM_REWRITE_TAC[CBALL_EQ_EMPTY, REAL_NOT_LT, IN_CBALL, dist] THEN
    REAL_ARITH_TAC] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN
  EXISTS_TAC ``dist(a + r / dist(a,b) * (b - a):real,
                   b - s / dist(a,b) * (b - a))`` THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC SETDIST_LE_DIST THEN
    REWRITE_TAC[dist, IN_CBALL, REAL_ARITH ``abs(a - (a + x)) = abs x:real``,
                                REAL_ARITH ``abs(a - (a - x)) = abs x:real``] THEN
    REWRITE_TAC [GSYM dist] THEN ONCE_REWRITE_TAC [DIST_SYM] THEN
    FULL_SIMP_TAC real_ss [dist, ABS_MUL, ABS_DIV, ABS_ABS, ABS_NZ,
      REAL_LT_IMP_NE, REAL_ARITH ``(b <> a) = (b - a <> 0:real)``] THEN
    KNOW_TAC ``abs (b - a:real) <> 0`` THENL [METIS_TAC [REAL_LT_IMP_NE], DISCH_TAC] THEN
    ASM_SIMP_TAC std_ss [REAL_DIV_RMUL, REAL_SUB_0, ABS_ZERO] THEN
    ASM_REAL_ARITH_TAC,
    REWRITE_TAC[dist, REAL_ARITH
     ``(a + d * (b - a)) - (b - e * (b - a)):real =
       (&1 - d - e) * (a - b:real)``] THEN
    REWRITE_TAC[ABS_MUL, real_div, REAL_ARITH
      ``&1 - r * y - s * y = &1 - (r + s) * y:real``] THEN REWRITE_TAC [GSYM real_div] THEN
    REWRITE_TAC [METIS [GSYM ABS_ABS] ``d * abs (a - b) = d * abs(abs (a - b:real))``] THEN
    REWRITE_TAC[GSYM ABS_MUL] THEN
    KNOW_TAC ``!n x:real. ~(n = &0) ==> ((&1 - x / n) * n = n - x)`` THENL
    [REPEAT GEN_TAC THEN DISCH_TAC THEN
     ASM_SIMP_TAC std_ss [REAL_SUB_RDISTRIB, REAL_DIV_RMUL] THEN
     REAL_ARITH_TAC, DISCH_TAC] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(b <> a) = (abs (a - b) <> 0:real)``]) THEN
    ASM_SIMP_TAC real_ss [REAL_SUB_0, ABS_ZERO] THEN
    FULL_SIMP_TAC std_ss [dist] THEN SIMP_TAC std_ss [REAL_LE_LT] THEN
    DISJ2_TAC THEN REWRITE_TAC [ABS_REFL, REAL_SUB_LE] THEN ASM_REWRITE_TAC []]);

(* ------------------------------------------------------------------------- *)
(* Use set distance for an easy proof of separation properties etc.          *)
(* ------------------------------------------------------------------------- *)

val SEPARATION_CLOSURES = store_thm ("SEPARATION_CLOSURES",
 ``!s t:real->bool.
        (s INTER closure(t) = {}) /\ (t INTER closure(s) = {})
        ==> ?u v. DISJOINT u v /\ open u /\ open v /\
                  s SUBSET u /\ t SUBSET v``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``{}:real->bool``, ``univ(:real)``] THEN
    ASM_REWRITE_TAC[OPEN_EMPTY, OPEN_UNIV] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``univ(:real)``, ``{}:real->bool``] THEN
    ASM_REWRITE_TAC[OPEN_EMPTY, OPEN_UNIV] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  EXISTS_TAC ``{x | x IN univ(:real) /\
                   (setdist({x},t) - setdist({x},s)) IN
                   {x | &0 < x}}`` THEN
  EXISTS_TAC ``{x | x IN univ(:real) /\
                   (setdist({x},t) - setdist({x},s)) IN
                   {x | x < &0}}`` THEN
  REPEAT CONJ_TAC THENL
   [REWRITE_TAC[SET_RULE ``DISJOINT s t <=> !x. x IN s /\ x IN t ==> F``] THEN
    SIMP_TAC std_ss [GSPECIFICATION, IN_UNIV] THEN REAL_ARITH_TAC,
    ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                             (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE THEN
    SIMP_TAC std_ss [REWRITE_RULE[real_gt] OPEN_HALFSPACE_COMPONENT_GT, OPEN_UNIV] THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST],
    ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                             (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
    MATCH_MP_TAC CONTINUOUS_OPEN_PREIMAGE THEN
    SIMP_TAC std_ss [OPEN_HALFSPACE_COMPONENT_LT, OPEN_UNIV] THEN
    SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST],
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNIV] THEN
    GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC(REAL_ARITH
     ``&0 <= x /\ (y = &0) /\ ~(x = &0) ==> &0 < x - y:real``),
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION, IN_UNIV] THEN
    GEN_TAC THEN DISCH_TAC THEN MATCH_MP_TAC(REAL_ARITH
     ``&0 <= y /\ (x = &0) /\ ~(y = &0) ==> x - y < &0:real``)] THEN
  ASM_SIMP_TAC std_ss [SETDIST_POS_LE, SETDIST_EQ_0_BOUNDED, BOUNDED_SING] THEN
  ASM_SIMP_TAC std_ss [CLOSED_SING, CLOSURE_CLOSED, NOT_INSERT_EMPTY,
               REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET,
               SET_RULE ``({a} INTER s = {}) <=> ~(a IN s)``] THEN
  ASM_SET_TAC[]);

val SEPARATION_NORMAL = store_thm ("SEPARATION_NORMAL",
 ``!s t:real->bool.
        closed s /\ closed t /\ (s INTER t = {})
        ==> ?u v. open u /\ open v /\
                  s SUBSET u /\ t SUBSET v /\ (u INTER v = {})``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[GSYM DISJOINT_DEF] THEN
  ONCE_REWRITE_TAC[TAUT
    `a /\ b /\ c /\ d /\ e <=> e /\ a /\ b /\ c /\ d`] THEN
  MATCH_MP_TAC SEPARATION_CLOSURES THEN
  ASM_SIMP_TAC std_ss [CLOSURE_CLOSED] THEN ASM_SET_TAC[]);

val SEPARATION_NORMAL_LOCAL = store_thm ("SEPARATION_NORMAL_LOCAL",
 ``!s t u:real->bool.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {})
        ==> ?s' t'. open_in (subtopology euclidean u) s' /\
                    open_in (subtopology euclidean u) t' /\
                    s SUBSET s' /\ t SUBSET t' /\ (s' INTER t' = {})``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``{}:real->bool``, ``u:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_REFL, OPEN_IN_EMPTY, INTER_EMPTY, EMPTY_SUBSET] THEN
    ASM_MESON_TAC[CLOSED_IN_IMP_SUBSET],
    ALL_TAC] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THENL
   [MAP_EVERY EXISTS_TAC [``u:real->bool``, ``{}:real->bool``] THEN
    ASM_SIMP_TAC std_ss [OPEN_IN_REFL, OPEN_IN_EMPTY, INTER_EMPTY, EMPTY_SUBSET] THEN
    ASM_MESON_TAC[CLOSED_IN_IMP_SUBSET],
    ALL_TAC] THEN
  EXISTS_TAC ``{x:real | x IN u /\ setdist({x},s) < setdist({x},t)}`` THEN
  EXISTS_TAC ``{x:real | x IN u /\ setdist({x},t) < setdist({x},s)}`` THEN
  SIMP_TAC std_ss [EXTENSION, SUBSET_DEF, GSPECIFICATION, SETDIST_SING_IN_SET, IN_INTER,
           NOT_IN_EMPTY, SETDIST_POS_LE, CONJ_ASSOC,
           REAL_ARITH ``&0 < x <=> &0 <= x /\ ~(x = &0:real)``] THEN
  CONJ_TAC THENL [ALL_TAC, METIS_TAC[REAL_LT_ANTISYM]] THEN
  ONCE_REWRITE_TAC[GSYM CONJ_ASSOC] THEN CONJ_TAC THENL
   [ALL_TAC,
    ASM_MESON_TAC[SETDIST_EQ_0_CLOSED_IN, CLOSED_IN_IMP_SUBSET, SUBSET_DEF,
                  MEMBER_NOT_EMPTY, IN_INTER]] THEN
  ONCE_REWRITE_TAC[GSYM REAL_SUB_LT] THEN
  ONCE_REWRITE_TAC [METIS [] ``(setdist ({x},t) - setdist ({x},s)) =
                           (\x. setdist ({x},t) - setdist ({x},s)) x``] THEN
  REWRITE_TAC[SET_RULE
   ``{x:real | x IN u /\ &0 < (f:real->real) x} =
     {x:real | x IN u /\ f x IN {x | &0 < x}}``] THEN
  CONJ_TAC THEN
  MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE THEN
  REWRITE_TAC[OPEN_HALFSPACE_COMPONENT_LT,
           REWRITE_RULE[real_gt] OPEN_HALFSPACE_COMPONENT_GT, OPEN_UNIV] THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SUB, CONTINUOUS_ON_SETDIST]);

val SEPARATION_NORMAL_COMPACT = store_thm ("SEPARATION_NORMAL_COMPACT",
 ``!s t:real->bool.
        compact s /\ closed t /\ (s INTER t = {})
        ==> ?u v. open u /\ compact(closure u) /\ open v /\
                  s SUBSET u /\ t SUBSET v /\ (u INTER v = {})``,
  REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
  REPEAT STRIP_TAC THEN FIRST_ASSUM
   (MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_BALL) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t UNION (univ(:real) DIFF ball(0,r))``]
        SEPARATION_NORMAL) THEN
  ASM_SIMP_TAC std_ss [CLOSED_UNION, GSYM OPEN_CLOSED, OPEN_BALL] THEN
  KNOW_TAC ``((s :real -> bool) INTER
  ((t :real -> bool) UNION
   (univ(:real) DIFF ball ((0 :real),(r :real)))) =
  ({} :real -> bool))`` THENL [ASM_SET_TAC[], DISCH_TAC THEN
    ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``u:real->bool`` THEN
  EXISTS_TAC ``v:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  CONJ_TAC THENL [MATCH_MP_TAC BOUNDED_CLOSURE, ASM_SET_TAC[]] THEN
  MATCH_MP_TAC BOUNDED_SUBSET THEN EXISTS_TAC ``ball(0:real,r)`` THEN
  REWRITE_TAC[BOUNDED_BALL] THEN ASM_SET_TAC[]);

val SEPARATION_HAUSDORFF = store_thm ("SEPARATION_HAUSDORFF",
 ``!x:real y.
      ~(x = y)
      ==> ?u v. open u /\ open v /\ x IN u /\ y IN v /\ (u INTER v = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(SPECL [``{x:real}``, ``{y:real}``] SEPARATION_NORMAL) THEN
  REWRITE_TAC[SING_SUBSET, CLOSED_SING] THEN
  DISCH_THEN MATCH_MP_TAC THEN ASM_SET_TAC[]);

val SEPARATION_T2 = store_thm ("SEPARATION_T2",
 ``!x:real y.
        ~(x = y) <=> ?u v. open u /\ open v /\ x IN u /\ y IN v /\
                           (u INTER v = {})``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN ASM_SIMP_TAC std_ss [SEPARATION_HAUSDORFF] THEN
  REWRITE_TAC[EXTENSION, IN_INTER, NOT_IN_EMPTY] THEN MESON_TAC[]);

val SEPARATION_T1 = store_thm ("SEPARATION_T1",
 ``!x:real y.
        ~(x = y) <=> ?u v. open u /\ open v /\ x IN u /\ ~(y IN u) /\
                           ~(x IN v) /\ y IN v``,
  REPEAT STRIP_TAC THEN EQ_TAC THENL
   [ASM_SIMP_TAC std_ss [SEPARATION_T2, EXTENSION, NOT_IN_EMPTY, IN_INTER],
    ALL_TAC] THEN MESON_TAC[]);

val SEPARATION_T0 = store_thm ("SEPARATION_T0",
 ``!x:real y. ~(x = y) <=> ?u. open u /\ ~(x IN u <=> y IN u)``,
  MESON_TAC[SEPARATION_T1]);

(* ------------------------------------------------------------------------- *)
(* Connectedness of the intersection of a chain.                             *)
(* ------------------------------------------------------------------------- *)

val CONNECTED_CHAIN = store_thm ("CONNECTED_CHAIN",
 ``!f:(real->bool)->bool.
        (!s. s IN f ==> compact s /\ connected s) /\
        (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
        ==> connected(BIGINTER f)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGINTER_EMPTY, CONNECTED_UNIV] THEN
  ABBREV_TAC ``c:real->bool = BIGINTER f`` THEN
  SUBGOAL_THEN ``compact(c:real->bool)`` ASSUME_TAC THENL
   [EXPAND_TAC "c" THEN MATCH_MP_TAC COMPACT_BIGINTER THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [CONNECTED_CLOSED_SET, COMPACT_IMP_CLOSED, NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``a:real->bool``, ``b:real->bool``] THEN CCONTR_TAC THEN
  FULL_SIMP_TAC std_ss [] THEN
  MP_TAC(ISPECL [``a:real->bool``, ``b:real->bool``] SEPARATION_NORMAL) THEN
  ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
  SUBGOAL_THEN ``?k:real->bool. k IN f`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN ``?n:real->bool. open n /\ k SUBSET n`` MP_TAC THENL
   [ASM_MESON_TAC[BOUNDED_SUBSET_BALL, COMPACT_IMP_BOUNDED, OPEN_BALL],
    REWRITE_TAC[BIGUNION_SUBSET] THEN STRIP_TAC] THEN
  MP_TAC(ISPEC ``k:real->bool`` COMPACT_IMP_HEINE_BOREL) THEN
  ASM_SIMP_TAC std_ss [] THEN
  KNOW_TAC ``~(!(f' :(real -> bool) -> bool).
  ((!(t :real -> bool). t IN f' ==> (open t :bool)) /\
   (k :real -> bool) SUBSET BIGUNION f') ==>
  ?(f'' :(real -> bool) -> bool).
    (f'' SUBSET f') /\ FINITE f'' /\ (k SUBSET BIGUNION f''))`` THENL
  [ALL_TAC, METIS_TAC []] THEN DISCH_THEN (MP_TAC o SPEC
   ``(u UNION v:real->bool) INSERT {n DIFF s | s IN f}``) THEN
  SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_INSERT, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [OPEN_UNION, OPEN_DIFF, COMPACT_IMP_CLOSED, NOT_IMP] THEN
  CONJ_TAC THENL
   [REWRITE_TAC[BIGUNION_INSERT] THEN REWRITE_TAC[SUBSET_DEF] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN ONCE_REWRITE_TAC[IN_UNION] THEN
    ASM_CASES_TAC ``(x:real) IN c`` THENL [ASM_SET_TAC[], DISJ2_TAC] THEN
    SIMP_TAC std_ss [BIGUNION_IMAGE, GSPECIFICATION] THEN
    UNDISCH_TAC ``~((x:real) IN c)`` THEN
    SUBST1_TAC(SYM(ASSUME ``BIGINTER f:real->bool = c``)) THEN
    SIMP_TAC std_ss [IN_BIGINTER, NOT_FORALL_THM] THEN
    STRIP_TAC THEN EXISTS_TAC ``P:real->bool`` THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  X_GEN_TAC ``g:(real->bool)->bool`` THEN
  REWRITE_TAC [GSYM DE_MORGAN_THM] THEN
  DISCH_THEN(CONJUNCTS_THEN2 MP_TAC STRIP_ASSUME_TAC) THEN
  REWRITE_TAC[SUBSET_INSERT_DELETE] THEN
  SUBGOAL_THEN ``FINITE(g DELETE (u UNION v:real->bool))`` MP_TAC THENL
   [ASM_REWRITE_TAC[FINITE_DELETE],
    REWRITE_TAC[TAUT `p ==> ~q <=> ~(p /\ q)`]] THEN
  REWRITE_TAC[FINITE_SUBSET_IMAGE] THEN
  DISCH_THEN(X_CHOOSE_THEN ``f':(real->bool)->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``?j:real->bool. j IN f /\
                   BIGUNION(IMAGE (\s. n DIFF s) f') SUBSET (n DIFF j)``
  STRIP_ASSUME_TAC THENL
   [ASM_CASES_TAC ``f':(real->bool)->bool = {}`` THEN
    ASM_REWRITE_TAC[IMAGE_EMPTY, IMAGE_INSERT, BIGUNION_EMPTY, EMPTY_SUBSET] THENL
     [ASM_SET_TAC[], ALL_TAC] THEN
    SUBGOAL_THEN
     ``?j:real->bool. j IN f' /\
                       BIGUNION(IMAGE (\s. n DIFF s) f') SUBSET (n DIFF j)``
    MP_TAC THENL [ALL_TAC, ASM_MESON_TAC[SUBSET_DEF]] THEN
    SUBGOAL_THEN
     ``!s t:real->bool. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s``
    MP_TAC THENL [ASM_MESON_TAC[SUBSET_DEF], ALL_TAC] THEN
    UNDISCH_TAC ``~(f':(real->bool)->bool = {})`` THEN
    UNDISCH_TAC ``FINITE(f':(real->bool)->bool)`` THEN
    SPEC_TAC(``f':(real->bool)->bool``,``f':(real->bool)->bool``) THEN
    KNOW_TAC ``!(f' :(real -> bool) -> bool). (f' <> {} ==>
  (!s t. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s) ==>
  ?j. j IN f' /\ BIGUNION (IMAGE (\s. n DIFF s) f') SUBSET n DIFF j) =
        (\f'. f' <> {} ==>
  (!s t. s IN f' /\ t IN f' ==> s SUBSET t \/ t SUBSET s) ==>
  ?j. j IN f' /\ BIGUNION (IMAGE (\s. n DIFF s) f') SUBSET n DIFF j) f'``
    THENL [METIS_TAC [], DISC_RW_KILL] THEN
    MATCH_MP_TAC FINITE_INDUCT THEN SIMP_TAC std_ss [] THEN
    SIMP_TAC std_ss [EXISTS_IN_INSERT, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
    SIMP_TAC std_ss [FORALL_IN_INSERT] THEN POP_ASSUM_LIST(K ALL_TAC) THEN
    SIMP_TAC std_ss [GSYM RIGHT_FORALL_IMP_THM] THEN
    MAP_EVERY X_GEN_TAC [``f:(real->bool)->bool``, ``i:real->bool``] THEN
    ASM_CASES_TAC ``f:(real->bool)->bool = {}`` THEN
    ASM_SIMP_TAC std_ss [IMAGE_EMPTY, IMAGE_INSERT, BIGUNION_INSERT, NOT_IN_EMPTY,
                    BIGUNION_EMPTY, UNION_EMPTY, SUBSET_REFL] THEN
    REWRITE_TAC [AND_IMP_INTRO, GSYM CONJ_ASSOC] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
    REWRITE_TAC [GSYM CONJ_ASSOC] THEN REWRITE_TAC [GSYM AND_IMP_INTRO] THEN
    DISCH_THEN(fn th => REPEAT DISCH_TAC THEN MP_TAC th) THEN
    KNOW_TAC ``(!(s' :real -> bool) (t :real -> bool).
               s' IN (f :(real -> bool) -> bool) ==> t IN f ==>
               s' SUBSET t \/ t SUBSET s')`` THENL
    [ASM_MESON_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
    DISCH_THEN(X_CHOOSE_THEN ``j:real->bool`` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN ``(n DIFF j) SUBSET (n DIFF i) \/
                  (n DIFF i:real->bool) SUBSET (n DIFF j)``
    STRIP_ASSUME_TAC THENL
     [ASM_SET_TAC[],
      DISJ1_TAC THEN ASM_SET_TAC[],
      DISJ2_TAC THEN EXISTS_TAC ``j:real->bool`` THEN ASM_SET_TAC[]],
    ALL_TAC] THEN
  SUBGOAL_THEN ``(j INTER k:real->bool) SUBSET (u UNION v)`` ASSUME_TAC THENL
   [MATCH_MP_TAC(SET_RULE
     ``k SUBSET (u UNION v) UNION (n DIFF j)
      ==> (j INTER k) SUBSET (u UNION v)``) THEN
    MATCH_MP_TAC SUBSET_TRANS THEN
    EXISTS_TAC ``BIGUNION g :real->bool`` THEN ASM_SIMP_TAC std_ss [] THEN
    MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC
     ``BIGUNION((u UNION v:real->bool) INSERT (g DELETE (u UNION v)))`` THEN
    CONJ_TAC THENL [MATCH_MP_TAC SUBSET_BIGUNION THEN SET_TAC[], ALL_TAC] THEN
    ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[BIGUNION_INSERT] THEN
    ASM_SET_TAC[],
    ALL_TAC] THEN
  SUBGOAL_THEN ``connected(j INTER k:real->bool)`` MP_TAC THENL
   [ASM_MESON_TAC[SET_RULE ``s SUBSET t ==> (s INTER t = s)``, INTER_COMM],
    REWRITE_TAC[connected] THEN
    MAP_EVERY EXISTS_TAC [``u:real->bool``, ``v:real->bool``] THEN
    ASM_REWRITE_TAC[] THEN ASM_SET_TAC[]]);

val CONNECTED_CHAIN_GEN = store_thm ("CONNECTED_CHAIN_GEN",
 ``!f:(real->bool)->bool.
       (!s. s IN f ==> closed s /\ connected s) /\
       (?s. s IN f /\ compact s) /\
       (!s t. s IN f /\ t IN f ==> s SUBSET t \/ t SUBSET s)
       ==> connected(BIGINTER f)``,
  GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  FIRST_X_ASSUM(X_CHOOSE_THEN ``s:real->bool`` STRIP_ASSUME_TAC) THEN
  SUBGOAL_THEN
   ``BIGINTER f = BIGINTER(IMAGE (\t:real->bool. s INTER t) f)``
  SUBST1_TAC THENL
   [SIMP_TAC std_ss [EXTENSION, BIGINTER_IMAGE] THEN ASM_SET_TAC[],
    MATCH_MP_TAC CONNECTED_CHAIN THEN
    SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, FORALL_IN_IMAGE] THEN
    ASM_SIMP_TAC std_ss [COMPACT_INTER_CLOSED] THEN
    CONJ_TAC THENL [X_GEN_TAC ``t:real->bool``, ASM_SET_TAC[]] THEN
    DISCH_TAC THEN
    SUBGOAL_THEN ``(s INTER t:real->bool = s) \/ (s INTER t = t)``
     (DISJ_CASES_THEN SUBST1_TAC) THEN
    ASM_SET_TAC[]]);

val CONNECTED_NEST = store_thm ("CONNECTED_NEST",
 ``!s. (!n. compact(s n) /\ connected(s n)) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> connected(BIGINTER {s n | n IN univ(:num)})``,
  GEN_TAC THEN STRIP_TAC THEN MATCH_MP_TAC CONNECTED_CHAIN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(s n SUBSET s n' \/ s n' SUBSET s n) =
                        (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

val CONNECTED_NEST_GEN = store_thm ("CONNECTED_NEST_GEN",
 ``!s. (!n. closed(s n) /\ connected(s n)) /\ (?n. compact(s n)) /\
       (!m n. m <= n ==> s n SUBSET s m)
       ==> connected(BIGINTER {s n | n IN univ(:num)})``,
  GEN_TAC THEN
  DISCH_THEN(REPEAT_TCL DISJ_CASES_THEN ASSUME_TAC) THEN
  MATCH_MP_TAC CONNECTED_CHAIN_GEN THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, IN_UNIV, CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM,
               EXISTS_IN_GSPEC] THEN
  ONCE_REWRITE_TAC [METIS [] ``(s n SUBSET s n' \/ s n' SUBSET s n) =
                        (\n n'. s n SUBSET s n' \/ s n' SUBSET s n) n n'``] THEN
  MATCH_MP_TAC WLOG_LE THEN ASM_MESON_TAC[]);

(* ------------------------------------------------------------------------- *)
(* Hausdorff distance between sets.                                          *)
(* ------------------------------------------------------------------------- *)

val hausdist = new_definition ("hausdist",
 ``hausdist(s:real->bool,t:real->bool) =
        if (({setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t} <> {}) /\
            (?b. !d. d IN {setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t} ==> d <= b))
        then sup ({setdist({x},t) | x IN s} UNION {setdist({y},s) | y IN t}) else &0``);

val HAUSDIST_POS_LE = store_thm ("HAUSDIST_POS_LE",
 ``!s t:real->bool. &0 <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_SUP' THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION, SETDIST_POS_LE] THEN
  KNOW_TAC ``?(y :real) (b :real).
  y IN {setdist ({x},(t :real -> bool)) | x IN (s :real -> bool)} UNION
  {setdist ({y},s) | y IN t} /\ (0 :real) <= y /\
  (!(x :real). x IN s ==> setdist ({x},t) <= b) /\
  !(y :real). y IN t ==> setdist ({y},s) <= b`` THENL
  [ALL_TAC, METIS_TAC [SWAP_EXISTS_THM]] THEN
  ASM_SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(0 <= y:real) = (\y. 0 <= y) y``] THEN
  MATCH_MP_TAC(SET_RULE
   ``~(s = {}) /\ (!x. x IN s ==> P x) ==> ?y. y IN s /\ P y``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION, SETDIST_POS_LE]);

val HAUSDIST_REFL = store_thm ("HAUSDIST_REFL",
 ``!s:real->bool. hausdist(s,s) = &0``,
  GEN_TAC THEN SIMP_TAC std_ss [GSYM REAL_LE_ANTISYM, HAUSDIST_POS_LE] THEN
  REWRITE_TAC[hausdist] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_SUP_LE' THEN
  SIMP_TAC std_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, REAL_LE_REFL]);

val HAUSDIST_SYM = store_thm ("HAUSDIST_SYM",
 ``!s t:real->bool. hausdist(s,t) = hausdist(t,s)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [UNION_COMM] THEN
  REWRITE_TAC[]);

val HAUSDIST_EMPTY = store_thm ("HAUSDIST_EMPTY",
 ``(!t:real->bool. hausdist ({},t) = &0) /\
   (!s:real->bool. hausdist (s,{}) = &0)``,
  REWRITE_TAC[hausdist, SETDIST_EMPTY] THEN
  REWRITE_TAC[SET_RULE ``{setdist ({x},t) | x IN {}} = {}``, UNION_EMPTY] THEN
  REWRITE_TAC[SET_RULE ``({c |x| x IN s} = {}) <=> (s = {})``] THEN
  X_GEN_TAC ``s:real->bool`` THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``~(s = {}) ==> ({c |x| x IN s} = {c})``] THEN
  REWRITE_TAC[SUP_SING, COND_ID]);

val HAUSDIST_SINGS = store_thm ("HAUSDIST_SINGS",
 ``!x y:real. hausdist({x},{y}) = dist(x,y)``,
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  REWRITE_TAC[SET_RULE ``{dist (x,y) | x IN {a}} = {dist (a,y)}``] THEN
  ONCE_REWRITE_TAC [METIS [DIST_SYM] ``{dist (x,y)} UNION {dist (y,x)} =
                               {dist (x,y)} UNION {dist (x,y)}``] THEN
  SIMP_TAC std_ss [UNION_IDEMPOT, SUP_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC std_ss [IN_SING, UNWIND_FORALL_THM2] THEN
  METIS_TAC[REAL_LE_REFL]);

Theorem HAUSDIST_EQ :
   !s t:real->bool s' t':real->bool.
        (!b. (!x. x IN s ==> setdist({x},t) <= b) /\
             (!y. y IN t ==> setdist({y},s) <= b) <=>
             (!x. x IN s' ==> setdist({x},t') <= b) /\
             (!y. y IN t' ==> setdist({y},s') <= b))
        ==> (hausdist(s,t) = hausdist(s',t'))
Proof
  REPEAT STRIP_TAC THEN REWRITE_TAC[hausdist] THEN
  MATCH_MP_TAC(METIS[]
   ``(p <=> p') /\ (s = s')
    ==> ((if p then s else &0:real) = (if p' then s' else &0:real))``) THEN
  CONJ_TAC THENL
   [BINOP_TAC THENL
     [PURE_REWRITE_TAC[SET_RULE ``(s = {}) <=> !x. x IN s ==> F``],
      AP_TERM_TAC THEN ABS_TAC],
    MATCH_MP_TAC SUP_EQ] THEN
  SIMP_TAC std_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN
  ASM_REWRITE_TAC[] THEN
  ONCE_REWRITE_TAC [METIS [] ``(a = b) = (~a = ~b:bool)``] THEN
  REWRITE_TAC [DE_MORGAN_THM] THEN
  SIMP_TAC std_ss' [NOT_FORALL_THM, MEMBER_NOT_EMPTY] THEN
  REWRITE_TAC[GSYM DE_MORGAN_THM] THEN AP_TERM_TAC THEN EQ_TAC THEN
  DISCH_THEN(fn th => POP_ASSUM MP_TAC THEN ASSUME_TAC th) THEN
  ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
  DISCH_THEN(MP_TAC o SPEC ``-(&1):real``) THEN
  SIMP_TAC std_ss [SETDIST_POS_LE, REAL_ARITH ``&0 <= x ==> ~(x <= -(&1:real))``] THEN
  SET_TAC[]
QED

val HAUSDIST_TRANSLATION = store_thm ("HAUSDIST_TRANSLATION",
 ``!a s t:real->bool.
        hausdist(IMAGE (\x. a + x) s,IMAGE (\x. a + x) t) = hausdist(s,t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC real_ss [SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
  SIMP_TAC real_ss [SET_RULE ``{a + x:real} = IMAGE (\x. a + x) {x}``] THEN
  REWRITE_TAC[SETDIST_TRANSLATION]);

val HAUSDIST_LINEAR_IMAGE = store_thm ("HAUSDIST_LINEAR_IMAGE",
 ``!f:real->real s t.
           linear f /\ (!x. abs(f x) = abs x)
           ==> (hausdist(IMAGE f s,IMAGE f t) = hausdist(s,t))``,
  REPEAT STRIP_TAC THEN
  REPEAT GEN_TAC THEN REWRITE_TAC[hausdist] THEN
  SIMP_TAC real_ss [SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
  ONCE_REWRITE_TAC[SET_RULE ``{(f:real->real) x} = IMAGE f {x}``] THEN
  ASM_SIMP_TAC std_ss [SETDIST_LINEAR_IMAGE]);

val HAUSDIST_CLOSURE = store_thm ("HAUSDIST_CLOSURE",
 ``(!s t:real->bool. hausdist(closure s,t) = hausdist(s,t)) /\
   (!s t:real->bool. hausdist(s,closure t) = hausdist(s,t))``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HAUSDIST_EQ THEN
  GEN_TAC THEN BINOP_TAC THEN REWRITE_TAC[SETDIST_CLOSURE] THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) <= b <=> (\x. setdist ({x},t) <= b) x``] THEN
  PURE_ONCE_REWRITE_TAC[SET_RULE
   ``(!x. x IN P ==> Q x) <=> (!x. x IN P ==> (\x. x) x IN {x | Q x})``] THEN
  MATCH_MP_TAC FORALL_IN_CLOSURE_EQ THEN
  SIMP_TAC std_ss [GSPEC_F, CONTINUOUS_ON_ID, CLOSED_EMPTY] THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) = (\x. setdist ({x},t)) x``] THEN
  REWRITE_TAC[SET_RULE
    ``{x | (f x) <= b:real} =
      {x | x IN UNIV /\ (f x) IN {x | x <= b}}``] THEN
  MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
  SIMP_TAC std_ss [CLOSED_UNIV, CONTINUOUS_ON_SETDIST] THEN
  REWRITE_TAC[CLOSED_HALFSPACE_COMPONENT_LE]);

val REAL_HAUSDIST_LE = store_thm ("REAL_HAUSDIST_LE",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\
        (!x. x IN s ==> setdist({x},t) <= b) /\
        (!y. y IN t ==> setdist({y},s) <= b)
        ==> hausdist(s,t) <= b``,
  REPEAT STRIP_TAC THEN
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  SIMP_TAC std_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN
  COND_CASES_TAC THENL [ALL_TAC, METIS_TAC[]] THEN
  MATCH_MP_TAC REAL_SUP_LE' THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  ASM_SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC]);

val REAL_HAUSDIST_LE_SUMS = store_thm ("REAL_HAUSDIST_LE_SUMS",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\
        s SUBSET {y + z | y IN t /\ z IN cball(0,b)} /\
        t SUBSET {y + z | y IN s /\ z IN cball(0,b)}
        ==> hausdist(s,t) <= b``,
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD, IN_CBALL_0] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  REWRITE_TAC[GSYM dist] THEN REPEAT STRIP_TAC THEN
  MATCH_MP_TAC REAL_HAUSDIST_LE THEN
  METIS_TAC[SETDIST_LE_DIST, REAL_LE_TRANS, IN_SING]);

val REAL_LE_HAUSDIST = store_thm ("REAL_LE_HAUSDIST",
 ``!s t:real->bool a b c z.
        ~(s = {}) /\ ~(t = {}) /\
        (!x. x IN s ==> setdist({x},t) <= b) /\
        (!y. y IN t ==> setdist({y},s) <= c) /\
        (z IN s /\ a <= setdist({z},t) \/ z IN t /\ a <= setdist({z},s))
        ==> a <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN DISCH_THEN(REPEAT_TCL CONJUNCTS_THEN ASSUME_TAC) THEN
  REWRITE_TAC[hausdist, SETDIST_SINGS] THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
  SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC] THEN COND_CASES_TAC THENL
   [MATCH_MP_TAC REAL_LE_SUP' THEN
    ASM_SIMP_TAC real_ss [EMPTY_UNION, SET_RULE ``({f x | x IN s} = {}) <=> (s = {})``] THEN
    SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC],
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [NOT_EXISTS_THM]) THEN
    ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    SIMP_TAC real_ss [NOT_FORALL_THM]] THEN
  EXISTS_TAC ``max b c:real`` THEN
  ASM_SIMP_TAC real_ss [REAL_LE_MAX] THEN ASM_SET_TAC[]);

val SETDIST_LE_HAUSDIST = store_thm ("SETDIST_LE_HAUSDIST",
 ``!s t:real->bool.
        bounded s /\ bounded t ==> setdist(s,t) <= hausdist(s,t)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  MATCH_MP_TAC REAL_LE_HAUSDIST THEN REWRITE_TAC[CONJ_ASSOC] THEN
  ASM_SIMP_TAC real_ss [RIGHT_EXISTS_AND_THM, LEFT_EXISTS_AND_THM] THEN
  CONJ_TAC THENL
   [ALL_TAC, METIS_TAC[SETDIST_LE_SING, MEMBER_NOT_EMPTY]] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC, GSYM dist] THEN
  DISCH_THEN(X_CHOOSE_TAC ``b:real``) THEN
  CONJ_TAC THEN EXISTS_TAC ``b:real`` THEN REPEAT STRIP_TAC THEN
  METIS_TAC[REAL_LE_TRANS, SETDIST_LE_DIST, MEMBER_NOT_EMPTY, IN_SING, DIST_SYM]);

val SETDIST_SING_LE_HAUSDIST = store_thm ("SETDIST_SING_LE_HAUSDIST",
 ``!s t x:real.
        bounded s /\ bounded t /\ x IN s ==> setdist({x},t) <= hausdist(s,t)``,
  REPEAT GEN_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
  ASM_CASES_TAC ``t:real->bool = {}`` THEN
  ASM_REWRITE_TAC[SETDIST_EMPTY, HAUSDIST_EMPTY, REAL_LE_REFL] THEN
  STRIP_TAC THEN MATCH_MP_TAC REAL_LE_HAUSDIST THEN
  ASM_SIMP_TAC real_ss [RIGHT_EXISTS_AND_THM] THEN
  SIMP_TAC real_ss [LEFT_EXISTS_AND_THM, EXISTS_OR_THM, CONJ_ASSOC] THEN
  CONJ_TAC THENL [ALL_TAC, ASM_MESON_TAC[REAL_LE_REFL]] THEN CONJ_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_REWRITE_TAC[] THEN SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN REWRITE_TAC[GSYM dist] THENL
   [ALL_TAC,
    KNOW_TAC ``(!y x:real. x IN s /\ y IN t ==> dist (x,y) <= a) ==>
                !y. y IN t ==> setdist ({y},s) <= a`` THENL
    [ALL_TAC, METIS_TAC [SWAP_FORALL_THM]]] THEN
  DISCH_TAC THEN X_GEN_TAC ``y:real`` THEN POP_ASSUM (MP_TAC o SPEC ``y:real``) THEN
  REPEAT STRIP_TAC THENL
   [UNDISCH_TAC ``~(t:real->bool = {})``,
    UNDISCH_TAC ``~(s:real->bool = {})``] THEN
  REWRITE_TAC[GSYM MEMBER_NOT_EMPTY] THEN
  DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``z:real``) THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] REAL_LE_TRANS) THENL
   [ALL_TAC, ONCE_REWRITE_TAC[DIST_SYM]] THEN
  MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_REWRITE_TAC[IN_SING]);

val SETDIST_HAUSDIST_TRIANGLE = store_thm ("SETDIST_HAUSDIST_TRIANGLE",
 ``!s t u:real->bool.
        ~(t = {}) /\ bounded t /\ bounded u
        ==> setdist(s,u) <= setdist(s,t) + hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``u:real->bool = {}``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_EMPTY, REAL_LE_ADD, REAL_ADD_LID,
                        SETDIST_POS_LE, HAUSDIST_POS_LE] THEN
  ONCE_REWRITE_TAC[REAL_ARITH ``a <= b + c <=> a - c <= b:real``] THEN
  ASM_SIMP_TAC real_ss [REAL_LE_SETDIST_EQ, NOT_INSERT_EMPTY, IN_SING] THEN
  MAP_EVERY X_GEN_TAC [``x:real``, ``y:real``] THEN STRIP_TAC THEN
  REWRITE_TAC[REAL_LE_SUB_RADD] THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},u)`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_LE_SING] THEN
  MP_TAC(ISPECL [``u:real->bool``, ``x:real``, ``y:real``]
        SETDIST_SING_TRIANGLE) THEN
  MATCH_MP_TAC(REAL_ARITH
   ``yu <= z ==> abs(xu - yu) <= d ==> xu <= d + z:real``) THEN
  MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN ASM_REWRITE_TAC[]);

val HAUSDIST_SETDIST_TRIANGLE = store_thm ("HAUSDIST_SETDIST_TRIANGLE",
 ``!s t u:real->bool.
        ~(t = {}) /\ bounded s /\ bounded t
        ==> setdist(s,u) <= hausdist(s,t) + setdist(t,u)``,
  ONCE_REWRITE_TAC[SETDIST_SYM, HAUSDIST_SYM] THEN
  ONCE_REWRITE_TAC[REAL_ADD_SYM] THEN
  SIMP_TAC real_ss [SETDIST_HAUSDIST_TRIANGLE]);

val REAL_LT_HAUSDIST_POINT_EXISTS = store_thm ("REAL_LT_HAUSDIST_POINT_EXISTS",
 ``!s t x:real d.
        bounded s /\ bounded t /\ ~(t = {}) /\ hausdist(s,t) < d /\ x IN s
        ==> ?y. y IN t /\ dist(x,y) < d``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{x:real}``, ``t:real->bool``, ``d:real``]
        REAL_SETDIST_LT_EXISTS) THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN MATCH_MP_TAC THEN
  ASM_REWRITE_TAC[NOT_INSERT_EMPTY] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN EXISTS_TAC ``hausdist(s:real->bool,t)`` THEN
  ASM_SIMP_TAC real_ss [] THEN MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN
  ASM_REWRITE_TAC[]);

val UPPER_LOWER_HEMICONTINUOUS = store_thm ("UPPER_LOWER_HEMICONTINUOUS",
 ``!f:real->real->bool t s.
      (!x. x IN s ==> f(x) SUBSET t) /\
      (!u. open_in (subtopology euclidean t) u
           ==> open_in (subtopology euclidean s)
                       {x | x IN s /\ f(x) SUBSET u}) /\
      (!u. closed_in (subtopology euclidean t) u
           ==> closed_in (subtopology euclidean s)
                         {x | x IN s /\ f(x) SUBSET u})
      ==> !x e. x IN s /\ &0 < e /\ bounded(f x)
                ==> ?d. &0 < d /\
                        !x'. x' IN s /\ dist(x,x') < d
                             ==> hausdist(f x,f x') < e``,
  REPEAT GEN_TAC THEN DISCH_TAC THEN REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``(f:real->real->bool) x = {}`` THENL
   [ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN METIS_TAC[REAL_LT_01], ALL_TAC] THEN
  FIRST_ASSUM(MP_TAC o SPECL [``x:real``, ``e / &2:real``] o MATCH_MP
        UPPER_LOWER_HEMICONTINUOUS_EXPLICIT) THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d1:real`` STRIP_ASSUME_TAC) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``0:real`` o MATCH_MP BOUNDED_SUBSET_BALL) THEN
  DISCH_THEN(X_CHOOSE_THEN ``r:real`` STRIP_ASSUME_TAC) THEN
  FIRST_ASSUM(MP_TAC o SPEC ``t INTER ball(0:real,r)`` o
        CONJUNCT1 o CONJUNCT2) THEN
  SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN REWRITE_TAC[open_in] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN
  ASM_SIMP_TAC std_ss [SUBSET_INTER, GSPECIFICATION] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d2:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d1 d2:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  X_GEN_TAC ``x':real`` THEN STRIP_TAC THEN
  REPEAT(FIRST_X_ASSUM(MP_TAC o SPEC ``x':real``)) THEN
  ASM_REWRITE_TAC[] THEN ONCE_REWRITE_TAC[DIST_SYM] THEN ASM_SIMP_TAC std_ss [] THEN
  STRIP_TAC THEN STRIP_TAC THEN
  ASM_CASES_TAC ``(f:real->real->bool) x' = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN
  KNOW_TAC ``0 < e / 2:real`` THENL [ASM_REWRITE_TAC [REAL_HALF], DISCH_TAC] THEN
  GEN_REWR_TAC RAND_CONV [GSYM REAL_HALF] THEN
  MATCH_MP_TAC(REAL_ARITH ``&0 < e / 2 /\ x <= e / &2 ==> x < e / 2 + e / 2:real``) THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_HAUSDIST_LE THEN
  METIS_TAC[SETDIST_LE_DIST, DIST_SYM, REAL_LE_TRANS,
                IN_SING, REAL_LT_IMP_LE]);

val HAUSDIST_NONTRIVIAL = store_thm ("HAUSDIST_NONTRIVIAL",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
             sup({setdist ({x},t) | x IN s} UNION {setdist ({y},s) | y IN t}))``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[hausdist] THEN
  COND_CASES_TAC THEN ASM_SIMP_TAC real_ss [] THEN
  FIRST_X_ASSUM(MP_TAC o SIMP_RULE real_ss [DE_MORGAN_THM]) THEN
  ASM_SIMP_TAC real_ss [EMPTY_UNION, GSYM IMAGE_DEF, IMAGE_EQ_EMPTY] THEN
  REWRITE_TAC [METIS [] ``(!b. ?d. d IN P /\ ~(d <= b)) =
                              ~(?b. !d. d IN P ==> d <= b:real)``] THEN
  MATCH_MP_TAC(TAUT `p ==> ~p ==> q`) THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN POP_ASSUM MP_TAC THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC] THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_NONTRIVIAL_ALT = store_thm ("HAUSDIST_NONTRIVIAL_ALT",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) = max (sup {setdist ({x},t) | x IN s})
                                (sup {setdist ({y},s) | y IN t}))``,
  REPEAT STRIP_TAC THEN ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL] THEN
  MATCH_MP_TAC SUP_UNION THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, FORALL_IN_IMAGE, IMAGE_EQ_EMPTY] THEN
  CONJ_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC real_ss [FORALL_IN_GSPEC, GSYM dist] THEN
  METIS_TAC [SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val REAL_HAUSDIST_LE_EQ = store_thm ("REAL_HAUSDIST_LE_EQ",
 ``!s t:real->bool b.
        ~(s = {}) /\ ~(t = {}) /\ bounded s /\ bounded t
        ==> (hausdist(s,t) <= b <=>
             (!x. x IN s ==> setdist({x},t) <= b) /\
             (!y. y IN t ==> setdist({y},s) <= b))``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL_ALT, REAL_MAX_LE] THEN
  BINOP_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``setdist ({x},t) = (\x. setdist ({x},t)) x:real``] THEN
  ONCE_REWRITE_TAC [SET_RULE ``(!x. x IN s ==> f x <= b) <=>
                               (!y. y IN {f x | x IN s} ==> y <= b:real)``] THEN
  MATCH_MP_TAC REAL_SUP_LE_EQ THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, IMAGE_EQ_EMPTY, FORALL_IN_IMAGE] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [bounded_def, FORALL_IN_UNION, FORALL_IN_IMAGE, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  POP_ASSUM MP_TAC THEN SIMP_TAC real_ss [FORALL_IN_GSPEC, GSYM dist] THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_UNION_LE = store_thm ("HAUSDIST_UNION_LE",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {}) /\ ~(u = {})
        ==> hausdist(s UNION t,s UNION u) <= hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ, BOUNDED_UNION, EMPTY_UNION] THEN
  SIMP_TAC real_ss [FORALL_IN_UNION] THEN
  SIMP_TAC real_ss [SETDIST_SING_IN_SET, IN_UNION, HAUSDIST_POS_LE] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_HAUSDIST_LE_EQ, BOUNDED_UNION, EMPTY_UNION] THEN
  CONJ_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THENL
   [MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},u)``,
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``setdist({x:real},t)``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_SUBSET_RIGHT, SUBSET_UNION] THENL
   [ALL_TAC, ONCE_REWRITE_TAC[HAUSDIST_SYM]] THEN
  MATCH_MP_TAC SETDIST_SING_LE_HAUSDIST THEN ASM_REWRITE_TAC[]);

val HAUSDIST_INSERT_LE = store_thm ("HAUSDIST_INSERT_LE",
 ``!s t a:real.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> hausdist(a INSERT s,a INSERT t) <= hausdist(s,t)``,
  ONCE_REWRITE_TAC[SET_RULE ``a INSERT s = {a} UNION s``] THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_UNION_LE, NOT_INSERT_EMPTY, BOUNDED_SING]);

val HAUSDIST_COMPACT_EXISTS = store_thm ("HAUSDIST_COMPACT_EXISTS",
 ``!s t:real->bool.
        bounded s /\ compact t /\ ~(t = {})
        ==> !x. x IN s ==> ?y. y IN t /\ dist(x,y) <= hausdist(s,t)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THENL [ASM_SET_TAC[], ALL_TAC] THEN
  MP_TAC(ISPECL [``{x:real}``, ``t:real->bool``]
        SETDIST_COMPACT_CLOSED) THEN
  ASM_SIMP_TAC real_ss [COMPACT_SING, COMPACT_IMP_CLOSED, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, UNWIND_THM2, RIGHT_EXISTS_AND_THM, UNWIND_THM1] THEN
  DISCH_THEN (X_CHOOSE_TAC ``y:real``) THEN EXISTS_TAC ``y:real`` THEN POP_ASSUM MP_TAC THEN
  REPEAT STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC REAL_LE_HAUSDIST THEN
  ASM_SIMP_TAC real_ss [LEFT_EXISTS_AND_THM, RIGHT_EXISTS_AND_THM] THEN
  REWRITE_TAC[CONJ_ASSOC] THEN
  CONJ_TAC THENL [CONJ_TAC, METIS_TAC[REAL_LE_REFL]] THEN
  MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``] BOUNDED_DIFFS) THEN
  ASM_SIMP_TAC real_ss [COMPACT_IMP_BOUNDED] THEN
  SIMP_TAC real_ss [bounded_def, FORALL_IN_GSPEC, GSYM dist] THEN
  DISCH_THEN (X_CHOOSE_TAC ``a:real``) THEN EXISTS_TAC ``a:real`` THEN
  METIS_TAC[SETDIST_LE_DIST, dist, DIST_SYM, REAL_LE_TRANS,
                MEMBER_NOT_EMPTY, IN_SING]);

val HAUSDIST_TRIANGLE = store_thm ("HAUSDIST_TRIANGLE",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {})
        ==> hausdist(s,u) <= hausdist(s,t) + hausdist(t,u)``,
  ONCE_REWRITE_TAC[GSYM(CONJUNCT1 HAUSDIST_CLOSURE)] THEN
  ONCE_REWRITE_TAC[GSYM(CONJUNCT2 HAUSDIST_CLOSURE)] THEN
  ONCE_REWRITE_TAC[GSYM COMPACT_CLOSURE, GSYM CLOSURE_EQ_EMPTY] THEN
  REPEAT GEN_TAC THEN MAP_EVERY
   (fn t => SPEC_TAC(mk_comb(``closure:(real->bool)->real->bool``,t),t))
   [``u:real->bool``, ``t:real->bool``, ``s:real->bool``] THEN
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, HAUSDIST_POS_LE, REAL_ADD_LID] THEN
  ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, HAUSDIST_POS_LE, REAL_ADD_RID] THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ, COMPACT_IMP_BOUNDED] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [HAUSDIST_SYM] THEN
  GEN_REWR_TAC (RAND_CONV o ONCE_DEPTH_CONV) [REAL_ADD_SYM] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN
   MAP_EVERY (fn t => SPEC_TAC(t,t))
   [``u:real->bool``, ``t:real->bool``, ``s:real->bool``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(~(u = {}) /\ ~(s = {}) /\ ~(t = {}) /\
                                compact u /\ compact t /\ compact s) =
                       (\s t u. ~(u = {}) /\ ~(s = {}) /\ ~(t = {}) /\
                                compact u /\ compact t /\ compact s) s t u``] THEN
  ONCE_REWRITE_TAC [METIS [] ``(!x. x IN s ==> setdist ({x},u) <=
                                hausdist (s,t) + hausdist (t,u)) =
                       (\s t u. !x. x IN s ==> setdist ({x},u) <=
                                hausdist (s,t) + hausdist (t,u)) s t u ``] THEN
  MATCH_MP_TAC(METIS[]
   ``(!s t u. P s t u ==> P u t s) /\
     (!s t u. P s t u ==> Q s t u)
     ==> (!s t u. P s t u ==> Q s t u /\ Q u t s)``) THEN BETA_TAC THEN
  CONJ_TAC THENL [METIS_TAC[CONJ_ACI], REPEAT GEN_TAC THEN STRIP_TAC] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?y:real. y IN t /\ dist(x,y) <= hausdist(s,t)``
  STRIP_ASSUME_TAC THENL
   [METIS_TAC[HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED], ALL_TAC] THEN
  SUBGOAL_THEN ``?z:real. z IN u /\ dist(y,z) <= hausdist(t,u)``
  STRIP_ASSUME_TAC THENL
   [METIS_TAC[HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED], ALL_TAC] THEN
  RULE_ASSUM_TAC (REWRITE_RULE [dist]) THEN
  FIRST_ASSUM(MATCH_MP_TAC o MATCH_MP (REAL_ARITH
   ``abs(y - z) <= b ==> abs(x - y) <= a /\ s <= abs(x - z) ==> s <= a + b:real``)) THEN
  ASM_REWRITE_TAC[GSYM dist] THEN MATCH_MP_TAC SETDIST_LE_DIST THEN
  ASM_REWRITE_TAC[IN_SING]);

val HAUSDIST_COMPACT_SUMS = store_thm ("HAUSDIST_COMPACT_SUMS",
 ``!s t:real->bool.
        bounded s /\ compact t /\ ~(t = {})
        ==> s SUBSET {y + z | y IN t /\ z IN cball(0,hausdist(s,t))}``,
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, IN_CBALL_0, EXISTS_PROD] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  SIMP_TAC real_ss [GSYM dist, HAUSDIST_COMPACT_EXISTS]);

val lemma = prove (
 ``!s t u:real->bool.
          bounded s /\ bounded t /\ bounded u /\
          ~(s = {}) /\ ~(t = {}) /\ ~(u = {})
          ==> !x. x IN s ==> setdist({x},u) <= hausdist(s,t) + hausdist(t,u)``,
    REPEAT STRIP_TAC THEN
    MP_TAC(ISPECL [``closure s:real->bool``, ``closure t:real->bool``]
        HAUSDIST_COMPACT_EXISTS) THEN
    ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC real_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET, HAUSDIST_CLOSURE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``y:real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPECL [``closure t:real->bool``, ``closure u:real->bool``]
      HAUSDIST_COMPACT_EXISTS) THEN
    ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY] THEN
    DISCH_THEN(MP_TAC o SPEC ``y:real``) THEN
    ASM_SIMP_TAC real_ss [REWRITE_RULE[SUBSET_DEF] CLOSURE_SUBSET, HAUSDIST_CLOSURE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``z:real`` STRIP_ASSUME_TAC) THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,z)`` THEN CONJ_TAC THENL
     [METIS_TAC[SETDIST_CLOSURE, SETDIST_LE_DIST, IN_SING], ALL_TAC] THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,y) + dist(y,z)`` THEN
    REWRITE_TAC[DIST_TRIANGLE] THEN ASM_REAL_ARITH_TAC);

val HAUSDIST_TRANS = store_thm ("HAUSDIST_TRANS",
 ``!s t u:real->bool.
        bounded s /\ bounded t /\ bounded u /\ ~(t = {})
        ==> hausdist(s,u) <= hausdist(s,t) + hausdist(t,u)``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``s:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, REAL_ADD_LID, HAUSDIST_POS_LE] THEN
  ASM_CASES_TAC ``u:real->bool = {}`` THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY, REAL_ADD_RID, HAUSDIST_POS_LE] THEN
  ASM_SIMP_TAC real_ss [REAL_HAUSDIST_LE_EQ] THEN
  ASM_MESON_TAC[lemma, HAUSDIST_SYM, SETDIST_SYM, REAL_ADD_SYM]);

val HAUSDIST_EQ_0 = store_thm ("HAUSDIST_EQ_0",
 ``!s t:real->bool.
      bounded s /\ bounded t
      ==> ((hausdist(s,t) = &0) <=> (s = {}) \/ (t = {}) \/ (closure s = closure t))``,
  REPEAT STRIP_TAC THEN
  MAP_EVERY ASM_CASES_TAC [``s:real->bool = {}``, ``t:real->bool = {}``] THEN
  ASM_REWRITE_TAC[HAUSDIST_EMPTY] THEN
  ASM_SIMP_TAC real_ss [GSYM REAL_LE_ANTISYM, HAUSDIST_POS_LE, REAL_HAUSDIST_LE_EQ] THEN
  SIMP_TAC real_ss [SETDIST_POS_LE, REAL_ARITH ``&0 <= x ==> (x <= &0 <=> (x = &0:real))``] THEN
  ASM_SIMP_TAC real_ss [SETDIST_EQ_0_SING, GSYM SUBSET_ANTISYM_EQ, SUBSET_DEF] THEN
  SIMP_TAC std_ss [FORALL_IN_CLOSURE_EQ, CLOSED_CLOSURE, CONTINUOUS_ON_ID]);

val HAUSDIST_COMPACT_NONTRIVIAL = store_thm ("HAUSDIST_COMPACT_NONTRIVIAL",
 ``!s t:real->bool.
        compact s /\ compact t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
            inf {e | &0 <= e /\
                   s SUBSET {x + y | x IN t /\ abs y <= e} /\
                   t SUBSET {x + y | x IN s /\ abs y <= e}})``,
  REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN
  MATCH_MP_TAC REAL_INF_UNIQUE THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC, EXISTS_IN_GSPEC] THEN
  SIMP_TAC real_ss [SUBSET_DEF, GSPECIFICATION, EXISTS_PROD] THEN
  SIMP_TAC real_ss [REAL_ARITH ``(a:real = b + x) <=> (a - b = x)``,
              ONCE_REWRITE_RULE[CONJ_SYM] UNWIND_THM1] THEN
  REWRITE_TAC[GSYM dist] THEN CONJ_TAC THENL
   [REPEAT STRIP_TAC THEN
    MATCH_MP_TAC REAL_HAUSDIST_LE THEN
    METIS_TAC[SETDIST_LE_DIST, DIST_SYM, REAL_LE_TRANS,
              IN_SING, REAL_LT_IMP_LE],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``hausdist(s:real->bool,t)`` THEN
    ASM_REWRITE_TAC[HAUSDIST_POS_LE] THEN
    METIS_TAC[DIST_SYM, HAUSDIST_SYM,
                  HAUSDIST_COMPACT_EXISTS, COMPACT_IMP_BOUNDED]]);

Theorem HAUSDIST_BALLS :
   (!a b:real r s.
        hausdist(ball(a,r),ball(b,s)) =
        if r <= &0 \/ s <= &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(ball(a,r),cball(b,s)) =
        if r <= &0 \/ s < &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(cball(a,r),ball(b,s)) =
        if r < &0 \/ s <= &0 then &0 else dist(a,b) + abs(r - s)) /\
   (!a b:real r s.
        hausdist(cball(a,r),cball(b,s)) =
        if r < &0 \/ s < &0 then &0 else dist(a,b) + abs(r - s))
Proof
  REWRITE_TAC[METIS[]
   ``(x = if p then y else z) <=> (p ==> (x = y)) /\ (~p ==> (x = z))``] THEN
  SIMP_TAC real_ss [TAUT `p \/ q ==> r <=> (p ==> r) /\ (q ==> r)`] THEN
  SIMP_TAC real_ss [BALL_EMPTY, CBALL_EMPTY, HAUSDIST_EMPTY, DE_MORGAN_THM] THEN
  ONCE_REWRITE_TAC[METIS[HAUSDIST_CLOSURE]
   ``hausdist(s,t) = hausdist(closure s,closure t)``] THEN
  SIMP_TAC real_ss [REAL_NOT_LE, REAL_NOT_LT, CLOSURE_BALL] THEN
  REWRITE_TAC[HAUSDIST_CLOSURE] THEN
  MATCH_MP_TAC(TAUT `(s ==> p /\ q /\ r) /\ s ==> p /\ q /\ r /\ s`) THEN
  CONJ_TAC THENL [MESON_TAC[REAL_LT_IMP_LE], REPEAT STRIP_TAC] THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL, BOUNDED_CBALL, CBALL_EQ_EMPTY,
               REAL_NOT_LT] THEN
  MATCH_MP_TAC SUP_UNIQUE THEN
  SIMP_TAC real_ss [FORALL_IN_GSPEC, FORALL_IN_UNION] THEN
  REWRITE_TAC[MESON[CBALL_SING] ``{a} = cball(a:real,&0)``] THEN
  ASM_REWRITE_TAC[SETDIST_BALLS, REAL_LT_REFL] THEN
  X_GEN_TAC ``c:real`` THEN REWRITE_TAC[IN_CBALL] THEN
  reverse EQ_TAC
  >- (RW_TAC real_ss [dist] >> REAL_ASM_ARITH_TAC) THEN
  ASM_CASES_TAC ``b:real = a`` THENL
  [ (* goal 1 (of 2) *)
    ONCE_ASM_REWRITE_TAC [DIST_SYM] THEN ASM_REWRITE_TAC[DIST_REFL, REAL_MAX_LE] THEN
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC o SPEC ``a + r * 1:real``)
     (MP_TAC o SPEC ``a + s * 1:real``)) THEN
    REWRITE_TAC[dist, REAL_ARITH ``abs(a:real - (a + x)) = abs x``] THEN
    SIMP_TAC real_ss [ABS_MUL, LESS_EQ_REFL] \\
    REAL_ASM_ARITH_TAC,
    (* goal 2 (of 2) *)
    DISCH_THEN(CONJUNCTS_THEN2
     (MP_TAC o SPEC ``a - r / dist(a,b) * (b - a):real``)
     (MP_TAC o SPEC ``b - s / dist(a,b) * (a - b):real``)) THEN
    REWRITE_TAC[dist, REAL_ARITH ``abs(a:real - (a - x)) = abs x``] THEN
    REWRITE_TAC[dist, ABS_MUL, REAL_ARITH
     ``b - e * (a - b) - a:real = (&1 + e) * (b - a)``] THEN
    ONCE_REWRITE_TAC [METIS [ABS_ABS] ``abs x * abs (a - b) =
                                        abs x * abs (abs (a - b:real))``] THEN
    REWRITE_TAC[GSYM ABS_MUL] THEN REWRITE_TAC[ABS_ABS] THEN
    ONCE_REWRITE_TAC [METIS [ABS_SUB] ``r / abs (a - b) * abs (b - a) =
                                   r / abs (a - b) * abs (a - b:real)``] THEN
    REWRITE_TAC[REAL_ADD_RDISTRIB, REAL_MUL_LID] THEN
    RULE_ASSUM_TAC (ONCE_REWRITE_RULE [REAL_ARITH ``(b <> a) = (abs (a - b) <> 0:real)``]) THEN
    ONCE_REWRITE_TAC [METIS [ABS_SUB] ``r / abs (a - b) * abs (b - a) =
                                   r / abs (a - b) * abs (a - b:real)``] THEN
    ASM_SIMP_TAC real_ss [REAL_DIV_RMUL, ABS_ZERO, REAL_SUB_0] THEN
    REAL_ASM_ARITH_TAC ]
QED

val HAUSDIST_ALT = store_thm ("HAUSDIST_ALT",
 ``!s t:real->bool.
        bounded s /\ bounded t /\ ~(s = {}) /\ ~(t = {})
        ==> (hausdist(s,t) =
             sup {abs(setdist({x},s) - setdist({x},t)) | x IN univ(:real)})``,
  REPEAT GEN_TAC THEN
  ONCE_REWRITE_TAC[GSYM COMPACT_CLOSURE, GSYM(CONJUNCT2 SETDIST_CLOSURE),
    GSYM CLOSURE_EQ_EMPTY, METIS[HAUSDIST_CLOSURE]
    ``hausdist(s:real->bool,t) = hausdist(closure s,closure t)``] THEN
  SPEC_TAC(``closure t:real->bool``,``t:real->bool``) THEN
  SPEC_TAC(``closure s:real->bool``,``s:real->bool``) THEN
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_NONTRIVIAL, COMPACT_IMP_BOUNDED] THEN
  MATCH_MP_TAC SUP_EQ THEN
  SIMP_TAC real_ss [FORALL_IN_UNION, FORALL_IN_GSPEC, IN_UNIV] THEN
  REWRITE_TAC[REAL_ARITH ``abs(y - x) <= b <=> x <= y + b /\ y <= x + b:real``] THEN
  GEN_TAC THEN SIMP_TAC real_ss [FORALL_AND_THM] THEN BINOP_TAC THEN
  (EQ_TAC THENL [ALL_TAC, METIS_TAC[SETDIST_SING_IN_SET, REAL_ADD_LID]]) THEN
  DISCH_TAC THEN X_GEN_TAC ``z:real`` THENL
   [MP_TAC(ISPECL[``{z:real}``, ``s:real->bool``] SETDIST_CLOSED_COMPACT),
    MP_TAC(ISPECL[``{z:real}``, ``t:real->bool``] SETDIST_CLOSED_COMPACT)] THEN
  ASM_REWRITE_TAC[CLOSED_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN(X_CHOOSE_THEN ``y:real`` (STRIP_ASSUME_TAC o GSYM)) THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``y:real``) THEN ASM_REWRITE_TAC[] THENL
   [MP_TAC(ISPECL[``{y:real}``, ``t:real->bool``] SETDIST_CLOSED_COMPACT),
    MP_TAC(ISPECL[``{y:real}``, ``s:real->bool``] SETDIST_CLOSED_COMPACT)] THEN
  ASM_REWRITE_TAC[CLOSED_SING, NOT_INSERT_EMPTY] THEN
  SIMP_TAC real_ss [IN_SING, RIGHT_EXISTS_AND_THM, UNWIND_THM2] THEN
  DISCH_THEN(X_CHOOSE_THEN ``x:real`` (STRIP_ASSUME_TAC o GSYM)) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(z:real,x)`` THEN
  ASM_SIMP_TAC real_ss [SETDIST_LE_DIST, IN_SING] THEN
  UNDISCH_TAC ``dist(y:real,x) <= b`` THEN REWRITE_TAC [dist] THEN REAL_ARITH_TAC);

val CONTINUOUS_DIAMETER = store_thm ("CONTINUOUS_DIAMETER",
 ``!s:real->bool e.
        bounded s /\ ~(s = {}) /\ &0 < e
        ==> ?d. &0 < d /\
                !t. bounded t /\ ~(t = {}) /\ hausdist(s,t) < d
                    ==> abs(diameter s - diameter t) < e``,
  REPEAT STRIP_TAC THEN EXISTS_TAC ``e / &2:real`` THEN
  ASM_REWRITE_TAC[REAL_HALF] THEN REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``diameter(s:real->bool) - diameter(t:real->bool) =
                 diameter(closure s) - diameter(closure t)``
  SUBST1_TAC THENL [ASM_MESON_TAC[DIAMETER_CLOSURE], ALL_TAC] THEN
  MATCH_MP_TAC REAL_LET_TRANS THEN
  EXISTS_TAC ``&2 * hausdist(s:real->bool,t)`` THEN
  CONJ_TAC THENL [ALL_TAC,
   FULL_SIMP_TAC std_ss [REAL_LT_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
   ASM_REAL_ARITH_TAC] THEN
  MP_TAC(ISPECL [``0:real``, ``hausdist(s:real->bool,t)``]
    DIAMETER_CBALL) THEN
  ASM_SIMP_TAC real_ss [HAUSDIST_POS_LE, GSYM REAL_NOT_LE] THEN
  DISCH_THEN(SUBST1_TAC o SYM) THEN MATCH_MP_TAC(REAL_ARITH
   ``x <= y + e /\ y <= x + e ==> abs(x - y) <= e:real``) THEN
  CONJ_TAC THEN
  W(MP_TAC o PART_MATCH (rand o rand) DIAMETER_SUMS o rand o snd) THEN
  ASM_SIMP_TAC real_ss [BOUNDED_CBALL, BOUNDED_CLOSURE] THEN
  MATCH_MP_TAC(REWRITE_RULE[CONJ_EQ_IMP] REAL_LE_TRANS) THEN
  MATCH_MP_TAC DIAMETER_SUBSET THEN
  ASM_SIMP_TAC real_ss [BOUNDED_SUMS, BOUNDED_CBALL, BOUNDED_CLOSURE] THEN
  ONCE_REWRITE_TAC[METIS[HAUSDIST_CLOSURE]
   ``hausdist(s:real->bool,t) = hausdist(closure s,closure t)``]
  THENL [ALL_TAC, ONCE_REWRITE_TAC[HAUSDIST_SYM]] THEN
  MATCH_MP_TAC HAUSDIST_COMPACT_SUMS THEN
  ASM_SIMP_TAC real_ss [COMPACT_CLOSURE, BOUNDED_CLOSURE, CLOSURE_EQ_EMPTY]);

(* ------------------------------------------------------------------------- *)
(* Isometries are embeddings, and even surjective in the compact case.       *)
(* ------------------------------------------------------------------------- *)

val ISOMETRY_IMP_OPEN_MAP = store_thm ("ISOMETRY_IMP_OPEN_MAP",
 ``!f:real->real s t u.
        (IMAGE f s = t) /\
        (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y))) /\
        open_in (subtopology euclidean s) u
        ==> open_in (subtopology euclidean t) (IMAGE f u)``,
  SIMP_TAC std_ss [open_in, FORALL_IN_IMAGE] THEN REPEAT GEN_TAC THEN STRIP_TAC THEN
  CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``x:real`` THEN DISCH_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[CONJ_EQ_IMP] THEN
  SIMP_TAC std_ss [FORALL_IN_IMAGE] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[SUBSET_DEF]) THEN
  ASM_SIMP_TAC std_ss [IN_IMAGE] THEN ASM_MESON_TAC[]);

val ISOMETRY_IMP_EMBEDDING = store_thm ("ISOMETRY_IMP_EMBEDDING",
 ``!f:real->real s t.
        (IMAGE f s = t) /\ (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
        ==> ?g. homeomorphism (s,t) (f,g)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC HOMEOMORPHISM_INJECTIVE_OPEN_MAP THEN
  ASM_SIMP_TAC std_ss [ISOMETRY_ON_IMP_CONTINUOUS_ON] THEN
  CONJ_TAC THENL [ASM_MESON_TAC[DIST_EQ_0], REPEAT STRIP_TAC] THEN
  MATCH_MP_TAC ISOMETRY_IMP_OPEN_MAP THEN ASM_MESON_TAC[]);

val ISOMETRY_IMP_HOMEOMORPHISM_COMPACT = store_thm ("ISOMETRY_IMP_HOMEOMORPHISM_COMPACT",
 ``!f s:real->bool.
        compact s /\ IMAGE f s SUBSET s /\
        (!x y. x IN s /\ y IN s ==> (dist(f x,f y) = dist(x,y)))
        ==> ?g. homeomorphism (s,s) (f,g)``,
  REPEAT STRIP_TAC THEN
  SUBGOAL_THEN ``IMAGE (f:real->real) s = s``
   (fn th => ASM_MESON_TAC[th, ISOMETRY_IMP_EMBEDDING]) THEN
  FIRST_ASSUM(ASSUME_TAC o MATCH_MP ISOMETRY_ON_IMP_CONTINUOUS_ON) THEN
  ASM_REWRITE_TAC[GSYM SUBSET_ANTISYM_EQ] THEN REWRITE_TAC[SUBSET_DEF] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SUBGOAL_THEN ``setdist({x},IMAGE (f:real->real) s) = &0`` MP_TAC THENL
   [MATCH_MP_TAC(REAL_ARITH ``&0 <= x /\ ~(&0 < x) ==> (x = &0:real)``) THEN
    REWRITE_TAC[SETDIST_POS_LE] THEN DISCH_TAC THEN
    KNOW_TAC ``?z. (z 0 = (x:real)) /\ !n. z(SUC n) = f(z n)`` THENL
    [RW_TAC std_ss [num_Axiom], STRIP_TAC] THEN
    SUBGOAL_THEN ``!n. (z:num->real) n IN s`` ASSUME_TAC THENL
     [INDUCT_TAC THEN ASM_SET_TAC[], ALL_TAC] THEN
    UNDISCH_TAC ``compact s`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o REWRITE_RULE [compact]) THEN
    DISCH_THEN(MP_TAC o SPEC ``z:num->real``) THEN
    ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN CCONTR_TAC THEN
    FULL_SIMP_TAC std_ss [] THEN
    FIRST_ASSUM(MP_TAC o MATCH_MP CONVERGENT_IMP_CAUCHY) THEN
    REWRITE_TAC[cauchy] THEN
    DISCH_THEN(MP_TAC o SPEC ``setdist({x},IMAGE (f:real->real) s)``) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``N:num``
     (MP_TAC o SPECL [``N:num``, ``N + 1:num``])) THEN
    KNOW_TAC ``N >= N /\ N + 1 >= N:num`` THENL
    [ARITH_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
     POP_ASSUM K_TAC THEN REWRITE_TAC[REAL_NOT_LT, o_THM]] THEN
    SUBGOAL_THEN ``(r:num->num) N < r (N + 1)`` MP_TAC THENL
     [RULE_ASSUM_TAC (REWRITE_RULE [METIS [] ``(~a \/ b) = (a ==> b)``]) THEN
      FIRST_X_ASSUM MATCH_MP_TAC THEN ARITH_TAC,
      SIMP_TAC std_ss [LT_EXISTS, LEFT_IMP_EXISTS_THM]] THEN
    X_GEN_TAC ``d:num`` THEN DISCH_THEN SUBST1_TAC THEN
    MATCH_MP_TAC REAL_LE_TRANS THEN EXISTS_TAC ``dist(x:real,z(SUC d))`` THEN CONJ_TAC THENL
     [MATCH_MP_TAC SETDIST_LE_DIST THEN ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC REAL_EQ_IMP_LE THEN
    SPEC_TAC(``(r:num->num) N``,``m:num``) THEN
    INDUCT_TAC THEN ASM_MESON_TAC[ADD_CLAUSES],
    REWRITE_TAC[SETDIST_EQ_0_SING, IMAGE_EQ_EMPTY] THEN
    ASM_MESON_TAC[COMPACT_IMP_CLOSED, NOT_IN_EMPTY,
                  COMPACT_CONTINUOUS_IMAGE, CLOSURE_CLOSED]]);

(* ------------------------------------------------------------------------- *)
(* Urysohn's lemma (for real, where the proof is easy using distances).      *)
(* ------------------------------------------------------------------------- *)

val lemma = prove (
   ``!s t u a b.
          closed_in (subtopology euclidean u) s /\
          closed_in (subtopology euclidean u) t /\
          (s INTER t = {}) /\ ~(s = {}) /\ ~(t = {}) /\ ~(a = b)
          ==> ?f:real->real.
                 f continuous_on u /\
                 (!x. x IN u ==> f(x) IN segment[a,b]) /\
                 (!x. x IN u ==> ((f x = a) <=> x IN s)) /\
                 (!x. x IN u ==> ((f x = b) <=> x IN t))``,
    REPEAT STRIP_TAC THEN EXISTS_TAC
      ``\x:real. a + setdist({x},s) / (setdist({x},s) + setdist({x},t)) *
                      (b - a:real)`` THEN SIMP_TAC std_ss [] THEN
    SUBGOAL_THEN
     ``(!x:real. x IN u ==> ((setdist({x},s) = &0) <=> x IN s)) /\
       (!x:real. x IN u ==> ((setdist({x},t) = &0) <=> x IN t))``
    STRIP_ASSUME_TAC THENL
     [ASM_REWRITE_TAC[SETDIST_EQ_0_SING] THEN CONJ_TAC THENL
       [MP_TAC(ISPEC ``s:real->bool`` CLOSED_IN_CLOSED),
        MP_TAC(ISPEC ``t:real->bool`` CLOSED_IN_CLOSED)] THEN
      DISCH_THEN(MP_TAC o SPEC ``u:real->bool``) THEN
      ASM_REWRITE_TAC[] THEN DISCH_THEN(X_CHOOSE_THEN ``v:real->bool``
       (CONJUNCTS_THEN2 ASSUME_TAC SUBST_ALL_TAC)) THEN
      ASM_MESON_TAC[CLOSURE_CLOSED, INTER_SUBSET, SUBSET_CLOSURE, SUBSET_DEF,
                    IN_INTER, CLOSURE_SUBSET],
      ALL_TAC] THEN
    SUBGOAL_THEN ``!x:real. x IN u ==> &0 < setdist({x},s) + setdist({x},t)``
    ASSUME_TAC THENL
     [REPEAT STRIP_TAC THEN MATCH_MP_TAC(REAL_ARITH
        ``&0 <= x /\ &0 <= y /\ ~((x = &0) /\ (y = &0)) ==> &0 < x + y:real``) THEN
      REWRITE_TAC[SETDIST_POS_LE] THEN ASM_SET_TAC[],
      ALL_TAC] THEN
    REPEAT CONJ_TAC THENL
     [ONCE_REWRITE_TAC [METIS [] ``(\x. a +
       setdist ({x},s) / (setdist ({x},s) + setdist ({x},t)) * (b - a)) =
                                   (\x. (\x. a) x +
       (\x. setdist ({x},s) / (setdist ({x},s) + setdist ({x},t)) * (b - a)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN REWRITE_TAC[CONTINUOUS_ON_CONST] THEN
      REWRITE_TAC[real_div, GSYM REAL_MUL_ASSOC] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. setdist ({x},s) *
       (inv (setdist ({x},s) + setdist ({x},t)) * (b - a))) =
                                   (\x. (\x. setdist ({x},s)) x *
       (\x. (inv (setdist ({x},s) + setdist ({x},t)) * (b - a))) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN CONJ_TAC THENL
      [REWRITE_TAC[CONTINUOUS_ON_SETDIST], ALL_TAC] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. inv (setdist ({x},s) + setdist ({x},t)) * (b - a)) =
            (\x. (\x. inv (setdist ({x},s) + setdist ({x},t))) x * (\x. (b - a)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_MUL THEN REWRITE_TAC[CONTINUOUS_ON_CONST, o_DEF] THEN
      REWRITE_TAC[CONTINUOUS_ON_SETDIST] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. inv (setdist ({x},s) + setdist ({x},t))) =
                              (\x. inv ((\x. setdist ({x},s) + setdist ({x},t)) x))``] THEN
      MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
      ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE] THEN
      ONCE_REWRITE_TAC [METIS [] ``(\x. setdist ({x},s) + setdist ({x},t)) =
                      (\x. (\x. setdist ({x},s)) x + (\x. setdist ({x},t)) x)``] THEN
      MATCH_MP_TAC CONTINUOUS_ON_ADD THEN
      REWRITE_TAC[CONTINUOUS_ON_SETDIST],
      X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      SIMP_TAC std_ss[segment, GSPECIFICATION] THEN ONCE_REWRITE_TAC [CONJ_SYM] THEN
      SIMP_TAC real_ss [REAL_ENTIRE, LEFT_AND_OVER_OR, REAL_ARITH
       ``(a + x * (b - a):real = (&1 - u) * a + u * b) <=>
        ((x - u) * (b - a) = 0)``, EXISTS_OR_THM] THEN
      DISJ1_TAC THEN ONCE_REWRITE_TAC[CONJ_SYM] THEN
      REWRITE_TAC[REAL_SUB_0, UNWIND_THM1] THEN
      ASM_SIMP_TAC std_ss [REAL_LE_DIV, REAL_LE_ADD, SETDIST_POS_LE, REAL_LE_LDIV_EQ,
                   REAL_ARITH ``a <= &1 * (a + b) <=> &0 <= b:real``],
      SIMP_TAC real_ss [REAL_ARITH ``(a + x:real = a) <=> (x = 0)``],
      REWRITE_TAC[REAL_ARITH ``(a + x * (b - a):real = b) <=>
                               ((x - &1) * (b - a) = 0)``]] THEN
    ASM_REWRITE_TAC[REAL_ENTIRE, REAL_SUB_0] THEN
    ASM_SIMP_TAC std_ss [REAL_SUB_0, REAL_EQ_LDIV_EQ,
                 REAL_MUL_LZERO, REAL_MUL_LID] THEN
    REWRITE_TAC[REAL_ARITH ``(x:real = x + y) <=> (y = &0)``] THEN
    ASM_REWRITE_TAC[]);

val URYSOHN_LOCAL_STRONG = store_thm ("URYSOHN_LOCAL_STRONG",
 ``!s t u a b.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {}) /\ ~(a = b)
        ==> ?f:real->real.
               f continuous_on u /\
               (!x. x IN u ==> f(x) IN segment[a,b]) /\
               (!x. x IN u ==> ((f x = a) <=> x IN s)) /\
               (!x. x IN u ==> ((f x = b) <=> x IN t))``,
  KNOW_TAC ``!(s :real -> bool) (t :real -> bool).
   (\s t. !(u :real -> bool) (a :real) (b :real).
  closed_in (subtopology euclidean u) s /\
  closed_in (subtopology euclidean u) t /\
  (s INTER t = ({} :real -> bool)) /\ a <> b ==>
  ?(f :real -> real).
    f continuous_on u /\
    (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
    (!(x :real). x IN u ==> ((f x = a) <=> x IN s)) /\
    !(x :real). x IN u ==> ((f x = b) <=> x IN t)) s t`` THENL
  [ALL_TAC, SIMP_TAC std_ss []] THEN
  MATCH_MP_TAC(MESON[]
   ``(!s t. P s t <=> P t s) /\
    (!s t. ~(s = {}) /\ ~(t = {}) ==> P s t) /\
    P {} {} /\ (!t. ~(t = {}) ==> P {} t)
    ==> !s t. P s t``) THEN
  SIMP_TAC std_ss [] THEN REPEAT CONJ_TAC THENL

   [REPEAT GEN_TAC THEN
    KNOW_TAC ``(!(u :real -> bool) (a :real) (b :real).
   closed_in (subtopology euclidean u) (s :real -> bool) /\
   closed_in (subtopology euclidean u) (t :real -> bool) /\
   (s INTER t = ({} :real -> bool)) /\ a <> b ==>
   ?(f :real -> real).
     f continuous_on u /\
     (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
     (!(x :real). x IN u ==> ((f x = a) <=> x IN s)) /\
     !(x :real). x IN u ==> ((f x = b) <=> x IN t)) <=>
   !(u :real -> bool) (b :real) (a :real).
   closed_in (subtopology euclidean u) t /\
   closed_in (subtopology euclidean u) s /\
   (t INTER s = ({} :real -> bool)) /\ a <> b ==>
   ?(f :real -> real).
    f continuous_on u /\
    (!(x :real). x IN u ==> f x IN segment [(a,b)]) /\
    (!(x :real). x IN u ==> ((f x = a) <=> x IN t)) /\
    !(x :real). x IN u ==> ((f x = b) <=> x IN s)`` THENL
    [ALL_TAC, DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     EQ_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THENL
     [POP_ASSUM (MP_TAC o SPECL [``u:real->bool``,``b:real``,``a:real``]),
      POP_ASSUM (MP_TAC o SPECL [``u:real->bool``,``a:real``,``b:real``])] THEN
     SIMP_TAC std_ss []] THEN
    REPEAT(AP_TERM_TAC THEN ABS_TAC) THEN
    METIS_TAC[SEGMENT_SYM, INTER_COMM, CONJ_ACI, EQ_SYM_EQ],
    SIMP_TAC real_ss [lemma],
    REPEAT STRIP_TAC THEN EXISTS_TAC ``(\x. midpoint(a,b)):real->real`` THEN
    ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, CONTINUOUS_ON_CONST, MIDPOINT_IN_SEGMENT] THEN
    REWRITE_TAC[midpoint] THEN CONJ_TAC THEN GEN_TAC THEN DISCH_TAC THEN
    UNDISCH_TAC ``~(a:real = b)`` THEN REWRITE_TAC[GSYM MONO_NOT_EQ] THEN
    ONCE_REWRITE_TAC [REAL_MUL_SYM] THEN REWRITE_TAC [GSYM real_div] THEN
    SIMP_TAC std_ss [REAL_EQ_LDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
    REAL_ARITH_TAC,
    REPEAT STRIP_TAC THEN ASM_CASES_TAC ``t:real->bool = u`` THENL
     [EXISTS_TAC ``(\x. b):real->real`` THEN
      ASM_SIMP_TAC std_ss [NOT_IN_EMPTY, ENDS_IN_SEGMENT, IN_UNIV,
                      CONTINUOUS_ON_CONST],
      SUBGOAL_THEN ``?c:real. c IN u /\ ~(c IN t)`` STRIP_ASSUME_TAC THENL
       [REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET)) THEN
        REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN ASM_SET_TAC[],
        ALL_TAC] THEN
      MP_TAC(ISPECL [``{c:real}``, ``t:real->bool``, ``u:real->bool``,
                     ``midpoint(a,b):real``, ``b:real``] lemma) THEN
      ASM_REWRITE_TAC[CLOSED_IN_SING, MIDPOINT_EQ_ENDPOINT] THEN
      KNOW_TAC ``({(c :real)} INTER (t :real -> bool) = ({} :real -> bool)) /\
                   {c} <> ({} :real -> bool)`` THENL
      [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN EXISTS_TAC ``f:real->real`` THEN
      POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [NOT_IN_EMPTY] THEN
      STRIP_TAC THEN CONJ_TAC THENL
       [SUBGOAL_THEN
         ``segment[midpoint(a,b):real,b] SUBSET segment[a,b]`` MP_TAC
        THENL
         [REWRITE_TAC[SUBSET_DEF, IN_SEGMENT, midpoint] THEN GEN_TAC THEN
          DISCH_THEN(X_CHOOSE_THEN ``u:real`` STRIP_ASSUME_TAC) THEN
          EXISTS_TAC ``(&1 + u) / &2:real`` THEN ASM_REWRITE_TAC[] THEN
          SIMP_TAC std_ss [REAL_LE_LDIV_EQ, REAL_LE_RDIV_EQ, REAL_ARITH ``0 < 2:real``] THEN
          CONJ_TAC THENL [UNDISCH_TAC ``0 <= u:real`` THEN REAL_ARITH_TAC, ALL_TAC] THEN
          CONJ_TAC THENL [UNDISCH_TAC ``u <= 1:real`` THEN REAL_ARITH_TAC, ALL_TAC] THEN
          ONCE_REWRITE_TAC [REAL_ARITH ``a * (b * c) = (a * c) * b:real``] THEN
          GEN_REWR_TAC (LAND_CONV o RAND_CONV) [GSYM REAL_MUL_RID] THEN
          ONCE_REWRITE_TAC [METIS [REAL_DIV_REFL, REAL_ARITH ``2 <> 0:real``]
           ``u * b * 1 = u * b * (2 / 2:real)``] THEN REWRITE_TAC [real_div] THEN
          ONCE_REWRITE_TAC [REAL_ARITH ``u * b * (2 * inv 2) = (u * b * 2) * inv 2:real``] THEN
          REWRITE_TAC [GSYM REAL_ADD_RDISTRIB] THEN REWRITE_TAC [GSYM real_div] THEN
          SIMP_TAC real_ss [REAL_EQ_LDIV_EQ] THEN REWRITE_TAC [REAL_ADD_RDISTRIB] THEN
          REWRITE_TAC [real_div, REAL_SUB_RDISTRIB] THEN
          REWRITE_TAC [REAL_ARITH
          ``(1 + u) * inv 2 * a * 2 = (1 + u) * a * (inv 2 * 2:real)``] THEN
          SIMP_TAC real_ss [REAL_MUL_LINV] THEN REAL_ARITH_TAC,
          ASM_SET_TAC[]],
        SUBGOAL_THEN ``~(a IN segment[midpoint(a,b):real,b])`` MP_TAC THENL
         [ALL_TAC, ASM_MESON_TAC[]] THEN
        DISCH_THEN(MP_TAC o CONJUNCT2 o MATCH_MP DIST_IN_CLOSED_SEGMENT) THEN
        REWRITE_TAC[DIST_MIDPOINT] THEN
        UNDISCH_TAC ``~(a:real = b)`` THEN REWRITE_TAC [dist] THEN
        SIMP_TAC real_ss [REAL_LE_RDIV_EQ] THEN REWRITE_TAC [REAL_NOT_LE] THEN
        REWRITE_TAC [abs] THEN COND_CASES_TAC THEN POP_ASSUM MP_TAC THEN REAL_ARITH_TAC]]]);

val URYSOHN_LOCAL = store_thm ("URYSOHN_LOCAL",
 ``!s t u a b.
        closed_in (subtopology euclidean u) s /\
        closed_in (subtopology euclidean u) t /\
        (s INTER t = {})
        ==> ?f:real->real.
               f continuous_on u /\
               (!x. x IN u ==> f(x) IN segment[a,b]) /\
               (!x. x IN s ==> (f x = a)) /\
               (!x. x IN t ==> (f x = b))``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``a:real = b`` THENL
   [EXISTS_TAC ``(\x. b):real->real`` THEN
    ASM_REWRITE_TAC[ENDS_IN_SEGMENT, CONTINUOUS_ON_CONST],
    MP_TAC(ISPECL [``s:real->bool``, ``t:real->bool``, ``u:real->bool``,
                   ``a:real``, ``b:real``] URYSOHN_LOCAL_STRONG) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``f:real->real``) THEN
    EXISTS_TAC ``f:real->real`` THEN POP_ASSUM MP_TAC THEN SIMP_TAC std_ss [] THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP CLOSED_IN_SUBSET)) THEN
    REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY] THEN SET_TAC[]]);

val URYSOHN_STRONG = store_thm ("URYSOHN_STRONG",
 ``!s t a b.
        closed s /\ closed t /\ (s INTER t = {}) /\ ~(a = b)
        ==> ?f:real->real.
               f continuous_on univ(:real) /\ (!x. f(x) IN segment[a,b]) /\
               (!x. (f x = a) <=> x IN s) /\ (!x. (f x = b) <=> x IN t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN] THEN
  ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN
  DISCH_THEN(MP_TAC o MATCH_MP URYSOHN_LOCAL_STRONG) THEN
  REWRITE_TAC[IN_UNIV]);

val URYSOHN = store_thm ("URYSOHN",
 ``!s t a b.
        closed s /\ closed t /\ (s INTER t = {})
        ==> ?f:real->real.
               f continuous_on univ(:real) /\ (!x. f(x) IN segment[a,b]) /\
               (!x. x IN s ==> (f x = a)) /\ (!x. x IN t ==> (f x = b))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[CLOSED_IN] THEN
  ONCE_REWRITE_TAC[GSYM SUBTOPOLOGY_UNIV] THEN DISCH_THEN
   (MP_TAC o ISPECL [``a:real``, ``b:real``] o MATCH_MP URYSOHN_LOCAL) THEN
  REWRITE_TAC[IN_UNIV]);

(* ------------------------------------------------------------------------- *)
(* Basics about "local" properties in general.                               *)
(* ------------------------------------------------------------------------- *)

val locally = new_definition ("locally",
 ``locally P (s:real->bool) <=>
        !w x. open_in (subtopology euclidean s) w /\ x IN w
              ==> ?u v. open_in (subtopology euclidean s) u /\ P v /\
                        x IN u /\ u SUBSET v /\ v SUBSET w``);

val LOCALLY_MONO = store_thm ("LOCALLY_MONO",
 ``!P Q s. (!t. P t ==> Q t) /\ locally P s ==> locally Q s``,
  REWRITE_TAC[locally] THEN MESON_TAC[]);

val LOCALLY_OPEN_SUBSET = store_thm ("LOCALLY_OPEN_SUBSET",
 ``!P s t:real->bool.
        locally P s /\ open_in (subtopology euclidean s) t
        ==> locally P t``,
  REPEAT GEN_TAC THEN REWRITE_TAC[locally] THEN STRIP_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real->bool``, ``x:real``]) THEN
  KNOW_TAC ``open_in (subtopology euclidean s) w /\ x IN w`` THENL
  [ASM_MESON_TAC[OPEN_IN_TRANS],
   DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
  STRIP_TAC THEN EXISTS_TAC ``u:real->bool`` THEN EXISTS_TAC ``v:real->bool`` THEN
  ASM_REWRITE_TAC[] THEN MATCH_MP_TAC OPEN_IN_SUBSET_TRANS THEN
  EXISTS_TAC ``s:real->bool`` THEN ASM_MESON_TAC[open_in, SUBSET_DEF]);

val LOCALLY_DIFF_CLOSED = store_thm ("LOCALLY_DIFF_CLOSED",
 ``!P s t:real->bool.
        locally P s /\ closed_in (subtopology euclidean s) t
        ==> locally P (s DIFF t)``,
  REPEAT STRIP_TAC THEN
  MATCH_MP_TAC LOCALLY_OPEN_SUBSET THEN
  EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
  MATCH_MP_TAC OPEN_IN_DIFF THEN
  ASM_REWRITE_TAC[OPEN_IN_SUBTOPOLOGY_REFL, SUBSET_UNIV, TOPSPACE_EUCLIDEAN]);

val LOCALLY_EMPTY = store_thm ("LOCALLY_EMPTY",
 ``!P. locally P {}``,
  REWRITE_TAC[locally] THEN MESON_TAC[open_in, SUBSET_DEF, NOT_IN_EMPTY]);

val LOCALLY_SING = store_thm ("LOCALLY_SING",
 ``!P a. locally P {a} <=> P {a}``,
  REWRITE_TAC[locally, open_in] THEN
  REWRITE_TAC[SET_RULE
   ``(w SUBSET {a} /\ P) /\ x IN w <=> (w = {a}) /\ (x = a) /\ P``] THEN
  SIMP_TAC std_ss [CONJ_EQ_IMP, RIGHT_FORALL_IMP_THM, UNWIND_FORALL_THM2, IN_SING] THEN
  REWRITE_TAC[SET_RULE
   ``(u SUBSET {a} /\ P) /\ Q /\ a IN u /\ u SUBSET v /\ v SUBSET {a} <=>
    (u = {a}) /\ (v = {a}) /\ P /\ Q``] THEN
  SIMP_TAC std_ss [RIGHT_EXISTS_AND_THM, UNWIND_THM2, IN_SING] THEN
  REWRITE_TAC[UNWIND_FORALL_THM2, MESON[REAL_LT_01] ``?x:real. &0 < x``]);

val LOCALLY_INTER = store_thm ("LOCALLY_INTER",
 ``!P:(real->bool)->bool.
        (!s t. P s /\ P t ==> P(s INTER t))
        ==> !s t. locally P s /\ locally P t ==> locally P (s INTER t)``,
  GEN_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THEN
  REWRITE_TAC[locally, OPEN_IN_OPEN] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM] THEN
  REWRITE_TAC [GSYM CONJ_ASSOC] THEN
  ONCE_REWRITE_TAC [METIS [] ``( ?v t.
     open t /\ P v /\ x IN s INTER t /\ s INTER t SUBSET v /\
           v SUBSET w) = (\w x.  ?v t.
     open t /\ P v /\ x IN s INTER t /\ s INTER t SUBSET v /\
           v SUBSET w) w x``] THEN
  ONCE_REWRITE_TAC [METIS [] ``s INTER t = (\t. s INTER t:real->bool) t``] THEN
  ONCE_REWRITE_TAC [METIS [] ``x IN w <=> (\w x.  x IN w) w x``] THEN
  ONCE_REWRITE_TAC [METIS[]
   ``(!w x. (?t. P t /\ (w = f t) /\ Q w x) ==> R w x) <=>
     (!t x. P t /\ Q (f t) x ==> R (f t) x)``] THEN
  SIMP_TAC std_ss [] THEN
  SIMP_TAC std_ss [GSYM FORALL_AND_THM, UNWIND_THM2, IN_INTER] THEN
  DISCH_TAC THEN X_GEN_TAC ``w:real->bool`` THEN X_GEN_TAC ``x:real`` THEN
  POP_ASSUM (MP_TAC o SPECL [``w:real->bool``,``x:real``]) THEN
  DISCH_THEN(fn th => STRIP_TAC THEN MP_TAC th) THEN
  ASM_REWRITE_TAC[] THEN DISCH_THEN(CONJUNCTS_THEN2
   (X_CHOOSE_THEN ``u1:real->bool`` (X_CHOOSE_THEN ``v1:real->bool``
        STRIP_ASSUME_TAC))
   (X_CHOOSE_THEN ``u2:real->bool`` (X_CHOOSE_THEN ``v2:real->bool``
        STRIP_ASSUME_TAC))) THEN
  EXISTS_TAC ``u1 INTER u2:real->bool`` THEN
  EXISTS_TAC ``v1 INTER v2:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER] THEN ASM_SET_TAC[]);

val lemma = prove (
  ``!P Q f g. (!s t. P s /\ homeomorphism (s,t) (f,g) ==> Q t)
        ==> (!s:real->bool t:real->bool.
                locally P s /\ homeomorphism (s,t) (f,g) ==> locally Q t)``,
    REPEAT GEN_TAC THEN DISCH_TAC THEN REPEAT GEN_TAC THEN
    REWRITE_TAC[locally] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(STRIP_ASSUME_TAC o REWRITE_RULE [homeomorphism]) THEN
    MAP_EVERY X_GEN_TAC [``w:real->bool``, ``y:real``] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPECL
     [``IMAGE (g:real->real) w``, ``(g:real->real) y``]) THEN
    KNOW_TAC ``open_in (subtopology euclidean (s :real -> bool))
                     (IMAGE (g :real -> real) (w :real -> bool)) /\
                             g (y :real) IN IMAGE g w`` THENL
     [CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
      SUBGOAL_THEN ``IMAGE (g:real->real) w =
                     {x | x IN s /\ f(x) IN w}``
      SUBST1_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[],
        MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``IMAGE (f:real->real) u``, ``IMAGE (f:real->real) v``] THEN
    CONJ_TAC THENL
     [SUBGOAL_THEN ``IMAGE (f:real->real) u =
                     {x | x IN t /\ g(x) IN u}``
      SUBST1_TAC THENL
       [RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[],
        MATCH_MP_TAC CONTINUOUS_ON_IMP_OPEN_IN THEN ASM_REWRITE_TAC[]],
      ALL_TAC] THEN
    CONJ_TAC THENL
     [FIRST_X_ASSUM MATCH_MP_TAC THEN EXISTS_TAC ``v:real->bool`` THEN
      ASM_REWRITE_TAC[homeomorphism] THEN
      REWRITE_TAC[homeomorphism] THEN REPEAT CONJ_TAC THEN
      TRY(FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[CONJ_EQ_IMP]
          CONTINUOUS_ON_SUBSET))),
      ALL_TAC] THEN
    RULE_ASSUM_TAC(REWRITE_RULE[open_in]) THEN ASM_SET_TAC[]);

val HOMEOMORPHISM_LOCALLY = store_thm ("HOMEOMORPHISM_LOCALLY",
 ``!P Q f:real->real g.
        (!s t. homeomorphism (s,t) (f,g) ==> (P s <=> Q t))
        ==> (!s t. homeomorphism (s,t) (f,g)
                   ==> (locally P s <=> locally Q t))``,
  REPEAT STRIP_TAC THEN EQ_TAC THEN
  MATCH_MP_TAC(SIMP_RULE std_ss [RIGHT_IMP_FORALL_THM,
        TAUT `p ==> q /\ r ==> s <=> p /\ r ==> q ==> s`] lemma) THEN
  ASM_MESON_TAC[HOMEOMORPHISM_SYM]);

val HOMEOMORPHIC_LOCALLY = store_thm ("HOMEOMORPHIC_LOCALLY",
 ``!P Q. (!s:real->bool t:real->bool. s homeomorphic t ==> (P s <=> Q t))
         ==> (!s t. s homeomorphic t ==> (locally P s <=> locally Q t))``,
  REPEAT GEN_TAC THEN STRIP_TAC THEN
  SIMP_TAC std_ss [homeomorphic, LEFT_IMP_EXISTS_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(homeomorphism (s,t) (f,g) ==>
                               (locally P s <=> locally Q t)) =
                     (\s t f g. homeomorphism (s,t) (f,g) ==>
                               (locally P s <=> locally Q t)) s t f g``] THEN
  ONCE_REWRITE_TAC[METIS[]
   ``(!a b c d. P a b c d) <=> (!c d a b. P a b c d)``] THEN
  GEN_TAC THEN GEN_TAC THEN BETA_TAC THEN MATCH_MP_TAC HOMEOMORPHISM_LOCALLY THEN
  ASM_MESON_TAC[homeomorphic]);

val LOCALLY_TRANSLATION = store_thm ("LOCALLY_TRANSLATION",
 ``!P:(real->bool)->bool.
        (!a s. P (IMAGE (\x. a + x) s) <=> P s)
        ==> (!a s. locally P (IMAGE (\x. a + x) s) <=> locally P s)``,
  GEN_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``a:real``) THEN
  MP_TAC(ISPECL
   [``P:(real->bool)->bool``, ``P:(real->bool)->bool``,
    ``\x:real. a + x``, ``\x:real. -a + x``]
     HOMEOMORPHISM_LOCALLY) THEN
  SIMP_TAC real_ss [homeomorphism] THEN
  SIMP_TAC real_ss [CONTINUOUS_ON_ADD, CONTINUOUS_ON_CONST, CONTINUOUS_ON_ID] THEN
  SIMP_TAC real_ss [UNWIND_FORALL_THM1, CONJ_EQ_IMP, GSYM IMAGE_COMPOSE, o_DEF] THEN
  REWRITE_TAC [REAL_ARITH ``(-a + (a + x:real) = x) /\ (a + (-a + x) = x:real)``] THEN
  REWRITE_TAC [IMAGE_ID] THEN METIS_TAC[]);

val LOCALLY_INJECTIVE_LINEAR_IMAGE = store_thm ("LOCALLY_INJECTIVE_LINEAR_IMAGE",
 ``!P:(real->bool)->bool Q:(real->bool)->bool.
        (!f s. linear f /\ (!x y. (f x = f y) ==> (x = y))
               ==> (P (IMAGE f s) <=> Q s))
        ==>  (!f s. linear f /\ (!x y. (f x = f y) ==> (x = y))
                    ==> (locally P (IMAGE f s) <=> locally Q s))``,
  GEN_TAC THEN GEN_TAC THEN
  DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``f:real->real``) THEN
  ASM_CASES_TAC ``linear(f:real->real) /\ (!x y. (f x = f y) ==> (x = y))`` THEN
  ASM_REWRITE_TAC[] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP LINEAR_INJECTIVE_LEFT_INVERSE) THEN
  REWRITE_TAC[FUN_EQ_THM, o_THM, I_THM] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:real->real`` STRIP_ASSUME_TAC) THEN
  MP_TAC(ISPECL
   [``Q:(real->bool)->bool``, ``P:(real->bool)->bool``,
    ``f:real->real``, ``g:real->real``]
     HOMEOMORPHISM_LOCALLY) THEN
  ASM_SIMP_TAC std_ss [homeomorphism, LINEAR_CONTINUOUS_ON] THEN
  ASM_SIMP_TAC std_ss [UNWIND_FORALL_THM1, CONJ_EQ_IMP, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [GSYM IMAGE_COMPOSE, o_DEF, IMAGE_ID] THEN MESON_TAC[]);

val LOCALLY_OPEN_MAP_IMAGE = store_thm ("LOCALLY_OPEN_MAP_IMAGE",
 ``!P Q f:real->real s.
        f continuous_on s /\
        (!t. open_in (subtopology euclidean s) t
              ==> open_in (subtopology euclidean (IMAGE f s)) (IMAGE f t)) /\
        (!t. t SUBSET s /\ P t ==> Q(IMAGE f t)) /\
        locally P s
        ==> locally Q (IMAGE f s)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  REWRITE_TAC[locally] THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``y:real``] THEN
  STRIP_TAC THEN
  FIRST_ASSUM(ASSUME_TAC o CONJUNCT1 o REWRITE_RULE [open_in]) THEN
  UNDISCH_TAC ``f continuous_on s`` THEN DISCH_TAC THEN
  FIRST_ASSUM(MP_TAC o  SPEC ``w:real->bool`` o
    REWRITE_RULE [CONTINUOUS_ON_OPEN]) THEN
  ASM_REWRITE_TAC[] THEN DISCH_TAC THEN
  SUBGOAL_THEN ``?x. x IN s /\ ((f:real->real) x = y)`` STRIP_ASSUME_TAC THENL
   [ASM_SET_TAC[], ALL_TAC] THEN
  FIRST_X_ASSUM(MP_TAC o SPECL
   [``{x | x IN s /\ (f:real->real) x IN w}``, ``x:real``]) THEN
  ASM_SIMP_TAC real_ss [GSPECIFICATION, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN MAP_EVERY EXISTS_TAC
   [``IMAGE (f:real->real) u``, ``IMAGE (f:real->real) v``] THEN
  ASM_SIMP_TAC real_ss [] THEN CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
  FIRST_X_ASSUM MATCH_MP_TAC THEN ASM_SET_TAC[]);

(* ------------------------------------------------------------------------- *)
(* F_sigma and G_delta sets.                                                 *)
(* ------------------------------------------------------------------------- *)

Overload gdelta = “gdelta_in euclidean”
Overload fsigma = “fsigma_in euclidean”

Theorem gdelta :
    !s. gdelta (s:real->bool) <=>
        ?g. COUNTABLE g /\ (!u. u IN g ==> open u) /\ (BIGINTER g = s)
Proof
    rw [gdelta_in, INTERSECTION_OF, euclidean_open_def, SUBSET_DEF, IN_APP,
        TOPSPACE_EUCLIDEAN, RELATIVE_TO_UNIV]
QED

Theorem fsigma :
    !s. fsigma (s:real->bool) <=>
        ?g. COUNTABLE g /\ (!c. c IN g ==> closed c) /\ (BIGUNION g = s)
Proof
    rw [fsigma_in, UNION_OF, euclidean_closed_def, SUBSET_DEF, IN_APP]
QED

Theorem GDELTA_COMPLEMENT :
   !s. gdelta(univ(:real) DIFF s) <=> fsigma s
Proof
   rw [GDELTA_IN_FSIGMA_IN, TOPSPACE_EUCLIDEAN, COMPL_COMPL_applied]
QED

Theorem METRIZABLE_SPACE_EUCLIDEAN :
   metrizable_space euclidean
Proof
   REWRITE_TAC[euclidean_def, METRIZABLE_SPACE_MTOPOLOGY]
QED

Theorem CLOSED_AS_GDELTA :
   !s:real->bool. closed s ==> gdelta s
Proof
    RW_TAC std_ss [euclidean_closed_def]
 >> MATCH_MP_TAC CLOSED_IMP_GDELTA_IN
 >> ASM_REWRITE_TAC [METRIZABLE_SPACE_EUCLIDEAN]
QED

(* ------------------------------------------------------------------------- *)
(* Local compactness.                                                        *)
(* ------------------------------------------------------------------------- *)

val LOCALLY_COMPACT = store_thm ("LOCALLY_COMPACT",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s ==> ?u v. x IN u /\ u SUBSET v /\ v SUBSET s /\
                             open_in (subtopology euclidean s) u /\
                             compact v``,
  GEN_TAC THEN REWRITE_TAC[locally] THEN EQ_TAC THEN DISCH_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN FIRST_X_ASSUM
     (MP_TAC o SPECL [``s INTER ball(x:real,&1)``, ``x:real``]) THEN
    ASM_SIMP_TAC real_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
    ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_LT_01] THEN
    MESON_TAC[SUBSET_INTER],
    MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN
    REWRITE_TAC[CONJ_EQ_IMP] THEN GEN_REWR_TAC LAND_CONV [OPEN_IN_OPEN] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    ASM_REWRITE_TAC[IN_INTER] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC real_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN
    UNDISCH_TAC ``open t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
    DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``(s INTER ball(x:real,e)) INTER u`` THEN
    EXISTS_TAC ``cball(x:real,e) INTER v`` THEN
    ASM_SIMP_TAC real_ss [OPEN_IN_INTER, OPEN_IN_OPEN_INTER, OPEN_BALL, CENTRE_IN_BALL,
                 COMPACT_INTER, COMPACT_CBALL, IN_INTER] THEN
    MP_TAC(ISPECL [``x:real``, ``e:real``] BALL_SUBSET_CBALL) THEN
    ASM_SET_TAC[]]);

val LOCALLY_COMPACT_ALT = store_thm ("LOCALLY_COMPACT_ALT",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s
            ==> ?u. x IN u /\
                    open_in (subtopology euclidean s) u /\
                    compact(closure u) /\ closure u SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  METIS_TAC[CLOSURE_SUBSET, SUBSET_TRANS, CLOSURE_MINIMAL,
            COMPACT_CLOSURE, BOUNDED_SUBSET, COMPACT_EQ_BOUNDED_CLOSED]);

val LOCALLY_COMPACT_INTER_CBALL = store_thm ("LOCALLY_COMPACT_INTER_CBALL",
 ``!s:real->bool.
        locally compact s <=>
        !x. x IN s ==> ?e. &0 < e /\ closed(cball(x,e) INTER s)``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT, OPEN_IN_CONTAINS_CBALL] THEN
  EQ_TAC THEN DISCH_TAC THEN GEN_TAC THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_SIMP_TAC real_ss [LEFT_IMP_EXISTS_THM] THENL
  [ MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN
    ASM_REWRITE_TAC[] THEN
    SUBGOAL_THEN ``cball(x:real,e) INTER s = cball (x,e) INTER v``
    SUBST1_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    ASM_SIMP_TAC real_ss [COMPACT_CBALL, COMPACT_INTER, COMPACT_IMP_CLOSED],

    X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
    EXISTS_TAC ``ball(x:real,e) INTER s`` THEN
    EXISTS_TAC ``cball(x:real,e) INTER s`` THEN
    REWRITE_TAC[GSYM OPEN_IN_CONTAINS_CBALL] THEN
    ASM_SIMP_TAC real_ss [IN_INTER, CENTRE_IN_BALL, INTER_SUBSET] THEN
    ASM_SIMP_TAC real_ss [COMPACT_EQ_BOUNDED_CLOSED, BOUNDED_INTER, BOUNDED_CBALL] THEN
    ONCE_REWRITE_TAC[INTER_COMM] THEN
    SIMP_TAC real_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
    REWRITE_TAC [SUBSET_DEF, IN_INTER] THEN GEN_TAC THEN DISCH_TAC THEN ASM_REWRITE_TAC [] THEN
    METIS_TAC[SUBSET_DEF, BALL_SUBSET_CBALL]]);

val LOCALLY_COMPACT_INTER_CBALLS = store_thm ("LOCALLY_COMPACT_INTER_CBALLS",
 ``!s:real->bool.
      locally compact s <=>
      !x. x IN s ==> ?e. &0 < e /\ !d. d <= e ==> closed(cball(x,d) INTER s)``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL] THEN
  EQ_TAC THENL [ALL_TAC, METIS_TAC[REAL_LE_REFL]] THEN
  DISCH_TAC THEN X_GEN_TAC ``x:real`` THEN POP_ASSUM (MP_TAC o SPEC ``x:real``) THEN
  ASM_CASES_TAC ``(x:real) IN s`` THEN ASM_REWRITE_TAC[] THEN
  STRIP_TAC THEN EXISTS_TAC ``e:real`` THEN ASM_REWRITE_TAC[] THEN
  GEN_TAC THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``cball(x:real,d) INTER s = cball(x,d) INTER cball(x,e) INTER s``
  SUBST1_TAC THENL
  [ REWRITE_TAC[INTER_ASSOC, GSYM CBALL_MIN_INTER] THEN
    AP_THM_TAC THEN AP_TERM_TAC THEN AP_TERM_TAC THEN
    BINOP_TAC THEN REWRITE_TAC[min_def] THEN PROVE_TAC [],
    ASM_SIMP_TAC real_ss [GSYM INTER_ASSOC, CLOSED_INTER, CLOSED_CBALL] ]);

val LOCALLY_COMPACT_COMPACT = store_thm ("LOCALLY_COMPACT_COMPACT",
 ``!s:real->bool.
        locally compact s <=>
        !k. k SUBSET s /\ compact k
            ==> ?u v. k SUBSET u /\
                      u SUBSET v /\
                      v SUBSET s /\
                      open_in (subtopology euclidean s) u /\
                      compact v``,
  GEN_TAC THEN GEN_REWR_TAC LAND_CONV [LOCALLY_COMPACT] THEN EQ_TAC THEN
  REPEAT STRIP_TAC THENL
   [ALL_TAC, METIS_TAC[SING_SUBSET, COMPACT_SING]] THEN
  UNDISCH_TAC ``!x. x IN s ==>
        ?u v. x IN u /\ u SUBSET v /\ v SUBSET s /\
          open_in (subtopology euclidean s) u /\ compact v`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->real->bool``, ``v:real->real->bool``] THEN
  DISCH_TAC THEN UNDISCH_TAC ``compact k`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE
   [COMPACT_EQ_HEINE_BOREL_SUBTOPOLOGY]) THEN
  DISCH_THEN(MP_TAC o SPEC ``IMAGE (\x:real. k INTER u x) k``) THEN
  ASM_SIMP_TAC std_ss [FORALL_IN_IMAGE, BIGUNION_IMAGE] THEN
  KNOW_TAC ``(!(x :real).
    x IN (k :real -> bool) ==>
    open_in (subtopology euclidean k)
      (k INTER (u :real -> real -> bool) x)) /\
    k SUBSET {y | ?(x :real). x IN k /\ y IN k INTER u x}`` THENL
   [CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
    REPEAT STRIP_TAC THEN MATCH_MP_TAC OPEN_IN_SUBTOPOLOGY_INTER_SUBSET THEN
    EXISTS_TAC ``s:real->bool`` THEN ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC OPEN_IN_INTER THEN REWRITE_TAC[OPEN_IN_REFL] THEN
    ASM_SET_TAC[],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    ONCE_REWRITE_TAC[TAUT `p /\ q /\ r <=> q /\ p /\ r`] THEN
    SIMP_TAC std_ss [EXISTS_FINITE_SUBSET_IMAGE, BIGUNION_IMAGE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``t:real->bool`` STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``BIGUNION(IMAGE (u:real->real->bool) t)`` THEN
    EXISTS_TAC ``BIGUNION(IMAGE (v:real->real->bool) t)`` THEN
    REPEAT CONJ_TAC THENL
     [ALL_TAC, ALL_TAC, ALL_TAC, MATCH_MP_TAC OPEN_IN_BIGUNION,
      MATCH_MP_TAC COMPACT_BIGUNION THEN ASM_SIMP_TAC std_ss [IMAGE_FINITE]] THEN
    ASM_SET_TAC[]]);

val LOCALLY_COMPACT_COMPACT_ALT = store_thm ("LOCALLY_COMPACT_COMPACT_ALT",
 ``!s:real->bool.
        locally compact s <=>
        !k. k SUBSET s /\ compact k
            ==> ?u. k SUBSET u /\
                    open_in (subtopology euclidean s) u /\
                    compact(closure u) /\ closure u SUBSET s``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_COMPACT] THEN EQ_TAC THEN
  DISCH_TAC THEN X_GEN_TAC ``k:real->bool`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN (X_CHOOSE_TAC ``u:real->bool``) THEN EXISTS_TAC ``u:real->bool`` THEN
  POP_ASSUM MP_TAC THEN
  METIS_TAC[CLOSURE_SUBSET, SUBSET_TRANS, CLOSURE_MINIMAL,
            COMPACT_CLOSURE, BOUNDED_SUBSET, COMPACT_EQ_BOUNDED_CLOSED]);

val LOCALLY_COMPACT_COMPACT_SUBOPEN = store_thm ("LOCALLY_COMPACT_COMPACT_SUBOPEN",
 ``!s:real->bool.
        locally compact s <=>
        !k t. k SUBSET s /\ compact k /\ open t /\ k SUBSET t
              ==> ?u v. k SUBSET u /\ u SUBSET v /\ u SUBSET t /\ v SUBSET s /\
                        open_in (subtopology euclidean s) u /\
                        compact v``,
  GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_COMPACT] THEN
  EQ_TAC THEN DISCH_TAC THEN REPEAT STRIP_TAC THENL
   [FIRST_X_ASSUM(MP_TAC o SPEC ``k:real->bool``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN MAP_EVERY EXISTS_TAC
     [``u INTER t:real->bool``, ``closure(u INTER t:real->bool)``] THEN
    REWRITE_TAC[CLOSURE_SUBSET, INTER_SUBSET] THEN REPEAT CONJ_TAC THENL
     [ASM_SET_TAC[],
      MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``closure(u:real->bool)`` THEN
      SIMP_TAC std_ss [SUBSET_CLOSURE, INTER_SUBSET] THEN
      MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``v:real->bool`` THEN ASM_REWRITE_TAC[] THEN
      MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
      ASM_SIMP_TAC std_ss [OPEN_IN_INTER_OPEN],
      REWRITE_TAC[COMPACT_CLOSURE] THEN
      ASM_MESON_TAC[BOUNDED_SUBSET, INTER_SUBSET, SUBSET_TRANS,
                    COMPACT_IMP_BOUNDED]],
    FIRST_X_ASSUM(MP_TAC o SPECL [``k:real->bool``, ``univ(:real)``]) THEN
    ASM_REWRITE_TAC[OPEN_UNIV, SUBSET_UNIV]]);

val OPEN_IMP_LOCALLY_COMPACT = store_thm ("OPEN_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. open s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  UNDISCH_TAC ``open s`` THEN DISCH_TAC THEN FIRST_ASSUM
   (MP_TAC o REWRITE_RULE [OPEN_CONTAINS_CBALL]) THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
  DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
  MAP_EVERY EXISTS_TAC [``ball(x:real,e)``, ``cball(x:real,e)``] THEN
  ASM_REWRITE_TAC[BALL_SUBSET_CBALL, CENTRE_IN_BALL, COMPACT_CBALL] THEN
  MATCH_MP_TAC OPEN_OPEN_IN_TRANS THEN ASM_REWRITE_TAC[OPEN_BALL] THEN
  MATCH_MP_TAC SUBSET_TRANS THEN METIS_TAC [BALL_SUBSET_CBALL]);

val CLOSED_IMP_LOCALLY_COMPACT = store_thm ("CLOSED_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. closed s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN MAP_EVERY EXISTS_TAC
   [``s INTER ball(x:real,&1)``, ``s INTER cball(x:real,&1)``] THEN
  ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, INTER_SUBSET, REAL_LT_01] THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_INTER_COMPACT, COMPACT_CBALL] THEN
  MP_TAC(ISPECL [``x:real``, ``&1:real``] BALL_SUBSET_CBALL) THEN ASM_SET_TAC[]);

val IS_INTERVAL_IMP_LOCALLY_COMPACT = store_thm ("IS_INTERVAL_IMP_LOCALLY_COMPACT",
 ``!s:real->bool. is_interval s ==> locally compact s``,
  REPEAT STRIP_TAC THEN REWRITE_TAC[LOCALLY_COMPACT] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  MP_TAC(ISPECL [``s:real->bool``, ``x:real``]
   INTERVAL_CONTAINS_COMPACT_NEIGHBOURHOOD) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``a:real``, ``b:real``, ``d:real``] THEN STRIP_TAC THEN
  MAP_EVERY EXISTS_TAC
   [``s INTER ball(x:real,d)``, ``interval[a:real,b]``] THEN
  ASM_SIMP_TAC std_ss [COMPACT_INTERVAL, OPEN_IN_OPEN_INTER, OPEN_BALL] THEN
  ASM_REWRITE_TAC[CENTRE_IN_BALL, IN_INTER] THEN ASM_SET_TAC[]);

val LOCALLY_COMPACT_UNIV = store_thm ("LOCALLY_COMPACT_UNIV",
 ``locally compact univ(:real)``,
  SIMP_TAC std_ss [OPEN_IMP_LOCALLY_COMPACT, OPEN_UNIV]);

val LOCALLY_COMPACT_INTER = store_thm ("LOCALLY_COMPACT_INTER",
 ``!s t:real->bool.
        locally compact s /\ locally compact t
        ==> locally compact (s INTER t)``,
  MATCH_MP_TAC LOCALLY_INTER THEN REWRITE_TAC[COMPACT_INTER]);

val LOCALLY_COMPACT_OPEN_IN = store_thm ("LOCALLY_COMPACT_OPEN_IN",
 ``!s t:real->bool.
        open_in (subtopology euclidean s) t /\ locally compact s
        ==> locally compact t``,
  REWRITE_TAC[OPEN_IN_OPEN] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [LOCALLY_COMPACT_INTER, OPEN_IMP_LOCALLY_COMPACT]);

val LOCALLY_COMPACT_CLOSED_IN = store_thm ("LOCALLY_COMPACT_CLOSED_IN",
 ``!s t:real->bool.
        closed_in (subtopology euclidean s) t /\ locally compact s
        ==> locally compact t``,
  REWRITE_TAC[CLOSED_IN_CLOSED] THEN REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [LOCALLY_COMPACT_INTER, CLOSED_IMP_LOCALLY_COMPACT]);

val LOCALLY_COMPACT_DELETE = store_thm ("LOCALLY_COMPACT_DELETE",
 ``!s a:real. locally compact s ==> locally compact (s DELETE a)``,
  REPEAT STRIP_TAC THEN MATCH_MP_TAC LOCALLY_COMPACT_OPEN_IN THEN
  EXISTS_TAC ``s:real->bool`` THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_DELETE, OPEN_IN_REFL]);

val HOMEOMORPHIC_LOCAL_COMPACTNESS = store_thm ("HOMEOMORPHIC_LOCAL_COMPACTNESS",
 ``!s t:real->bool.
        s homeomorphic t ==> (locally compact s <=> locally compact t)``,
  MATCH_MP_TAC HOMEOMORPHIC_LOCALLY THEN
  REWRITE_TAC[HOMEOMORPHIC_COMPACTNESS]);

val LOCALLY_COMPACT_TRANSLATION_EQ = store_thm ("LOCALLY_COMPACT_TRANSLATION_EQ",
 ``!a:real s. locally compact (IMAGE (\x. a + x) s) <=>
                locally compact s``,
  MATCH_MP_TAC LOCALLY_TRANSLATION THEN
  REWRITE_TAC[COMPACT_TRANSLATION_EQ]);

val LOCALLY_CLOSED = store_thm ("LOCALLY_CLOSED",
 ``!s:real->bool. locally closed s <=> locally compact s``,
  GEN_TAC THEN EQ_TAC THENL
   [ALL_TAC, MESON_TAC[LOCALLY_MONO, COMPACT_IMP_CLOSED]] THEN
  REWRITE_TAC[locally] THEN DISCH_TAC THEN
  MAP_EVERY X_GEN_TAC [``w:real->bool``, ``x:real``] THEN STRIP_TAC THEN
  FIRST_X_ASSUM(MP_TAC o SPECL [``w:real->bool``, ``x:real``]) THEN
  ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN
  EXISTS_TAC ``u INTER ball(x:real,&1)`` THEN
  EXISTS_TAC ``v INTER cball(x:real,&1)`` THEN
  ASM_SIMP_TAC std_ss [OPEN_IN_INTER_OPEN, OPEN_BALL] THEN
  ASM_SIMP_TAC std_ss [CLOSED_INTER_COMPACT, COMPACT_CBALL] THEN
  ASM_REWRITE_TAC[IN_INTER, CENTRE_IN_BALL, REAL_LT_01] THEN
  MP_TAC(ISPEC ``x:real`` BALL_SUBSET_CBALL) THEN ASM_SET_TAC[]);

val LOCALLY_COMPACT_OPEN_UNION = store_thm ("LOCALLY_COMPACT_OPEN_UNION",
 ``!s t:real->bool.
        locally compact s /\ locally compact t /\
        open_in (subtopology euclidean (s UNION t)) s /\
        open_in (subtopology euclidean (s UNION t)) t
        ==> locally compact (s UNION t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL, IN_UNION] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN STRIP_TAC THENL
   [UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
    DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    UNDISCH_TAC ``open_in (subtopology euclidean (s UNION t)) s`` THEN DISCH_TAC THEN
    FIRST_ASSUM (MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL]),
    UNDISCH_TAC ``!x. x IN t ==> ?e. 0 < e /\ closed (cball (x,e) INTER t)`` THEN
    DISCH_TAC THEN FIRST_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    UNDISCH_TAC ``open_in (subtopology euclidean (s UNION t)) t`` THEN DISCH_TAC THEN
    FIRST_ASSUM (MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL])] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN ASM_REWRITE_TAC[] THEN
  UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
  DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN
  UNDISCH_TAC `` !x. x IN t ==> ?e. 0 < e /\ closed (cball (x,e) INTER t)`` THEN
  DISCH_THEN (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC [] THENL
  [DISCH_TAC THEN DISCH_THEN (X_CHOOSE_TAC ``e:real``),
   DISCH_THEN (X_CHOOSE_TAC ``e:real``) THEN DISCH_TAC] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
  REWRITE_TAC[CBALL_MIN_INTER, INTER_ASSOC] THEN
  FIRST_ASSUM(MP_TAC o MATCH_MP (SET_RULE
   ``u INTER st SUBSET s ==> s SUBSET st ==> (u INTER st = u INTER s)``)) THEN
  REWRITE_TAC[SUBSET_UNION] THEN
  ONCE_REWRITE_TAC [SET_RULE ``a INTER b INTER c = b INTER (a INTER c)``] THEN
  DISCH_THEN SUBST1_TAC THEN
  ONCE_REWRITE_TAC [SET_RULE ``a INTER (b INTER c) = b INTER (a INTER c)``] THEN
  METIS_TAC[CLOSED_INTER, CLOSED_CBALL, INTER_ACI]);

val LOCALLY_COMPACT_CLOSED_UNION = store_thm ("LOCALLY_COMPACT_CLOSED_UNION",
 ``!s t:real->bool.
        locally compact s /\ locally compact t /\
        closed_in (subtopology euclidean (s UNION t)) s /\
        closed_in (subtopology euclidean (s UNION t)) t
        ==> locally compact (s UNION t)``,
  REPEAT GEN_TAC THEN REWRITE_TAC[LOCALLY_COMPACT_INTER_CBALL, IN_UNION] THEN
  STRIP_TAC THEN X_GEN_TAC ``x:real`` THEN
  DISCH_THEN(STRIP_ASSUME_TAC o MATCH_MP (TAUT
   `p \/ q ==> p /\ q \/ p /\ ~q \/ q /\ ~p`))
  THENL
   [FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN
    ASM_SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM] THEN
    X_GEN_TAC ``d:real`` THEN STRIP_TAC THEN
    X_GEN_TAC ``e:real`` THEN STRIP_TAC THEN
    EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THEN
    SIMP_TAC std_ss [SET_RULE ``u INTER (s UNION t) = u INTER s UNION u INTER t``] THEN
    MATCH_MP_TAC CLOSED_UNION THEN REWRITE_TAC[CBALL_MIN_INTER] THEN CONJ_TAC THENL
    [ONCE_REWRITE_TAC [SET_RULE ``a INTER b INTER c = b INTER (a INTER c)``],
     REWRITE_TAC [GSYM INTER_ASSOC]] THEN
    METIS_TAC[CLOSED_CBALL, CLOSED_INTER, INTER_ACI],
    UNDISCH_TAC ``!x. x IN s ==> ?e. 0 < e /\ closed (cball (x,e) INTER s)`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    UNDISCH_TAC ``closed_in (subtopology euclidean (s UNION t)) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [closed_in]),
    FIRST_X_ASSUM (MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``e:real`` STRIP_ASSUME_TAC) THEN
    UNDISCH_TAC ``closed_in (subtopology euclidean (s UNION t)) s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM (STRIP_ASSUME_TAC o REWRITE_RULE [closed_in])] THEN
  FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_CONTAINS_CBALL]) THEN
  REWRITE_TAC[TOPSPACE_EUCLIDEAN_SUBTOPOLOGY, IN_DIFF, IN_UNION] THEN
  DISCH_THEN(MP_TAC o SPEC ``x:real`` o CONJUNCT2) THEN ASM_SIMP_TAC std_ss [] THEN
  DISCH_THEN(X_CHOOSE_THEN ``d:real`` STRIP_ASSUME_TAC) THEN
  EXISTS_TAC ``min d e:real`` THEN ASM_REWRITE_TAC[REAL_LT_MIN] THENL
   [SUBGOAL_THEN ``cball (x:real,min d e) INTER (s UNION t) =
                  cball(x,d) INTER cball (x,e) INTER s`` SUBST1_TAC
    THENL [REWRITE_TAC[CBALL_MIN_INTER] THEN ASM_SET_TAC[], ALL_TAC],
    SUBGOAL_THEN ``cball (x:real,min d e) INTER (s UNION t) =
                  cball(x,d) INTER cball (x,e) INTER t`` SUBST1_TAC
    THENL [REWRITE_TAC[CBALL_MIN_INTER] THEN ASM_SET_TAC[], ALL_TAC]] THEN
  ASM_MESON_TAC[GSYM INTER_ASSOC, CLOSED_INTER, CLOSED_CBALL]);

val OPEN_IN_LOCALLY_COMPACT = store_thm ("OPEN_IN_LOCALLY_COMPACT",
 ``!s t:real->bool.
        locally compact s
        ==> (open_in (subtopology euclidean s) t <=>
             t SUBSET s /\
             !k. compact k /\ k SUBSET s
                 ==> open_in (subtopology euclidean k) (k INTER t))``,
  REPEAT(STRIP_TAC ORELSE EQ_TAC) THENL
   [ASM_MESON_TAC[OPEN_IN_IMP_SUBSET],
    UNDISCH_TAC ``open_in (subtopology euclidean s) t`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [OPEN_IN_OPEN]) THEN
    REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``t':real->bool``) THEN
    EXISTS_TAC ``t':real->bool`` THEN ASM_SET_TAC[],
    ONCE_REWRITE_TAC[OPEN_IN_SUBOPEN] THEN
    X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``a:real``) THEN
    KNOW_TAC ``a IN s:real->bool`` THENL
    [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
     SIMP_TAC std_ss [LEFT_IMP_EXISTS_THM]] THEN
    MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
    STRIP_TAC THEN EXISTS_TAC ``t INTER u:real->bool`` THEN
    ASM_REWRITE_TAC[IN_INTER, INTER_SUBSET] THEN
    MATCH_MP_TAC OPEN_IN_TRANS THEN EXISTS_TAC ``u:real->bool`` THEN
    ASM_REWRITE_TAC[] THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``closure u:real->bool``) THEN
    KNOW_TAC ``compact (closure u) /\ closure u SUBSET s`` THENL
     [SUBGOAL_THEN ``(closure u:real->bool) SUBSET v`` MP_TAC THENL
       [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
        REWRITE_TAC[COMPACT_CLOSURE] THEN
        ASM_MESON_TAC[SUBSET_TRANS, BOUNDED_SUBSET, COMPACT_IMP_BOUNDED]],
      DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
      REWRITE_TAC[OPEN_IN_OPEN] THEN DISCH_THEN (X_CHOOSE_TAC ``t':real->bool``) THEN
      EXISTS_TAC ``t':real->bool`` THEN ASM_REWRITE_TAC [] THEN
      MP_TAC(ISPEC ``u:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[]]]);

val LOCALLY_COMPACT_PROPER_IMAGE_EQ = store_thm ("LOCALLY_COMPACT_PROPER_IMAGE_EQ",
 ``!f:real->real s.
        f continuous_on s /\
        (!k. k SUBSET (IMAGE f s) /\ compact k
             ==> compact {x | x IN s /\ f x IN k})
        ==> (locally compact s <=> locally compact (IMAGE f s))``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``f:real->real``, ``s:real->bool``,
                 ``IMAGE (f:real->real) s``] PROPER_MAP) THEN
  ASM_REWRITE_TAC[SUBSET_REFL] THEN STRIP_TAC THEN EQ_TAC THEN DISCH_TAC THENL
   [REWRITE_TAC[LOCALLY_COMPACT_ALT] THEN X_GEN_TAC ``y:real`` THEN
    DISCH_TAC THEN FIRST_ASSUM(MP_TAC o SPEC ``y:real``) THEN
    ASM_REWRITE_TAC[] THEN UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
    FIRST_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT_COMPACT_ALT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``{x | x IN s /\ ((f:real->real) x = y)}``) THEN
    ONCE_REWRITE_TAC [METIS [] ``(f x = y) = (\x. (f x = y)) x``] THEN
    ASM_SIMP_TAC std_ss [SUBSET_RESTRICT] THEN
    DISCH_THEN(X_CHOOSE_THEN ``u:real->bool`` STRIP_ASSUME_TAC) THEN
    SUBGOAL_THEN
     ``?v. open_in (subtopology euclidean (IMAGE f s)) v /\
          y IN v /\
          {x | x IN s /\ (f:real->real) x IN v} SUBSET u``
    MP_TAC THENL
     [GEN_REWR_TAC (BINDER_CONV o RAND_CONV o LAND_CONV)
       [GSYM SING_SUBSET] THEN
      MATCH_MP_TAC CLOSED_MAP_OPEN_SUPERSET_PREIMAGE THEN
      ASM_REWRITE_TAC[SING_SUBSET, IN_SING],
      DISCH_THEN (X_CHOOSE_TAC ``v:real->bool``) THEN EXISTS_TAC ``v:real->bool`` THEN
      POP_ASSUM MP_TAC THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
      SUBGOAL_THEN ``closure v SUBSET IMAGE (f:real->real) (closure u)``
      ASSUME_TAC THENL
       [MATCH_MP_TAC SUBSET_TRANS THEN EXISTS_TAC ``closure(IMAGE (f:real->real) u)`` THEN
        CONJ_TAC THENL
         [MATCH_MP_TAC SUBSET_CLOSURE THEN
          REPEAT(FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET)) THEN
          ASM_SET_TAC[],
          MATCH_MP_TAC CLOSURE_MINIMAL THEN
          SIMP_TAC std_ss [CLOSURE_SUBSET, IMAGE_SUBSET] THEN
          MATCH_MP_TAC COMPACT_IMP_CLOSED THEN
          MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
          ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]],
        CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
        REWRITE_TAC[COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
        FIRST_X_ASSUM(MATCH_MP_TAC o MATCH_MP (REWRITE_RULE[IMP_CONJ_ALT]
          BOUNDED_SUBSET)) THEN
        MATCH_MP_TAC COMPACT_IMP_BOUNDED THEN
        MATCH_MP_TAC COMPACT_CONTINUOUS_IMAGE THEN ASM_REWRITE_TAC[] THEN
        ASM_MESON_TAC[CONTINUOUS_ON_SUBSET]]],
    REWRITE_TAC[LOCALLY_COMPACT_ALT] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    UNDISCH_TAC ``locally compact (IMAGE (f :real -> real) (s :real -> bool))`` THEN
    DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LOCALLY_COMPACT_ALT]) THEN
    DISCH_THEN(MP_TAC o SPEC ``(f:real->real) x``) THEN
    ASM_SIMP_TAC std_ss [FUN_IN_IMAGE] THEN
    DISCH_THEN(X_CHOOSE_THEN ``v:real->bool`` STRIP_ASSUME_TAC) THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``closure v:real->bool``) THEN
    ASM_REWRITE_TAC[] THEN STRIP_TAC THEN
    EXISTS_TAC ``{x | x IN s /\ (f:real->real) x IN v}`` THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN CONJ_TAC THENL
     [MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN
      ASM_MESON_TAC[SUBSET_REFL],
      ALL_TAC] THEN
    SUBGOAL_THEN
     ``closure {x | x IN s /\ f x IN v} SUBSET
       {x | x IN s /\ (f:real->real) x IN closure v}``
    ASSUME_TAC THENL
     [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED] THEN
      MP_TAC(ISPEC ``v:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
      CONJ_TAC THENL [ALL_TAC, ASM_SET_TAC[]] THEN
      SIMP_TAC std_ss [COMPACT_EQ_BOUNDED_CLOSED, CLOSED_CLOSURE] THEN
      METIS_TAC[COMPACT_IMP_BOUNDED, BOUNDED_SUBSET]]]);

val LOCALLY_COMPACT_PROPER_IMAGE = store_thm ("LOCALLY_COMPACT_PROPER_IMAGE",
 ``!f:real->real s.
        f continuous_on s /\
        (!k. k SUBSET (IMAGE f s) /\ compact k
             ==> compact {x | x IN s /\ f x IN k}) /\
        locally compact s
        ==> locally compact (IMAGE f s)``,
  METIS_TAC[LOCALLY_COMPACT_PROPER_IMAGE_EQ]);

val MUMFORD_LEMMA = store_thm ("MUMFORD_LEMMA",
 ``!f:real->real s t y.
        f continuous_on s /\ IMAGE f s SUBSET t /\ locally compact s /\
        y IN t /\ compact {x | x IN s /\ (f x = y)}
        ==> ?u v. open_in (subtopology euclidean s) u /\
                  open_in (subtopology euclidean t) v /\
                  {x | x IN s /\ (f x = y)} SUBSET u /\ y IN v /\
                  IMAGE f u SUBSET v /\
                  (!k. k SUBSET v /\ compact k
                       ==> compact {x | x IN u /\ f x IN k})``,
  REPEAT STRIP_TAC THEN
  FIRST_ASSUM(MP_TAC o SPEC ``{x | x IN s /\ ((f:real->real) x = y)}`` o
   REWRITE_RULE [LOCALLY_COMPACT_COMPACT]) THEN
  ASM_SIMP_TAC std_ss [SUBSET_RESTRICT, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->bool``, ``v:real->bool``] THEN
  STRIP_TAC THEN
  SUBGOAL_THEN ``(closure u:real->bool) SUBSET v`` ASSUME_TAC THENL
   [MATCH_MP_TAC CLOSURE_MINIMAL THEN ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED],
    ALL_TAC] THEN
  SUBGOAL_THEN ``compact(closure u:real->bool)`` ASSUME_TAC THENL
   [ASM_REWRITE_TAC[COMPACT_CLOSURE] THEN
    ASM_MESON_TAC[BOUNDED_SUBSET, COMPACT_IMP_BOUNDED],
    ALL_TAC] THEN
  MATCH_MP_TAC(TAUT `(~p ==> F) ==> p`) THEN DISCH_TAC THEN
  SUBGOAL_THEN
   ``!b. open_in (subtopology euclidean t) b /\ y IN b
        ==> u INTER {x | x IN s /\ (f:real->real) x IN b} PSUBSET
            closure u INTER {x | x IN s /\ (f:real->real) x IN b}``
  MP_TAC THENL
   [REPEAT STRIP_TAC THEN REWRITE_TAC[PSUBSET_DEF] THEN
    SIMP_TAC std_ss [CLOSURE_SUBSET,
             SET_RULE ``s SUBSET t ==> s INTER u SUBSET t INTER u``] THEN
    MATCH_MP_TAC(MESON[] ``!P. ~P s /\ P t ==> ~(s = t)``) THEN
    EXISTS_TAC
     ``\a. !k. k SUBSET b /\ compact k
              ==> compact {x | x IN a /\ (f:real->real) x IN k}`` THEN
    SIMP_TAC std_ss [] THEN CONJ_TAC THENL
     [KNOW_TAC ``(open_in (subtopology euclidean s) (u INTER {x | x IN s /\ f x IN b})
                  ==> {x | x IN s /\ (f x = y)} SUBSET u INTER {x | x IN s /\ f x IN b}
                  ==> IMAGE f (u INTER {x | x IN s /\ f x IN b}) SUBSET b
                  ==> ~(!k. k SUBSET b /\ compact k
                  ==> compact
                    {x | x IN u INTER {x | x IN s /\ f x IN b} /\ f x IN k}))
                  ==> ~(!k. k SUBSET b /\ compact k
                     ==> compact
                     {x | x IN u INTER {x | x IN s /\ f x IN b} /\ f x IN k})`` THENL
       [ALL_TAC, METIS_TAC []] THEN
       KNOW_TAC ``open_in (subtopology euclidean s)
                  (u INTER {x | x IN s /\ (f:real->real) x IN b})`` THENL
       [MATCH_MP_TAC OPEN_IN_INTER THEN ASM_SIMP_TAC std_ss [] THEN
        MATCH_MP_TAC CONTINUOUS_OPEN_IN_PREIMAGE_GEN THEN ASM_SET_TAC[],
        ASM_SET_TAC[]],
      X_GEN_TAC ``k:real->bool`` THEN STRIP_TAC THEN
      SUBGOAL_THEN
       ``{x | x IN closure u INTER {x | x IN s /\ f x IN b} /\ f x IN k} =
        v INTER {x | x IN closure u /\ (f:real->real) x IN k}``
      SUBST1_TAC THENL [ASM_SET_TAC[], MATCH_MP_TAC COMPACT_INTER_CLOSED] THEN
      ASM_REWRITE_TAC[] THEN MATCH_MP_TAC CONTINUOUS_CLOSED_PREIMAGE THEN
      ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED, CLOSED_CLOSURE] THEN
      ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_TRANS]],
    DISCH_THEN(MP_TAC o GEN ``n:num`` o SPEC
     ``t INTER ball(y:real,inv(&n + &1))``) THEN
    SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL, IN_INTER, CENTRE_IN_BALL] THEN
    ASM_REWRITE_TAC[REAL_LT_INV_EQ,
     METIS [REAL_LT, REAL_OF_NUM_ADD, GSYM ADD1, LESS_0] ``&0 < &n + &1:real``] THEN
    KNOW_TAC ``~(!n. ?x. x IN closure u /\
           ~(x IN u) /\
           x IN {x | x IN s /\ f x IN t /\ f x IN ball (y,inv (&n + &1))})`` THENL
    [ALL_TAC,
     METIS_TAC [CLOSURE_SUBSET, REAL_OF_NUM_ADD, SET_RULE
     ``u SUBSET u'
      ==> (u INTER t PSUBSET u' INTER t <=>
           ?x. x IN u' /\ ~(x IN u) /\ x IN t)``]] THEN
    KNOW_TAC ``~(?x. (!n. x n IN closure u) /\
       (!n. ~(x n IN u)) /\
       (!n. x n IN s) /\
       (!n. f (x n) IN t) /\
       (!n. dist (y,f (x n)) < inv (&n + &1)))`` THENL
    [ALL_TAC,
     SIMP_TAC std_ss [SKOLEM_THM, GSPECIFICATION, IN_BALL, FORALL_AND_THM] THEN
     METIS_TAC [SKOLEM_THM]] THEN
    DISCH_THEN(X_CHOOSE_THEN ``x:num->real`` STRIP_ASSUME_TAC) THEN
    MP_TAC(ISPEC ``closure u:real->bool`` compact) THEN
    ASM_REWRITE_TAC[] THEN DISCH_THEN(MP_TAC o SPEC ``x:num->real``) THEN
    ASM_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``l:real``, ``r:num->num``] THEN
    CCONTR_TAC THEN FULL_SIMP_TAC std_ss [] THEN
    SUBGOAL_THEN ``(f:real->real) l = y`` ASSUME_TAC THENL
     [MATCH_MP_TAC(ISPEC ``sequentially`` LIM_UNIQUE) THEN
      EXISTS_TAC ``(f:real->real) o x o (r:num->num)`` THEN
      ASM_REWRITE_TAC[TRIVIAL_LIMIT_SEQUENTIALLY] THEN CONJ_TAC THENL
       [SUBGOAL_THEN ``(f:real->real) continuous_on closure u`` MP_TAC THENL
         [ASM_MESON_TAC[CONTINUOUS_ON_SUBSET, SUBSET_TRANS], ALL_TAC] THEN
        REWRITE_TAC[CONTINUOUS_ON_SEQUENTIALLY] THEN
        DISCH_THEN MATCH_MP_TAC THEN ASM_SIMP_TAC std_ss [o_THM],
        REWRITE_TAC[o_ASSOC] THEN MATCH_MP_TAC LIM_SUBSEQUENCE THEN
        ASM_SIMP_TAC std_ss [LIM_SEQUENTIALLY, o_THM] THEN
        CONJ_TAC THENL [METIS_TAC [], ALL_TAC] THEN
        X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN
        MP_TAC(SPEC ``e:real`` REAL_ARCH_INV) THEN
        ASM_REWRITE_TAC[] THEN DISCH_THEN (X_CHOOSE_TAC ``N:num``) THEN
        EXISTS_TAC ``N:num`` THEN X_GEN_TAC ``n:num`` THEN
        DISCH_TAC THEN ONCE_REWRITE_TAC[DIST_SYM] THEN
        MATCH_MP_TAC REAL_LT_TRANS THEN EXISTS_TAC ``inv(&n + &1:real)`` THEN
        ASM_REWRITE_TAC[] THEN MATCH_MP_TAC REAL_LT_TRANS THEN
        EXISTS_TAC ``inv(&N:real)`` THEN ASM_REWRITE_TAC[] THEN
        MATCH_MP_TAC REAL_LT_INV2 THEN
        ASM_SIMP_TAC arith_ss [REAL_OF_NUM_ADD, REAL_LT]],
      UNDISCH_TAC ``open_in (subtopology euclidean s) u`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [open_in]) THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC (MP_TAC o SPEC ``l:real``)) THEN
      SIMP_TAC std_ss [NOT_IMP, NOT_EXISTS_THM] THEN
      CONJ_TAC THENL [ASM_SET_TAC[], X_GEN_TAC ``e:real`` THEN
      CCONTR_TAC THEN FULL_SIMP_TAC std_ss []] THEN
      UNDISCH_TAC ``(((x :num -> real) o (r :num -> num) --> (l :real))
          sequentially :bool)`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [LIM_SEQUENTIALLY]) THEN
      DISCH_THEN(MP_TAC o SPEC ``e:real``) THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(X_CHOOSE_THEN ``n:num`` (MP_TAC o SPEC ``n:num``)) THEN
      ASM_SIMP_TAC std_ss [LESS_EQ_REFL, o_THM] THEN ASM_SET_TAC[]]]);

(* ------------------------------------------------------------------------- *)
(* Locally compact sets are closed in an open set and are homeomorphic       *)
(* to an absolutely closed set if we have one more dimension to play with.   *)
(* ------------------------------------------------------------------------- *)

val LOCALLY_COMPACT_OPEN_INTER_CLOSURE = store_thm ("LOCALLY_COMPACT_OPEN_INTER_CLOSURE",
 ``!s:real->bool. locally compact s ==> ?t. open t /\ (s = t INTER closure s)``,
  GEN_TAC THEN SIMP_TAC std_ss [LOCALLY_COMPACT, OPEN_IN_OPEN, CLOSED_IN_CLOSED] THEN
  SIMP_TAC std_ss [GSYM LEFT_EXISTS_AND_THM, GSYM RIGHT_EXISTS_AND_THM] THEN
  ONCE_REWRITE_TAC [METIS [] ``(x IN s INTER t /\ s INTER t SUBSET v /\
                                v SUBSET s /\ open t /\ compact v) =
                         (\v t. x IN s INTER t /\ s INTER t SUBSET v /\
                                v SUBSET s /\ open t /\ compact v) v t``] THEN
  REWRITE_TAC[GSYM CONJ_ASSOC, TAUT `p /\ (x = y) /\ q <=> (x = y) /\ p /\ q`] THEN
  ONCE_REWRITE_TAC[MESON[] ``(?v t. P v t) <=> (?t v. P v t)``] THEN
  DISCH_TAC THEN POP_ASSUM (MP_TAC o SIMP_RULE std_ss [RIGHT_IMP_EXISTS_THM]) THEN
  SIMP_TAC std_ss [SKOLEM_THM, LEFT_IMP_EXISTS_THM] THEN
  MAP_EVERY X_GEN_TAC [``u:real->real->bool``, ``v:real->real->bool``] THEN
  DISCH_TAC THEN EXISTS_TAC ``BIGUNION (IMAGE (u:real->real->bool) s)`` THEN
  ASM_SIMP_TAC std_ss [CLOSED_CLOSURE, OPEN_BIGUNION, FORALL_IN_IMAGE] THEN
  REWRITE_TAC[INTER_BIGUNION] THEN MATCH_MP_TAC EQ_TRANS THEN EXISTS_TAC
   ``BIGUNION {v INTER s | v | v IN IMAGE (u:real->real->bool) s}`` THEN
  CONJ_TAC THENL
   [SIMP_TAC std_ss [BIGUNION_GSPEC, EXISTS_IN_IMAGE] THEN ASM_SET_TAC[], ALL_TAC] THEN
  AP_TERM_TAC THEN
  ONCE_REWRITE_TAC [METIS [] ``v INTER s = (\v. v INTER s:real->bool) v``] THEN
  MATCH_MP_TAC(SET_RULE ``(!x. x IN s ==> (f(g x) = f'(g x)))
    ==> ({f x | x IN IMAGE g s} = {f' x | x IN IMAGE g s})``) THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  SIMP_TAC std_ss [GSYM SUBSET_ANTISYM_EQ] THEN CONJ_TAC THENL
   [MP_TAC(ISPEC ``s:real->bool`` CLOSURE_SUBSET) THEN ASM_SET_TAC[],
  REWRITE_TAC[SUBSET_INTER, INTER_SUBSET] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``closure((u:real->real->bool) x INTER s)`` THEN
  ASM_SIMP_TAC std_ss [OPEN_INTER_CLOSURE_SUBSET] THEN MATCH_MP_TAC SUBSET_TRANS THEN
  EXISTS_TAC ``(v:real->real->bool) x`` THEN
  ASM_SIMP_TAC std_ss [] THEN MATCH_MP_TAC CLOSURE_MINIMAL THEN
  ASM_SIMP_TAC std_ss [COMPACT_IMP_CLOSED] THEN ASM_SET_TAC[]]);

val LOCALLY_COMPACT_CLOSED_IN_OPEN = store_thm ("LOCALLY_COMPACT_CLOSED_IN_OPEN",
 ``!s:real->bool.
    locally compact s ==> ?t. open t /\ closed_in (subtopology euclidean t) s``,
  GEN_TAC THEN
  DISCH_THEN(MP_TAC o MATCH_MP LOCALLY_COMPACT_OPEN_INTER_CLOSURE) THEN
  STRIP_TAC THEN EXISTS_TAC ``t:real->bool`` THEN ASM_SIMP_TAC std_ss [] THEN
  FIRST_X_ASSUM SUBST1_TAC THEN
  SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, CLOSED_CLOSURE]);

val LOCALLY_COMPACT_CLOSED_INTER_OPEN = store_thm ("LOCALLY_COMPACT_CLOSED_INTER_OPEN",
 ``!s:real->bool.
        locally compact s <=> ?t u. closed t /\ open u /\ (s = t INTER u)``,
  MESON_TAC[CLOSED_IMP_LOCALLY_COMPACT, OPEN_IMP_LOCALLY_COMPACT,
            LOCALLY_COMPACT_INTER, INTER_COMM, CLOSED_CLOSURE,
            LOCALLY_COMPACT_OPEN_INTER_CLOSURE]);

(* ------------------------------------------------------------------------- *)
(* Forms of the Baire propery of dense sets.                                 *)
(* ------------------------------------------------------------------------- *)

val BAIRE = store_thm ("BAIRE",
 ``!g s:real->bool.
        locally compact s /\ COUNTABLE g /\
        (!t. t IN g
             ==> open_in (subtopology euclidean s) t /\ s SUBSET closure t)
        ==> s SUBSET closure(BIGINTER g)``,
  REPEAT STRIP_TAC THEN ASM_CASES_TAC ``g:(real->bool)->bool = {}`` THEN
  ASM_REWRITE_TAC[BIGINTER_EMPTY, CLOSURE_UNIV, SUBSET_UNIV] THEN
  MP_TAC(ISPEC ``g:(real->bool)->bool`` COUNTABLE_AS_IMAGE) THEN
  ASM_REWRITE_TAC[] THEN
  MAP_EVERY (C UNDISCH_THEN (K ALL_TAC))
   [``COUNTABLE(g:(real->bool)->bool)``,
    ``~(g:(real->bool)->bool = {})``] THEN
  DISCH_THEN(X_CHOOSE_THEN ``g:num->real->bool`` SUBST_ALL_TAC) THEN
  RULE_ASSUM_TAC(SIMP_RULE std_ss [FORALL_IN_IMAGE, IN_UNIV]) THEN
  REWRITE_TAC[SUBSET_DEF, CLOSURE_NONEMPTY_OPEN_INTER] THEN
  X_GEN_TAC ``a:real`` THEN DISCH_TAC THEN
  X_GEN_TAC ``v:real->bool`` THEN STRIP_TAC THEN
  MP_TAC(ISPECL
   [``\n:num u:real->bool.
        open_in (subtopology euclidean s) u /\ ~(u = {}) /\ u SUBSET v``,
    ``\n:num u v:real->bool.
       ?c. compact c /\ v SUBSET c /\ c SUBSET u /\ c SUBSET (g n)``]
   DEPENDENT_CHOICE) THEN
  SIMP_TAC std_ss [] THEN
  KNOW_TAC ``(?(a :real -> bool).
    open_in (subtopology euclidean (s :real -> bool)) a /\
    a <> ({} :real -> bool) /\ a SUBSET (v :real -> bool)) /\
 (!(n :num) (x :real -> bool).
    open_in (subtopology euclidean s) x /\ x <> ({} :real -> bool) /\
    x SUBSET v ==>
    ?(y :real -> bool).
      (open_in (subtopology euclidean s) y /\ y <> ({} :real -> bool) /\
       y SUBSET v) /\
      ?(c :real -> bool).
        compact c /\ y SUBSET c /\ c SUBSET x /\
        c SUBSET (g :num -> real -> bool) n)`` THENL
   [CONJ_TAC THENL
     [EXISTS_TAC ``s INTER v:real->bool`` THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER] THEN ASM_SET_TAC[],
      ALL_TAC] THEN
    MAP_EVERY X_GEN_TAC [``n:num``, ``w:real->bool``] THEN STRIP_TAC THEN
    FIRST_X_ASSUM(STRIP_ASSUME_TAC o SPEC ``n:num``) THEN
    SUBGOAL_THEN ``?b:real. b IN w /\ b IN g(n:num)``
    STRIP_ASSUME_TAC THENL
     [UNDISCH_TAC ``open_in (subtopology euclidean s) (w:real->bool)`` THEN
      SIMP_TAC std_ss [OPEN_IN_OPEN, LEFT_IMP_EXISTS_THM] THEN
      X_GEN_TAC ``t:real->bool`` THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[IN_INTER] THEN
      UNDISCH_TAC ``s SUBSET closure((g:num->real->bool) n)`` THEN
      REWRITE_TAC[SUBSET_DEF, CLOSURE_NONEMPTY_OPEN_INTER] THEN
      FIRST_X_ASSUM(X_CHOOSE_TAC ``x:real`` o
        REWRITE_RULE [GSYM MEMBER_NOT_EMPTY]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN
      KNOW_TAC ``x:real IN s`` THENL [ASM_SET_TAC[], DISCH_TAC THEN
       ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      DISCH_THEN(MP_TAC o SPEC ``t:real->bool``) THEN
      KNOW_TAC ``x:real IN t /\ open t`` THENL
      [ASM_SET_TAC[], DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC] THEN
      FIRST_X_ASSUM(MP_TAC o MATCH_MP OPEN_IN_IMP_SUBSET) THEN SET_TAC[],
      UNDISCH_TAC ``locally compact s`` THEN DISCH_TAC THEN
      FIRST_ASSUM(MP_TAC o REWRITE_RULE [locally]) THEN
      DISCH_THEN(MP_TAC o SPECL
       [``w INTER (g:num->real->bool) n``, ``b:real``]) THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_INTER, OPEN_IN_REFL, IN_INTER] THEN
      SIMP_TAC std_ss [GSYM RIGHT_EXISTS_AND_THM] THEN
      STRIP_TAC THEN MAP_EVERY EXISTS_TAC [``u:real->bool``,``v':real->bool``] THEN
      ASM_SET_TAC[]],
    DISCH_TAC THEN ASM_REWRITE_TAC [] THEN POP_ASSUM K_TAC THEN
    SIMP_TAC std_ss [SKOLEM_THM, GSYM RIGHT_EXISTS_AND_THM, LEFT_IMP_EXISTS_THM] THEN
    MAP_EVERY X_GEN_TAC [``u:num->real->bool``, ``c:num->real->bool``] THEN
    SIMP_TAC std_ss [FORALL_AND_THM] THEN STRIP_TAC THEN
    MATCH_MP_TAC(SET_RULE ``!s. s SUBSET t /\ ~(s = {}) ==> ~(t = {})``) THEN
    EXISTS_TAC ``BIGINTER {c n:real->bool | n IN univ(:num)}`` THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    MATCH_MP_TAC COMPACT_NEST THEN ASM_REWRITE_TAC[] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    ONCE_REWRITE_TAC [METIS [] ``(c n SUBSET c m) = (\m n. c n SUBSET c m) m n``] THEN
    MATCH_MP_TAC TRANSITIVE_STEPWISE_LE THEN ASM_SET_TAC[]]);

val BAIRE_ALT = store_thm ("BAIRE_ALT",
 ``!g s:real->bool.
        locally compact s /\ ~(s = {}) /\ COUNTABLE g /\ (BIGUNION g = s)
        ==> ?t u. t IN g /\ open_in (subtopology euclidean s) u /\
                  u SUBSET (closure t)``,
  REPEAT STRIP_TAC THEN MP_TAC(ISPECL
  [``IMAGE (\t:real->bool. s DIFF closure t) g``, ``s:real->bool``] BAIRE) THEN
  ASM_SIMP_TAC std_ss [COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  MATCH_MP_TAC(TAUT `~q /\ (~r ==> p) ==> (p ==> q) ==> r`) THEN
  CONJ_TAC THENL
   [MATCH_MP_TAC(SET_RULE
     ``~(s = {}) /\ ((t = {}) ==> (closure t = {})) /\ (t = {})
      ==> ~(s SUBSET closure t)``) THEN
    ASM_SIMP_TAC std_ss [CLOSURE_EMPTY] THEN
    MATCH_MP_TAC(SET_RULE ``i SUBSET s /\ (s DIFF i = s) ==> (i = {})``) THEN
    CONJ_TAC THENL [SIMP_TAC std_ss [BIGINTER_IMAGE] THEN ASM_SET_TAC[], ALL_TAC] THEN
    REWRITE_TAC[DIFF_BIGINTER2] THEN
    REWRITE_TAC[SET_RULE ``{f x | x IN IMAGE g s} = {f(g x) | x IN s}``] THEN
    SIMP_TAC std_ss [SET_RULE ``s DIFF (s DIFF t) = s INTER t``] THEN
    REWRITE_TAC[SET_RULE ``{s INTER closure t | t IN g} =
                          {s INTER t | t IN IMAGE closure g}``] THEN
    SIMP_TAC std_ss [GSYM INTER_BIGUNION, SET_RULE ``(s INTER t = s) <=> s SUBSET t``] THEN
    FIRST_X_ASSUM(SUBST1_TAC o SYM) THEN
    GEN_REWR_TAC (LAND_CONV o RAND_CONV) [GSYM IMAGE_ID] THEN
    MATCH_MP_TAC BIGUNION_MONO_IMAGE THEN SIMP_TAC std_ss [CLOSURE_SUBSET],
    SIMP_TAC std_ss [NOT_EXISTS_THM] THEN STRIP_TAC THEN
    X_GEN_TAC ``t:real->bool`` THEN REPEAT STRIP_TAC THENL
     [ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s DIFF (s INTER t)``] THEN
      MATCH_MP_TAC OPEN_IN_DIFF THEN
      ASM_SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, CLOSED_CLOSURE, OPEN_IN_REFL],
      REWRITE_TAC[SUBSET_DEF] THEN X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
      REWRITE_TAC[CLOSURE_APPROACHABLE] THEN
      X_GEN_TAC ``e:real`` THEN DISCH_TAC THEN FIRST_X_ASSUM(MP_TAC o SPECL
       [``t:real->bool``, ``s INTER ball(x:real,e)``]) THEN
      ASM_SIMP_TAC std_ss [OPEN_IN_OPEN_INTER, OPEN_BALL, SUBSET_DEF, IN_INTER, IN_BALL,
                   IN_DIFF] THEN
      METIS_TAC[DIST_SYM]]]);

val NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED = store_thm ("NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED",
 ``!g:(real->bool)->bool.
        COUNTABLE g /\ (!s. s IN g ==> closed s /\ (interior s = {}))
        ==> (interior(BIGUNION g) = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPECL [``{univ(:real) DIFF s | s IN g}``, ``univ(:real)``]
        BAIRE) THEN
  SIMP_TAC std_ss [LOCALLY_COMPACT_UNIV, GSYM OPEN_IN, SUBTOPOLOGY_UNIV] THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC real_ss [GSYM IMAGE_DEF, COUNTABLE_IMAGE, FORALL_IN_IMAGE] THEN
  ASM_SIMP_TAC std_ss [GSYM closed_def, SET_RULE
   ``UNIV SUBSET s <=> (UNIV DIFF s = {})``] THEN
  SIMP_TAC std_ss[GSYM INTERIOR_COMPLEMENT] THEN
  SIMP_TAC std_ss [IMAGE_DEF, GSYM BIGUNION_BIGINTER] THEN
  ASM_SIMP_TAC std_ss [SET_RULE ``UNIV DIFF (UNIV DIFF s) = s``]);

val NOWHERE_DENSE_COUNTABLE_BIGUNION = store_thm ("NOWHERE_DENSE_COUNTABLE_BIGUNION",
 ``!g:(real->bool)->bool.
        COUNTABLE g /\ (!s. s IN g ==> (interior(closure s) = {}))
        ==> (interior(BIGUNION g) = {})``,
  REPEAT STRIP_TAC THEN
  MP_TAC(ISPEC ``IMAGE closure (g:(real->bool)->bool)``
        NOWHERE_DENSE_COUNTABLE_BIGUNION_CLOSED) THEN
  ASM_SIMP_TAC std_ss [COUNTABLE_IMAGE, FORALL_IN_IMAGE, CLOSED_CLOSURE] THEN
  MATCH_MP_TAC(SET_RULE ``s SUBSET t ==> (t = {}) ==> (s = {})``) THEN
  MATCH_MP_TAC SUBSET_INTERIOR THEN MATCH_MP_TAC BIGUNION_MONO THEN
  SIMP_TAC std_ss [EXISTS_IN_IMAGE] THEN MESON_TAC[CLOSURE_SUBSET]);

(* ------------------------------------------------------------------------- *)
(* Partitions of unity subordinate to locally finite open coverings.         *)
(* ------------------------------------------------------------------------- *)

val SUBORDINATE_PARTITION_OF_UNITY = store_thm ("SUBORDINATE_PARTITION_OF_UNITY",
 ``!c s. s SUBSET BIGUNION c /\ (!u. u IN c ==> open u) /\
         (!x. x IN s
              ==> ?v. open v /\ x IN v /\
                      FINITE {u | u IN c /\ ~(u INTER v = {})})
         ==> ?f:(real->bool)->real->real.
                      (!u. u IN c
                           ==> f u continuous_on s /\
                               !x. x IN s ==> &0 <= f u x) /\
                      (!x u. u IN c /\ x IN s /\ ~(x IN u) ==> (f u x = &0)) /\
                      (!x. x IN s ==> (sum c (\u. f u x) = &1)) /\
                      (!x. x IN s
                           ==> ?n. open n /\ x IN n /\
                                   FINITE {u | u IN c /\
                                           ~(!x. x IN n ==> (f u x = &0))})``,
  REPEAT STRIP_TAC THEN
  ASM_CASES_TAC ``?u:real->bool. u IN c /\ s SUBSET u`` THENL
   [FIRST_X_ASSUM(CHOOSE_THEN STRIP_ASSUME_TAC) THEN
    EXISTS_TAC ``\v:real->bool x:real. if v = u then &1 else &0:real`` THEN
    SIMP_TAC arith_ss [COND_RAND, COND_RATOR, o_DEF, REAL_POS, REAL_OF_NUM_EQ,
                METIS [] ``(if p then q else T) <=> p ==> q``] THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_ON_CONST, COND_ID, SUM_DELTA] THEN
    CONJ_TAC THENL [ASM_SET_TAC[], ALL_TAC] THEN
    X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    EXISTS_TAC ``ball(x:real,&1)`` THEN
    REWRITE_TAC[OPEN_BALL, CENTRE_IN_BALL, REAL_LT_01] THEN
    MATCH_MP_TAC SUBSET_FINITE_I THEN EXISTS_TAC ``{u:real->bool}`` THEN
    SIMP_TAC std_ss [FINITE_SING, SUBSET_DEF, GSPECIFICATION, IN_SING] THEN
    X_GEN_TAC ``v:real->bool`` THEN
    ASM_CASES_TAC ``v:real->bool = u`` THEN ASM_REWRITE_TAC[],
    ALL_TAC] THEN
  EXISTS_TAC ``\u:real->bool x:real.
        if x IN s
        then setdist({x},s DIFF u) / sum c (\v. setdist({x},s DIFF v))
        else &0`` THEN
  SIMP_TAC std_ss [SUBSET_DEF, FORALL_IN_IMAGE] THEN
  SIMP_TAC std_ss [SUM_POS_LE, SETDIST_POS_LE, REAL_LE_DIV] THEN
  SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF, real_div, REAL_MUL_LZERO] THEN
  SIMP_TAC std_ss [SUM_RMUL] THEN REWRITE_TAC[GSYM real_div] THEN
  MATCH_MP_TAC(TAUT `r /\ p /\ q ==> p /\ q /\ r`) THEN CONJ_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN (X_CHOOSE_TAC ``n:real->bool``) THEN EXISTS_TAC ``n:real->bool`` THEN
    POP_ASSUM MP_TAC THEN
    REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
    ASM_REWRITE_TAC[] THEN
    MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_FINITE_I) THEN
    SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real->bool`` THEN
    ASM_CASES_TAC ``(u:real->bool) IN c`` THENL [ALL_TAC, METIS_TAC []] THEN
    ASM_REWRITE_TAC [] THEN ONCE_REWRITE_TAC[MONO_NOT_EQ] THEN DISCH_TAC THEN
    FULL_SIMP_TAC std_ss [NOT_EXISTS_THM] THEN X_GEN_TAC ``y:real`` THEN CCONTR_TAC THEN
    FULL_SIMP_TAC std_ss [] THEN POP_ASSUM MP_TAC THEN
    REWRITE_TAC[real_div, REAL_ENTIRE] THEN
    COND_CASES_TAC THEN ASM_REWRITE_TAC[] THEN
    ASM_CASES_TAC ``(y:real) IN u`` THEN
    ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF, REAL_MUL_LZERO] THEN
    ASM_SET_TAC[], ALL_TAC] THEN
  SUBGOAL_THEN
   ``!v x:real. v IN c /\ x IN s /\ x IN v ==> &0 < setdist({x},s DIFF v)``
  ASSUME_TAC THENL
   [REPEAT STRIP_TAC THEN
    SIMP_TAC std_ss [SETDIST_POS_LE, REAL_ARITH ``&0 < x <=> &0 <= x /\ ~(x = &0:real)``] THEN
    MP_TAC(ISPECL [``s:real->bool``, ``s DIFF v:real->bool``, ``x:real``]
        SETDIST_EQ_0_CLOSED_IN) THEN
    ONCE_REWRITE_TAC[SET_RULE ``s DIFF t = s INTER (UNIV DIFF t)``] THEN
    ASM_SIMP_TAC std_ss [CLOSED_IN_CLOSED_INTER, GSYM OPEN_CLOSED] THEN
    DISCH_THEN SUBST1_TAC THEN ASM_REWRITE_TAC[] THEN
    ASM_REWRITE_TAC[IN_INTER, IN_DIFF, IN_UNION] THEN ASM_SET_TAC[],
    ALL_TAC] THEN
  SUBGOAL_THEN
   ``!x:real. x IN s ==> &0 < sum c (\v. setdist ({x},s DIFF v))``
  ASSUME_TAC THENL
   [X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
    ONCE_REWRITE_TAC[GSYM SUM_SUPPORT] THEN
    REWRITE_TAC[support, NEUTRAL_REAL_ADD] THEN
    MATCH_MP_TAC SUM_POS_LT THEN SIMP_TAC std_ss [SETDIST_POS_LE] THEN
    CONJ_TAC THENL
     [FIRST_X_ASSUM(MP_TAC o SPEC ``x:real``) THEN ASM_REWRITE_TAC[] THEN
      DISCH_THEN(CHOOSE_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
      DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
      MATCH_MP_TAC(REWRITE_RULE[IMP_CONJ_ALT] SUBSET_FINITE_I) THEN
      SIMP_TAC std_ss [SUBSET_DEF, GSPECIFICATION] THEN X_GEN_TAC ``u:real->bool`` THEN
      ASM_CASES_TAC ``(x:real) IN u`` THEN
      ASM_SIMP_TAC std_ss [SETDIST_SING_IN_SET, IN_DIFF] THEN ASM_SET_TAC[],
      UNDISCH_TAC `` s SUBSET BIGUNION c:real->bool`` THEN DISCH_TAC THEN
      FIRST_X_ASSUM(MP_TAC o REWRITE_RULE [SUBSET_DEF]) THEN
      DISCH_THEN(MP_TAC o SPEC ``x:real``) THEN REWRITE_TAC[IN_BIGUNION] THEN
      ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_THEN (X_CHOOSE_TAC ``t:real->bool``) THEN
      EXISTS_TAC ``t:real->bool`` THEN METIS_TAC[REAL_LT_IMP_NE]],
    ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE, REAL_DIV_REFL, o_DEF] THEN
  X_GEN_TAC ``u:real->bool`` THEN DISCH_TAC THEN
  MATCH_MP_TAC CONTINUOUS_ON_EQ THEN
  EXISTS_TAC ``\x:real.
        setdist({x},s DIFF u) / sum c (\v. setdist({x},s DIFF v))`` THEN
  SIMP_TAC std_ss [] THEN REWRITE_TAC[real_div] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(\x. setdist ({x},s DIFF u) *
   inv (sum c (\v. setdist ({x},s DIFF v)))) =
     (\x. (\x. setdist ({x},s DIFF u)) x *
   (\x. inv (sum c (\v. setdist ({x},s DIFF v)))) x)``] THEN
  MATCH_MP_TAC CONTINUOUS_ON_MUL THEN
  SIMP_TAC std_ss [CONTINUOUS_ON_SETDIST, o_DEF] THEN
  ONCE_REWRITE_TAC [METIS []
   ``(\x. inv (sum c (\v. setdist ({x},s DIFF v)))) =
     (\x. inv ((\x. sum c (\v. setdist ({x},s DIFF v))) x))``] THEN
  MATCH_MP_TAC(REWRITE_RULE[o_DEF] CONTINUOUS_ON_INV) THEN
  ASM_SIMP_TAC std_ss [REAL_LT_IMP_NE, CONTINUOUS_ON_EQ_CONTINUOUS_WITHIN] THEN
  X_GEN_TAC ``x:real`` THEN DISCH_TAC THEN
  FIRST_X_ASSUM(fn th =>
    MP_TAC(SPEC ``x:real`` th) THEN ASM_REWRITE_TAC[] THEN
    DISCH_THEN(X_CHOOSE_THEN ``n:real->bool`` STRIP_ASSUME_TAC)) THEN
  MATCH_MP_TAC CONTINUOUS_TRANSFORM_WITHIN_OPEN_IN THEN
  MAP_EVERY EXISTS_TAC
   [``\x:real. sum {v | v IN c /\ ~(v INTER n = {})}
                         (\v. setdist({x},s DIFF v))``,
    ``s INTER n:real->bool``] THEN
  ASM_SIMP_TAC std_ss [IN_INTER, OPEN_IN_OPEN_INTER] THEN CONJ_TAC THENL
   [X_GEN_TAC ``y:real`` THEN DISCH_TAC THEN
    CONV_TAC SYM_CONV THEN MATCH_MP_TAC SUM_EQ_SUPERSET THEN
    ASM_REWRITE_TAC[SUBSET_RESTRICT] THEN STRIP_TAC THENL
    [ASM_SET_TAC [], ALL_TAC] THEN X_GEN_TAC ``v:real->bool`` THEN
    DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC) THEN
    ASM_SIMP_TAC std_ss [GSPECIFICATION] THEN DISCH_TAC THEN
    MATCH_MP_TAC SETDIST_SING_IN_SET THEN ASM_SET_TAC[],
    ONCE_REWRITE_TAC [METIS []
     ``(\x. sum {v | v IN c /\ v INTER n <> {}}
       (\v. setdist ({x},s DIFF v))) =
       (\x. sum {v | v IN c /\ v INTER n <> {}}
       (\v. (\v x. setdist ({x},s DIFF v)) v x))``] THEN
    MATCH_MP_TAC CONTINUOUS_SUM THEN
    ASM_SIMP_TAC std_ss [CONTINUOUS_AT_SETDIST, CONTINUOUS_AT_WITHIN]]);

(* ------------------------------------------------------------------------- *)
(* Bounds on intervals where they exist (moved from integrationTheory)       *)
(* ------------------------------------------------------------------------- *)

(* NOTE: HOL Light's original definitions:

   `sup {a | ?x. x IN s /\ (x = a)}` = `sup s`
   `inf {a | ?x. x IN s /\ (x = a)}` = `inf s`

   are not specified on {} but `sup {} = inf {}` can be proven due to the
   definition of `inf` in HOL Light. However in HOL4 this is not derivable.
   Now we explicitly define that the upper and lower bounds of {} are both 0.
   This change shouldn't cause anything wrong. -- Chun Tian, Oct 24, 2019.
 *)
Definition interval_upperbound :
    (interval_upperbound:(real->bool)->real) s =
       if s = {} then 0:real else sup s
End

Definition interval_lowerbound :
    (interval_lowerbound:(real->bool)->real) s =
       if s = {} then 0:real else inf s
End

Theorem INTERVAL_UPPERBOUND :
    !a b:real. a <= b ==> (interval_upperbound(interval[a,b]) = b)
Proof
    RW_TAC std_ss [interval_upperbound]
 >- (fs [EXTENSION, GSPECIFICATION, IN_INTERVAL] \\
     METIS_TAC [REAL_LE_REFL])
 >> MATCH_MP_TAC REAL_SUP_UNIQUE
 >> SIMP_TAC std_ss [GSPECIFICATION, IN_INTERVAL]
 >> ASM_MESON_TAC[REAL_LE_REFL]
QED

Theorem OPEN_INTERVAL_UPPERBOUND :
    !a b:real. a < b ==> interval_upperbound(interval(a,b)) = b
Proof
    RW_TAC std_ss [interval_upperbound]
 >- METIS_TAC [INTERVAL_EQ_EMPTY, GSYM real_lte]
 >> MATCH_MP_TAC REAL_SUP_UNIQUE
 >> rw [GSPECIFICATION, IN_INTERVAL]
 >- (MATCH_MP_TAC REAL_LT_IMP_LE >> art [])
 >> MP_TAC (Q.SPECL [‘max a b'’, ‘b’] REAL_MEAN)
 >> rw [REAL_MAX_LT]
 >> Q.EXISTS_TAC ‘z’ >> art []
QED

Theorem INTERVAL_LOWERBOUND :
    !a b:real. a <= b ==> (interval_lowerbound(interval[a,b]) = a)
Proof
    RW_TAC std_ss [interval_lowerbound]
 >- (fs [EXTENSION, GSPECIFICATION, IN_INTERVAL] \\
     METIS_TAC [REAL_LE_REFL])
 >> MATCH_MP_TAC REAL_INF_UNIQUE
 >> SIMP_TAC std_ss [GSPECIFICATION, IN_INTERVAL]
 >> ASM_MESON_TAC [REAL_LE_REFL]
QED

Theorem OPEN_INTERVAL_LOWERBOUND :
    !a b:real. a < b ==> interval_lowerbound(interval(a,b)) = a
Proof
    RW_TAC std_ss [interval_lowerbound]
 >- METIS_TAC [INTERVAL_EQ_EMPTY, GSYM real_lte]
 >> MATCH_MP_TAC REAL_INF_UNIQUE
 >> rw [GSPECIFICATION, IN_INTERVAL]
 >- (MATCH_MP_TAC REAL_LT_IMP_LE >> art [])
 >> MP_TAC (Q.SPECL [‘a’, ‘min b b'’] REAL_MEAN)
 >> rw [REAL_LT_MIN]
 >> Q.EXISTS_TAC ‘z’ >> art []
QED

Theorem INTERVAL_LOWERBOUND_NONEMPTY :
    !a b:real. ~(interval[a,b] = {}) ==>
               (interval_lowerbound(interval[a,b]) = a)
Proof
    SIMP_TAC std_ss [INTERVAL_LOWERBOUND, INTERVAL_NE_EMPTY]
QED

Theorem INTERVAL_UPPERBOUND_NONEMPTY :
    !a b:real. ~(interval[a,b] = {}) ==>
               (interval_upperbound(interval[a,b]) = b)
Proof
    SIMP_TAC std_ss [INTERVAL_UPPERBOUND, INTERVAL_NE_EMPTY]
QED

Theorem INTERVAL_BOUNDS_EMPTY[simp] :
    (interval_upperbound {} = 0) /\
    (interval_lowerbound {} = 0)
Proof
    rw [interval_upperbound, interval_lowerbound]
QED

(* ------------------------------------------------------------------------- *)
(* Content (length) of an interval (moved from integrationTheory)            *)
(* ------------------------------------------------------------------------- *)

val content = new_definition ("content",
  ``content(s:real->bool) =
    if s = {} then 0:real
              else (interval_upperbound s - interval_lowerbound s)``);

val CONTENT_CLOSED_INTERVAL = store_thm ("CONTENT_CLOSED_INTERVAL",
 ``!a b:real. a <= b ==> (content(interval[a,b]) = b - a)``,
 REPEAT GEN_TAC THEN DISCH_TAC THEN SIMP_TAC std_ss [interval] THEN
 KNOW_TAC ``{x | (a :real) <= x /\ x <= (b :real)} <> {}`` THENL
 [ONCE_REWRITE_TAC [GSYM MEMBER_NOT_EMPTY] THEN
  FULL_SIMP_TAC std_ss [GSPECIFICATION, REAL_LE_LT] THENL
  [KNOW_TAC ``(?(x :real). a < x /\ x < b)`` THENL
  [FULL_SIMP_TAC std_ss [REAL_MEAN], ALL_TAC] THEN STRIP_TAC THEN
  EXISTS_TAC ``x:real`` THEN ASM_REWRITE_TAC [],
  EXISTS_TAC ``a:real`` THEN ASM_REWRITE_TAC []],
  FULL_SIMP_TAC std_ss [content, INTERVAL_UPPERBOUND,
                                 INTERVAL_LOWERBOUND, GSYM interval]]);

val CONTENT_UNIT = store_thm ("CONTENT_UNIT",
 ``content(interval[0,1]) = 1:real``,
  SIMP_TAC arith_ss [CONTENT_CLOSED_INTERVAL, REAL_LE_01, REAL_SUB_RZERO]);

val CONTENT_POS_LE = store_thm ("CONTENT_POS_LE",
 ``!a b:real. &0 <= content(interval[a,b])``,
  REPEAT GEN_TAC THEN REWRITE_TAC[content] THEN
  COND_CASES_TAC THEN REWRITE_TAC[REAL_LE_REFL] THEN
  FULL_SIMP_TAC std_ss [INTERVAL_NE_EMPTY] THEN
  ASM_SIMP_TAC std_ss [INTERVAL_UPPERBOUND, INTERVAL_LOWERBOUND, REAL_SUB_LE]);

val CONTENT_POS_LT = store_thm ("CONTENT_POS_LT",
 ``!a b:real. a < b ==> &0 < content(interval[a,b])``,
  REPEAT STRIP_TAC THEN
  ASM_SIMP_TAC std_ss [CONTENT_CLOSED_INTERVAL, REAL_LT_IMP_LE] THEN
  ASM_SIMP_TAC std_ss [REAL_SUB_LT]);

val CONTENT_EQ_0_GEN = store_thm ("CONTENT_EQ_0_GEN",
 ``!s:real->bool. bounded s
     ==> ((content s = &0) <=> ?a. !x. x IN s ==> (x = a))``,
  REPEAT GEN_TAC THEN REWRITE_TAC[content] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[NOT_IN_EMPTY] THEN
  REWRITE_TAC [bounded_def] THEN DISCH_TAC THEN
  ASM_SIMP_TAC std_ss [interval_upperbound, interval_lowerbound,
  GSPEC_ID, REAL_SUB_0, REAL_SUP_EQ_INF] THEN EQ_TAC THENL
  [METIS_TAC [GSYM UNIQUE_MEMBER_SING],
   REWRITE_TAC [GSYM UNIQUE_MEMBER_SING] THEN KNOW_TAC ``?a:real. a IN s`` THENL
   [EXISTS_TAC ``CHOICE (s:real->bool)`` THEN
    METIS_TAC [CHOICE_DEF, GSYM SPECIFICATION], METIS_TAC []]]);

val CONTENT_EQ_0 = store_thm ("CONTENT_EQ_0",
 ``!a b:real. (content(interval[a,b]) = &0) <=> b <= a``,
  REPEAT GEN_TAC THEN REWRITE_TAC[content, INTERVAL_EQ_EMPTY] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[] THENL
  [FULL_SIMP_TAC std_ss [GSYM INTERVAL_EQ_EMPTY, REAL_LT_IMP_LE],
   FULL_SIMP_TAC std_ss [GSYM INTERVAL_EQ_EMPTY, REAL_NOT_LT,
   INTERVAL_LOWERBOUND, INTERVAL_UPPERBOUND, REAL_SUB_0] THEN
   METIS_TAC [REAL_LE_LT, REAL_LE_ANTISYM]]);

val CONTENT_0_SUBSET_GEN = store_thm ("CONTENT_0_SUBSET_GEN",
 ``!s t:real->bool.
      s SUBSET t /\ bounded t /\ (content t = &0) ==> (content s = &0)``,
  REPEAT GEN_TAC THEN
  REPEAT(DISCH_THEN(CONJUNCTS_THEN2 ASSUME_TAC MP_TAC)) THEN
  SUBGOAL_THEN ``bounded(s:real->bool)`` ASSUME_TAC THENL
   [ASM_MESON_TAC[BOUNDED_SUBSET], ALL_TAC] THEN
  ASM_SIMP_TAC std_ss [CONTENT_EQ_0_GEN] THEN
  POP_ASSUM_LIST(MP_TAC o end_itlist CONJ) THEN SET_TAC[]);

val CONTENT_0_SUBSET = store_thm ("CONTENT_0_SUBSET",
 ``!s a b:real. s SUBSET interval[a,b] /\
        (content(interval[a,b]) = &0) ==> (content s = &0)``,
  MESON_TAC[CONTENT_0_SUBSET_GEN, BOUNDED_INTERVAL]);

val CONTENT_CLOSED_INTERVAL_CASES = store_thm ("CONTENT_CLOSED_INTERVAL_CASES",
 ``!a b:real. content(interval[a,b]) =
              if a <= b then b - a else &0``,
  REPEAT GEN_TAC THEN COND_CASES_TAC THEN
  ASM_SIMP_TAC std_ss [CONTENT_EQ_0, CONTENT_CLOSED_INTERVAL] THEN
  ASM_MESON_TAC[REAL_LE_TOTAL]);

val CONTENT_EQ_0_INTERIOR = store_thm ("CONTENT_EQ_0_INTERIOR",
 ``!a b:real.
        (content(interval[a,b]) = &0) <=> (interior(interval[a,b]) = {})``,
  REWRITE_TAC[CONTENT_EQ_0, INTERIOR_CLOSED_INTERVAL, INTERVAL_EQ_EMPTY]);

val CONTENT_EQ_0_1 = store_thm ("CONTENT_EQ_0_1",
 ``!a b:real.
        (content(interval[a,b]) = &0) <=> b <= a``,
  REWRITE_TAC [CONTENT_EQ_0]);

val CONTENT_POS_LT_EQ = store_thm ("CONTENT_POS_LT_EQ",
 ``!a b:real. &0 < content(interval[a,b]) <=> a < b``,
  REPEAT GEN_TAC THEN EQ_TAC THEN REWRITE_TAC[CONTENT_POS_LT] THEN
  REWRITE_TAC[REAL_ARITH ``&0 < x:real <=> &0 <= x:real /\ ~(x = &0:real)``] THEN
  REWRITE_TAC[CONTENT_POS_LE, CONTENT_EQ_0] THEN MESON_TAC[REAL_NOT_LE]);

val CONTENT_EMPTY = store_thm ("CONTENT_EMPTY",
 ``content {} = &0``,
  REWRITE_TAC[content]);

val CONTENT_SUBSET = store_thm ("CONTENT_SUBSET",
 ``!a b c d:real.
        interval[a,b] SUBSET interval[c,d]
        ==> content(interval[a,b]) <= content(interval[c,d])``,
  REPEAT STRIP_TAC THEN GEN_REWR_TAC LAND_CONV [content] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[CONTENT_POS_LE] THEN
  UNDISCH_TAC ``interval [(a,b)] SUBSET interval [(c,d)]`` THEN
  REWRITE_TAC [SUBSET_DEF] THEN
  RULE_ASSUM_TAC(REWRITE_RULE[INTERVAL_NE_EMPTY]) THEN
  REWRITE_TAC[IN_INTERVAL] THEN DISCH_THEN(fn th =>
    MP_TAC(SPEC ``a:real`` th) THEN MP_TAC(SPEC ``b:real`` th)) THEN
  ASM_SIMP_TAC std_ss [REAL_LE_REFL, content] THEN REPEAT STRIP_TAC THEN
  ONCE_REWRITE_TAC[METIS [] ``(if b then c else d) = (if ~b then d else c)``] THEN
  REWRITE_TAC[INTERVAL_NE_EMPTY] THEN COND_CASES_TAC THENL
  [ALL_TAC, ASM_MESON_TAC[REAL_LE_TRANS]] THEN
  ASM_SIMP_TAC std_ss [INTERVAL_LOWERBOUND, INTERVAL_UPPERBOUND] THEN
  METIS_TAC [real_sub, REAL_LE_ADD2, REAL_LE_NEG]);

val CONTENT_LT_NZ = store_thm ("CONTENT_LT_NZ",
 ``!a b. &0 < content(interval[a,b]) <=> ~(content(interval[a,b]) = &0)``,
  REWRITE_TAC[CONTENT_POS_LT_EQ, CONTENT_EQ_0] THEN MESON_TAC[REAL_NOT_LE]);

Theorem INTERVAL_BOUNDS_NULL :
    !a b:real. (content(interval[a,b]) = &0)
        ==> (interval_upperbound(interval[a,b]) =
             interval_lowerbound(interval[a,b]))
Proof
    rpt GEN_TAC >> ASM_CASES_TAC ``interval[a:real,b] = {}``
 >| [ (* goal 1 (of 2) *)
      RW_TAC std_ss [interval_upperbound, interval_lowerbound,
                     GSYM INTERVAL_EQ_EMPTY, NOT_IN_EMPTY] \\
      fs [EXTENSION, GSPECIFICATION, NOT_IN_EMPTY, IN_INTERVAL] \\
      METIS_TAC [real_lte, REAL_LE_REFL],
      (* goal 2 (of 2) *)
      RULE_ASSUM_TAC (SIMP_RULE std_ss [GSYM INTERVAL_EQ_EMPTY, REAL_NOT_LT]) \\
      ASM_SIMP_TAC std_ss [INTERVAL_UPPERBOUND, INTERVAL_LOWERBOUND] \\
      REWRITE_TAC [CONTENT_EQ_0] >> ASM_REAL_ARITH_TAC ]
QED

val _ = export_theory();

(* References:

  [1] Bartle, R.G.: A Modern Theory of Integration. American Mathematical Soc. (2001).
 *)

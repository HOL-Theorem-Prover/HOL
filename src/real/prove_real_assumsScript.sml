(* ========================================================================= *)
(*  The bridge theory between OpenTheory real-1.61 and HOL4's realaxTheory   *)
(* ========================================================================= *)

open HolKernel boolLib bossLib BasicProvers;

open OpenTheoryReader;

(* NOTE: when proving real assumptions, we should not directly use theorems in
   realaxTheory, because we don't know which of them coincide with theorems
   provided by OT real-1.61. Instead, we retrieve all needed theorems from OT
   article, just like in prove_base_assumsScript.sml. -- Chun Tian, 7/7/2022
 *)
local open realaxTheory in end

val Thy = "prove_real_assums";
val _ = new_theory Thy;

(* NOTE: the purpose of the following two definitions is to replace HOL4's
   "invalid" definitions of “real_0” and “real_1” (in realaxTheory), from

   |- real_0 = real_ABS treal_0
   |- real_1 = real_ABS treal_1

   to

   |- real_0 = real_of_num 0
   |- real_1 = real_of_num 1

   where “real_of_num” (Number.Real.fromNatural) is provided by OT's real-1.61.
  (In HOL4, “real_0|1” are more primitive and “real_of_num” is defined upon
  “real_0|1”. In OpenTheory, on the other hand, there's no “real_0|1” at all,
   while Number.Real.fromNatural is defined in a completely different way.)

   For this purpose, the existing constants “real_0” and “real_1” defined in
   realaxTheory must be deleted when exporting OT articles (by the following
   two lines in realax.otd):

   delconst real_0
   delconst real_1

   Furthermore, when reading OT articles generated by HOL4, all occurrences of
  “realax$real_0” and “realax$real_1” must be redirected to the new definitions
   here. This is done by the ML function "const_name" (below), having the
   following two lines:

   | const_name (["HOL4","realax"],"real_0") = {Thy=Thy,Name="real_0"}
   | const_name (["HOL4","realax"],"real_1") = {Thy=Thy,Name="real_1"}

   Finally, all occurrences of “real_of_num” in the present theory will be
   also replaced by Number.Real.fromNatural. This is done by the following
   line in $(HOLDIR)/src/opentheory/hol4.int:

   const "HOL4.realax.real_of_num" as "Number.Real.fromNatural"

 *)
val REAL_0 = new_definition("REAL_0",concl realaxTheory.REAL_0);
val REAL_1 = new_definition("REAL_1",concl realaxTheory.REAL_1);

val ERR = mk_HOL_ERR Thy;

(* "fake" constant for reading hol4-real-assums.art *)
val _ = new_constant("hol-real-assums-1.0",alpha);

(* "fake" types and constants for reading real-1.61 (OT native article)

   NOTE: Currently OT's set theoretic operators are not connected with HOL4's
         pred_setTheory, and OT's "Real_sup" is not connected with “real$sup”.
 *)
val _ = new_constant("real-1.61",alpha);
val _ = new_type ("set", 1);
val _ = new_constant("empty", “:'a set”);
val _ = new_constant("member", “:'a -> 'a set -> bool”);
val _ = new_constant("sup", “:real set -> real”);

(* According to hol4-real.thy, this fake constant "inv" without definition is
   actually OT's Number.Real.inv, which has already a definition.
 *)
val _ = new_constant("inv", “:real -> real”);

(* According to hol4-real.thy, inv0_def redefines realaxTheory.real_inv:

   |- inv T1 = real_ABS (treal_inv (real_REP T1))

   It seems that HOL4's “inv” is slightly differrent with OT's “inv”: the former
   accepts division-by-zero, while the later does not. Thus the following
   definition serves as a link to OT's existing definition of “inv”
 *)
Definition inv0_def :
   inv0 x = if x = 0r then 0r else prove_real_assums$inv x
End

(* According to hol4-real.thy, this fake constant "/" without definition is
   actually OT's Number.Real./, which has already a definition.
 *)
val _ = new_constant("/", “:real -> real -> real”);

(* According to hol4-real.thy, real_div_def redefines realaxTheory.real_div:

   |- x / y = x * inv y

   It seems that HOL4's “/” is slightly differrent with OT's “/”: the former
   accepts division-by-zero, while the later does not. Thus the following
   definition serves as a link to OT's existing definition of “/”.

   For this purpose, the existing constants “inv” and “/” defined in
   realaxTheory must be deleted when exporting OT articles (by the following
   two lines in realax.otd):

   delconst inv
   delconst /

   Furthermore, the following two lines in the ML function "const_name" makes
   sure that all occurrences of “realax$inv” and “realax$/” are replaced by
   new constants defined here:

   | const_name (["HOL4","realax"],"inv") = {Thy=Thy,Name="inv0"}
   | const_name (["HOL4","realax"],"/") = {Thy=Thy,Name="real_div"}

 *)
Definition real_div_def :
   real_div x y = if y = 0r then 0r else prove_real_assums$/ x y
End

(* NOTE: the constants mappings between Number.Real.* to realax.* only make
   us see the theorems being read in a familar way. It does not mean that
   we can use theorems in realaxTheory to prove any leaking assumptions (unless
   some of these theorems are also provided by OT's real-1.61).
 *)
fun const_name ([],"=") = {Thy="min",Name="="}
  | const_name ([],"select") = {Thy="min",Name="@"}
  | const_name (["Data","Bool"],"==>") = {Thy="min",Name="==>"}
  | const_name (["Data","Bool"],"~") = {Thy="bool",Name="~"}
  | const_name (["Data","Bool"],"!") = {Thy="bool",Name="!"}
  | const_name (["Data","Bool"],"?") = {Thy="bool",Name="?"}
  | const_name (["Data","Bool"],"?!") = {Thy="bool",Name="?!"}
  | const_name (["Data","Bool"],"\\/") = {Thy="bool",Name="\\/"}
  | const_name (["Data","Bool"],"/\\") = {Thy="bool",Name="/\\"}
  | const_name (["Data","Bool"],"T") = {Thy="bool",Name="T"}
  | const_name (["Data","Bool"],"F") = {Thy="bool",Name="F"}
  | const_name (["Data","Bool"],"cond") = {Thy="bool",Name="COND"}
  | const_name (["Number","Real"],"fromNatural") = {Thy="realax",Name="real_of_num"}
  | const_name (["Number","Real"],"inv") = {Thy=Thy,Name="inv"}
  | const_name (["Number","Real"],"<") = {Thy="realax",Name="real_lt"}
  | const_name (["Number","Real"],">") = {Thy="realax",Name="real_gt"}
  | const_name (["Number","Real"],">=") = {Thy="realax",Name="real_ge"}
  | const_name (["Number","Real"],"<=") = {Thy="realax",Name="real_lte"}
  | const_name (["Number","Real"],"*") = {Thy="realax",Name="real_mul"}
  | const_name (["Number","Real"],"+") = {Thy="realax",Name="real_add"}
  | const_name (["Number","Real"],"-") = {Thy="realax",Name="real_sub"}
  | const_name (["Number","Real"],"~") = {Thy="realax",Name="real_neg"}
  | const_name (["Number","Real"],"/") = {Thy=Thy,Name="/"}
  | const_name (["Number","Real"],"max") = {Thy="realax",Name="max"}
  | const_name (["Number","Real"],"min") = {Thy="realax",Name="min"}
  | const_name (["Number","Real"],"abs") = {Thy="realax",Name="abs"}
  | const_name (["Number","Real"],"^") = {Thy="realax",Name="pow"}
  | const_name (["Number","Real"],"sup") = {Thy=Thy,Name="sup"}
  | const_name (["Number","Natural"],"^") = {Thy="arithmetic",Name="EXP"}
  | const_name (["Number","Natural"],"<=") = {Thy="arithmetic",Name="<="}
  | const_name (["Number","Natural"],"*") = {Thy="arithmetic",Name="*"}
  | const_name (["Number","Natural"],"+") = {Thy="arithmetic",Name="+"}
  | const_name (["Number","Natural"],"even") = {Thy="arithmetic",Name="EVEN"}
  | const_name (["Number","Natural"],"zero") = {Thy="num",Name="0"}
  | const_name (["Number","Natural"],"suc") = {Thy="num",Name="SUC"}
  | const_name (["Number","Natural"],"bit1") = {Thy="arithmetic",Name="BIT1"}
  | const_name (["HOL4","arithmetic"],"BIT2") = {Thy="arithmetic",Name="BIT2"}
  | const_name (["HOL4","realax"],"real_0") = {Thy=Thy,Name="real_0"}
  | const_name (["HOL4","realax"],"real_1") = {Thy=Thy,Name="real_1"}
  | const_name (["HOL4","realax"],"inv") = {Thy=Thy,Name="inv0"}
  | const_name (["HOL4","realax"],"/") = {Thy=Thy,Name="real_div"}
  | const_name (["Set"],"{}") = {Thy=Thy,Name="empty"}
  | const_name (["Set"],"member") = {Thy=Thy,Name="member"}
  | const_name (ns,n) = {Thy=Thy,Name=String.concatWith "_"(ns@[n])};

fun tyop_name ([],"bool") = {Thy="min",Tyop="bool"}
  | tyop_name ([],"->") = {Thy="min",Tyop="fun"}
  | tyop_name ([],"ind") = {Thy="min",Tyop="ind"}
  | tyop_name (["Number","Real"],"real") = {Thy="realax",Tyop="real"}
  | tyop_name (["Number","Natural"],"natural") = {Thy="num",Tyop="num"}
  | tyop_name (["Set"],"set") = {Thy=Thy,Tyop="set"}
  | tyop_name (ns,n) = {Thy=Thy,Tyop=String.concatWith "_"(ns@[n])};

local
  fun mk_rep_abs {name,ax,args,rep,abs} =
    let
      val abs = “real_ABS”
      val rep = “real_REP”
      val P = rator(concl ax)
    in
      {abs_rep = mk_thm([], “(\a. ^abs (^rep a)) = (\a. a)”),
       rep_abs = mk_thm([], “(\r. ^rep (^abs r) = r) = (\r. P r)”)}
    end
in
  val (reader:reader) = {
    define_tyop = mk_rep_abs,
    define_const = fn x => fn th => REFL T,
    axiom = fn _ => mk_thm,
    const_name = const_name,
    tyop_name = tyop_name}
end

val base_thms = read_article "base-theorems.art" reader;
val _ = Net.itnet (fn th => (Thm.delete_proof th; K ())) base_thms ();

fun itpred P th acc = if P th then th::acc else acc;
fun amatch tm = Net.itnet (itpred (DB.matches tm)) base_thms [];
val axioms = List.rev (Net.listItems base_thms);

(*
 32 theorems in OpenTheory real-1.61 package, stored in the above "axioms":

 01 |- !x. x <= x,
 02 |- !x. 0 + x = x,
 03 |- !x. -x + x = 0,
 04 |- !x. x pow 0 = 1,
 05 |- !x. 1 * x = x,
 06 |- !x. abs x = if 0 <= x then x else -x,
 07 |- !x. x <> 0 ==> inv x * x = 1,
 08 |- !p. (?x. p x) /\ (?m. !x. p x ==> x <= m) ==>
           ?s. (!x. p x ==> x <= s) /\ !m. (!x. p x ==> x <= m) ==> s <= m,
 09 |- !x y. x > y <=> y < x,
 10 |- !x y. x >= y <=> y <= x,
 11 |- !x y. x * y = y * x,
 12 |- !m n. &m * &n = &(m * n),
 13 |- !x y. x + y = y + x,
 14 |- !m n. &m + &n = &(m + n),
 15 |- !x y. x < y <=> ~(y <= x),
 16 |- !x y. x - y = x + -y,
 17 |- !m n. &m = &n <=> m = n,
 18 |- !m n. &m <= &n <=> m <= n,
 19 |- !x n. x pow SUC n = x * x pow n,
 20 |- !m n. max m n = if m <= n then n else m,
 21 |- !m n. min m n = if m <= n then m else n,
 22 |- !x y. x <= y /\ y <= x <=> x = y,
 23 |- !x y. x <= y \/ y <= x,
 24 |- !x y. y <> 0 ==> x / y = x * inv y,
 25 |- !x y. 0 <= x /\ 0 <= y ==> 0 <= x * y,
 26 |- !s x. s <> empty /\ (?m. !x. member x s ==> x <= m) /\ member x s ==>
             x <= sup s,
 27 |- !s m. s <> empty /\ (?m. !x. member x s ==> x <= m) /\
             (!x. member x s ==> x <= m) ==> sup s <= m,
 28 |- !x y z. y <= z ==> x + y <= x + z,
 29 |- !x y z. x <= y /\ y <= z ==> x <= z,
 30 |- !x y z. x * (y * z) = x * y * z,
 31 |- !x y z. x * (y + z) = x * y + x * z,
 32 |- !x y z. x + (y + z) = x + y + z
*)

(* These are goals to prove *)
val goalsNet = read_article "hol4-real-assums.art" reader;
val goals = Net.listItems goalsNet;

val _ = say ("number of real assumptions: " ^
             Int.toString(List.length goals) ^ "\n");

(* |- !x y. x < y <=> ~(y <= x)
   NOTE: OT's real_lt has different (correct) quantifier order with HOL's.
 *)
val real_lt = hd(amatch(concl(SPEC_ALL realaxTheory.real_lt)));

val REAL_ADD_LID     = hd(amatch(concl realaxTheory.REAL_ADD_LID'));
val REAL_ADD_LINV    = hd(amatch(concl realaxTheory.REAL_ADD_LINV'));
val REAL_MUL_LID     = hd(amatch(concl realaxTheory.REAL_MUL_LID'));
val REAL_LE_TOTAL    = hd(amatch(concl realaxTheory.REAL_LE_TOTAL));
val REAL_LE_TRANS    = hd(amatch(concl realaxTheory.REAL_LE_TRANS));
val REAL_LE_LADD_IMP = hd(amatch(concl realaxTheory.REAL_LE_LADD_IMP));
val REAL_LE_ANTISYM  = hd(amatch(concl realaxTheory.REAL_LE_ANTISYM));
val REAL_ADD_ASSOC   = hd(amatch(concl realaxTheory.REAL_ADD_ASSOC));
val REAL_ADD_SYM     = hd(amatch(concl realaxTheory.REAL_ADD_SYM));
val REAL_MUL_SYM     = hd(amatch(concl realaxTheory.REAL_MUL_SYM));
val REAL_LDISTRIB    = hd(amatch(concl realaxTheory.REAL_LDISTRIB));
val REAL_MUL_ASSOC   = hd(amatch(concl realaxTheory.REAL_MUL_ASSOC));
val REAL_LE_MUL      = hd(amatch(concl realaxTheory.REAL_LE_MUL));
val REAL_LE_REFL     = hd(amatch(concl realaxTheory.REAL_LE_REFL));

(* |- !x. x <> 0r ==> inv x * x = 1 *)
val REAL_MUL_LINV = hd(amatch(
  subst[prim_mk_const{Thy="realax",Name="inv"} |-> prim_mk_const{Thy=Thy,Name="inv"}]
  (concl realaxTheory.REAL_MUL_LINV')));

(* |- |- !x y. y <> 0 ==> x / y = x * inv y *)
val real_div0 = hd(amatch(
   “!x y. ~(y = 0r) ==> (prove_real_assums$/ x y = x * prove_real_assums$inv y)”));

(* |- !x y z. x < y /\ y < z ==> x < z *)
val th1 = store_thm
  ("th1", el 1 goals |> concl,
  rpt gen_tac
  \\ PURE_REWRITE_TAC[real_lt]
  \\ reverse(qspecl_then[`x`,`y`]strip_assume_tac REAL_LE_TOTAL)
  >- asm_simp_tac bool_ss []
  \\ reverse(qspecl_then[`y`,`z`]strip_assume_tac REAL_LE_TOTAL)
  >- asm_simp_tac bool_ss []
  \\ rpt strip_tac
  \\ imp_res_tac REAL_LE_TRANS);

val REAL_LT_TRANS = th1;

(* |- !x y z. y < z ==> x + y < x + z *)
val th2 = store_thm
  ("th2", el 2 goals |> concl,
  rpt gen_tac
  \\ PURE_REWRITE_TAC[real_lt]
  \\ reverse(qspecl_then[`y`,`z`]strip_assume_tac REAL_LE_TOTAL)
  >- asm_simp_tac bool_ss []
  \\ rpt strip_tac
  \\ `x + y <= x + z` by metis_tac[REAL_LE_LADD_IMP]
  \\ `x + z = x + y` by metis_tac[REAL_LE_ANTISYM]
  \\ `~x + x + z = ~x + x + y` by metis_tac[REAL_ADD_ASSOC]
  \\ `z = y` by metis_tac[REAL_ADD_LID,REAL_ADD_LINV]
  \\ metis_tac[REAL_LE_ANTISYM]);

val REAL_ADD_LID_UNIQ = prove(
  ``!x y. (x + y = y) = (x = 0)``,
  metis_tac[REAL_ADD_LID,REAL_ADD_SYM,REAL_ADD_LINV,REAL_ADD_ASSOC]);

val REAL_MUL_LZERO = prove(
  ``!x. 0 * x = 0``,
  metis_tac[REAL_ADD_LID_UNIQ,REAL_ADD_LID,REAL_LDISTRIB,REAL_MUL_SYM]);

val REAL_ENTIRE = prove(
  ``!x y. (x * y = 0) = (x = 0) \/ (y = 0)``,
  metis_tac[REAL_MUL_LINV,REAL_MUL_LID,REAL_MUL_ASSOC,REAL_MUL_LZERO,REAL_MUL_SYM]);

(* |- !x y. real_0 < x /\ real_0 < y ==> real_0 < x * y *)
val th3 = store_thm
  ("th3", el 3 goals |> concl,
  rpt gen_tac
  \\ PURE_REWRITE_TAC[real_lt,REAL_0]
  \\ qspecl_then[`x`,`0`]strip_assume_tac REAL_LE_TOTAL >- asm_simp_tac bool_ss []
  \\ qspecl_then[`y`,`0`]strip_assume_tac REAL_LE_TOTAL >- asm_simp_tac bool_ss []
  \\ `0 <= x * y` by imp_res_tac REAL_LE_MUL
  \\ rpt strip_tac
  \\ `x * y = 0` by metis_tac[REAL_LE_ANTISYM]
  \\ metis_tac[REAL_ENTIRE]);

(* |- !x y. x = y \/ x < y \/ y < x *)
val th4 = store_thm
  ("th4", el 4 goals |> concl,
  metis_tac[real_lt,REAL_LE_TOTAL,REAL_LE_ANTISYM])

(* |- !x y. real_div x y = x * inv0 y *)
val th5 = store_thm
  ("th5", el 5 goals |> concl,
  SIMP_TAC bool_ss [FUN_EQ_THM,real_div_def,inv0_def]
  \\ metis_tac[real_div0,REAL_MUL_LZERO,REAL_MUL_SYM]);

(* |- !x y. x <= y <=> ~(y < x) *)
val th6 = store_thm
  ("th6", el 6 goals |> concl,
    metis_tac[real_lt]);

val otax = hd(amatch
  ``!p. (?(x:real). p x) /\ (?m. !x. p x ==> x <= m) ==>
        ?s. (!x. p x ==> x <= s) /\ !m. (!x. p x ==> x <= m) ==> s <= m``);

val REAL_LE_LT = prove(
  ``!x y. x <= y <=> x < y \/ (x = y)``,
  metis_tac[real_lt,REAL_LE_TOTAL,REAL_LE_ANTISYM]);

(* |- !P. (!x. P x ==> real_0 < x) /\ (?x. P x) /\ (?z. !x. P x ==> x < z) ==>
          ?s. !y. (?x. P x /\ y < x) <=> y < s
 *)
val th7 = store_thm
  ("th7", el 7 goals |> concl,
  rpt strip_tac
  \\ qspec_then`P`mp_tac otax
  \\ impl_tac >- metis_tac[REAL_LE_LT]
  \\ strip_tac
  \\ qexists_tac`s`
  \\ gen_tac
  \\ EQ_TAC \\ strip_tac
  >- metis_tac[REAL_LT_TRANS,REAL_LE_LT]
  \\ metis_tac[REAL_LE_TOTAL,REAL_LE_LT,real_lt]);

(* |- !x. x <> real_0 ==> inv0 x * x = real_1 *)
val th8 = store_thm
  ("th8", el 8 goals |> concl,
  metis_tac[REAL_MUL_LINV,REAL_0,REAL_1,inv0_def]);

(* |- !x. -x + x = real_0 *)
val th9 = store_thm
  ("th9", el 9 goals |> concl,
  metis_tac[REAL_ADD_LINV,REAL_0]);

(* |- !x. real_0 + x = x *)
val th10 = store_thm
  ("th10", el 10 goals |> concl,
  metis_tac[REAL_ADD_LID,REAL_0]);

(* |- !x. real_1 * x = x *)
val th11 = store_thm
  ("th11", el 11 goals |> concl,
  metis_tac[REAL_MUL_LID,REAL_1]);

(* |- !x. ~(x < x) *)
val th12 = store_thm
  ("th12", el 12 goals |> concl,
  simp_tac bool_ss [real_lt,REAL_LE_REFL]);

(*
val (pow0,powsuc) = CONJ_PAIR realaxTheory.real_pow;
val () = Thm.delete_proof pow0
val () = Thm.delete_proof powsuc
 *)
val pow0   = hd(amatch “x pow 0 = 1”);
val powsuc = hd(amatch “x pow SUC n = x * x pow n”);

(* |- (!x. x pow 0 = 1) /\ !x n. x pow SUC n = x * x pow n *)
val th13 = store_thm
  ("th13", el 13 goals |> concl,
  MATCH_ACCEPT_TAC(CONJ pow0 powsuc));

(* |- !m n. &m + &n = &(m + n) *)
val REAL_OF_NUM_ADD = hd(amatch(concl realaxTheory.REAL_OF_NUM_ADD));

(* |- 0 = real_0 /\ !n. &SUC n = &n + real_1 *)
val th14 = store_thm
  ("th14", el 14 goals |> concl,
  REWRITE_TAC[REAL_0,REAL_1,REAL_OF_NUM_ADD,arithmeticTheory.ADD1]);

(* |- !x. abs x = if 0 <= x then x else -x *)
val real_abs = hd(amatch(concl realaxTheory.real_abs));

(* |- |- !x y. x - y = x + -y *)
val real_sub = hd(amatch(concl realaxTheory.real_sub));

(* |- abs = (\x. if 0 <= x then x else -x) *)
val th15 = store_thm
  ("th15", el 15 goals |> concl,
  SIMP_TAC bool_ss [FUN_EQ_THM,real_abs]);

(* |- $- = (\x y. x + -y) *)
val th16 = store_thm
  ("th16", el 16 goals |> concl,
  SIMP_TAC bool_ss [FUN_EQ_THM,real_sub]);

(* |- $<= = (\x y. ~(y < x)) *)
val th17 = store_thm
  ("th17", el 17 goals |> concl,
  SIMP_TAC bool_ss [FUN_EQ_THM]
  \\ metis_tac[real_lt]);

(* |- real_1 = 1 *)
val th18 = store_thm
  ("th18", el 18 goals |> concl,
  ACCEPT_TAC REAL_1);

(* |- inv0 real_0 = real_0 *)
val th19 = store_thm
  ("th19", el 19 goals |> concl,
  metis_tac[inv0_def,REAL_0]);

(* |- real_0 = 0 *)
val th20 = store_thm
  ("th20", el 20 goals |> concl,
  ACCEPT_TAC REAL_0);

(* |- !m n. &m = &n <=> m = n *)
val REAL_OF_NUM_EQ = hd(amatch(concl realaxTheory.REAL_OF_NUM_EQ));

(* |- real_1 <> real_0 *)
val th21 = store_thm
  ("th21", el 21 goals |> concl,
  PURE_REWRITE_TAC[REAL_0,REAL_1,REAL_OF_NUM_EQ,
    arithmeticTheory.ONE,prim_recTheory.SUC_ID]
  \\ strip_tac);

val _ = if List.length goals = 21 then ()
        else raise ERR "" ("unexpected number of assumptions: " ^
                           Int.toString(List.length goals) ^ "\n");

val _ = export_theory();

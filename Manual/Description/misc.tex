\chapter{Miscellaneous Features}

This section describes some of the features
that exist for managing the interface
%
\index{HOL system@\HOL{} system!adjustment of user interface of}
%
to the \HOL{} system.

\begin{itemize}
\item The help system.
\item The trace system for controlling feedback and printing.
\item \holmake{}: a tool for dependency maintenance in large developments.
\item Functions for counting the number of primitive inferences done in
an evaluation, and timing it.
\item A tool for embedding pretty-printed HOL theorems, terms and
  types in \LaTeX{} documents.
\end{itemize}

\section{Help}

 There are several kinds of help available in \HOL{}, all accessible
 through the same incantation:
 \begin{verbatim}
     help <string>;
 \end{verbatim}

 The kinds of help available are:

 \begin{description}

 \item [Moscow~ML help.] \index{Moscow ML} (When using Moscow~ML~\HOL{})
   This is uniformly excellent.
   Information for library routines is available, whether the library is loaded or not \emph{via} \texttt{help~"Lib"}.

\item [\HOL{} overview.] This is a short summary of important information
  about \HOL{}.

\item [\HOL{} help.] This on-line help is intended to document all
  HOL-specific functions available to the user. It is very detailed
  and often accurate; however, it can be out-of-date, refer to earlier
  versions of the system, or even be missing!

\item [\HOL{} structure information.]
  For most structures in the \HOL{} source, one can get a listing of the entrypoints found in the accompanying signature.
  This is helpful for locating functions and is automatically derived from the system sources, so it is always up-to-date.

\item [Theory facts.]
  These are automatically derived from theory files, so they are always up-to-date.
  The signature of each theory is available (since theories are represented by structures in \HOL{}).
  Also, each axiom, definition, and theorem in the theory can be accessed by name in the help system.
  As such theorems are pretty-printed into the corresponding \texttt{Theory.sig} file, the help system will find both the declaration in the signature (\eg, \ml{val~nm~:thm}), and the entry for that theorem in the comment-block.
\end{description}

Therefore the following example queries can be made:

\begin{table}[h]
  \begin{center}
    \begin{tabular}{|l|l|} \hline
      \verb+help "installPP"+ & Moscow ML help \\
      \verb+help "hol"+ &  \HOL{} overview \\
      \verb+help "aconv"+ &  on-line \HOL{} help \\
      \verb+help "Tactic"+ & \HOL{} source structure information \\
      \verb+help "boolTheory"+ &  theory structure signature \\
      \verb+help "list_Axiom"+ & theory structure signature and theorem
      statement \\ \hline
    \end{tabular}
  \end{center}
\end{table}

\section{The Trace System}
\index{traces, controlling HOL feedback@traces, controlling \HOL{} feedback}
\label{sec:traces}

The trace system gives the user one central interface with which to control most of \HOL's many different flags, though they are scattered all over the system, and defined in different modules.
These flags are typically those that determine the level to which \HOL{} tools provide information to the user while operating.
For example, a trace level of zero will usually make a tool remain completely
silent while it operates.
The tool may still raise an exception when it fails, but it won't also
output any messages saying so.

There are three core functions, all in the \ml{Feedback} structure:
\begin{hol}
\begin{verbatim}
   traces : unit ->
            {default: int, max: int, name: string, trace_level: int} list

   set_trace : string -> int -> unit
   trace     : (string * int) -> ('a -> 'b) -> ('a -> 'b)
\end{verbatim}
\end{hol}

The \ml{traces} function returns a list of all the traces in the system.
The \ml{set\_trace} function allows the user to set a trace directly.
The effect of this might be seen in a subsequent call to \ml{traces()}.
Finally, the \ml{trace} function allows for a trace to be temporarily set while a function executes, restoring the trace to its old value when the function returns (whether normally, or with an exception).



\section{\texorpdfstring{Maintaining \HOL{} Formalizations with \holmake}{Maintaining HOL Formalizations with \holmake}}
\label{Holmake}
\index{Holmake@\holmake|(}

The purpose of \holmake{} is to maintain dependencies in a \HOL{} project (a collection of \HOL{} files, possibly distributed over multiple directories).
A single invocation of \holmake{} will compute dependencies between files, (re)compile plain ML code, (re)compile and execute theory scripts, and (re)compile the resulting theory modules.
\holmake{} does not require the user to provide any explicit dependency information themselves.
\holmake{} can be very convenient to use, but there are some conventions and restrictions on it that must be followed, described below.

\holmake{} can be accessed through
\begin{verbatim}
   <hol-dir>/bin/Holmake.
\end{verbatim}

The development model that \holmake{} is designed to support is that
there are two modes of work: theory construction and system revision.
In `theory construction' mode, the user builds up a theory by
interacting with HOL, perhaps over many sessions. In `system rebuild'
mode, a component that others depend on has been altered, so all modules
dependent on it have to be brought up to date. System rebuild mode is
simpler so we deal with it first.

\subsection{System rebuild}

A system rebuild happens when an existing theory has been improved in
some way (augmented with a new theorem, a change to a definition,
etc.), or perhaps some support ML code has been modified or added to
the formalization under development. The user needs to find and
recompile just those modules affected by the change. This is what an
invocation of \holmake{} does, by identifying the out-of-date modules
and re-compiling and re-executing them.


\subsection{Theory construction}

A theory \emph{my}\texttt{Theory} is constructed by writing the file \emph{my}\texttt{Script.sml}.
In this file, the context (semantic, and also proof support) is established, by specifying parent theories and useful libraries.
In the course of building the theory, the user is writing what one might call the ``\HOL{} script language'': this is a mixture of \ML{} (used mostly to write tactics) and \HOL{} material (inside definitions and theorem statements).
This script file is used to achieve inter-session persistence of
the theory being constructed.

Once the user finishes the perhaps long and arduous task of constructing
a theory, the user should
\begin{enumerate}
\item check the script is separately compilable;
\item invoke \holmake{}. This will (a) compile and execute the
  script file; and (b) compile the resulting theory file. After this,
  the theory file is available for use.
\end{enumerate}

\subsection{Source conventions for script and SML files}

\paragraph{Script and theory files}
The file that generates the \HOL{} theory \textit{my}\texttt{Theory} must be called \textit{my}\texttt{Script.sml}.
After the theory has been successfully generated, it can be \texttt{open}-ed at the head of other developments:
\begin{alltt}
    open myTheory
\end{alltt}
\index{load (ML function)@\ml{load} (\ML{} function)}
and it can be loaded interactively:
\begin{alltt}
    load "myTheory";
\end{alltt}
The file \texttt{myScript.sml} should begin with the standard boilerplate:
\begin{alltt}
    open HolKernel Parse boolLib bossLib

    val _ = new_theory "my"
\end{alltt}
This ``boilerplate'' ensures that the standard tactics and \ML{} commands will be in the namespace when the script file is compiled.
Interactively, these modules have already been loaded and \texttt{open}-ed, so what can be typed directly at \texttt{hol} cannot necessarily be included as-is in a script file.
In addition, if \texttt{myTheory} depends on other \HOL{} theories, this ancestry should also be recorded in the script file.
The easiest way to achieve this is simply to \texttt{open} the relevant theories.
Conventionally, the \texttt{open} declarations for such theories appear just before the call to \texttt{new_theory}.
For example:
\begin{alltt}
    open HolKernel Parse boolLib bossLib

    open myfirstAncestorTheory OtherAncestorTheory

    val _ = new_theory "my"
\end{alltt}
\index{load (ML function)@\ml{load} (\ML{} function)}
Interactively, these may well be the names of theories that have been explicitly loaded into the context with the \texttt{load} function.
In the interactive system, one has to explicitly \ml{load} modules; on the other hand, the batch compiler will load modules automatically.
For example, in order to execute \ml{open Foo} (or refer to values in structure \ml{Foo}) in the interactive system, one must first have executed \ml{load "Foo"}.
(This is on the assumption that structure \ml{Foo} is defined in a file \texttt{Foo.sml}.)
Contrarily, the batch compiler will reject files having occurrences of \ml{load}, since \ml{load} is only defined for the interactive system.

In addition, simply referring to a theory's theorems using the `dot-notation' will make that theory an ancestor.
For example,
\begin{alltt}
    Theorem mytheorem:
      ...
    Proof
      simp[ThirdAncestorTheory.important_lemma] ...
    QED
\end{alltt}
will record a dependency on \texttt{ThirdAncestoryTheory}, making it just as much an ancestor as the theories that have been explicitly \texttt{open}-ed elsewhere.
This ``trick'' is not good practice however, and can lead to strange behaviours when working interactively.
If it feels important to keep the top-level \ML{} namespace uncontaminated, the right idiom for the top of the script file is
\begin{alltt}
    local open ThirdAncestorTheory in end
\end{alltt}

Finally, all script files should also end with the invocation:
\begin{verbatim}
    val _ = export_theory()
\end{verbatim}
When the script is finally executed, this call writes the theory to disk.

\index{special syntactic forms for scripts}
The calls to \texttt{new_theory} and \texttt{export_theory} must bracket a sequence of \ML{} declarations and/or uses of special syntactic forms for scripts (the so-called ``modern syntax'').
The special syntactic forms all map to \ML{} declarations, and include uses of keywords like \ml{Theorem}, \ml{Type}, and \ml{Overload}.
An \ML{} declaration will typically be a \texttt{val}-binding, but might also be a function definition (\emph{via} \texttt{fun}), an \texttt{open}, or even a \texttt{structure} declaration.
Declarations are \emph{not} expressions.
This means that script files should \emph{not} include bare calls to \HOL{} functions like \texttt{set_fixity}.
Instead, declarations such as the following need to be used:
\begin{alltt}
    val _ = set_fixity "symbol" (Infixl 500);
\end{alltt}
This is because (due to restrictions imposed by Moscow~ML\index{Moscow ML}) the script file is required to be an ML structure, and the contents of a structure must be \emph{declarations}, not expressions.
Indeed, one is allowed to (and generally should) omit the bracketing
\begin{alltt}
    structure myScript = struct
    ...
    end
\end{alltt}
lines, but the contents of the file are still interpreted as if belonging to a structure.

Finally, take care not to have the string ``\texttt{Theory}'' appear at the end of the name of any of your files.
\HOL{} generates files containing this string, and when it cleans up after itself, it removes such files using a regular expression.
This will also remove other files with names containing ``\texttt{Theory.sml}'' or ``\texttt{Theory.sig}''.
For example, if, in your development directory, you had a file of \ML{} code named \texttt{MyTheory.sml} and you were also managing a \HOL{} development there with \holmake, then \texttt{MyTheory.sml} would get deleted if \texttt{Holmake~clean} were invoked.

\paragraph{Other SML code}
When developing \HOL{} libraries, one should again attempt to follow Moscow~ML's conventions.
Most importantly, file names should match \texttt{signature} and \texttt{structure} names.
If this can be done, the automatic dependency analysis done by \holmake{} will work ``out of the box''.
A signature for module \texttt{foo} should always appear in file \texttt{foo.sig}, and should have the form
\begin{alltt}
    signature foo =
    sig
      ...
    end
\end{alltt}
The accompanying implementation of \texttt{foo} should appear in file \texttt{foo.sml}, and should have the form
\begin{alltt}
    structure foo :> foo =
    struct
    ...
    end
\end{alltt}
As with theory files, the contents of a \texttt{structure} must be a sequence of declarations only.
Neither sort of file should have any other declarations within it (before or after the \texttt{signature} or \texttt{structure}).

Deviations from this general pattern are possible, but life is much simpler if such deviations can be avoided.
The \HOL{} distribution\footnote{See, for example, the kernel implementation in \texttt{src/0}.} contains some examples of trickier situations where the guidelines need to be ignored.
Ignoring the guidelines will generally result in the need for quite involved \texttt{Holmakefile}s (see Section~\ref{sec:using-Holmakefiles} below).

\subsection{Summary}

A complete theory construction might be performed by the following steps:
\begin{itemize}
\item Construct theory script, perhaps over many sessions;
\item Transform script into separately compilable form;
\item Invoke \holmake{} to generate the theory and compile it.
\end{itemize}
After that, the theory is usable as an ML module.
This flow is demonstrated in the Euclid example of \TUTORIAL.

Alternatively, and probably with the help of one of the editor modes,\footnote{There are editor modes for \texttt{emacs}, \texttt{vim}, and others.} one can develop a theory with a script file that is always separately compilable.

\subsection{\holmake{} Limitations}

Without information to the contrary, \holmake{} assumes that all files of interest are in the current directory or in \HOL{}'s master \texttt{sigobj} directory.
Using a \texttt{Holmakefile} (see Section~\ref{sec:using-Holmakefiles}), it is possible to mention files in other directories (which can contain their own \texttt{Holmakefile}s), both as dependencies and as explicit targets with rules on how those targets should be built.

\index{Holmake@\holmake!recursive invocation}%
\index{Holmake@\holmake!INCLUDES variable@\texttt{INCLUDES} variable}%
The right approach when a development spans multiple directories is to indicate that there is a dependency on other directories by using the \texttt{INCLUDES} variable in a \texttt{Holmakefile}.\footnote{In one-off situations, it is also possible to use the \texttt{-I} flag on \holmake{}'s command-line.}
\holmake{} requires that, just as files must have an acyclic dependency graph, the directories containing those files must have a compatible, and acyclic, \texttt{INCLUDES} graph.
With \texttt{INCLUDES} information to hand, \holmake{} will process the entire \texttt{INCLUDES} graph, looking throughout the graph for theory files that the current directory may depend on, and rebuilding those remote targets as necessary.

Finally, it is borderline impossible (or at least, extremely difficult) to describe how theories are built from script files using, \eg, the Unix command-line.
This means that it is hard to independently control/script the processing of $x$\texttt{Script.sml} files; one must instead rely on the logic built into \holmake{} to do this.


\subsection{\holmake{}'s command-line arguments}
\index{Holmake@\holmake!command-line arguments}
Like {\tt make}, \holmake{} takes command-line arguments corresponding to the targets that the user desires to build.
As a special case of this, theories and \ML{} object files can be specified on the command-line by just giving the same string as would be passed to the \ml{open} declaration form.\footnote{Strictly, the files generated on disk for these cases have a \texttt{.uo} suffix; this feature allows that suffix to be omitted.}
Command-line targets do not have to provide paths to directories where those targets are ``housed'' if there is only target of the given name in the combination of all \texttt{INCLUDE}-d directories.

If there are no command-line targets, then \holmake{} will look for a \texttt{Holmakefile} in the current directory.
If there is none, or if that file specifies no targets, then \holmake{} will attempt to build all \ML{} modules and \HOL{} theories it can detect in the current directory.
If there is a target in the \texttt{Holmakefile}, then \holmake{} will try to build the first such target (only).

In addition, there are three special targets that can be used:
\begin{description}
\item[{\tt clean}] Removes all compiled files (unless over-ridden by a
  make-file target of the same name, see
  section~\ref{sec:using-Holmakefiles} below).
\item [{\tt cleanDeps}] Removes all of the pre-computed dependency
  files.  This can be an important thing to do if, for example, you
  have introduced a new {\tt .sig} file on top of an existing {\tt
    .sml} file.
\item [{\tt cleanAll}] Removes all compiled files as well as all of
  the hidden dependency information.
\end{description}

\noindent Finally, users can directly affect the workings of \holmake{}
with the following command-line options/flags:
\begin{description}
\item[\texttt{-f <theory>}] Toggles whether or not a theory should be
  built in ``fast'' mode.
  Fast building causes tactic proofs (invocations of \texttt{prove}, \texttt{store\_thm}, and the \texttt{Theorem}-\texttt{Proof}-\texttt{QED} form) to automatically succeed.
  This lack of soundness is marked by the \texttt{fast\_proof} oracle tag.
  This tag will appear on all theorems proved in this way and all subsequent theorems that depend on such theorems.
  \holmake's default is not to build in fast mode.
\item[\texttt{--fast}] Makes \holmake's default be to build in fast
  mode (see above).
\item[{\tt --help} or {\tt -h}] Prints out a useful option summary and
  exits.
\item[\tt --holdir <directory>] Associate this build with the given
  HOL directory, rather than the one this version of \holmake{} was
  configured to use by default.
\item[\tt --holmakefile <file>] Use the given file as a make-file.
  See section~\ref{sec:using-Holmakefiles} below for more on this.
\item[\tt -I <directory>]
  Look in specified directory for additional object files, including other HOL theories.
  This option can be repeated, with multiple {\tt -I}'s to allow for multiple directories to be referenced.
  Files in directories specified in this way will be rebuilt if they are needed for the specified list of targets.
\item[\texttt{--interactive} or \texttt{-i}] Causes the HOL code that
  runs when a theory building file is executed to have the flag
  \texttt{Globals.interactive} set to true.  This will alter the diagnostic
  output of a number of functions within the system.
\item[\texttt{-j<n>} or \texttt{--jobs=<n>}] Specify the maximum number of parallel jobs \holmake{} should use when building targets.
  Each job is a separate process, and so can only interfere with other jobs \emph{via} their interactions with the file system.
  Under Moscow~ML this option is ignored; its \holmake{} can only run jobs sequentially.
  If not set, the default value for this option is 4.
\item[\texttt{-k} or \texttt{--keep-going}] Causes \holmake{} to try
  to build all specified targets, rather than stopping as soon as one
  fails to build.
\item[\texttt{--logging}] Causes \holmake{} to record the times taken
  to build any theory files it encounters.  The times are logged in a
  file in the current directory.  The name of this file includes the
  time when \holmake{} completed, and when on a Unix system, the name
  of the machine where the job was run.  If \holmake{} exits
  unsuccessfully, the filename is preceded by the string
  ``\texttt{bad-}''. Each line in the log-file is of the form
  \textit{theory-name time-taken}, with the time recorded in seconds.
\item[\texttt{--no\_holmakefile}]  Do not use a make-file, even if a file
  called \texttt{Holmakefile} is present in the current directory.
\item[\texttt{--no\_overlay}] Do not use an overlay file.  All HOL
  builds require the presence of a special overlay file from the
  kernel when compiling scripts and libraries.  This is not
  appropriate for compiling code that has no connection to HOL, so
  this option makes the compilation not use the overlay file.  This
  option is also used in building the kernel before the overlay itself
  has been compiled.
\item[\texttt{--no\_preexecs}] Do not search for or execute any \texttt{.hol\_preexec} files in the file-system.
See Section~\ref{sec:holmake-preexec} below for more on this facility.
\item[\texttt{--no\_prereqs}]%
\index{Holmake@\holmake!recursive invocation}%
Do not recursively attempt to build ``include'' directories before working in the current directory.
If a target in the current directory depends on something in another directory that does not exist, \holmake{} will fail to build it.
If the remote target exists, but is stale, it will be used in its stale state, come what may.
\item[\texttt{--no\_sigobj}]
  Do not link against \HOL{} system's directory of \HOL{} system files.
  Use of this option goes some way towards turning \holmake{} into a general \ML{} \textsf{make} system.
  However, it will still attempt to do ``\HOL{} things'' with files whose names end in \texttt{Script} and \texttt{Theory}.
  This option implies \texttt{--no\_overlay}.
\item[\texttt{--overlay <file>}] Use the given file as the overlay
  rather than the default.
\item[\texttt{--qof},\texttt{--noqof}]
  Where q-o-f stands for ``quit on failure''.
  By default, if a tactic fails to prove a theorem, the running script exits with a failure.
  Depending on the presence or absence of the \texttt{-k} flag, this failure to build a theory may cause \holmake{} to also exit (with a failure).
  With the \texttt{--noqof} option, \holmake{} will cause the running script to use \texttt{mk\_thm} to assert the failed goal, allowing the build to continue and other theorems to be proved.
\item[\texttt{--quiet}] Minimise the amount of output produced by
  \holmake{}.  Fatal error messages will still be written to the
  standard error stream.  Note that other programs called by \holmake{} will not
  be affected.
\item[\texttt{-r}]%
\index{Holmake@\holmake!recursive invocation}%
Forces \holmake{} to behave more recursively than it would otherwise.
This overrides the \texttt{--no\_prereqs} option.
When performing a ``clean'' action (prompted by \texttt{clean}, \texttt{cleanAll} or \texttt{cleanDeps} arguments), this cleaning is done recursively through all ``includes'' directories (which is not done otherwise).
When building normally, all targets in ``includes'' directories are built; normally only dependencies of targets in the current directory are built.
\item[{\tt --rebuild\_deps}] Forces \holmake{} to always
  rebuild the dependency information for files it examines, whether or
  not it thinks it needs to.  This option is implemented by having
  \holmake{} wipe all of its dependency cache (as per the
  \texttt{cleanDeps} option above) before proceeding with the build.
\end{description}

\noindent \holmake{} should never exit with error messages such as ``Uncaught
exception''.  Such behaviour is a bug, please report it!


\subsection{Using a make-file with \holmake}
\label{sec:using-Holmakefiles}

\holmake{} will use a make-file to augment its behaviour if one is
present in the current directory.  By default it will look for a file
called \texttt{Holmakefile}, but it can be made to look at any file at
all with the \texttt{--holmakefile} command-line option.  The
combination of \holmake{} and a make-file is supposed to behave as
much as possible like a standard implementation of \textsf{make}.

A make-file consists of two types of entries, variable definitions and
rules.  Outside of these entries, white-space is insignificant, but
newline and \texttt{TAB} characters are very significant within them.
Comments can be started with hash (\texttt{\#}) characters and last
until the end of the line.  Quoting is generally done with use of the
back-slash (\verb+\+) character.  In particular, a backslash-newline
pair always allows a line to be continued as if the newline wasn't
present at all.

A variable definition is of the form
\[
\textsl{Ident} \;\;\textsl{op}\;\; \textsl{text}\;\;  \texttt{<NEWLINE>}
\]
where $\textsl{op}$ is either \texttt{=} or \texttt{+=}.
A rule is of the form
\[
\textsl{text } \texttt{:} \textsl{ text} \texttt{ <NEWLINE>}
(\texttt{<TAB>}\textsl{text}\texttt{ <NEWLINE>})^*
\]
Henceforth, the text following a \texttt{TAB} character in a rule will
be referred to as the \emph{command text}.  Text elsewhere will be
referred to as \emph{normal text}.  Normal text has comments stripped
from it, so hash characters there must be escaped with a back-slash
character.  An \textsl{Ident} is any non-empty sequence of
alpha-numeric characters, including the underscore (\texttt{\_}).

In some contexts, normal text is interpreted as a list of words.
These lists use white-space as element separators.  If a word needs to
include white-space itself, those white-space characters should be
escaped with back-slashes.

\newcommand{\varref}[1]{\texttt{\$(#1)}}
\paragraph{Variable definitions and references} The text on the RHS of a variable
definition can be substituted into any other context by using a
\emph{variable reference}, of the form \varref{VARNAME}.
References on right-hand sides are evaluated \emph{late}, at time of use, not at time of definition.
This means it is permissible to have forward references.
This makes it impossible to write things like
\[
  \texttt{VAR = \varref{VAR} something\_new}
\]
because the eventual evaluation of \varref{VAR} would lead to an infinite loop.
GNU \textsf{make}'s facility for immediate definition of variables with \texttt{:=} is not supported, but the \texttt{+=} definition form does allow variables to be ``extended''.
In particular, this form ``acts essentially as if you had included the extra text in the initial definition of the variable'' (as \emph{per} GNU \textsf{make}'s documentation).
Extending a variable \texttt{VAR} in this way does not constitute a \emph{use} of this variable, so any variable references in its original definition will remain unexpanded until \texttt{VAR} is used in a rule.

Note also that white-space around the equals-sign in a variable
definition is stripped.  This means that
\[
\texttt{VAR =<whitespace><NEWLINE>}
\] gives \texttt{VAR} the empty string as its value.\footnote{It is
  possible to give a variable a value of pure whitespace by writing \[
\begin{array}{l}
\texttt{NOTHING =}\\
\texttt{ONE\_SPACE = \varref{NOTHING}\textvisiblespace\hspace{1mm}\varref{NOTHING}}\\
\end{array}\]}

Finally, note that the text inside a variable reference is itself
evaluated.  This means that one can write something like
\varref{FOO\_\varref{OS}} and have this first expand the \texttt{OS}
variable, presumably giving rise to some useful string (such as
\texttt{unix}), and then have the resulting variable
(\texttt{FOO\_unix}, say) expanded.  This effectively allows the
construction of functions by cases (define variables
\texttt{FOO\_unix}, \texttt{FOO\_macos} etc.; then use the nested
variable reference above).  If the internal variable expands to
something containing spaces, this will not turn a normal variable
reference into a function call (see below).  On the other hand,
if the initial reference contains a space, the function name component
\emph{will} be expanded, allowing implementation of a function by
cases determining which text-manipulation function should be called.

\paragraph{Rules}
Make-file rules are interpreted in the same way as by traditional
\textsf{make}.  The files specified after the colon (if any) are those
files that each target (the files before the colon) is said to
``depend'' on.  If any of these are newer than a target, then
\holmake{} rebuilds that target according to the commands.  If there
are no dependencies, then the commands are executed iff the
target doesn't exist.  If there are no commands, and the target is not
of a type that \holmake{} already knows how to build, then it will
just make sure that the dependencies are up to date (this may or
may not create the target).  If there are no commands attached to a
rule, and the target is one that \holmake{} does know how to build,
then the rule's extra dependencies are added to those that \holmake{}
has managed to infer for itself, and \holmake{} will build the target
using its built-in rule.  If commands are provided for a type of file
that \holmake{} knows how to build itself, then the make-file's
commands and dependencies take precedence, and only they will be
executed.

In addition, it is possible to indicate that the built-in process of generating theory files from script files generates side products.
This is done by writing a command-less rule of the form
\begin{alltt}
   target : *thyScript.sml
\end{alltt}
where an asterisk character precedes the name of the script file.
This indicates that the action of executing the code in \texttt{thyScript.sml} will not only generate the usual \texttt{thyTheory.sig} and \texttt{thyTheory.sml} files, but also the file \texttt{target}.
If \holmake{} is asked to build any of these three files, and any is absent or out of date with respect to \texttt{thyScript.sml} (or any other dependency), then the code in \texttt{thyScript.sml} will be run.

If a command-line is preceded by a hyphen (\verb!-!) character, then
the rest of the line is executed, but its error-code is ignored.
(Normally, a command-line raising an error will cause \holmake{} to
conclude that the target can not be built.)  If a command-line is
preceded by an at-sign (\verb!@!), then that command-line will not be
echoed to the screen when it is run.  These two options can be
combined in either order at the start of a command-line.

Command text is interpreted only minimally by \holmake.  On Unix,
back-slashes are not interpreted at all.  On Windows, back-slashes
followed by newlines are turned into spaces. Otherwise, command text
is passed as is to the underlying command interpreter
(\texttt{/bin/sh} say, on Unix, or \texttt{COMMAND.COM} on Windows).
In particular, this means that hash-characters do \emph{not} start
comments on command-lines, and such ``comments'' will be passed to the
shell, which may or may not treat them as comments when it sees them.

\paragraph{Special targets}
Some target names for rules are handled specially by \holmake{}:
\begin{itemize}
\item Dependencies associated with the target name \texttt{.PHONY} are taken to be list of other targets in the make-file that are not actually the name of files to be built.
For example, targets naming conceptual collections of files such as \texttt{all} should be marked as ``phony''.
If a target is phony, then its dependencies will be built even if a file of that name exists and is newer than the dependencies.
\item The special way that command-line arguments \texttt{clean}, \texttt{cleanAll} and \texttt{cleanDeps} are handled means that targets of those names will not work.
In order to extend cleaning behaviour, use the \texttt{EXTRA\_CLEANS} variable (see below).
\end{itemize}
\paragraph{Functions}
\index{Holmake@\holmake!functions for text-manipulation}
\holmake{} supports some simple functions for manipulating text.  All
functions are written with the general form
\texttt{\$(\textsl{function-name}\textvisiblespace{}\hspace{1mm}\textsl{arg}${}_1$,\textsl{arg}${}_2$\dots,\textsl{arg}${}_n$)}.
Arguments can not include commas (use variable references to variables
whose value are commas instead), but can otherwise be arbitrary text.
\begin{description}
\item[\texttt{\$(dprot arg)}] quotes (or ``protects'') the space
  characters that occur in a string so that the string will be treated
  as a unit if it occurs in a rule's dependency list.  For example,
  the file
\begin{verbatim}
   dep = foo bar
   target: $(dep)
      do_something
\end{verbatim}
  will see \texttt{target} as having two dependencies, not one,
  because spaces are used to delimit dependencies.  If a dependency's
  name includes spaces, then this function can be used to quote them
  for \holmake's benefit.  Note that the \texttt{dprot} function
  does \emph{not} do the same thing as \texttt{protect} on either Unix
  or Windows systems.
\item[\texttt{\$(findstring arg1,arg2)}] checks if \texttt{arg1} occurs
  in (is a sub-string of) \texttt{arg2}.  If it does so occur, the
  result is \texttt{arg1}, otherwise the result is the empty string.
\item[\texttt{\$(if arg1,arg2,arg3)}] examines \texttt{arg1}.  If it
  is the empty string, then the value of the whole is equal to the
  value of \texttt{arg3}.  Otherwise, the value is that of \texttt{arg2}.
\item[\texttt{\$(patsubst arg1,arg2,text)}] splits \texttt{text} into component
  words, and then transforms each word by attempting to see if it
  matches the pattern in \texttt{arg1}.  If so, it replaces that word
  with \texttt{arg2} (suitably instantiated).  If not, the word is
  left alone.  The modified words are then reassembled into a
  white-space separated list and returned as the value.

  A pattern is any piece of text including no more than one occurrence
  of the percent~(\texttt{\%}) character.  The percent character
  matches any non-empty string.  All other characters must be matched
  literally.  The instantiation for \texttt{\%} is remembered when the
  replacement is constructed.  Thus, \[
    \texttt{\$(patsubst \%.sml,\%.uo,\$(SMLFILES))}
   \] turns a list of files with suffixes \texttt{.sml} into the same
  list with the suffixes replaced with \texttt{.uo}.
\item[\texttt{\$(protect arg)}] wraps \texttt{arg} in appropriate
  quote characters to ensure that it will pass through the operating
  system's command shell unscathed.  This is important in the presence
  of file-names that include spaces or other shell-significant
  characters like less-than and greater-than.  Those make-file
  variables that point directly at executables (\texttt{MOSMLC},
  \texttt{MOSMLLEX} etc.) are automatically protected in this way.
  Others, which might be used in concatenation with other elements,
  are not so protected.  Thus, if \texttt{DIR} might include spaces,
  one should write
\begin{verbatim}
   $(protect $(DIR)/subdirectory/program)
\end{verbatim}
  so that the above will be read as one unit by the underlying shell.
\item[\texttt{\$(subst arg1,arg2,text)}] replaces every occurrence
  of \texttt{arg1} in \texttt{text} with \texttt{arg2}.
\item[\texttt{\$(tee arg1,arg2)}]\index{tee@\texttt{tee}!Holmake function@\texttt{Holmake} function} produces a (moderately complicated) shell command line that behaves like \texttt{arg1~|~tee~arg2}, but whose exit code is \texttt{arg1}'s rather than \texttt{tee}'s.
\item[\texttt{\$(which arg)}] is replaced by the full path to an executable and readable occurrence of a file called \texttt{arg} within a directory in the list of directories in the \texttt{PATH} environment variable.
For example \texttt{\$(which cat)} will usually expand to \texttt{/bin/cat} on Unix-like systems.
If there is no occurrence of \texttt{arg} in any directory in \texttt{PATH}, this function call expands to the empty string.
\item[\texttt{\$(wildcard pattern)}] expands the shell ``glob'' pattern (\eg, \texttt{*Script.sml}) into the list of matching filenames.
If the pattern doesn't match any files, then the function returns \texttt{pattern} unchanged.
\end{description}

\paragraph{Special and pre-defined variables}

\index{Holmake@\holmake!variables in makefiles}
\index{Holmake@\holmake!INCLUDES variable@\texttt{INCLUDES} variable}
If defined, the \texttt{INCLUDES} variable is used to add directories to the list of directories consulted when files are compiled and linked.
The effect is as if the directories specified had all been included on the command-line with \texttt{-I} options.
The \texttt{PRE\_INCLUDES} variable works similarly, but the directories specified here are placed before any \texttt{INCLUDES} directories when dependency analysis is done.
Both \texttt{INCLUDES} and \texttt{PRE\_INCLUDES} directories are consulted before the distribution's \texttt{sigobj} directory (containing all core material).

\index{Holmake@\holmake!recursive invocation}
By default, directories specified in the \texttt{INCLUDES} and \texttt{PRE\_INCLUDES} directory are also built by \holmake{} before it attempts to build in the current directory.
If the \texttt{-r} (``force recursion'') command-line flag is used, these directories are also ``clean''-ed when a cleaning target is given to \holmake{}.

\index{CLINE_OPTIONS (Holmakefile variable)@\texttt{CLINE\_OPTIONS} (Holmakefile variable)}%
The \texttt{CLINE\_OPTIONS} variable is used for the specification of command-line switches that are presumably usually appropriate for calls to \holmake{} in the containing directory.
The options present in \texttt{CLINE\_OPTIONS} are used to build a ``base environment'' of switches; this base environment is then overridden by whatever was actually passed on the command-line.
For example, a useful \texttt{CLINE\_OPTIONS} line%
\footnote{Note that a \texttt{-{}-noqof} option in a makefile might be overridden from the command-line with the otherwise useless seeming \texttt{-{}-qof} option.
In addition, the \texttt{-{}-no\_hmakefile} command-line option will stop the makefile from being consulted at all.} %
might be
\begin{alltt}
    CLINE_OPTIONS = -j1 --noqof
\end{alltt}
Under Poly/ML, the similar \texttt{POLY\_CLINE\_OPTIONS} variable can be used to pass run-time options to the Poly/ML executable that is run during theory construction.


\index{EXTRA_CLEANS (Holmakefile variable)@\texttt{EXTRA\_CLEANS} (Holmakefile variable)}%
The \texttt{EXTRA\_CLEANS} variable is used to
specify the name of additional files that should be deleted when a
\texttt{Holmake clean} command is issued.

Within a command, the variable \texttt{\$<} is used to stand for the
name of the first dependency of the rule.  The variable \texttt{\$@} is
used to stand for the target of the rule.

Finally there are variables that expand to program names and other
useful information:
\begin{description}
\item[\texttt{CP}] This variable is replaced by an operating-system
  appropriate program to perform a file copy.  The file to be copied
  is the first argument, the second is the place to copy to.  The
  second argument can be a directory.  (Under Unix, \texttt{CP}
  expands to \texttt{/bin/cp}; under Windows, it expands to
  \texttt{copy}.)
\item[\texttt{DEBUG\_FLAG}] This variable is replaced by \texttt{"-{}-dbg"} if that flag was passed to \holmake, or the empty string if not.
\item[\texttt{DEFAULT\_TARGETS}]\index{DEFAULT_TARGETS (Holmakefile variable)@\texttt{DEFAULT\_TARGETS} (Holmakefile variable)}%
This variable expands to a list of the targets in the current directory that \holmake{} would build if there was no target in the Holmakefile, and no target was specified on the command-line.
Thus, if one wishes to continue to have all these defaults built alongside an additional target, an appropriate idiom to use at the head of the file would be
\begin{alltt}
    all: $(DEFAULT_TARGETS) mytarget1 mytarget2
    .PHONY: all
\end{alltt}
followed by rules for building the new target(s).

\item[\texttt{HOLDIR}] The root of the HOL installation.
\item[\texttt{HOLHEAP}]
Under Poly/ML, this variable expands to the name of the heap that should be used to build this directory (to be used instead of the heap that underlies the \texttt{hol} executable).
See Section~\ref{sec:polyml-heaps} below for more on using custom heaps with Poly/ML.
\item[\texttt{HOLMOSMLC}] This variable is replaced by an invocation
  of the Moscow ML compiler along with the \texttt{-q} flag (necessary
  for handling quotations), and the usual \texttt{-I} include
  specifications (pre-includes, the hol-directory include, and the
  normal includes).
\item[\texttt{HOLMOSMLC-C}] This variable is the same as
  \texttt{HOLMOSMLC} except that it finishes with a closing
  \texttt{-c} option (hence the name) followed by the name of the
  system's overlay file.  This is needed for compilation of HOL source
  files, but not for linking of HOL object code, which can be done
  with \texttt{HOLMOSMLC}.
\item[\texttt{HOL\_NUMJOBS}] The value of the \texttt{-j} option (4 by default under Poly/ML, 1 under Moscow~ML) controlling the number of parallel jobs that \holmake{} will use.
\item[\texttt{KERNELID}]
  The kernel option that was passed to \HOL's \texttt{build} command, stripped of its leading hyphens.
  This will typically be \texttt{stdknl} (the standard kernel) but may take on other values if other custom kernels are being used.
\item[\texttt{ML\_SYSNAME}] The name of the ML system being used:
  either \texttt{mosml} or \texttt{poly}.
\item[\texttt{MLLEX}] This is the path of the \texttt{mllex} tool that
  is built as part of HOL's configuration.
\item[\texttt{MLYACC}] This is the path of the \texttt{mlyacc} tool that
  is built as part of HOL's configuration.
\item[\texttt{MOSMLC}] This is replaced by an invocation of the
  compiler along with just the normal includes.
\item[\texttt{MOSMLLEX}] This is replaced by an invocation of the
  \texttt{mosmllex} program that comes with the Moscow ML
  distribution.
\item[\texttt{MOSMLYAC}] This is replaced by an invocation of the
  \texttt{mosmlyac} program that comes with the Moscow ML
  distribution.
\item[\texttt{MV}] This variable is replaced by an operating-system
  appropriate program to perform a file movement.  The file to be
  moved is the first argument, the second is the place to move to.
  The second argument can be a directory.  (Under Unix, \texttt{MV}
  expands to \texttt{mv}; under Windows, it expands to \texttt{rename}.)
\item[\texttt{OS}] This variable is replaced by the name of the
  current operating system, which will be one of the strings
  \texttt{"linux"}, \texttt{"solaris"}, \texttt{"macosx"},
  \texttt{"unix"} (for all other Unices), or \texttt{"winNT"}, for all
  Microsoft Windows operating systems (those of the 21st century,
  anyway).
\item[\texttt{SIGOBJ}] Effectively \varref{HOLDIR}\texttt{/sigobj},
  where HOL object code is stored.
  \item[\texttt{UNQUOTE}] The location of the quotation-filter executable.
\end{description}
The \texttt{MOSMLLEX} and \texttt{MOSMLYAC} abbreviations are really
only useful if the originals aren't necessarily going to be on the
user's ``path''.  For backwards compatibility, the five variables
above including the sub-string ``\texttt{MOSML}'' in their names can
also be used by simply writing their names directly (i.e., without the
enclosing \varref{\dots}), as long as these references occur first on
a command-line.

Under Poly/ML, commands involving the variable \texttt{MOSMLC} are interpreted ``appropriately''.
If the behaviour is not as desired, we recommend using \texttt{ifdef~POLY}~(see below) to write rules that pertain only to HOL under Poly/ML.
We strongly discourage the use of \texttt{MOSMLYAC} and \texttt{MOSMLLEX}, even when running HOL under Moscow~ML.

If a reference is made to an otherwise undefined string, then it is
treated as a reference to an environment variable.  If there is no
such variable in the environment, then the variable is silently given
the empty string as its value.

\paragraph{Conditional parts of makefiles}
\index{Holmake@\holmake!conditional inclusion of sections}
As in GNU~\textsf{make}, parts of a \texttt{Holmakefile} can be included or excluded dynamically, depending on tests that can be performed on strings including variables.
%
This is similar to the way directives such as \texttt{\#ifdef} can be used to control the C~preprocessor.

There are four possible directives in a \texttt{Holmakefile}: \texttt{ifdef}, \texttt{ifndef}, \texttt{ifeq} and \texttt{ifneq}.
%
The versions including the extra `n' character reverse the boolean sense of the test.
%
Conditional directives can be chained together with \texttt{else} directives, and must be terminated by the \texttt{endif} command.
%
The following example is a file that only has any content if the \texttt{POLY} variable is defined, which happens when Poly/ML is the underlying \ML{} system.
\begin{hol}
\begin{verbatim}
ifdef POLY
TARGETS = target1 target2

target1: dependency1
      build_command -o target1 dependency1
endif
\end{verbatim}
\end{hol}
The next example includes chained \texttt{else} commands:
\begin{hol}
\begin{verbatim}
ifeq "$(HOLDIR)" "foo"
VAR = X
else ifneq "$(HOLDIR)" "bar"
VAR = Y
else
VAR = Z
endif
\end{verbatim}
\end{hol}
\index{ifeq (Holmake directive)@\texttt{ifeq} (Holmake directive)}
\index{ifneq (Holmake directive)@\texttt{ifneq} (Holmake directive)}
The \texttt{ifneq} and \texttt{ifeq} forms test for string equality.
%
They can be passed their arguments as in the example, or delimited with apostrophes, or in parentheses with no delimiters, as in:
\begin{hol}
\begin{verbatim}
ifeq ($(HOLDIR),$(OTHERDIR))
VAR = value
endif
\end{verbatim}
\end{hol}

\index{ifdef (Holmake directive)@\texttt{ifdef} (Holmake directive)}
\index{ifndef (Holmake directive)@\texttt{ifndef} (Holmake directive)}
The definedness tests \texttt{ifdef} and \texttt{ifndef} test if a name has a non-null expansion in the current environment.
%
This test is just of one level of expansion.
%
In the following example, \texttt{VAR} is defined even though it ultimately expands to the emptry string, but \texttt{NULL} is not.
%
The variable \texttt{FOOBAR} is also not defined.
\begin{hol}
\begin{verbatim}
NULL =
VAR = $(NULL)
\end{verbatim}
\end{hol}
Note that environment variables with non-empty values are also considered to be defined.

\subsection{Execution of Commands before \holmake{} Begins}
\label{sec:holmake-preexec}

When building complicated projects, it may be useful to have programs executed before any invocation of \holmake{} properly begins.
This can be done through the use of \texttt{.hol\_preexec} files.
\index{Holmake@\holmake!hol_preexec files@\texttt{.hol\_preexec} files}
\index{pre-execution files (Holmake)@pre-execution files (\holmake{})}
When \holmake{} begins, and before it has even begun to examine \texttt{Holmakefile}s, it scans upwards in the directory hierarchy looking for files of this name.
This scanning will also follow \texttt{INCLUDES} directives, possibly causing a jump sideways in the hierarchy.

When this scanning is complete, the contents of all these files will be executed as shell commands (using the \ml{OS.Process.system} command, which is in turn a wrapper for the standard C library \texttt{system} function).
Each command will be interpreted in the directory containing it, and (under Unix at least), in an environment where the \texttt{HOLORIG} variable is set to the path of the directory where \holmake{} was originally invoked.
The commands are executed sequentially in a pre-order depth-first traversal of the directory hierarchy (relying on the behaviour of \ml{String.compare} on paths).
If any command fails (returns a non-zero exit code), \holmake{} will abort; in this way pre-execution commands can be used as checks as well as commands that are supposed to bring about useful changes to the state of the file-system.

\textbf{Warning:} This facility allows for code at a higher-level (in terms of the parent-child relationship between paths) in the file-system hierarchy to execute.
\holmake{} will log all such executions by default, printing out the commands as it executes them.
This execution does not happen with ``clean'' targets, or if the \texttt{-h} or \texttt{--no\_preexecs} command-line options are used.
It is not possible to stop this behaviour by putting the \texttt{--no\_preexecs} option into a \texttt{CLINE\_OPTIONS} variable with a \texttt{Holmakefile}; all such execution will have occurred before any such are really consulted.

\index{Holmake@\holmake|)}


\section{\texorpdfstring{Generating and Using Heaps in Poly/ML \HOL{}}{Generating and Using Heaps in Poly/ML HOL}}
\label{sec:polyml-heaps}

\index{heaps (in Poly/ML)|(}
\index{Poly/ML}
\index{Moscow ML}
Poly/ML has a nice facility whereby the state of one of its interactive sessions can be stored on disk and then reloaded.
This allows for an efficient resumption of work in a known state.
The \HOL{} implementation uses this facility to implement the \texttt{hol} executable.
In Poly/ML, \texttt{hol} starts immediately.
In Moscow~ML, \texttt{hol} starts up by visibly (and relatively slowly) ``loading'' the various source files that provide the system's functionality (\eg, \ml{bossLib}).

Users can use the same basic technology to ``dump'' heaps of their own.
Such heaps can be preloaded with source code implementing special-purpose reasoning facilities, and with various necessary background theories.
This can make developing big mechanisations considerably more pleasant.

\subsection{\texorpdfstring{Generating \HOL{} heaps}{Generating HOL heaps}}

The easiest way to generate a \HOL{} heap is to use the \texttt{buildheap} executable that is built as part of the standard build process for (Poly/ML)~\HOL.
This program takes a list of object files to include in a heap, an optional heap to build upon (use the \texttt{-b} command-line switch; the default is to use the heap behind the core \texttt{hol} executable), and an optional name for the new heap (the default is the traditional Unix \texttt{a.out}).
Thus the command-line
\begin{alltt}
   buildheap -o realheap transcTheory polyTheory
\end{alltt}
would build a heap in the current directory called \texttt{realheap}, and would preload it with the standard theories of transcendental numbers and real-valued polynomials.

A reasonable way to manage the generation of heaps is to use a \texttt{Holmakefile}.
For example, the \texttt{realheap} above might be generated with the source in Figure~\ref{fig:realheap-makefile}.
The use of the special variable \texttt{HOLHEAP} has a number of nice side effects.
First, it makes the given file a dependency of all other products in the current directory.
This means that the \HOL{} heap will be built first.
Secondly, the other products in the current directory will be built on top of that heap, not the default heap behind \texttt{hol}.
\begin{figure}
\begin{alltt}
   ifdef POLY
   HOLHEAP = realheap
   OBJNAMES = polyTheory transcTheory
   DEPS = $(patsubst %,$(dprot $(SIGOBJ)/%),$(OBJNAMES))

   $(HOLHEAP): $(DEPS)
           $(protect $(HOLDIR)/bin/buildheap) -o $@ $(OBJNAMES)
   endif
\end{alltt}
\caption{A \texttt{Holmakefile} fragment for building a custom \HOL{} heap embodying the standard real number theories.
If the heap's dependencies are not core \HOL{} theories as they are here, then both the dependency line and the arguments to \texttt{buildheap} will need to be adjusted to link to the directory containing the files.
For core \HOL{} theories, the dependency has to mention the \texttt{SIGOBJ} directory, but when passing arguments to \texttt{buildheap}, that information doesn't need to be provided as \texttt{SIGOBJ} is always consulted by all \HOL{} builds.
Finally, note how the use of the \texttt{dprot} and \texttt{protect} functions will ensure that \holmake{} will do the right thing even when \texttt{HOLDIR} contains spaces.}
\label{fig:realheap-makefile}
\end{figure}

\subsection{\texorpdfstring{Using \HOL{} heaps}{Using HOL heaps}}
As just described, if a \texttt{Holmakefile} specifies a \texttt{HOLHEAP}, then files in that directory will be built on top of that heap rather than the default.
This is also true if the specified heap is in another directory (\ie, the \texttt{HOLHEAP} line might specify a file such as \texttt{otherdir/myheap}).
In this case, the \texttt{Holmakefile} won't (shouldn't) include instructions on how to build that heap, but the advantages of that heap are still available.
Again, that heap is also considered a dependency for all files in the current directory, so that they will be rebuilt if it is newer than they are.

It is obviously important to be able to use heaps interactively.
If the standard \texttt{hol} executable is invoked in a directory where there is a \texttt{Holmakefile} specifying a heap, the default heap will not be used and the given heap will be used instead.
The fact that this is happening is mentioned as the interactive session begins.
For example:

\begin{samepage}
\begin{alltt}
---------------------------------------------------------------------
       HOL-4 [Kananaskis 8 (stdknl, built Tue Jul 24 16:48:44 2012)]

       For introductory HOL help, type: help "hol";
---------------------------------------------------------------------

[extending loadPath with Holmakefile INCLUDES variable]
[In non-standard heap: computability-heap]
Poly/ML 5.4.1 Release
>
\end{alltt}
\end{samepage}

Finally, note that when using the \texttt{HOLHEAP} variable, heaps are required to be built before everything else in a directory, and that such heaps embody theories or \ML{} sources that are \emph{ancestral} to the directory in which the heap occurs.
Thus, if one wanted to package up a heap embodying the standard theories for the real numbers, and to do it in \texttt{src/real} (which feels natural), this heap could be built using the method described here, but could only be referred to as a \texttt{HOLHEAP} in the directories that used it, \emph{not} in \texttt{src/real}'s \texttt{Holmakefile}.
Subsequently, developments in other directories could use this heap by specifying\[
  \texttt{\$(HOLDIR)/src/real/realheap}
\]
as the value for their \texttt{HOLHEAP} variables.

\index{heaps (in Poly/ML)|)}
\section{Timing and Counting Theorems}

\index{counting inferences, in HOL proofs@counting inferences, in \HOL{} proofs|(}
\index{inferences, in HOL logic@inferences, in \HOL{} logic!counting of|(}
\index{timing of HOL evaluations@timing of \HOL{} evaluations|(}


\HOL{} can be made to record its use of primitive
inferences, axioms, definitions and use of oracles.  Such recording is
enabled with the function

\begin{holboxed}
\index{counting_thms@\ml{counting\_thms}|pin}
\begin{verbatim}
   val counting_thms : bool -> unit
\end{verbatim}
\end{holboxed}

\noindent (This function as with all the others in this section is
found in the \texttt{Count} structure.)

Calling \ml{counting\_thms true} enables counting, and
\ml{counting\_thms false} disables it.  The default is for counting to
be disabled.  If it is enabled, whenever \HOL{} performs a primitive
inference (or accepts an axiom or definition) a counter is
incremented.  A total count as well as counts per primitive inference
are maintained.  The value of this counter is returned by the
function:

\begin{holboxed}
\index{thm_count@\ml{thm\_count}|pin}
\begin{verbatim}
  val thm_count : unit ->
   {ASSUME : int, REFL : int, BETA_CONV : int, SUBST : int,
    ABS : int, DISCH : int, MP : int, INST_TYPE : int, MK_COMB : int,
    AP_TERM : int, AP_THM : int, ALPHA : int, ETA_CONV : int,
    SYM : int, TRANS : int, EQ_MP : int, EQ_IMP_RULE : int,
    INST : int, SPEC : int, GEN : int, EXISTS : int, CHOOSE : int,
    CONJ : int, CONJUNCT1 : int, CONJUNCT2 : int, DISJ1 : int,
    DISJ2 : int, DISJ_CASES : int, NOT_INTRO : int, NOT_ELIM : int,
    CCONTR : int, GEN_ABS : int, definition : int, axiom : int,
    from_disk : int, oracle :int, total :int }
\end{verbatim}\end{holboxed}

\noindent This counter can be reset with the function:

\begin{holboxed}
\index{reset_thm_count@\ml{reset\_thm\_count}|pin}
\begin{verbatim}
   val reset_thm_count : unit -> unit
\end{verbatim}\end{holboxed}

Finally, the \texttt{Count} structure also includes another function
which easily enables the number of inferences performed by an \ML{}
procedure to be assessed:

\begin{holboxed}
\index{Count.apply@\ml{Count.apply}|pin}
\begin{verbatim}
   val apply : ('a -> 'b) -> 'a -> 'b
\end{verbatim}
\end{holboxed}

An invocation, \ml{Count.apply f x}, applies the function \ml{f} to
the argument \ml{x} and performs a count of inferences during this
time.  This function also records the total time taken in the
execution of the application.

For example, timing the action of \ml{numLib}'s \ml{ARITH\_CONV}:

\setcounter{sessioncount}{1}
\begin{session}
\begin{verbatim}
- Count.apply numLib.ARITH_CONV ``x > y ==> 2 * x > y``;
runtime: 0.010s,    gctime: 0.000s,     systime: 0.000s.
Axioms asserted: 0.
Definitions made: 0.
Oracle invocations: 0.
Theorems loaded from disk: 0.
HOL primitive inference steps: 165.
Total: 165.
> val it = |- x > y ==> 2 * x > y = T : thm
\end{verbatim}
\end{session}

\index{counting inferences, in HOL proofs@counting inferences, in \HOL{} proofs|)}
\index{inferences, in HOL logic@inferences, in \HOL{} logic!counting of|)}
\index{timing of HOL evaluations@timing of \HOL{} evaluations|)}



\input{latex-munger}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:

%  LocalWords:  HOL mechanisations HOLHEAP Holmakefile

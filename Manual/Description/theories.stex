%%% -*- Mode: LaTeX; -*-
\newcommand{\subr}{\sb{\mathsf{r}}}
\chapter{Core Theories}\label{HOLtheories}

% LaTeX macros in HOL manuals
%
% \holtxt{..}     for typewriter text that is HOL types or terms.  To
%                 produce backslashes, for /\, \/ and \x. x + 1, use \bs
% \ml{..}         for typewriter text that is ML input, including the
%                 names of HOL API functions, such as mk_const
% \theoryimp{..}  for names of HOL theories.

% Inside \begin{verbatim}, indent contents three spaces, unless
% displaying a HOL session in a box (boxed or session environments).
% In that case, put the session flush against the left margin

% Rather than wrapping begin{verbatim} blocks in \small, which does
% terrible things to line-spacing in the vicinity, use the hol
% environment, thus \begin{hol}\begin{verbatim}...\end{verbatim}\end{hol}

\setcounter{sessioncount}{0}

\newcommand{\konst}[1]{\ensuremath{\mbox{\small{\textbf{\sf{#1}}}}}}
\newcommand{\nil}{\mathbf{[} \;\mathbf{]}}
\newcommand{\cons}[2]{{#1}\mathbf{:}\mathbf{:}{#2}}

\index{theories, in HOL logic@theories, in \HOL{} logic!hierarchies
of}%
The \HOL{} system provides a collection of theories on which to base verification tools or further theory development.
In the rest of this section, these theories are briefly described.
The sections that follow provide an overview of the contents of each theory.
For a complete list of all the axioms, definitions and theorems in \HOL, see the online resources distributed with the system.
In particular, the HTML file \url{help/HOLindex.html} is a good place to start browsing the available theories.
For a graphical picture of the theory hierarchy, see \url{help/theorygraph/theories.html}.

In addition, core theories of higher mathematics are described in Chapter~\ref{ch:math}.

\section{The Theory {\tt min}}\label{minTheory}

The starting theory of \HOL{} is the theory \ml{min}.
\index{min, the HOL theory@\ml{min}, the \HOL{} theory|(}
In this theory, the type constant {\small\verb+bool+} of booleans,
the binary type operator $(\alpha,\beta)${\small\verb+fun+} of functions, and the type
constant {\small\verb+ind+} of individuals are declared. Building on
these types, three primitive constants
\index{constants, in HOL logic@constants, in \HOL{} logic!primitive logical}%
\index{primitive constants, of HOL logic@primitive constants, of \HOL{} logic}%
are declared: equality, implication, and a choice operator:
\index{ equality, in HOL logic@\ml{=} (equality, in \HOL{} logic)}
\index{equality, in HOL logic@equality, in \HOL{} logic}
\begin{description}
\item [Equality] Equality ({\small\verb+= : 'a -> 'a -> bool+}) is an
  infix operator.
\index{equality, in HOL logic@equality, in \HOL{} logic}
\item [Implication] Implication
  ({\small\verb+==> : bool -> bool -> bool+}) is the
  \emph{material implication} and is an infix operator that is
  right-associative, \ie, \verb+x ==> y ==> z+ parses to the same term
  as \verb+x ==> (y ==> z)+.
\index{implication, in HOL logic@implication, in \HOL{} logic}
\item [Choice] Equality
and implication are standard predicate calculus notions, but choice is
more exotic: if $t$ is a term having type $\sigma${\small\verb+->bool+},
then {\small\verb+@x.+}$t${\small\verb+ x+} (or, equivalently,
{\small\verb+$@+}$t$) denotes \emph{some} member of the set whose
characteristic\index{characteristic predicate, of type definitions}
 function is $t$. If the set is empty, then
{\small\verb+@x.+}$t${\small\verb+ x+} denotes an arbitrary member of the
set denoted by $\sigma$. The constant {\small\verb+@+} is a higher order
version of Hilbert's
\index{Hilbert, D.}%
\index{epsilon operator}%
 $\hilbert$-operator; it is related to the constant
$\iota$ in Church's formulation of higher order logic. For more details,
see Church's
\index{Church, A.}
original paper \cite{Church}, Leisenring's
\index{Leisenring, A.}
book on Hilbert's $\hilbert$-symbol \cite{Leisenring}, or Andrews'
textbook on type theory \cite{Andrews}.
\end{description}

\medskip

\noindent No theorems or axioms are placed in theory \theoryimp{min}.
The primitive rules of inference of \HOL{} depend on the presence of
\theoryimp{min}.
%
\index{min, the HOL theory@\ml{min}, the \HOL{} theory|)}

\section{Basic Theories}

The most basic theories in HOL provide support for a standard
collection of types. The theory \theoryimp{bool} defines the basis of
the \HOL{} logic, including the boolean operations and
quantifiers. On this platform, quite a bit of theorem-proving
infrastructure can already be built. Further basic types are developed
in the theory of pairs (\theoryimp{prod}), disjoint sums
(\theoryimp{sum}), the one-element type (\theoryimp{one}), and the
(\theoryimp{option}) type.


\subsection{The theory \theoryimp{bool}}\label{boolfull}

\index{axioms!primitive, of HOL logic@primitive, of \HOL{} logic|(}
%
At start-up, the initial theory for users of the \HOL{} system is
called \ml{bool}\index{HOL@\HOL{}}, which is constructed when the
\HOL{} system is built. The theory \theoryimp{bool} is an extension of
the combination of the ``conceptual'' theories \theory{LOG} and
\theory{INIT}, described in \LOGIC.  Thus it contains the four axioms
%
\index{axioms!in bool theory@in \ml{bool} theory}
%
for higher order logic. These axioms, together with the rules of
inference described in Section~\ref{rules}, constitute the core of the
\HOL{} logic.  Because of the way the \HOL{} system evolved from \LCF%
%
\index{LCF@\LCF}%
%
\footnote{To simplify the porting of the LCF theorem-proving tools to
  the HOL system, the HOL logic was made as like PP$\lambda$ (the
  logic built-in to LCF) as possible.}, the particular axiomatization
of higher order logic it uses differs from the classical
axiomatization due to Church\index{Church, A.}  \cite{Church}.  The
biggest difference is that in Church's formulation type variables
%
\index{type variables, in HOL logic@type variables, in \HOL{} logic!differences from classical}
%
are in the meta-language, whereas in the \HOL{} logic they are part of
the object language.

The logical constants
%
\index{logical constants, in HOL logic@logical constants, in \HOL{} logic}
%
\holtxt{T}~(truth),
%
\index{truth values, in HOL logic@truth values, in \HOL{} logic!constants for}
%
\holtxt{F}~(falsity),
\holtxt{\~{}}~(negation),
%
\index{ negation, in HOL logic@\holtxt{\~{}} (negation, in \HOL{} logic)}
%
\holtxt{/\bs} (conjunction),
%
\index{ conjunction, in HOL logic@\holtxt{/\bs} (conjunction, in \HOL{} logic)}
%
\holtxt{\bs/} (disjunction),
%
\index{ disjunction, in HOL logic@\holtxt{\bs/} (disjunction, in \HOL{} logic)}
%
\holtxt{!} (universal quantification),
%
\index{ universal quantifier, in HOL logic@\holtxt{"!} (universal quantifier, in \HOL{} logic)}
%
\holtxt{?} (existential quantification),
%
\index{ existential quantifier, in HOL logic@\holtxt{?} (existential quantifier, in \HOL{} logic)}
%
and \holtxt{?!} (unique existence quantifier)
%
\index{ exists unique, in HOL logic@\holtxt{?"!} (exists unique, in \HOL{} logic)}
%
can all be defined in terms of equality,
%
\index{equality, in HOL logic@equality, in \HOL{} logic}
%
implication and choice.  The definitions listed below are fairly
standard; each one is preceded by its \ML{} name.  Later definitions
sometimes build on earlier ones.

\begin{hol}
\index{truth values, in HOL logic@truth values, in \HOL{} logic!definition of}
\index{T@\holtxt{T}!definitional axiom for}
\index{disjunction, in HOL logic@disjunction, in \HOL{} logic!definitional axiom for}
\index{conjunction, in HOL logic@conjunction, in \HOL{} logic!definitional axiom for}
\index{iff, in HOL logic@iff, in \HOL{} logic!definitional axiom for}
\index{negation, in HOL logic@negation, in \HOL{} logic!definitional axiom for}
\index{ exists unique, in HOL logic@\holtxt{?"!} (exists unique, in \HOL{} logic)}
\index{F (falsity), the HOL constant@\holtxt{F} (falsity), the \HOL{} constant!definitional axiom for}
\index{conjunction, in HOL logic@conjunction, in \HOL{} logic!definitional axiom for}
\index{disjunction, in HOL logic@disjunction, in \HOL{} logic!definitional axiom for}
\index{equality, in HOL logic@equality, in \HOL{} logic!primitive axiom for}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL{} logic!definitional axiom for}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL{} logic!definitional axiom for}
\index{exists unique, in HOL logic@exists unique, in \HOL{} logic!definitional axiom for}
\begin{verbatim}
   T_DEF              |- T  = ((\x:bool. x) = (\x. x))

   FORALL_DEF         |- !  = \P:'a->bool. P = (\x. T)

   EXISTS_DEF         |- ?  = \P:'a->bool. P($@ P)

   AND_DEF            |- /\ = \t1 t2. !t. (t1 ==> t2 ==> t) ==> t

   OR_DEF             |- \/ = \t1 t2. !t. (t1 ==> t) ==> (t2 ==> t) ==> t

   F_DEF              |- F  = !t. t

   NOT_DEF            |- ~  = (\t. t ==> F)

   EXISTS_UNIQUE_DEF  |- ?! = (\P. $? P /\ (!x y. P x /\ P y ==> (x = y)))
\end{verbatim}
\end{hol}


There are four
%
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL{} logic!in four primitive axioms}
%
axioms in the theory \theoryimp{bool};
%
\index{bool, the HOL theory@\ml{bool}, the \HOL{} theory}
%
the first three are the following:

\begin{hol}
\index{BOOL_CASES_AX@\ml{BOOL\_CASES\_AX}}
\index{ETA_AX@\ml{ETA\_AX}}
\index{SELECT_AX@\ml{SELECT\_AX}}
\index{implication, in HOL logic@implication, in \HOL{} logic!primitive axiom for}
\index{ choice function, in HOL logic@\holtxt{"@} (choice function, in \HOL{} logic)}
\index{choice axiom}
\index{axiom of choice}
\index{axioms!of choice}
\index{choice operator, in HOL logic@choice operator, in \HOL{} logic!primitive axiom for}
\begin{alltt}
##thm BOOL_CASES_AX

##thm ETA_AX

##thm SELECT_AX
\end{alltt}
\end{hol}

\noindent
The fourth and last axiom of the \HOL{} logic is the Axiom of
Infinity\index{axiom of infinity}. Its statement is phrased in terms of
the function properties {\small\verb+ONE_ONE+} and {\small\verb+ONTO+}. The
definitions are:

\begin{hol}
\index{ONE_ONE_DEF@\ml{ONE\_ONE\_DEF}}
\index{ONTO_DEF@\ml{ONTO\_DEF}}
\index{one-to-one predicate, in HOL logic@one-to-one predicate, in \HOL{} logic!definitional axiom for}
\index{onto predicate, in HOL logic@onto predicate, in \HOL{} logic!definitional axiom for}
\begin{alltt}
##thm ONE_ONE_DEF
##thm ONTO_DEF
\end{alltt}
\end{hol}

\noindent The Axiom of Infinity\index{axioms!in bool theory@in \ml{bool} theory} is
%
\begin{hol}
\index{INFINITY_AX@\ml{INFINITY\_AX}}
\index{axiom of infinity}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL{} logic!in infinity axiom}
\begin{alltt}
##thm INFINITY_AX
\end{alltt}
\end{hol}
%
\noindent
This asserts that there exists a one-to-one map from \holtxt{ind} to
itself that is not onto. This implies that the type \holtxt{ind}
denotes an infinite set.
%
\index{axioms!primitive, of HOL logic@primitive, of \HOL{} logic|)}

The three other axioms of the theory \theoryimp{bool}, the rules of
inference in Section~\ref{rules} and the Axiom of Infinity are,
together, sufficient for developing all of standard mathematics. Thus,
in principle, the user of the \HOL{} system should never need to make a
non-definitional
%
\index{axioms!dispensibility of adding}%
\index{definitional theories}%
%
theory. In practice, it is often very tempting to take the risk of
introducing new axioms because deriving them from definitions can be
tedious---proving that `axioms' follow from definitions amounts to
proving their consistency.

\paragraph {Further definitions}

The theory \theoryimp{bool} also supplies the definitions of a number of
useful constants.
\begin{hol}
\index{COND, the HOL constant@\holtxt{COND}, the \HOL{} constant}
\index{LET, the HOL constant@\ml{LET}, the \HOL{} constant}
\index{conditionals, in HOL logic@conditionals, in \HOL{} logic!definitional axiom for}
\begin{alltt}
##thm LET_DEF
##thm COND_DEF
##thm IN_DEF
\end{alltt}
\end{hol}

The constant \holtxt{LET}
%
\index{let-terms, in HOL logic@\holtxt{let}-terms, in \HOL{} logic!constant for}
%
is used in representing terms containing local variable bindings (\ie,
\holtxt{let}-terms).
%
\index{let-terms, in HOL logic@\holtxt{let}-terms, in \HOL{} logic!definitional axiom for}
%
For example, the concrete syntax \holtxt{let v = M in N} is translated
by the parser to the term \holtxt{LET (\bs{}v.N) M}. For the full
description of how \holtxt{let} expressions are translated, see
Section~\ref{sec:let-exp}.

The constant \holtxt{COND} is used to represent conditional
expressions. The concrete syntax
%
\index{terms, in HOL logic@terms, in \HOL{} logic!conditional}%
\index{conditionals, in HOL logic@conditionals, in \HOL{} logic}%
%
$\holtxt{if}\;t_1\;\holtxt{then}\;t_2\;\holtxt{else}\;t_3$ abbreviates
the application \holtxt{COND $t_1$ $t_2$ $t_3$}.

The constant \holtxt{IN} (written as an infix) is the basis of
the modelling of sets by their characteristic functions.  The term
$x\holtxt{ IN }P$ can be read as ``$x$ is an element of the set
$P$'', or (more in line with its definition) as ``the predicate $P$ is
true of $x$''.

Finally, the polymorphic constant $\holtxt{ARB}:\alpha$ denotes a
fixed but arbitrary element. \holtxt{ARB} is occasionally useful when
attempting to deal with the issue of partiality.

\subsubsection{Restricted quantifiers}\label{res-quant}

\index{restricted quantification}
%
The theory \theoryimp{bool} also defines constants that implement
\emph{restricted quantification}. This provides a means of simulating
subtypes and dependent types with predicates. The most heavily used
are restrictions of the existential and universal quantifiers:
%
\begin{alltt}
##thm RES_FORALL_DEF
##thm RES_EXISTS_DEF

##thm RES_ABSTRACT_DEF
\end{alltt}
%
The definition of \ml{RES\_ABSTRACT} is a characterising formula, rather
than a direct equation.  There are two important properties
\begin{itemize}
\item if $y$ is an element of $P$ then $(\bs{}x :: P.\; M)
  y = M[y/x]$
\item If two restricted abstractions agree on all values over their
  (common) restricting set, then they are equal.
\end{itemize}

For completeness, restricted versions of unique existence and
indefinite description are provided, although hardly used.
\begin{alltt}
##thm RES_EXISTS_UNIQUE_DEF
##thm RES_SELECT_DEF
\end{alltt}

The definition of \ml{RES\_EXISTS\_UNIQUE} uses the restricted
quantification syntax with the {\small\verb+::+} symbol, referring to
the earlier definitions \ml{RES\_EXISTS} and \ml{RES\_FORALL}.
The \texttt{::} syntax is used with restricted quantifiers to allow
arbitrary predicates to restrict binding variables. The \HOL{} parser
allows restricted quantification of all of a sequence of binding
variables by putting the restriction at the end of the sequence, thus
with a universal quantification:
%
\[
\forall x \, y \, z \, {\tt ::} \; P \, . \; Q(x,y,z)
\]
%
Here the predicate $P$ restricts all of $x$, $y$ and $z$.

\subsubsection{Derived syntactic forms}\label{derived-terms}

\index{quotation, in HOL logic@quotation, in \HOL{} logic!of non-primitive terms|(}
% don't refill the \index entries above, it's important to keep each
% entry on one line
The \HOL{} quotation parser
%
\index{quotation, in HOL logic@quotation, in \HOL{} logic!parser for}
%
can translate various standard logical
notations
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of standard notations}
%
into primitive terms. For example, if \ml{+} has been declared an
infix
%
\index{infixes, in HOL logic@infixes, in \HOL{} logic}
%
(as explained in Section~\ref{theoryfns}), as it is when
\ml{arithmeticTheory} has been loaded, then \ml{``x+1``} is
translated to \ml{``\$+~x~1``}. The escape character \ml{\$}
%
\index{ dollar sign, in HOL logic parser@\ml{\$} (dollar sign, in \HOL{} logic parser)!as escape character}%
\index{declared constants, in HOL logic@declared constants, in \HOL{} logic}%
\index{infixes, in HOL logic@infixes, in \HOL{} logic}%
%
suppresses the infix behaviour of \ml{+} and prevents the quotation
parser getting confused.  In general, \ml{\$} can be used to suppress
any special syntactic behaviour a token (such as \texttt{if},
\texttt{+} or \texttt{let})
%
\index{tokens!suppressing parsing behaviour of}
%
might have. This is illustrated in the table below, in which the terms
in the column headed \textit{`\ML{} quotation'} are translated by the
quotation parser to the corresponding terms in the column headed
\textit{`Primitive term'}.  Conversely, the terms in the latter column
are always printed in the form shown in the former one.  The \ML{}
constructor expressions in the rightmost column evaluate to the same
values (of type \ml{term}) as the other quotations in the same row.

\bigskip

\begin{center}
\index{choice operator, in HOL logic@choice operator, in \HOL{} logic!syntax of}
\index{ negation, in HOL logic@\holtxt{\~{}} (negation, in \HOL{} logic)}
\index{ disjunction, in HOL logic@\holtxt{\bs/} (disjunction, in \HOL{} logic)}
\index{ conjunction, in HOL logic@\holtxt{/\bs} (conjunction, in \HOL{} logic)}
\index{ implication, in HOL logic@\holtxt{==>} (implication, in \HOL{} logic)}
\index{ equality, in HOL logic@\ml{=} (equality, in \HOL{} logic)}
\index{ universal quantifier, in HOL logic@\holtxt{"!} (universal quantifier, in \HOL{} logic)}
\index{ existential quantifier, in HOL logic@\holtxt{?} (existential quantifier, in \HOL{} logic)}
\index{ choice function, in HOL logic@\holtxt{"@} (choice function, in \HOL{} logic)}
\index{terms, in HOL logic@terms, in \HOL{} logic!non-primitive}
\index{terms, in HOL logic@terms, in \HOL{} logic!constructors for}
\index{conditionals, in HOL logic@conditionals, in \HOL{} logic}
\index{conjunction, in HOL logic@conjunction, in \HOL{} logic!constructor for}
\index{disjunction, in HOL logic@disjunction, in \HOL{} logic!constructor for}
\index{equality, in HOL logic@equality, in \HOL{} logic!syntax of}
\index{negation, in HOL logic@negation, in \HOL{} logic!syntax of}
\index{negation, in HOL logic@negation, in \HOL{} logic!constructor for}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL{} logic!syntax of}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL{} logic!syntax of}
\index{implication, in HOL logic@implication, in \HOL{} logic!syntax of}
\index{mk_neg@\ml{mk\_neg}}
\index{mk_disj@\ml{mk\_disj}}
\index{mk_conj@\ml{mk\_conj}}
\index{mk_imp@\ml{mk\_imp}}
\index{mk_eq@\ml{mk\_eq}}
\index{mk_forall@\ml{mk\_forall}}
\index{mk_exists@\ml{mk\_exists}}
\index{mk_select@\ml{mk\_select}}
\index{mk_cond@\ml{mk\_cond}}
\index{mk_let@\ml{mk\_let}}
\index{conjunction, in HOL logic@conjunction, in \HOL{} logic!syntax of}
\begin{tabular}{|l|l|l|l|} \hline
\multicolumn{4}{|c|}{ } \\
\multicolumn{4}{|c|}{\bf Non-primitive terms} \\
\multicolumn{4}{|c|}{ } \\
{\it Kind of term} & {\it \ML\ quotation} &
{\it Primitive term} &
{\it Constructor expression} \\ \hline
 & & & \\
Negation & {\small\verb+~+}$t$ & {\small\verb+$~ +}$t$ & {\small\verb+mk_neg(+}$t${\small\verb+)+} \\ \hline
Disjunction & $t_1${\small\verb+\/+}$t_2$ & {\small\verb+$\/ +}$t_1\ t_2$ &
{\small\verb+mk_disj(+}$t_1${\small\verb+,+}$t_2${\small\verb+)+} \\ \hline
%
Conjunction & $t_1$\holtxt{/\bs}$t_2$ & $\holtxt{\$/\bs}\ t_1\ t_2$ &
{\small\verb+mk_conj(+}$t_1${\small\verb+,+}$t_2${\small\verb+)+} \\
\hline
%
Implication & $t_1${\small\verb+==>+}$t_2$ & {\small\verb+$==> +}$t_1\ t_2$ &
{\small\verb+mk_imp(+}$t_1${\small\verb+,+}$t_2${\small\verb+)+} \\ \hline
%
Equality & $t_1${\small\verb+=+}$t_2$ & {\small\verb+$= +}$t_1\ t_2$ &
{\small\verb+mk_eq(+}$t_1${\small\verb+,+}$t_2${\small\verb+)+} \\ \hline
%
$\forall$-quantification & {\small\verb+!+}$x${\small\verb+.+}$t$ &
\holtxt{\$!(\bs}$x${\small\verb+.+}$t${\small\verb+)+} & {\small\verb+mk_forall(+}$x${\small\verb+,+}$t${\small\verb+)+} \\ \hline
%
$\exists$-quantification & {\small\verb+?+}$x${\small\verb+.+}$t$ &
\holtxt{\$?(\bs}$x${\small\verb+.+}$t${\small\verb+)+} & {\small\verb+mk_exists(+}$x${\small\verb+,+}$t${\small\verb+)+} \\ \hline
%
$\hilbert$-term & {\small\verb+@+}$x${\small\verb+.+}$t$ &
\holtxt{\$@(\bs}$x${\small\verb+.+}$t${\small\verb+)+} & {\small\verb+mk_select(+}$x${\small\verb+,+}$t${\small\verb+)+} \\ \hline
%
Conditional & {\small\verb+if +}$t\ ${\small\verb+then +}$t_1${\small\verb+ else +}$t_2$ &
{\small\verb+COND +}$t\ t_1\ t_2$ & {\small\verb+mk_cond(+}$t${\small\verb+,+}$t_1${\small\verb+,+}$t_2${\small\verb+)+}
 \\ \hline
%
{\small\verb+let+}-expression & {\small\verb+let +}$x${\small\verb+=+}$t_1${\small\verb+ in +}$t_2$ &
\holtxt{LET(\bs}$x${\small\verb+.+}$t_2${\small\verb+)+}$t_1$ &
\holtxt{mk\_let(mk\_abs($x$,$t_2$),$t_1$)} \\ \hline
\end{tabular}
\end{center}

\bigskip

There are constructors, destructors and indicators for all the obvious
constructs. (Indicators, \eg, \ml{is\_neg}, return truth values
indicating whether or not a term belongs to the syntax class in
question.) In addition to the constructors listed in the table there
are constructors, destructors, and indicators for pairs and lists,
namely \ml{mk\_pair},
%
\index{mk_pair@\ml{mk\_pair}}
%
\ml{mk\_cons}
%
\index{mk_cons@\ml{mk\_cons}}
%
and \ml{mk\_list}
%
\index{mk_list@\ml{mk\_list}}
%
(see \REFERENCE).  The constants \holtxt{COND} and \holtxt{LET} are
explained in Section~\ref{boolfull}.  The constants \holtxt{\bs/},
%
\index{disjunction, in HOL logic@disjunction, in \HOL{} logic!syntax of}
%
\holtxt{/\bs}, \holtxt{==>} and \holtxt{=} are examples of
\textit{infixes} and represent $\vee$, $\wedge$, $\imp$ and equality,
respectively. If $c$ is declared to be an infix, then the \HOL{}
parser will translate $t_1\ c\ t_2$ to {\small\verb+$+}$c\ t_1\ t_2$.

The constants {\small\verb+!+}, {\small\verb+?+} and {\small\verb+@+}
are examples of \label{binder} \textit{binders}
%
\index{binders, in HOL logic@binders, in \HOL{} logic}
%
and represent $\forall$, $\exists$ and $\hilbert$, respectively.  If
$c$ is declared to be a binder, then the \HOL{} parser will translate
\holtxt{$c$ $x$.$t$} to the combination \holtxt{\$$c$(\bs$x$.$t$)}
(\ie, the application of the constant $c$ to the representation of the
abstraction $\lquant{x}t$).
\index{ function abstraction binder, in HOL logic@\holtxt{\bs} (function abstraction binder, in \HOL{} logic)}

\begin{center}

\index{variables, in HOL logic@variables, in \HOL{} logic!multiple bound}
\index{list_mk_comb@\ml{list\_mk\_comb}|pin}
\index{list_mk_abs@\ml{list\_mk\_abs}|pin}
\index{list_mk_forall@\ml{list\_mk\_forall}|pin}
\index{list_mk_exists@\ml{list\_mk\_exists}|pin}
\index{combinations, in HOL logic@combinations, in \HOL{} logic!abbreviation for multiple}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL{} logic!abbreviation for multiple}
\index{universal quantifier, in HOL logic@universal quantifier, in \HOL{} logic!abbreviation for multiple}
\begin{tabular}{|l|l|l|} \hline
\multicolumn{3}{|c|}{ } \\
\multicolumn{3}{|c|}{\bf Syntactic abbreviations} \\
\multicolumn{3}{|c|}{ } \\
{\it Abbreviated term} & {\it Meaning} &
{\it Constructor expression} \\ \hline
 & &  \\
$t\ t_1 \cdots t_n$ &
{\small\verb+(+}$\cdots${\small\verb+(+}$t\ t_1${\small\verb+)+}$\cdots t_n${\small\verb+)+} &
{\small\verb+list_mk_comb(+}$t${\small\verb+,[+}$t_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$t_n${\small\verb+])+} \\ \hline
\holtxt{\bs}$x_1\cdots x_n${\small\verb+.+}$t$ &
\holtxt{\bs}$x_1${\small\verb+. +}$\cdots$\holtxt{ \bs}$x_n${\small\verb+.+}$t$ &
{\small\verb+list_mk_abs([+}$x_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$x_n${\small\verb+],+}$t${\small\verb+)+}
\\ \hline
{\small\verb+!+}$x_1\cdots x_n${\small\verb+.+}$t$ &
{\small\verb+!+}$x_1${\small\verb+. +}$\cdots${\small\verb+ !+}$x_n${\small\verb+.+}$t$ &
{\small\verb+list_mk_forall([+}$x_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$x_n${\small\verb+],+}$t${\small\verb+)+}
\\ \hline
{\small\verb+?+}$x_1\cdots x_n${\small\verb+.+}$t$ &
{\small\verb+?+}$x_1${\small\verb+. +}$\cdots${\small\verb+ ?+}$x_n${\small\verb+.+}$t$ &
{\small\verb+list_mk_exists([+}$x_1${\small\verb+, +}$\ldots${\small\verb+ ,+}$x_n${\small\verb+],+}$t${\small\verb+)+} \\
\hline
\end{tabular}
\end{center}

\noindent There are also constructors
\ml{list\_mk\_conj}\index{list_mk_conj@\ml{list\_mk\_conj}},
\ml{list\_mk\_disj}\index{list_mk_disj@\ml{list\_mk\_disj}},
\ml{list\_mk\_imp}\index{list_mk_imp@\ml{list\_mk\_imp}} and
for conjunctions, disjunctions, and implications respectively.
The corresponding destructor functions are called \ml{strip\_comb} \etc
%
\index{term constructors, in HOL logic@term constructors, in \HOL{} logic}
%
\index{terms, in HOL logic@terms, in \HOL{} logic!constructors for}
%
\index{quotation, in HOL logic@quotation, in \HOL{} logic!of non-primitive terms|)}

\subsubsection{Theorems}

A large number of theorems involving the logical constants are
pre-proved in the theory \theoryimp{bool}. The following theorems
illustrate how higher order logic allows concise expression of
theorems supporting quantifier movement.

\begin{holboxed}
\begin{verbatim}
 LEFT_AND_FORALL_THM  |- !P Q. (!x. P x) /\ Q = !x. P x /\ Q
 RIGHT_AND_FORALL_THM |- !P Q. P /\ (!x. Q x) = !x. P /\ Q x

 LEFT_EXISTS_AND_THM  |- !P Q. (?x. P x /\ Q) = (?x. P x) /\ Q
 RIGHT_EXISTS_AND_THM |- !P Q. (?x. P /\ Q x) = P /\ ?x. Q x

 LEFT_FORALL_IMP_THM  |- !P Q. (!x. P x ==> Q) = (?x. P x) ==> Q
 RIGHT_FORALL_IMP_THM |- !P Q. (!x. P ==> Q x) = P ==> !x. Q x

 LEFT_EXISTS_IMP_THM  |- !P Q. (?x. P x ==> Q) = (!x. P x) ==> Q
 RIGHT_EXISTS_IMP_THM |- !P Q. (?x. P ==> Q x) = P ==> ?x. Q x

 LEFT_FORALL_OR_THM   |- !Q P. (!x. P x \/ Q) = (!x. P x) \/ Q
 RIGHT_FORALL_OR_THM  |- !P Q. (!x. P \/ Q x) = P \/ !x. Q x

 LEFT_OR_EXISTS_THM   |- !P Q. (?x. P x) \/ Q = ?x. P x \/ Q
 RIGHT_OR_EXISTS_THM  |- !P Q. P \/ (?x. Q x) = ?x. P \/ Q x

 EXISTS_OR_THM        |- !P Q. (?x. P x \/ Q x) = (?x. P x) \/ ?x. Q x
 FORALL_AND_THM       |- !P Q. (!x. P x /\ Q x) = (!x. P x) /\ !x. Q x

 NOT_EXISTS_THM       |- !P. ~(?x. P x) = !x. ~P x
 NOT_FORALL_THM       |- !P. ~(!x. P x) = ?x. ~P x

 SKOLEM_THM           |- !P. (!x. ?y. P x y) = ?f. !x. P x (f x)
\end{verbatim}
\end{holboxed}

Also, a theorem justifying Skolemization ({\small\verb+SKOLEM_THM+}) is
proved. Many other theorems may be found in \theoryimp{bool} theory.


\subsection{Combinators}
\label{sec:combinTheory}

\index{function composition, in HOL logic@function composition, in \HOL{} logic|(}

The theory \theoryimp{combin}
\index{combin@\theoryimp{combin}}%
\index{combinators, in HOL logic@combinators, in \HOL{} logic}%
contains the definitions of function composition (infixed \ml{o}),
\index{ function composition operator, in HOL logic@\ml{o} (function composition operator), in \HOL{} logic|(}
a reversed function application operator,
\index{ function application operator, in HOL logic@\ml{:>} ((reversed) function application operator), in \HOL{} logic}
function override (infixed \ml{=+}),
\index{ function override operator, in HOL logic@\ml{=+} (function override opreator), in \HOL{} logic}
and the combinators
\ml{S},
\index{S, the HOL constant@\ml{S}, the \HOL{} constant}
\ml{K},
\index{K, the HOL constant@\ml{K}, the \HOL{} constant}
\ml{I},
\index{I, the HOL constant@\ml{I}, the \HOL{} constant}
\ml{W},
\index{W, the HOL constant@\ml{W}, the \HOL{} constant}
and \ml{C},
\index{C, the HOL constant@\ml{C}, the \HOL{} constant}

\begin{hol}
\begin{alltt}
>>__ open combinTheory
##thm o_DEF
##thm APP_DEF
##thm UPDATE_def
##thm K_DEF
##thm S_DEF
##thm I_DEF
##thm W_DEF
##thm C_DEF
\end{alltt}
\end{hol}

\noindent The following elementary properties are proved in the theory
\ml{combin}:

\begin{hol}
\begin{alltt}
##thm o_THM
##thm o_ASSOC

##thm UPDATE_EQ
##thm UPDATE_COMMUTES
##thm APPLY_UPDATE_THM

##thm K_THM
##thm S_THM
##thm I_THM
##thm W_THM
##thm C_THM
\end{alltt}
\end{hol}

The above illustrates that there are two ways of writing function update terms.
As per the definition above (\ml{UPDATE\_def}), the infix \holtxt{=+} takes a key $k$ and a value $v$, and returns a higher-order function, which when in turn is passed a function $f$, returns a version of that function that has been updated to return $v$ when applied to $k$, and is otherwise the same as $f$.
The same effect can be achieved with the ``substitution style'' syntax: $f\llparenthesis{}k\mapsto v\rrparenthesis$.
There is an ASCII form of this notation as well:
\begin{session}
\begin{alltt}
>> ``(k2 =+ v2) ((k1 =+ v1) f)``;
>> ``f (| k |-> v |)``;
\end{alltt}
\end{session}

\index{ function application operator, in HOL logic@\ml{:>} ((reversed) function application operator), in \HOL{} logic}
There are no theorems about \ml{:>}; its use is as a convenient syntax for function applications.
For example, chains of updates can lose some parentheses if written
\begin{hol}
\begin{verbatim}
   f :> (k1 =+ v1) :> (k2 =+ v2) :> (k3 =+ v3)
\end{verbatim}
\end{hol}
This presentation also makes the order in which functions are applied read from left-to-right.

Having the symbols \ml{o}, \ml{S}, \ml{K}, \ml{I}, \ml{W}, and \ml{C}
as built-in constants
%
\index{variables, in HOL logic@variables, in \HOL{} logic!with constant names}
%
is sometimes inconvenient because they are often wanted as mnemonic
names for variables (\eg, \ml{S} to range over sets and \ml{o} to
range over outputs).\footnote{Constants declared in new theories can
  freely re-use these names, with ambiguous inputs resolved by type
  inference.}  Variables with these names can be used in the current
system if \ml{o}, \ml{S}, \ml{K}, \ml{I}, \ml{W}, and \ml{C} are first
hidden (see Section~\ref{hidden}).
In fact, this happens so often with the constant \holtxt{C} that the name \holtxt{C} is ``hidden'' by default.
\index{flip, as alias for HOL constant C@\holtxt{flip}, as alias for \HOL{} constant \holtxt{C}}
Instead, it can be written in fully-qualified form, as \holtxt{combin\$C}, or with the alias \holtxt{flip}, as can be seen above.
%
\index{ function composition operator, in HOL logic@\ml{o} (function composition operator), in \HOL{} logic|)}
\index{function composition, in HOL logic@function composition, in \HOL{} logic|)}
\index{constants, in HOL logic@constants, in \HOL{} logic!fully-qualified names of}

\subsection{Pairs}\label{prod}

\index{representing types, in HOL logic@representing types, in \HOL{} logic!pair example of|(}
\index{pairs, in HOL logic@pairs, in \HOL{} logic|(}
\index{product types!in HOL logic@in \HOL{} logic|(}
%
The Cartesian  product  type  operator
%
\index{type operators, in HOL logic@type operators, in \HOL{} logic!for pairs}
%
\holtxt{prod}
%
\index{prod, the HOL type operator@\holtxt{prod}, the \HOL{} type operator}
%
is defined in the theory \theoryimp{pair}. Values of type
\holtxt{($\sigma_1$,$\sigma_2$)prod} are ordered pairs whose first
component has type $\sigma_1$ and whose second component has type
$\sigma_2$.  The \HOL{} type parser
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of pairs}
%
converts type expressions of the form \holtxt{:$\sigma_1$\#$\sigma_2$}
%
\index{ product type operator, in HOL logic@\holtxt{\#} (product type operator, in \HOL{} logic)}
%
into \holtxt{($\sigma_1$,$\sigma_2$)prod},
%
\index{ pair constructor, in HOL logic@\ml{,} (pair constructor, in \HOL{} logic)}
%
and the printer inverts this transformation. Pairs
%
\index{pairing constructor, in HOL logic@pairing constructor, in \HOL{} logic}
%
are constructed with an infixed comma symbol

\begin{hol}
\begin{verbatim}
   $, : 'a -> 'b -> 'a # 'b
\end{verbatim}
\end{hol}

\noindent
so, for example, if $t_1$ and $t_2$ have types $\sigma_1$ and
$\sigma_2$ respectively, then $t_1$\ml{,}$t_2$ is a term with type
$\sigma_1$\holtxt{\#}$\sigma_2$. Usually, pairs are written within
brackets: \holtxt{($t_1$,$t_2$)}. The comma symbol associates
%
\index{pairing constructor, in HOL logic@pairing constructor, in \HOL{} logic!associativity of}
%
to the right, so that \holtxt{($t_1$,$t_2$,$\ldots$,$t_n$)} means
\holtxt{($t_1$,($t_2$,$\ldots$,$t_n$))}.

\paragraph {Defining the product type}

The type of Cartesian products is defined by representing a pair
{\small\verb%(%}$t_1${\small\verb%,%}$t_2${\small\verb%)%}
by the function
%
\begin{hol}
\begin{alltt}
   \bs{}a b. (a=\m{t\sb{1}}) /\bs (b=\m{t\sb{2}})
\end{alltt}
\end{hol}
%
\noindent The representing type of
$\sigma_1${\small\verb%#%}$\sigma_2$ is thus
$\sigma_1${\small\verb%->%}$\sigma_2${\small\verb%->bool%}.
It is easy to prove the following theorem.\footnote{This theorem has
an un-reduced $\beta$-redex in order to meet the interface
required by the type definition principle.}
%
\begin{hol}
\begin{verbatim}
   |- ?p:'a->'b->bool. (\p. ?x y. p = \a b. (a = x) /\ (b = y)) p
\end{verbatim}
\end{hol}
%
The type operator {\small\verb%prod%} is defined by invoking \ml{new\_type\_definition}\index{new_type_definition@\ml{new\_type\_definition}} with this theorem which results in the definitional axiom
\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL{} logic!for products}%
\index{axioms!in bool theory@in \ml{bool} theory}%
\ml{prod\_TY\_DEF} shown below being asserted in the theory \ml{pair}.
%
\begin{hol}
\begin{alltt}
>>__ open pairTheory
##thm prod_TY_DEF
\end{alltt}
\end{hol}
%
Next, the representation and abstraction functions \holtxt{REP\_prod}
and \holtxt{ABS\_prod} for the new type are introduced, along with the
following characterizing theorem, by use of the function
\ml{define\_new\_type\_bijections}.
%
\begin{hol}
\begin{alltt}
##thm ABS_REP_prod
\end{alltt}
\end{hol}

\paragraph {Pairs and projections}

The infix constructor `{\small\verb%,%}' is then defined
to be an application of the abstraction function. Subsequently, two
crucial theorems are proved: {\small\verb+PAIR_EQ+} asserts that equal
pairs have equal components and {\small\verb+ABS_PAIR_THM+} shows that
every term having a product type can be decomposed into a pair of terms.
\begin{hol}
\index{pairing constructor, in HOL logic@pairing constructor, in \HOL{} logic!definition of}
\index{PAIR_EQ@\ml{PAIR\_EQ}}
\index{ABS_PAIR_THM@\ml{ABS\_PAIR\_THM}}
\begin{alltt}
##thm COMMA_DEF
##thm PAIR_EQ
##thm ABS_PAIR_THM
\end{alltt}
\end{hol}
%
By Skolemizing {\small\verb+ABS_PAIR_THM+} and making constant specifications
for {\small\verb+FST+} and {\small\verb+SND+}, the following theorems
are proved.
%
\begin{hol}
\index{PAIR@\ml{PAIR}}
\index{FST, the HOL constant@\ml{FST}, the \HOL{} constant!definition of}
\index{SND, the HOL constant@\ml{SND}, the \HOL{} constant!definition of}
\index{selectors, in HOL logic@selectors, in \HOL{} logic!for pairs}
\begin{alltt}
##thm PAIR
##thm FST
##thm SND
\end{alltt}
\end{hol}
\index{pairs, in HOL logic@pairs, in \HOL{} logic|)}
\index{product types!in HOL logic@in \HOL{} logic|)}
\index{representing types, in HOL logic@representing types, in \HOL{} logic!pair example of|)}

\paragraph{Pairs and functions}

In \HOL{}, a function of type $\alpha \# \beta\to\gamma$ always has a
counterpart of type $\alpha\to\beta\to\gamma$, and \emph{vice versa}.
This conversion is accomplished by the functions \holtxt{CURRY} and
\holtxt{UNCURRY}. These functions are inverses.
%
\begin{hol}
\index{CURRY, the HOL constant@\ml{CURRY}, the \HOL{} constant}
\index{UNCURRY, the HOL constant@\ml{UNCURRY}, the \HOL{} constant}
\begin{alltt}
##thm CURRY_DEF
##thm UNCURRY_DEF

##thm CURRY_UNCURRY_THM
##thm UNCURRY_CURRY_THM
\end{alltt}
\end{hol}


\paragraph {Mapping functions over a pair}

Functions $f : \alpha \to \gamma_1$ and $g : \beta\to\gamma_2$ can be
applied component-wise ({\small\verb+##+}, infix) over a pair of type
$\alpha \# \beta$ to obtain a pair of type $\gamma_1 \# \gamma_2$.
%
\begin{hol}
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for pairs}
\index{ PAIR_MAP function@\ml{\#\#} (\holtxt{PAIR\_MAP} function)}
\begin{alltt}
##thm PAIR_MAP_THM
\end{alltt}
\end{hol}

\paragraph {Binders and pairs}

When doing proofs, statements involving tuples may take the form of a
binding (quantification or $\lambda$-abstraction) of a variable with a
product type. It may be convenient in subsequent reasoning steps to
replace the variables with tuples of variables. The following theorems
support this.
%
\begin{hol}
\begin{alltt}
##thm FORALL_PROD
##thm EXISTS_PROD
##thm LAMBDA_PROD
\end{alltt}
\end{hol}
%
The theorem \ml{LAMBDA\_PROD} involves a \emph{paired
 abstraction}, discussed in Section \ref{HOL-varstruct}.


\paragraph {Wellfounded relations on pairs}
\index{wellfounded relations!lexicographic combination}
Wellfoundedness, defined in Section \ref{prim-rec-conseq},
is a useful notion, especially for proving termination of
recursive functions. For pairs, the lexicographic combination
of relations ({\small\verb+LEX+}, infix) may be defined by using
paired abstractions. Then the theorem that lexicographic combination
of wellfounded relations delivers a wellfounded relation is easy to
prove.
%
\begin{hol}
\begin{alltt}
##thm LEX_DEF
##thm WF_LEX
\end{alltt}
\end{hol}

\subsubsection{Paired abstractions}
\label{HOL-varstruct}
\index{pairs, in HOL logic@pairs, in \HOL{} logic!in abstractions|(}
\index{pairs, in HOL logic@pairs, in \HOL{} logic!parsing of}
\index{terms, in HOL logic@terms, in \HOL{} logic!pair|(}
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of paired abstractions}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!paired|(}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!uncurrying, in paired|(}

It is notationally convenient to include pairing in the lambda
notation, as a simple pattern-matching mechanism. The quotation parser
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of function abstractions}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!abbreviation for multiple}
\index{terms, in HOL logic@terms, in \HOL{} logic!function abstraction}
will convert the term
{\small\bs\texttt{(}}$x_1${\small\verb%,%}$x_2${\small\verb%).%}$t$
to {\small\verb%UNCURRY(%\bs}$x_1\ x_2${\small\verb%.%}$t${\small\verb%)%}.
The transformation is done recursively so that, for example,
%
\begin{hol}
\begin{alltt}
   \bs(\m{x\sb{1}},\m{x\sb{2}},\m{x\sb{3}}).\m{t}
\end{alltt}
\end{hol}
%
\noindent is converted to
%
\begin{hol}
\begin{alltt}
   UNCURRY (\bs\m{x\sb{1}}. UNCURRY(\bs\m{x\sb{2}} \m{x\sb{3}}.\m{t}))
\end{alltt}
\end{hol}
%
\noindent More generally, the quotation parser repeatedly applies the
transformation:
%
\begin{hol}
\begin{alltt}
   \bs(\m{v\sb{1}},\m{v\sb{2}}).\m{t}\m{\quad \leadsto\quad}UNCURRY(\bs\m{v\sb{1}}.\bs\m{v\sb{2}}.\m{t})
\end{alltt}
\end{hol}
%
\noindent until no more variable structures remain. For example:

\vspace{1ex}
\begin{tabular}{ll}
\texttt{\bs($x$,$y$).$t$} &
  $\leadsto$ \texttt{UNCURRY(\bs$x\,y$.$t$)}\\
%
\texttt{\bs($x_1$,$x_2$,$\ldots$,$x_n$).$t$} &
  $\leadsto$ \texttt{UNCURRY(\bs$x_1$.\bs($x_2$,$\ldots$,$x_n$).$t$)}\\
%
\texttt{\bs(($x_1$,$\ldots$,$x_n$),$y_1$,$\ldots$,$y_m$).$t$} &
  $\leadsto$
  \texttt{UNCURRY(\bs($x_1$,$\ldots$,$x_n$).\bs($y_1$,$\ldots$,$y_m$).$t$)}\\
\end{tabular}

\vspace{1ex}

\noindent As a result of this parser translation, a variable structure, such as \ml{(x,y)} in
\ml{\bs(x,y).x+y}, is not a subterm of the abstraction
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!subterms of}
in which it occurs; it disappears on parsing.
\index{binders, in HOL logic@binders, in \HOL{} logic!parsing of}%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of binders}%
This can lead to unexpected errors (accompanied by obscure error
messages).  For example, antiquoting a pair into the bound variable
position of a lambda abstraction fails:

\begin{session}
\begin{alltt}
>> ``\(x,y).x+y``;

>> val p = Term `(x:num,y:num)`;

>>+ Lib.try Term `\^p.x+y` handle _ => T
\end{alltt}
\end{session}
If $b$ is a binder, then \ml{$b$($x_1$,$x_2$).$t$} is parsed as
\ml{$b$(\bs($x_1$,$x_2$).$t$)}, and hence transformed as above.  For
example,
\ml{!(x,y).\ x > y}
parses to
\ml{\$!(UNCURRY(\bs{}x.\bs{}y.\ x > y))}.
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!paired|)}
\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!uncurrying, in paired|)}
\index{pairs, in HOL logic@pairs, in \HOL{} logic!in abstractions|)}
\index{terms, in HOL logic@terms, in \HOL{} logic!pair|)}


\subsubsection{\texttt{let}-terms}
\label{sec:let-exp}

The quotation parser
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of let-terms@of \holtxt{let}-terms}
%
accepts \ml{let}-terms
\index{terms, in HOL logic@terms, in \HOL{} logic!let-@\holtxt{let}-}%
\index{let-terms, in HOL logic@\holtxt{let}-terms, in \HOL{} logic!as abbreviations}%
similar to those in \ML. For example, the following terms are allowed:

\begin{hol}
\begin{verbatim}
   let x = 1 and y = 2 in x+y

   let f(x,y) = (x*x)+(y*y); a = 20*20; b = 50*49 in f(a,b)
\end{verbatim}
\end{hol}

\ml{let}-terms are actually abbreviations for ordinary terms which are
specially supported by the parser and pretty printer.
The constant \ml{LET}
%
\index{LET, the HOL constant@\ml{LET}, the \HOL{} constant}
%
is defined (in the theory \ml{bool}) by:

\begin{hol}\index{function abstraction, in HOL logic@function abstraction, in \HOL{} logic!relation to let-terms@relation to \ml{let}-terms}
\begin{verbatim}
   LET = (\f x. f x)
\end{verbatim}
\end{hol}

\noindent and is used to encode \ml{let}-terms in the logic. The parser
repeatedly applies the transformations:

\bigskip

{\small\begin{tabular}{ll}
\texttt{let~$f\,v_1\,\ldots\,v_n$~=~$t_1$~in~$t_2$} &
$\leadsto$~~\texttt{LET(\bs$f$.$t_2$)(\bs$v_1\,\ldots\,v_n$.$t_1$)}\\
%
\texttt{let~($v_1$,$\ldots$,$v_n$)~=~$t_1$~in~$t_2$} &
$\leadsto$~~\texttt{LET(\bs($v_1$,$\ldots$,$v_n$).$t_2$)$t_1$}\\
%
\texttt{let~$v_1$=$t_1$~and~$\ldots$~and~$v_n$=$t_n$~in~$t$} &
$\leadsto$~~\texttt{LET($\ldots$(LET(LET(\bs$v_1\ldots v_n$.$t$)$t_1$)$t_2$)$\ldots$)$t_n$}\\
\end{tabular}}

\bigskip


\noindent The underlying structure of the term can be seen by applying
destructor operations.  For example:

\begin{session}
\begin{alltt}
>> Term `let x = 1; y = 2; in x+y`;

>> dest_comb it;

>> Term `let (x,y) = (1,2) in x+y`;

>> dest_comb it;
\end{alltt}
\end{session}

Readers are encouraged to convince themselves that the translations of
\ml{let}-terms represent the intuitive meaning suggested by the
surface syntax.%
%

\subsection{Disjoint sums}
\label{sum}
\index{disjoint unions, the HOL theory of@disjoint unions, the \HOL{} theory of|(}
\index{sums (disjoint unions), the HOL theory of@sums (disjoint unions), the \HOL{} theory of|(}


The theory \theoryimp{sum} defines the binary disjoint union type
operator \holtxt{sum}.  A type \holtxt{($\sigma_1$,$\sigma_2$)sum}
denotes the disjoint union of types $\sigma_1$ and $\sigma_2$.  The
type operator \holtxt{sum} can be defined, just as \holtxt{prod} was,
but the details are omitted here.\footnote{The definition of disjoint
  unions in the HOL system is due to Tom Melham. The technical details
  of this definition can be found in~\cite{Melham-banff}.}  The \HOL{}
parser
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of sum types}
%
converts \holtxt{``:$\sigma_1$+$\sigma_2$``}
%
\index{ disjoint union type operator, in HOL logic@\ml{+} (disjoint union type operator, in HOL logic)}
%
into \holtxt{``:($\sigma_1$,$\sigma_2$)sum``}, and the printer inverts
this.

The standard operations on sums are:

\begin{hol}
\index{INL, the HOL constant@\ml{INL}, the \HOL{} constant}
\index{INR, the HOL constant@\ml{INR}, the \HOL{} constant}
\index{ISL, the HOL constant@\ml{ISL}, the \HOL{} constant}
\index{ISR, the HOL constant@\ml{ISR}, the \HOL{} constant}
\index{OUTL, the HOL constant@\ml{OUTL}, the \HOL{} constant}
\index{OUTR, the HOL constant@\ml{OUTR}, the \HOL{} constant}
\begin{verbatim}
   INL  : 'a -> 'a + 'b
   INR  : 'b -> 'a + 'b
   ISL  : 'a + 'b -> bool
   ISR  : 'a + 'b -> bool
   OUTL : 'a + 'b -> 'a
   OUTR : 'a + 'b -> 'b
\end{verbatim}
\end{hol}

\noindent These are all defined as constants in the theory \ml{sum}.  The
constants \ml{INL} and \ml{INR} inject into the left and right summands,
respectively. The constants \ml{ISL} and \ml{ISR} test for membership of the
left and right summands, respectively. The constants \ml{OUTL} and \ml{OUTR}
project from a sum to the left and right summands, respectively.

The following theorem is proved in the theory \ml{sum}. It provides a
complete and abstract characterization of the disjoint sum type, and
is used to justify the definition of functions over sums.

>>__ open sumTheory
\begin{hol}
\begin{alltt}
   ##thm sum_Axiom
\end{alltt}
\end{hol}

\noindent Also provided are the following theorems having to
do with the discriminator functions \ml{ISL} and \ml{ISR}:

\begin{hol}
\begin{alltt}
   ##thm ISL
   ##thm ISR

   ##thm ISL_OR_ISR
\end{alltt}
\end{hol}

\noindent The \ml{sum} theory also provides the following theorems
relating the projection functions and the discriminators.

\begin{hol}
\begin{alltt}
   ##thm OUTL
   ##thm OUTR

   ##thm INL
   ##thm INR
\end{alltt}
\end{hol}

The sum type operator can be seen as functorial over its arguments and so has a ``map'' function, \holtxt{SUM\_MAP}, with definition and results showing its functoriality:
\begin{hol}
\begin{alltt}
   ##thm SUM_MAP_def
   ##thm SUM_MAP_I
   ##thm SUM_MAP_o
\end{alltt}
\end{hol}

\index{disjoint unions, the HOL theory of@disjoint unions, the \HOL{} theory of|)}
\index{sums (disjoint unions), the HOL theory of@sums (disjoint unions), the \HOL{} theory of|)}


\subsection{The one-element type}%
\index{one, the HOL theory and type@\ml{one}, the \HOL{} theory and type}%
\index{unit, the HOL type (alias for one)@\ml{unit}, the \HOL{} type (alias for \holtxt{one})}%

The theory \ml{one} defines  the type  \ml{one} which  contains one element.
The type is also abbreviated as \ml{unit}, which is the name of the analogous type in \ML{}, and this is the type's preferred printing form.
The constant \ml{one} denotes this one element, but, again by analogy with \ML{}, the preferred parsing and printing form for this constant is \holtxt{()}.\footnote{When using the parenthesis-version, the \holtxt{one} value's syntax consists of two parenthesis tokens, so that one can write the value with white-space between the parentheses if desired.}
The pre-proved theorems in the theory \ml{one} are:

\begin{hol}
\index{one_Axiom@\ml{one\_Axiom}}
\begin{alltt}
>>__ open oneTheory; show_types := true;
##thm one_axiom
##thm one
##thm one_Axiom
>>__ show_types := false;
\end{alltt}
\end{hol}

\noindent
These three theorems are equivalent characterizations of the type with only one value.
The theory \ml{one} is typically used in constructing more elaborate types.

\subsubsection{The itself type}
\index{itself, the HOL type operator@\holtxt{itself}, the \HOL{} type operator}%
The unary \holtxt{itself} type operator (in \theoryimp{boolTheory})
provides a family of singleton types akin to \holtxt{one}.
Thus, for every type $\alpha$, \holtxt{$\alpha$~itself} is a type containing just one value.
This value's name is \holtxt{the\_value}, but the parser and pretty-printer are set up so that for the type \holtxt{$\alpha$~itself}, \holtxt{the\_value} can be written as \holtxt{(:$\alpha$)} (the syntax includes the parentheses).
For example, \holtxt{(:num)} is the single value inhabiting the type \holtxt{num~itself}.

The point of the itself type is that if one defines a function with \holtxt{$\alpha$~itself} as the domain, the function picks out just one value in its range,  and so one can think of the function as being one from the type to a value for the whole type.

For example, one could define
\begin{hol}
\begin{verbatim}
   finite_univ (:'a) = FINITE (UNIV :'a set)
\end{verbatim}
\end{hol}
It would then be straightforward to prove the following theorems
\begin{hol}
\begin{alltt}
   \(\vdash\) finite_univ(:bool)
   \(\vdash\) \(\neg\)finite_univ(:num)
   \(\vdash\) finite_univ(:'a) \(\land\) finite_univ(:'b) \(\Rightarrow\) finite_univ(:'a # 'b)
\end{alltt}
\end{hol}

The itself type is used in the Finite Cartesian Product construction that underlies the fixed-width word type (see Section~\ref{sec:bit-vectors} below).

\subsection{The option type}
\index{options, the HOL theory of@options, the \HOL{} theory of}

The theory \theoryimp{option} defines a type operator \verb+option+
that `lifts' its argument type, creating a type with all of the
values of the argument and one other, specially distinguished value.
The constructors of this type are
\begin{hol}
\begin{verbatim}
   NONE : 'a option
   SOME : 'a -> 'a option
\end{verbatim}
\end{hol}
Options can be used to model partial functions.  If a function of type
$\alpha\rightarrow\beta$ does not have useful $\beta$ values for all
$\alpha$ inputs, then this distinction can be marked by making the
range of the function $\beta\,\holtxt{option}$, and mapping the
undefined $\alpha$ values to \holtxt{NONE}.

An inductive type, options have a recursion theorem supporting the
definition of primitive recursive functions over option values.
%
\begin{hol}
\begin{alltt}
>>__ open optionTheory
##thm option_Axiom
\end{alltt}
\end{hol}
The \theoryimp{option} theory also defines a case constant that allows
one to inspect option values in a ``pattern-matching'' style.
\begin{hol}
\begin{verbatim}
   case e of
     NONE => u
   | SOME x => f x
\end{verbatim}
\end{hol}
%
The constant underlying this syntactic sugar is \verb+option_CASE+
with definition
\begin{hol}
\begin{alltt}
##thm option_case_def
\end{alltt}
\end{hol}
%
Another useful function maps a function over an option:
%
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for options}
\begin{hol}
\begin{alltt}
##thm OPTION_MAP_DEF
\end{alltt}
\end{hol}
Finally, the \holtxt{THE} function takes a \holtxt{SOME}
value to that constructor's argument, and is unspecified on
\holtxt{NONE}:
\begin{hol}
\begin{alltt}
##thm THE_DEF
\end{alltt}
\end{hol}

\section{Numbers}

The natural numbers, integers, and real numbers are provided in a
series of theories. Also available are theories of extended real numbers,
$n$-bit words
(numbers modulo $2^n$), floating point and fixed point numbers.

\subsection{Natural numbers}
\label{sec:arithmetic}

The natural numbers are developed in a series of theories:
\theoryimp{num}, \theoryimp{prim\_rec}, \theoryimp{arithmetic}, and
\theoryimp{numeral}. In \theoryimp{num}, the type of numbers is
defined from the Axiom of Infinity, and Peano's axioms are derived. In
\theoryimp{prim\_rec} the Primitive Recursion theorem is proved. Based
on that, a large theory treating the standard arithmetic operations is
developed in \theoryimp{arithmetic}. Lastly, a theory of numerals is
developed in \theoryimp{numeral}.

\subsubsection{The theory \theoryimp{num}}

The theory \theoryimp{num}
\index{num, the theory in HOL logic@\ml{num}, the theory in \HOL{} logic}
defines the type \ml{num} of natural numbers to be
isomorphic to a countable subset of the primitive type \ml{ind}.  In this
theory, the constants \ml{0}
\index{ zero, in HOL logic@\ml{0} (zero, in \HOL{} logic)}
and \ml{SUC} (the successor function) are defined
and Peano's axioms
\index{axioms!in num theory@in \ml{num} theory}%
\index{Peano's axioms}%
\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL{} logic!for natural numbers}%
pre-proved in the form:

\begin{hol}
\index{NOT_SUC@\ml{NOT\_SUC}}
\index{INV_SUC@\ml{INV\_SUC}}
\index{induction theorems, in HOL logic@induction theorems, in \HOL{} logic!for natural numbers}
\begin{alltt}
>>__ open numTheory
##thm NOT_SUC
##thm INV_SUC
##thm INDUCTION
\end{alltt}
\end{hol}

In higher order logic, Peano's axioms are sufficient for developing
number theory because addition and multiplication can be defined. In
first order logic these must be taken as primitive.  Note also that
\ml{INDUCTION} could not be stated as a single axiom in first order
logic because predicates (\eg, \holtxt{P}) cannot be quantified.

\subsubsection{The theory \theoryimp{prim\_rec}}
\label{sec:prim-rec}

\index{primitive recursion theorem!for numbers}
\index{prim_rec, the HOL theory@\ml{prim\_rec}, the \HOL{} theory|(}
In classical logic, unlike domain theory logics such as \PPL,
%
\index{PPlambda (same as PPLAMBDA), of LCF system@\ml{PP}$\lambda$ (same as \ml{PPLAMBDA}), of \ml{LCF} system}
%
arbitrary recursive definitions
%
\index{recursive definitions, in classical logics}
%
are not allowed. For example, there is no function $f$ (of type
\ml{num->num}) such that

\begin{alltt}
   !\(x\). \(f\) \(x\) = (\(f\) \(x\)) + 1
\end{alltt}
Certain restricted forms of recursive
%
\index{primitive recursive functions}
%
definition do, however, uniquely define functions. An important
example are the \emph{primitive recursive} functions.\footnote{In
  higher order logic, primitive recursion is much more powerful than
  in first order logic; for example, Ackermann's function can be
  defined by primitive recursion in higher order logic.} For any $x$
and $f$ the \emph{primitive recursion theorem} tells us that there is
a unique function \holtxt{fn} such that:

\begin{alltt}
   (fn 0 = \(x\)) /\bs (!\(n\). fn(SUC \(n\)) = f (fn \(n\)) \(n\))
\end{alltt}

The primitive recursion theorem, named \ml{num\_Axiom} in \HOL,
follows from Peano's
%
\index{Peano's axioms}
%
axioms.

\begin{hol}\index{num_Axiom@\ml{num\_Axiom}}
\index{characterizing theorem!for numbers}
\begin{alltt}
>>__ open prim_recTheory
##thm num_Axiom
\end{alltt}
\end{hol}

\noindent The theorem states the validity of primitive recursive
definitions on the natural numbers: for any \ml{x} and \ml{f} there exists a
corresponding total function \ml{fn} which satisfies
the primitive recursive definition whose form is determined by \ml{x} and
\ml{f}.

\paragraph{The less-than relation}

The less-than relation `\holtxt{<}'
\index{ less than, in HOL logic@\ml{<} (less than, in \HOL{} logic)}%
\index{less than, in HOL logic@less than, in \HOL{} logic}%
is most naturally defined by primitive recursion. However, in our
development it is needed for the proof of the
  primitive recursion theorem, so it must be defined before definition
  by primitive recursion is available. The theory \theoryimp{prim\_rec}
  therefore contains the following non-recursive definition of \ml{<}:

\begin{hol}
\begin{alltt}
##thm LESS_DEF
\end{alltt}
\end{hol}

\noindent
This definition says that {\small\verb%m < n%} if there exists a set (with
characteristic function {\small\verb%P%}) that is downward
closed\footnote{A set of numbers is \textit{downward closed} if whenever it
contains the successor of a number, it also contains the number.} and
contains {\small\verb%m%} but not {\small\verb%n%}.
\index{prim_rec, the HOL theory@\ml{prim\_rec}, the \HOL{} theory|)}


\subsubsection{Mechanizing primitive recursive definitions}
\label{num-prim-rec}

\index{recursive definitions, in HOL logic@recursive definitions, in \HOL{} logic!automated, for numbers}
\index{primitive recursion theorem!automated use of, in HOL system@automated use of, in \HOL{} system|(}
The primitive
\index{primitive recursive definitions, in HOL logic@primitive recursive definitions, in \HOL{} logic!justification of}
recursion theorem can be used to justify any definition of a function
on the natural numbers by primitive recursion.  For example, a
primitive recursive definition in higher order logic of the form

\begin{hol}
\begin{alltt}
   fun 0       x\(\sb{1}\) \m{\dots} x\(\sb{i}\) = \m{f\sb{1}[}x\(\sb{1}\)\m{,\ldots,\,} x\(\sb{i}]\)
   fun (SUC n) x\(\sb{1}\) \m{\dots} x\(\sb{i}\) = \m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\m{,} x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
\end{alltt}
\end{hol}

\noindent where all the free variables in the  terms $t_1$,
\dots, $t_i$ are contained in $\{$\ml{n}, $\ml{x}_1$, \dots, $\ml{x}_i\}$,
is logically equivalent to:

\begin{hol}
\begin{alltt}
   fun 0       = \bs{}x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
   fun (SUC n) = \bs{}x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\m{,}x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)
               = (\bs{}f n x\(\sb{1}\) \m{\dots} x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\m{,} x\(\sb{1}\)\m{,\ldots,\,}x\(\sb{i}]\)) (fun n) n
\end{alltt}
\end{hol}

The existence  of  a  recursive  function  \ml{fun} which  satisfies these two
equations follows directly from the primitive recursion theorem
\ml{num\_Axiom} shown above.   Specializing the  quantified variables \verb!x!
and \verb!f!  in  a suitably  type-instantiated version  of \ml{num\_Axiom} so
that

\begin{hol}
\begin{alltt}
   x\m{=}\bs{}x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)  {\rm and}  f\(=\)\bs{}f n x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\))
\end{alltt}
\end{hol}

\noindent yields the existence theorem shown below:

\begin{hol}
\begin{alltt}
   |- ?fn. fn 0       = \bs{}x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\) /\bs{}
           fn (SUC n) = (\bs{}f n x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}f \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)) (fn n) n
\end{alltt}
\end{hol}

\noindent This theorem allows a constant \ml{fun} to be introduced (via the
definitional mechanism of constant specifications---see Section~\ref{conspec})
to denote the recursive function that satisfies the two equations in the body
of the theorem. Introducing a constant \ml{fun} to name the function asserted
to exist by the theorem shown above, and simplifying using $\beta$-reduction,
yields the following theorem:

\begin{hol}
\begin{alltt}
   |- fun 0       = \bs{}x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\) /\bs{}
      fun (SUC n) = \bs{}x\(\sb{1}\) \(\dots\) x\(\sb{i}\).\m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
\end{alltt}
\end{hol}

\noindent It follows immediately from this theorem that the constant \ml{fun}
satisfies the primitive recursive defining equations given by the theorem shown
below:

\begin{hol}
\begin{alltt}
   |- fun 0 x\(\sb{1}\) \(\dots\) x\(\sb{i}\) = \m{f\sb{1}[}x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
      fun (SUC n) x\(\sb{1}\) \(\dots\) x\(\sb{i}\) = \m{f\sb{2}[}fun n \m{t\sb{1} \dots t\sb{i},} n\(,\) x\(\sb{1}\)\(,\ldots,\,\)x\(\sb{i}]\)
\end{alltt}
\end{hol}

To automate the use of the primitive recursion theorem in deriving
recursive definitions of this kind, the \HOL{} system provides a function
which automatically proves the existence of primitive recursive
functions and then makes a constant specification to introduce the constant
that denotes such a function:

\begin{holboxed}
\index{new_recursive_definition@\ml{new\_recursive\_definition}|pin}
\begin{verbatim}
   new_recursive_definition :
      {def : term, name : string, rec_axiom : thm} -> thm
\end{verbatim}
\end{holboxed}

\noindent In fact, \ml{new\_recursive\_definition} handles
primitive recursive definitions over a range of types, not just the
natural numbers. For details, see the \REFERENCE\ documentation.

More conveniently still, the \ml{Define} function (see
Section~\ref{sec:high-level-proof-steps}) supports primitive
recursion, along with other styles of recursion, and does not require
the user to quote the primitive recursion axiom. It may, however,
require termination proofs to be performed; fortunately, these need
not be done for primitive recursions.

\subsubsection{Dependent choice and wellfoundedness}
\label{prim-rec-conseq}

The primitive recursion theorem is useful beyond its main purpose of
justifying recursive definitions. For example, the theory
\theoryimp{prim\_rec} proves the Axiom of Dependent Choice ({\small\verb+DC+}).

\begin{hol}
\index{axiom of dependent choice (DC)@axiom of dependent choice (\ml{DC})}
\index{axioms!of choice}
\begin{alltt}
##thm DC
\end{alltt}
\end{hol}
\index{wellfounded relations!absence of infinite descending chains}
The proof uses {\small\verb+SELECT_AX+}. The theorem {\small\verb+DC+}
is useful when one wishes to build a function having a certain
property from a relation. For example, one way to define the
wellfoundedness of a relation $R$ is to say that it has no infinite
decreasing $R$ chains.
%
\begin{hol}
\begin{alltt}
##thm wellfounded_def
##thm WF_IFF_WELLFOUNDED
\end{alltt}
\end{hol}
By use of {\small\verb+DC+}, this statement can be proved
to be equal to the notion of wellfoundedness {\small\verb+WF+}
(namely, that every set has an $R$-minimal element) defined in the theory
\theoryimp{relation}.

Theorems asserting the wellfoundedness of the predecessor relation and
the less-than relation, as well as the wellfoundedness of measure
functions are also proved in \theoryimp{prim\_rec}.

\begin{hol}
\index{measure, the HOL constant@\holtxt{measure}, the \HOL{} constant}
\begin{alltt}
##thm WF_PRED
##thm WF_LESS

##thm measure_def
##thm measure_thm
##thm WF_measure
\end{alltt}
\end{hol}


\subsection{Arithmetic}
\index{arithmetic, the HOL theory of@arithmetic, the \HOL{} theory of}

The \HOL{} theory \theoryimp{arithmetic} contains primitive recursive
definitions of the following standard arithmetic operators.

\begin{hol}
\index{EXP, the HOL constant@\holtxt{EXP}, the \HOL{} constant}
\index{ addition, in HOL logic@\holtxt{+} (addition, in \HOL{} logic)}
\index{ subtraction, in HOL logic@\holtxt{-} (subtraction, in \HOL{} logic)}
\index{ multiplication, in HOL logic@\holtxt{*} (multiplication, in \HOL{} logic)!on natural numbers}
\index{ exponentiation, in HOL logic@\holtxt{**} (exponentiation, in \HOL{} logic)}
\index{addition, in HOL logic@addition, in \HOL{} logic}
\index{subtraction, in HOL logic@subtraction, in \HOL{} logic}
\index{multiplication, in HOL logic@multiplication, in \HOL{} logic!on natural numbers}
\index{exponentiation, in HOL logic@exponentiation, in \HOL{} logic!on natural numbers}
\begin{alltt}
>>__ open arithmeticTheory
##thm ADD

##thm SUB

##thm MULT

##thm EXP
\end{alltt}
\end{hol}
%
Note that \holtxt{EXP} is an infix.
The infix notation \holtxt{**} may be used in place of \holtxt{EXP}.
Thus (\holtxt{x EXP y}) means $x^y$, and so does (\holtxt{x ** y}).
In addition, the parser special-cases superscript 2 and 3 notations, so that \holtxt{x$^2$} is actually the same term as \holtxt{x EXP 2}, and \holtxt{x$^3$} is the same term as \holtxt{x EXP 3}.


\paragraph{Comparison operators}

A full set of comparison operators is defined in terms of \verb+<+.

\begin{hol}
\index{ greater than, in HOL logic@\ml{>} (greater than, in \HOL{} logic)}
\index{ less or equal, in HOL logic@\ml{<=} (less or equal, in \HOL{} logic)}
\index{ greater or equal, in HOL logic@\ml{>=} (greater or equal, in \HOL{} logic)}
\begin{alltt}
##thm GREATER_DEF
##thm LESS_OR_EQ
##thm GREATER_OR_EQ
\end{alltt}
\end{hol}

Note that in all of \HOL{}'s standard numeric theories, it is usual practice to avoid uses of the ``greater-than'' constants and to express everything with either \holtxt{$<$} or \holtxt{$\le$}.

\paragraph{Division and modulus}

A constant specification is used to introduce division ({\small\verb+DIV+}, infix) and
modulus ({\small\verb+MOD+}, infix) operators, together with their
characterizing property.
\begin{hol}
\index{MOD, the HOL constant@\ml{MOD}, the \HOL{} constant}
\index{DIV, the HOL constant@\ml{DIV}, the \HOL{} constant}
\begin{alltt}
##thm DIVISION
\end{alltt}
\end{hol}

\paragraph{Even and odd}

The properties of a number being even or odd are defined recursively.
%
\begin{hol}
\index{EVEN, the HOL constant@\ml{EVEN}, the \HOL{} constant}
\index{ODD, the HOL constant@\ml{ODD}, the \HOL{} constant}
\begin{alltt}
##thm EVEN

##thm ODD
\end{alltt}
\end{hol}

\paragraph{Maximum and minimum}

The minimum and maximum of two numbers are defined in the usual way.
%
\begin{hol}
\index{MIN, the HOL constant@\ml{MIN}, the \HOL{} constant}
\index{MAX, the HOL constant@\ml{MAX}, the \HOL{} constant}
\begin{alltt}
##thm MAX_DEF
##thm MIN_DEF
\end{alltt}
\end{hol}

\paragraph{Factorial}
\index{FACT, the HOL constant@\ml{FACT}, the \HOL{} constant}

The factorial of a number is a primitive recursive definition.
%
\begin{hol}
\begin{alltt}
##thm FACT
\end{alltt}
\end{hol}

\paragraph{Function iteration}
\index{FUNPOW, the HOL constant@\ml{FUNPOW}, the \HOL{} constant}

The iterated application $f^n(x)$ of a function $f : \alpha \to
\alpha$ is defined by primitive recursion. The definition
(\ml{FUNPOW}) is tail-recursive, which can be awkward to reason
about. An alternative characterization (\ml{FUNPOW\_SUC}) may be easier
to apply when doing proofs.
%
\begin{hol}
\begin{alltt}
##thm FUNPOW
##thm FUNPOW_SUC
\end{alltt}
\end{hol}

\medskip

On this basis, an \adhoc\ but useful collection of over two hundred
and fifty elementary theorems of arithmetic are proved when \HOL{} is
built and stored in the theory \theoryimp{arithmetic}.  For a complete
list of the available theorems, see \REFERENCE.  See also
Section~\ref{sec:while-loops} for discussion of the \holtxt{LEAST}
operator, which returns the least number satisfying a predicate.

\subsubsection{Grammar information}

The following table gives the parsing status of the arithmetic
constants.

\begin{center}
{\small
\begin{tabular}{@{}ccc}
Operator & Strength & Associativity \\ \hline
\holtxt{>=} & 450 & non \\
\holtxt{<=} & 450 & non \\
\holtxt{>} & 450 & non \\
\holtxt{<} & 450 & non \\
\holtxt{+} & 500 & left \\
\holtxt{-} & 500 & left \\
\holtxt{*} & 600& left \\
\holtxt{DIV} & 600 & left \\
\holtxt{MOD} & 650 & left \\
\holtxt{EXP} & 700 & right \\
\end{tabular}}
\end{center}

\subsection{Numerals}\label{sec:numerals}

The type \ml{num}
\index{num, the type in \HOL{} logic@\ml{num}, the type in \HOL{} logic}
\index{numerals, in HOL logic@numerals, in \HOL{} logic}
is usually thought of as being supplied with an infinite collection of
numerals: \ml{1}, \ml{2}, \ml{3}, etc. However, the \HOL{} logic has
no way to define such infinite families of constants; instead, all
numerals other than $0$ are actually built up from the constants
introduced by the following definitions:
\begin{alltt}
>>__ val np = valOf (temp_remove_user_printer "num.numeral_computations")
##thm NUMERAL_DEF

##thm BIT1
##thm BIT2

##thm ALT_ZERO
\end{alltt}

\noindent For example, the numeral $5$ is represented by the term
\[
   \ml{NUMERAL}(\ml{BIT1}(\ml{BIT2}\;\ml{ZERO}))
\]
and the \HOL{} parser and pretty-printer make such terms appear as
numerals. This binary representation for numerals allows for
asymptotically efficient calculation. Theorems supporting arithmetic
calculations on numerals can be found in the \theoryimp{numeral}
theory; these are mechanized by the \verb+reduce+ library. Thus,
arithmetic calculations are performed by deductive steps in \HOL.  For
example the following calculation of $2 ^{(1023 + 14)/9}$ takes
approximately 4,200 primitive inference steps and returns quickly:
%
\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>> Count.apply reduceLib.REDUCE_CONV ``2 EXP ((1023 + 14) DIV 9)``;
\end{alltt}
\end{session}

\paragraph {Construction of numerals}
\index{numerals, in HOL logic@numerals, in \HOL{} logic!construction of}

Numerals may of course be built using \ml{mk\_comb}, and taken apart with
\ml{dest\_comb}; however, a more convenient interface to this
functionality is provided by the functions \ml{mk\_numeral},
\ml{dest\_numeral}, and \ml{is\_numeral} (found in the structure
\ml{numSyntax}). These entry-points make use of an \ML{} structure
\ml{Arbnum} which implements arbitrary precision numbers {\verb+num+}. The
following session shows how \HOL{} numerals are constructed from elements of
type \verb+num+ and how numerals are destructed. The structure
{\small\verb+Arbnum+} provides a full collection of arithmetic
operations, using the usual names for the operations, \eg, \verb|+|,
\verb|*|, \verb|-|, \etc

\begin{session}
\begin{alltt}
>> numSyntax.mk_numeral
     (Arbnum.fromString "3432432423423423234");

>> numSyntax.dest_numeral it;

>> Arbnum.+(it,it);
\end{alltt}
\end{session}

\paragraph{Numerals and the parser}
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of numerals}
\index{tokens!parsing numerals}
\index{numerals, in HOL logic@numerals, in \HOL{} logic!parsing}
%
Simple digit sequences are parsed as decimal numbers, but the parser
also supports the input of numbers in binary, octal and hexadecimal
notation.  Numbers may be written in binary and hexadecimal form by
prefixing them with the strings \holtxt{0b} and \holtxt{0x} respectively.
The `digits' \texttt{A}--\texttt{F} in hexadecimal numbers may be written in upper or lower case.
Binary numbers have their most significant digits left-most.
In the interests of backwards compatibility, octal numbers are not enabled by default, but if the reference \ml{base\_tokens.allow\_octal\_input} is set to \ml{true}, then octal numbers are those that appear with leading zeroes.

Finally, all numbers may be padded with underscore characters
(\ml{\_}).  These can be used to groups digits for added legibility
and have no semantic effect.

Thus
\begin{session}
\begin{alltt}
>> ``0xAA``;

>> ``0b1010_1011``;

>> base_tokens.allow_octal_input := true;

>> ``067``;
\end{alltt}
\end{session}

\paragraph{Numerals and Peano numbers}

Numerals are related to numbers built from \holtxt{0} and \holtxt{SUC}
via the derived inference rule \ml{num\_CONV}, found in the
\ml{numLib} library.

\begin{holboxed}
\index{num_CONV@\ml{num\_CONV}|pin}
\begin{verbatim}
   num_CONV : term -> thm
\end{verbatim}
\end{holboxed}

\noindent \ml{num\_CONV} can be used to generate the `\ml{SUC}'
equation for any non-zero numeral.  For example:

\begin{session}
\begin{alltt}
>>_ open numLib;
>> num_CONV ``2``;

>> num_CONV ``3141592653``;
\end{alltt}
\end{session}

\noindent The \ml{num\_CONV} function works purely by inference.

\subsubsection{Overloading of arithmetic operators}
\label{arith-overloading}

When other numeric theories are loaded (such as those for the reals or
integers), numerals are overloaded so that the numeral {\small\verb+1+} can
actually stand for a natural number, an integer or a real value. The
parser has a pass of overloading resolution in which it attempts to
determine the actual type to give to a numeral. For example, in the
following session, the theory of integers is loaded, whereupon the
numeral \verb+2+ is taken to be an integer.
%
\begin{session}
\begin{alltt}
>> load "integerTheory";

>> ``2``;

>> type_of it;
\end{alltt}
\end{session}

 In order to precisely specify the desired type, the user can use single
character suffixes (`\ml{n}' for the natural numbers, and `\ml{i}' for
the integers):
\begin{session}
\begin{alltt}
>> type_of ``2n``;

>> type_of ``42i``;
\end{alltt}
\end{session}

A numeric literal for a \HOL{} type other than \verb+num+, such as
\verb+42i+,  is represented by the application of an
\emph{injection} function of type {\small\verb+num -> ty+} to a
numeral. The injection function is different for each type
{\small\verb+ty+}. See Section \ref{integers} for further discussion.

The functions {\verb+mk_numeral+}, {\verb+dest_numeral+}, and
{\verb+is_numeral+} only work for numerals, and not for numeric
literals with character suffixes other than {\small\verb+n+}. For
information on how to install new character suffixes, consult the
\ml{add\_numeral\_form} entry in \REFERENCE.

\subsection{Integers}
\label{integers}
\index{integers, the HOL theory of@integers, the \HOL{} theory of}

There is an extensive theory of integers in \HOL. The type of integers
is constructed as a quotient on pairs of natural numbers. A standard
collection of operators are defined. These are overloaded with
similar operations on the natural numbers, and on the real numbers.
The constants defined in the integer theory include those found in the
following table.

\index{multiplication, in HOL logic@multiplication, in \HOL{} logic!on integers}
\index{ multiplication, in HOL logic@\holtxt{*} (multiplication, in \HOL{} logic)!on integers}
\begin{center}
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+int_ge+} &{\small\verb+>=+} & 450 & non \\
{\small\verb+int_le+} &{\small\verb+<=+} & 450 & non \\
{\small\verb+int_gt+} &{\small\verb+>+}  & 450 & non \\
{\small\verb+int_lt+} &{\small\verb+<+}  & 450 & non \\
{\small\verb+int_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+int_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+int_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb%/%} & & 600 & left \\
{\small\verb+%+} & & 650 & left \\
{\small\verb+int_exp+} &{\small\verb%**%} & 700 & right \\
{\small\verb+int_of_num+} &{\small\verb%&%} & 900 & prefix \\
{\small\verb+int_neg+} &{\small\verb%~%} & 900 & prefix \\
\end{tabular}}
\end{center}

The overloaded symbol \holtxt{\& : num~$\rightarrow$~int} denotes the
injection function from natural numbers to integers. The following
session illustrates how overloading and integers literals are treated.

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>> “1i = &(1n + 0n)”;

>> show_numeral_types := true;

>> “&1 = &(1n + 0n)”;
>>_ show_numeral_types := false;
\end{alltt}
\end{session}

In addition, there is an absolute value function \holtxt{ABS}:
\begin{alltt}
##thm integerTheory.INT_ABS
\end{alltt}
with the obvious definition.

This then characterises the \holtxt{Num} function which maps from integers back into natural numbers (of type \holtxt{:int~$\rightarrow$~num} therefore):
\begin{alltt}
##thm integerTheory.Num_EQ_ABS
\end{alltt}

\subsection{Rational numbers}\label{rationals}
\index{rational numbers, the HOL theory of@rationals, the \HOL{} theory of|(}

The type of rationals is constructed as a quotient on ordered pairs of
integers (the numerator and the denominator of a fraction) whose second
component must not be zero. To make things easier in the \HOL\ theory,
the sign of a rational number is always moved to the numerator.
So, the denominator is always positive.

A standard collection of operators, which are overloaded with similar
operations on the integers, are defined. These include those found in
the following table. Injection from natural numbers is supported
by the overloaded symbol {\small\verb+& : num -> rat+} and the
suffix {\small\verb+q+}.


\begin{center}
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+rat_geq+} &{\small\verb+>=+} & 450 & non \\
{\small\verb+rat_leq+} &{\small\verb+<=+} & 450 & non \\
{\small\verb+rat_gre+} &{\small\verb+>+}  & 450 & non \\
{\small\verb+rat_les+} &{\small\verb+<+}  & 450 & non \\
{\small\verb+rat_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+rat_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+rat_minv+} & & & \\
{\small\verb+rat_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb+rat_div+} &{\small\verb%/%} & 600 & left \\
{\small\verb+rat_ainv+} &{\small\verb%~%} & 900 & prefix \\
{\small\verb+rat_of_num+} &{\small\verb%&%} & 900 & prefix \\
\end{tabular}}
\end{center}

The theorems in the theory of rational numbers include field properties,
arithmetic rules, manipulation of (in)equations and their reduction to
(in)equations between integers, properties of less-than relations and the
density of rational numbers. For details, consult \REFERENCE\ and the
source files.

\index{rational numbers, the HOL theory of@rationals, the \HOL{} theory of|)}

\subsection{Real numbers}\label{reals}
\index{real numbers, the HOL theory of@real numbers, the \HOL{} theory of|(}

>>__ load "realTheory"; open realTheory
>>__ load "real_sigmaTheory"; open real_sigmaTheory  

There is an extensive collection of theories that make up the
development of real numbers and analysis in HOL, due to John Harrison
\cite{jrh:thesis}. We will only give a sketchy overview of the
development; the interested reader should consult \REFERENCE\ and
Harrison's thesis.

The axioms for the real numbers are derived from the `half reals' which
are constructed from the `half rationals'. This part of the development
is recorded in {\small\verb+hratTheory+} and
{\small\verb+hrealTheory+}, but is not used once the reals have been
constructed. The real axioms are derived in the theory
{\small\verb+realaxTheory+}. A standard collection of operators on the
reals, and theorems about them, is found in {\small\verb+realaxTheory+}
and {\small\verb+realTheory+}. The operators and their parse status are
listed in the following table.

\begin{center}
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+real_ge+} &{\small\verb+>=+} & 450 & non \\
{\small\verb+real_lte+} &{\small\verb+<=+} & 450 & non \\
{\small\verb+real_gt+} &{\small\verb+>+}  & 450 & non \\
{\small\verb+real_lt+} &{\small\verb+<+}  & 450 & non \\
{\small\verb+real_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+real_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+real_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb+real_div+} & {\small\verb%/%} & 600 & left \\
{\small\verb+pow+} & &700 & right \\
{\small\verb+rpow+} & &700 & right \\
{\small\verb+real_of_num+} &{\small\verb%&%} & 900 & prefix \\
{\small\verb+real_neg+} &{\small\verb%~%} & 900 & prefix \\
\end{tabular}}
\end{center}

On the basis of {\small\verb+realTheory+}, the following sequence of
theories is constructed:

\begin{description}
\item [real_sigma] Summation of real numbers (the $\Sigma$ operator, etc.)
\item [topology] General topology.
\item [metric] Metric spaces, including metric on the real line.
\item [nets] Moore-Smith convergence nets, and special cases like sequences.
\item [real_topology] Topology of one-dimensional Euclidean space (Section~\ref{sec:topology}).
\item [seq] Sequences and series of real numbers.
\item [derivative] The \emph{new} univariate differential calculus (Section~\ref{sec:calculus}).
\item [lim] Limits, continuity and the \emph{old} differentiation.
\item [powser] Power series.
\item [transc] Transcendental functions, \eg, exp, sin,
  cos, ln, root, sqrt, pi, tan, asn, acs, atn.
\item [integration] The \emph{new} univariate integral calculus (Section~\ref{sec:calculus}).
\item [integral] The \emph{old} univariate integral calculus.
\end{description}
\index{real numbers, the HOL theory of@real numbers, the \HOL{} theory of|)}

\index{complex numbers, the HOL theory of@complex numbers, the \HOL{} theory of}
\noindent
\HOL{} also includes a basic theory of the complex numbers (\ml{complexTheory}), where the type \holtxt{complex} is a type abbreviation for a pair of real numbers.
The $\sqrt{-1}$ value is the \HOL{} constant \holtxt{i}.
Numerals are supported (with the suffix \holtxt{c} available to force numerals to be parsed as complex numbers).
The standard arithmetic operations are defined, with the appropriate theorems proved about them.

\subsection{Extended real numbers}
\label{sec:extreal}
\index{extended real numbers, the HOL theory of@extreal numbers, the \HOL{} theory of|(}

The \HOL{} provides an extensive theory of extended real numbers
(\theoryimp{extreal}), originally developed by T. Mhamdi, O. Hasan, and S. Tahar~\cite{Mhamdi:2011dd}.
With extended reals, the limit of a
monotonic sequence is always defined, infinite when the sequence is divergent,
but still defined and properties can be proven on it.

It is often helpful to use the values $+\infty$ and $-\infty$ in
calculations. To do this properly, we have to consider the
\emph{extended real line} $\overline{\mathbb{R}} := [-\infty,
+\infty]$. If we agree that $-\infty < x$ and $y < +\infty$ for all
$x,y\in\mathbb{R}$, then $\overline{\mathbb{R}}$ inherits the ordering
from $\mathbb{R}$ as well as the usual rules of addition, subtraction,
multiplication and division of elements from $\mathbb{R}$. The latter needs to be
augmented as shown in Table~\ref{tab:extrealAdd}~\cite[p.~61]{Schilling:2017}:

\begin{table}[ht]
\begin{center}
{\small
\begin{tabular}{@{}c|cccc}
$+$ & 0 & $y$ & $+\infty$ & $-\infty$ \\ \hline
  0 & 0 & $y$ & $+\infty$ & $-\infty$ \\
  $x$ & $x$ & $x + y$ & $+\infty$ & $-\infty$ \\
  $+\infty$ & $+\infty$ & $+\infty$ & $+\infty$ & $\nexists$ \\
  $-\infty$ & $-\infty$ & $-\infty$ & $\nexists$ & $-\infty$ \\
\end{tabular}
\qquad
\begin{tabular}{@{}c|cccc}
$-$ & 0 & $y$ & $+\infty$ & $-\infty$ \\ \hline
  0 & 0 & $-y$ & $-\infty$ & $+\infty$ \\
  $x$ & $x$ & $x - y$ & $-\infty$ & $+\infty$ \\
  $+\infty$ & $+\infty$ & $+\infty$ & $\nexists$ & $+\infty$ \\
  $-\infty$ & $-\infty$ & $-\infty$ & $-\infty$ & $\nexists$ \\
\end{tabular}

\vspace{1em}

\begin{tabular}{@{}c|cccc}
$\cdot$ & 0 & $\pm b$ & $+\infty$ & $-\infty$ \\ \hline
  0 & 0 & 0 & 0 & 0 \\
  $\pm a$ & 0 & $a\cdot b$ & $\pm\infty$ & $\mp\infty$ \\
  $+\infty$ & 0 & $\pm\infty$ & $+\infty$ & $-\infty$ \\
  $-\infty$ & 0 & $\mp\infty$ & $-\infty$ & $+\infty$ \\
\end{tabular}
\qquad
\begin{tabular}{@{}c|cccc}
$/$ & 0 & $\pm b$ & $+\infty$ & $-\infty$ \\ \hline
  0 & $\nexists$ & 0 & 0 & 0 \\
  $\pm a$ & $\nexists$ & $a / b$ & 0 & 0 \\
  $+\infty$ & $\nexists$ & $\pm\infty$ & $\nexists$ & $\nexists$ \\
  $-\infty$ & $\nexists$ & $\mp\infty$ & $\nexists$ & $\nexists$ \\
\end{tabular}}
\end{center}
\caption{$+$, $-$, $\cdot$ and $/$ in $\overline{\mathbb{R}}$, where
  $x, y\in\mathbb{R}$ and $a,b\in(0, \infty)$}
\label{tab:extrealAdd}
\end{table}

In \HOL{}, the type of extended real numbers (\emph{extreals} hereafter)
is constructed by an algebraic datatype \ty{extreal} (see Section~\ref{sec:datatype}):
\begin{hol}
\begin{verbatim}
  Datatype `extreal = NegInf | PosInf | Normal real`
\end{verbatim}
\end{hol}
Thus \holtxt{Normal r} denotes the extreal corresponding
to the real number \holtxt{r}, while \holtxt{PosInf} and
\holtxt{NegInf} denote $+\infty$ and $-\infty$, respectively.
 In order to precisely specify extreals corresponding to natural
 numbers, the user can use the single character suffix `\ml{x}':
\begin{session}
\begin{alltt}
>>__ load "extrealTheory";
>>__ open extrealTheory;
>> type_of ``0x``;
\end{alltt}
\end{session}
The function \holtxt{real} can be used to convert extreals back to the
corresponding reals ($+\infty$ and $-\infty$ are mapped to \holtxt{0x}).
%
A standard collection of arithmetic operators%
\footnote{Note that, unlike the case of real numbers in \HOL{}, $0 / 0
  = 0$ (or ``division by zero'' in general) does not hold on
  extreals. This particular design choice sometimes makes proofs of
  extreal-related theorems a bit harder (but more aligned with their
  textbook proofs), as whenever terms like
  \holtxt{inv x} or \holtxt{1 / x} are involved, \holtxt{x <> 0} must
  be proved to proceed.}
and elementary functions
on the extreals are defined and overloaded on the
corresponding operators of real numbers, show in Table~\ref{tab:extrealOp}.

\begin{table}[ht]
\centering
{\small
\begin{tabular}{@{}cccc}
Constant & Overloaded symbol & Strength & Associativity \\ \hline
{\small\verb+extreal_le+} &{\small\verb+<=+} & 450 & non \\
{\small\verb+extreal_lt+} &{\small\verb+<+}  & 450 & non \\
{\small\verb+extreal_add+} &{\small\verb%+%} & 500 & left \\
{\small\verb+extreal_sub+} &{\small\verb%-%} & 500 & left \\
{\small\verb+extreal_mul+} &{\small\verb%*%} & 600 & left \\
{\small\verb+extreal_div+} & {\small\verb%/%} & 600 & left \\
{\small\verb+extreal_of_num+} &{\small\verb%&%} & 900 & prefix \\
{\small\verb+extreal_ainv+} &{\small\verb%~%} and {\small\verb%-%} & 900 & prefix \\
{\small\verb+extreal_inv+} &{\small\verb+inv+} & & prefix \\
{\small\verb+extreal_abs+} &{\small\verb+abs+} & & prefix \\
{\small\verb+extreal_pow+} & {\small\verb+pow+} & 700 & right \\
{\small\verb+extreal_powr+} & {\small\verb+powr+} & 700 & right \\
{\small\verb+extreal_exp+} &{\small\verb+exp+} & & prefix \\
{\small\verb+extreal_sqrt+} &{\small\verb%sqrt%} & & prefix \\
{\small\verb+extreal_logr+} &{\small\verb+logr+} & & prefix \\
{\small\verb+extreal_lg+} &{\small\verb+lg+} & & prefix \\
{\small\verb+extreal_ln+} &{\small\verb+ln+} & & prefix \\
\end{tabular}}
\caption{Arithmetic operators and transcendental functions for extreals}
\label{tab:extrealOp}
\end{table}

The addition of extreals is not associative and commutative in general, because
\holtxt{PosInf + NegInf} and \holtxt{NegInf + PosInf} are not defined (see
Table~\ref{tab:extrealAdd}). To swap the elements of additions, the
user must avoid mixing of PosInf and NegInf in
the involved elements (\eg, by letting one of them be normal):
\begin{hol}
\begin{alltt}
##thm add_comm
##thm add_comm_normal
##thm add_assoc
\end{alltt}
\end{hol}
On the other hand, the set of extreals is a totally ordered set such that for all
$a \in \overline{\mathbb{R}}$, $-\infty \leq a \leq +\infty$.
With this order, $\overline{\mathbb{R}}$ is a complete lattice where every
subset has a supremum (\holtxt{extreal_sup} or \holtxt{sup}) and an
infimum (\holtxt{extreal_inf} or \holtxt{inf}). In particular, for
empty sets (of extreals) we have:
\begin{hol}
\begin{alltt}
##thm sup_empty
##thm inf_empty
\end{alltt}
\end{hol}

\paragraph{Finite and infinite sum of extreals}

The sum of extreals over a finite set
(\holtxt{EXTREAL_SUM_IMAGE}, overloaded on \holtxt{SIGMA}), $\sum_{i\in s} f(i)$, is defined
by \holtxt{pred_set.ITSET} (see Section~\ref{sec:theory-of-sets}):
\begin{hol}
\begin{alltt}
##thm EXTREAL_SUM_IMAGE_DEF
\end{alltt}
\end{hol}
To actually work with \holtxt{EXTREAL_SUM_IMAGE},
beside that $s$ must be a
finite set, there must be no mixing of
\holtxt{PosInf} and \holtxt{NegInf} in the values of \holtxt{f},
\ie,~either all $f(i)$ are not $+\infty$ or they are not $-\infty$ ($i \in s$).
The following theorem fully captures the properties of
\holtxt{EXTREAL_SUM_IMAGE}:
\begin{hol}
\begin{alltt}
>>__ val oldwidth = !Globals.linewidth;
     val _ = Globals.linewidth := oldwidth - 10;
##thm EXTREAL_SUM_IMAGE_THM
>>__ val _ = Globals.linewidth := oldwidth;
\end{alltt}
\end{hol}

The (countably) infinite sum of extreals (\holtxt{ext_suminf},
overloaded on \holtxt{suminf}), $\sum_{i\in \mathbb{N}}
f(i)$, is only defined on non-negative function $f$ as the supremum
of the $n$th partial sum:
\begin{hol}
\begin{alltt}
##thm ext_suminf_def
\end{alltt}
\end{hol}
Thus mathematically \holtxt{ext_suminf} represents \emph{positive
  series}, which always has a unique nonnegative value: \holtxt{PosInf} if the
positive series is \emph{divergent}, other normal extreals (\ie,~\holtxt{< PosInf}) if the
positive series is \emph{convergent} (on that normal extreal). A
fundamental result for positive series says that it converges if and
only if its $n$th partial sums are bounded:
\begin{hol}
\begin{alltt}
##thm pos_summable
\end{alltt}
\end{hol}
Finally, 2-dimensional (positive) infinite sums
$\sum_{i,j\in\mathbb{N}} f(i,j)$ can be reduced to iterated sums
$\sum_{i\in\mathbb{N}} \sum_{j\in\mathbb{N}} f(i,j)$ given an arbitrary bijection between
$\mathbb{N}$ and $\mathbb{N}\times\mathbb{N}$:
\begin{hol}
\begin{alltt}
##thm ext_suminf_2d_full
\end{alltt}
\end{hol}

\paragraph{Upper and lower limits of extreal sequences}

For a sequence of extreal numbers, the \emph{limes inferior} or \emph{lower limit} is
defined as (see, \eg, Appendix A of \cite{Schilling:2017} for more details.)
\begin{hol}
\begin{alltt}
##thm ext_liminf_def
\end{alltt}
\end{hol}

and the \emph{limes superior} or \emph{upper limit} is defined as
\begin{hol}
\begin{alltt}
##thm ext_limsup_def
\end{alltt}
\end{hol}

Some basic properties of \holtxt{ext_limsup} and \holtxt{ext_liminf} are provided in
\theoryimp{extreal} theory:
\begin{hol}
\begin{alltt}
##thm ext_liminf_alt_limsup
##thm ext_liminf_pos
##thm ext_liminf_le_limsup
##thm ext_limsup_alt_liminf
##thm ext_limsup_pos
\end{alltt}
\end{hol}

The most important property, however, that the normal limit of a sequence of extreal numbers
(when forcely converted to real numbers) coincides with its upper and lower limits
(in this case they are also the same), together with useful lemmas, are provided
in \theoryimp{martingale} theory:
\begin{hol}
\begin{alltt}
>>__ load "martingaleTheory";
>>__ open martingaleTheory;
##thm ext_limsup_thm

##thm ext_limsup_le_subseq
##thm ext_liminf_le_subseq
##thm ext_limsup_imp_subseq
##thm ext_liminf_imp_subseq
\end{alltt}
\end{hol}

\subsection{Bit vectors}
\label{sec:bit-vectors}
\index{bit vectors, the HOL theory of@bit vectors, the \HOL{} theory of|(}

{
\newcommand{\fcp}[2]{\ty{#1}[\ty{#2}]}
\newcommand{\worda}{\fcp{\bool}{\ensuremath\alpha}}
\newcommand{\wordb}{\fcp{\bool}{\ensuremath\beta}}
\newcommand{\wordc}{\fcp{\bool}{\ensuremath\gamma}}
\newcommand{\rarr}{\ensuremath\rightarrow}
\newcommand{\hash}{\,\holtxt{\#}\,}
\newcommand{\oo}[2]{\mbox{\holtxt{#1\,'\,#2}}}

\HOL{} provides a theory of bit vectors, or $n$-bit words.  For example, in computer architectures one finds:
bytes/octets ($n = 8$), half-words ($n = 16$), words ($n = 32$) and long-words
($n = 64$).  In the theory \theoryimp{words}, bit vectors are represented as
\emph{finite Cartesian products}: an $n$-bit word is given type $\worda$
where the \emph{size} of the type $\alpha$ determines the word length $n$.    This
approach comes from an idea of John Harrison, which was presented at TPHOLs
2005.\footnote{The current theory subsumes previous word theories -- it evolved from a development based on an equivalence class construction.  Wai Wong's word theory, which was based on Paul Curzon's \ml{rich\_list} theory, is no longer distributed with HOL.  The principle advantages of the current theory are that there is just one theory for all word sizes and that word length side conditions are not required.}

\subsubsection{Finite Cartesian products}
\label{ss:fcpTheory}

The \HOL{} theory \theoryimp{fcp} introduces an infix type operator
\holtxt{**}, which is used to represent finite Cartesian products.\footnote{The theory of
finite Cartesian products was ported from HOL Light.}  The type \holtxt{'a ** 'b}, or equivalently \fcp{'a}{'b}, is conceptually equivalent to:
\begin{hol}
$\underbrace{\ty{'a}\;\hash\;\ty{'a}\;\hash\;\cdots\;\hash\;\ty{'a}}_{\holtxt{dimindex('b)}}$
\end{hol}
where \holtxt{dimindex('b)} is the cardinality of \holtxt{univ(:'b)} when \ty{'b} is finite and is one when it is infinite.
Thus, \fcp{'a}{\num} is similar to \ty{'a}, and \fcp{'a}{\bool} is similar to \ty{'a}\hash\ty{'a}.
Numeral type names are supported, so one can freely work with indexing sets of any size, \eg, the type \ty{32} has thirty-two elements and \fcp{\bool}{32} represents 32-bit words.

The \emph{components} of a finite Cartesian product are accessed with an
indexing function
\begin{hol}
\begin{alltt}
   fcp_index : \fcp{'a}{'b}\rarr\num\rarr\ty{'a}
\end{alltt}
\end{hol}
which is typically written with an infixed apostrophe: \oo{x}{i}
denotes the value of vector \holtxt{x} at position \holtxt{i}.
Typically, indices are constrained to be less than the size of
\ty{'b}.\footnote{Note that FCP indices in HOL Light are ranged from 1
  to \holtxt{dimindex('b)}, while in HOL4 they are ranged from 0 to
  \holtxt{dimindex('b) - 1}, thus is \emph{less} than the size of
  \ty{'b}. Also note that the function
  \holtxt{fcp_index} in HOL Light is specified for index values:
  \texttt{f ' i = 0} when \holtxt{i = 0} or \holtxt{i > dimindex('b)}. In HOL4, however,
  \texttt{f ' i} is unspecified when \holtxt{i >= dimindex('b)}.}

The following theorem shows that two Cartesian products \holtxt{x} and
\holtxt{y} are equal if, and only if, all of their components \oo{x}{i} and
\oo{y}{i} are equal:
\begin{hol}
\begin{alltt}
>>__ load "fcpTheory"; open fcpTheory;
##thm CART_EQ
\end{alltt}
\end{hol}

In order to construct Cartesian products, the theory \theoryimp{fcp} introduces a
binder \holtxt{FCP}, which is characterised by the following theorems:
\begin{hol}
\begin{alltt}
##thm FCP_BETA
##thm FCP_ETA
\end{alltt}
\end{hol}
The theorem \ml{FCP\_BETA} shows that the components of \holtxt{\$FCP g} are
determined by the function \holtxt{g:\num\rarr\ty{'a}}.  The theorem
\ml{FCP\_ETA} shows that a binding can be eliminated when all of the components
are identical to that of \holtxt{x}.
These two theorems, together with \ml{CART\_EQ}, can be found in the
\emph{simpset} fragment \ml{fcpLib.FCP\_ss}.

Finite Cartesian products provide a good means to model $n$-bit words.  That is
to say, the type \fcp{bool}{'a} can represent a binary word whose length $n$
corresponds with the size of the type \ty{'a}.  The binder \holtxt{FCP}
provides a flexible means for defining words -- one can supply a function
\holtxt{f:\num\rarr\bool} that gives the word's bit values, each of which can be accessed using the indexing map \holtxt{fcp\_index}.

\subsubsection{Bit theory}
\label{ss:bitTheory}

The theory \theoryimp{bit} defines some bit operations over the natural numbers,
\eg, \holtxt{BITS}, \holtxt{SLICE}, \holtxt{BIT}, \holtxt{BITWISE} and
\holtxt{BIT\_MODIFY}. In this context, natural numbers are treated as binary words of
unbounded length.  The operations in \theoryimp{bit} are primarily defined using \holtxt{DIV}, \holtxt{MOD} and \holtxt{EXP}.  For example, from the definition of \holtxt{BIT}, the following theorem holds:
\begin{hol}
\begin{alltt}
>>__ load "bitTheory"; open bitTheory;
##thm BIT_DEF
\end{alltt}
\end{hol}
Here \holtxt{BIT b n} states that the $b$-th bit (counted from the least significant bit, starting by 0) of $n$ is 1.
(In other words, \holtxt{BIT b n} maps the $b$-th bit of $n$ from 0 to \holtxt{false} and 1 to \holtxt{true}.)

On the other hand, \holtxt{SBIT} can be used to construct a number by summing up
values corresponding to each bits.
\holtxt{SBIT b n} represents the \emph{single} $n$-th bit value indicated by the Boolean value $b$,
to be accumulated for constructing the destination number:
\begin{hol}
\begin{alltt}
##thm SBIT_def
\end{alltt}
\end{hol}

This theory is used in the development of the word theory and it also provides
a mechanism for the efficient evaluation of some word operations via the theory
\theoryimp{numeral\_bit}.

\subsubsection{Words theory}

The theory \theoryimp{words} introduces a selection of polymorphic constants and operations, which can be type instantiated to any word size.  For example, word addition
has type:
\begin{hol}
+:\worda\rarr\worda\rarr\worda
\end{hol}
If \ty{'a} is instantiated to \ty{32} then this operation corresponds with 32-bit addition.
All theorems about word operations apply for any word length.\footnote{Note
that it is impossible to introduce words of length zero because all types
must be inhabited, and hence their size will always be greater than or equal to
one.}

\paragraph{Some basic operations}

The function \holtxt{w2n:\worda\rarr\num} gives the natural number value of a
word.  If $x\in\bools^{\{0, 1, \ldots, n - 1\}}$ is a finite Cartesian product
representing an $n$-bit word then its natural number value is:
\[ \mathrm{w2n}(x) = \sum_{i = 0}^{n - 1} \textbf{if } x_i \textbf{ then } 2^i
\textbf{ else } 0\ .\]
The length of a word (the number $n$) is given by the function
\holtxt{word\_len:\worda\rarr\num}.
The function \holtxt{n2w:\num\rarr\worda} maps from a number to a word,
and the function \holtxt{w2n:\worda\rarr\num} maps from a word to a number. They are
defined in \HOL{} by:
\begin{hol}
\begin{alltt}
>>__ load "wordsTheory"; open wordsTheory;
##thm n2w_def
##thm w2n_def
\end{alltt}
\end{hol}
The suffix \holtxt{w} is used to denote word literals, \eg,
\holtxt{255w} is the same as \holtxt{n2w 255}.

The function \holtxt{w2w:\worda\rarr\wordb} provides word-to-word conversion (casting):
\begin{hol}
\begin{alltt}
##thm w2w_def
\end{alltt}
\end{hol}
If $\beta$ is smaller than $\alpha$ then the higher bits of \holtxt{w} will be
lost (it performs bit extraction), otherwise the longer word will have the same value as the original (in effect providing zero padding).
However, if one were treating \holtxt{w} as a two's complement number then the
word needs to be sign extended, \ie,
\begin{eqnarray*}
\mbox{\small ($-$ve)}\quad 1b_{n-2} \cdots b_0\ \mapsto \ 1 \cdots 1 1 b_{n-2}
\cdots b_0 \\
\mbox{\small ($+$ve)}\quad 0b_{n-2} \cdots b_0\ \mapsto \ 0 \cdots 0 0 b_{n-2}
\cdots b_0
\end{eqnarray*}
The function \holtxt{sw2sw:\worda\rarr\wordb} provides this sign extending version of
\holtxt{w2w}.

A collection of operations are provided for mapping to and from strings and number (digit) lists, \eg,
\begin{hol}
\begin{verbatim}
|- word_to_dec_string 876w = "876"
\end{verbatim}
\end{hol}
and
\begin{hol}
\begin{verbatim}
|- word_to_hex_list 876w = [12; 6; 3]
\end{verbatim}
\end{hol}
These function are specialised versions of \holtxt{w2s} and \holtxt{w2l} respectively.

\paragraph{Concatenation}

The operation \holtxt{word\_concat:\worda\rarr\wordb\rarr\wordc} concatenates words.
Note that the return type is not constrained.
This means that two sixteen bit words can be concatenated to give a word of any length -- which may be smaller or larger than the expected value of 32.
The related function \holtxt{word\_join} does return a word of the expected length, \ie, of type \fcp{\bool}{$\alpha+\beta$};  however, the concatenation operation is more useful because we often want \fcp{\bool}{\ty{32}} and not the logically distinct \fcp{\bool}{\ty{16}+\ty{16}}.

\paragraph{Signed and unsigned words}

Words can be \emph{viewed} as being either signed (using the two's
complement representation) or as being unsigned.  However, this is not
made explicit within the theory\footnote{Words are not tagged as being
  signed/unsigned.  Mappings to/from the integers (\holtxt{w2i} and
  \holtxt{i2w}) are provided in the theory \theoryimp{integer\_word}.}
and all of the arithmetic operations are defined using the natural
numbers, \ie, via \holtxt{w2n} and \holtxt{n2w}.  In particular,
addition and multiplication work naturally (have the same definition)
under the two's complement representation.  This is not the case
however with word-to-word conversion, orderings, division and right
shifting, where signed and unsigned variants are needed.  When
operating over the natural numbers, some of the two's complement
versions have slightly unnatural looking presentations.  For example,
with the signed (two's complement) version of ``less than'' we have
\holtxt{255w < (0w:word8)} because the word \holtxt{255w} is actually
taken to be representing the integer $-1$, whereas the unsigned
version is more natural: \holtxt{0w <+ (255w:word8)}.

\paragraph{Bit field operations}

The standard Boolean bit field operations are provided, \ie, bitwise negation
(one's complement), conjunction, disjunction and exclusive-or.  These functions
are defined quite naturally using the Cartesian product binder; for example,
bitwise conjunction is defined by:
\begin{hol}
\begin{verbatim}
|- !v w. v && w = FCP i. v ' i /\ w ' i .
\end{verbatim}
\end{hol}
There is also a collection of word \emph{reduction} operations, which reduce bit vectors to 1-bit words, \eg,
\[ \mathrm{reduce\_and}(x)\;'\; 0= \bigwedge_{i = 0}^{n - 1} x_i\ .\]

The functions \holtxt{word\_lsb}, \holtxt{word\_msb} and \holtxt{word\_bit(i)}
give the bit value of a word at positions $0$, $n - 1$ and $i$
respectively.  Four operations are provided for selecting bit
fields, or sub-words: \holtxt{word\_bits} (\holtxt{--}),  \holtxt{word\_signed\_bits} (\holtxt{---}), \holtxt{word\_slice} (\holtxt{''}) and
\holtxt{word\_extract} (\holtxt{><}).  For example, \holtxt{word\_bits 4 1} will select four bits starting from bit position 1.  The slice function is an in-place variant (it zeroes bits outside of the bit range) and the extract function combines \holtxt{word\_bits} with a word cast (\holtxt{w2w}).  The operation \holtxt{word\_signed\_bits} is similar to \holtxt{word\_bits}, except that it sign-extends the bit field.

The \holtxt{bit\_field\_insert} operation inserts a bit field.  For example,
\begin{hol}
\begin{verbatim}
bit_field_insert 5 2 a b
\end{verbatim}
\end{hol}
is word \holtxt{b} with bits 5--2 replaced by bits 3--0 of \holtxt{a}.

A word's bit ordering can be flipped over with \holtxt{word\_reverse}, \ie, bit zero is swapped with bit $n - 1$ and so forth.

The function
\holtxt{word\_modify:(\num\,\rarr\,\bool\,\rarr\,\bool)\,\rarr\,\worda\,\rarr\,\worda} changes
a word by applying a map at each bit position.
This operation provides a very flexible and convenient mechanism for
manipulating words, \eg,
\begin{hol}
\holtxt{word\_modify ($\lambda$i b.\,if EVEN i then $\sim$b else b) w}
\end{hol}
negates the bits of \holtxt{w} that are in even positions.  Of course, the
binder \holtxt{FCP} also provides a very general means to represent words using
a predicate; \eg, \holtxt{\$FCP ODD} represents a word where all the odd bits
are set.

\paragraph{Shifts}

Six types of shifts are provided: logical shift left/right (\holtxt{<<} and
\holtxt{>>>}), arithmetic shift right (\holtxt{>>}), rotate left/right
(\holtxt{\#<<} and \holtxt{\#>>}) and rotate right extended by 1 place
(\holtxt{word\_rrx}).  These shifts are illustrated in Figure~\ref{fig:shifts} and are defined in a similar manner to the other bit field operations.  For
example, rotating right is defined by:
\begin{hol}
\begin{verbatim}
|- !w n. w #>> x = FCP i. w ' (i + x) MOD dimindex (:'a) .
\end{verbatim}
\end{hol}
Rotating left by $x$ places is defined as rotating right by $n - x \bmod n$
places.

\begin{figure}
\begin{center}
\small
\begin{tabular}{ll}
\scalebox{.8}{\includegraphics{figs/lsl}} &
\scalebox{.8}{\includegraphics{figs/lsr}} \\
(a) Logical shift left: \holtxt{w = v << x}. & (b) Logical shift right:
\holtxt{w = v >>> x}. \\[12pt]
\scalebox{.8}{\includegraphics{figs/asr}} &
\hspace{-5mm}\scalebox{.8}{\includegraphics{figs/ror}} \\
(c) Arithmetic shift right: \holtxt{w = v >> x}. & (d) Rotate right: \holtxt{w
= v \#>> x}. \\[12pt]
\multicolumn{2}{c}{\scalebox{.8}{\includegraphics{figs/rrx}}} \\
\multicolumn{2}{c}{(e) Rotate right extended by 1 place: \holtxt{(d,w) =
word\_rrx (c,v)}.}
\end{tabular}
\caption{Shift operations.}
\label{fig:shifts}
\end{center}
\end{figure}

\paragraph{Arithmetic and orderings}

The arithmetic operations are: addition, subtraction, unary minus (two's
complement), logarithm (base-2), multiplication, modulus and division (signed and
unsigned).
These operations are defined with respect to the natural numbers.  For example,
word addition is defined by:
\begin{hol}
\begin{verbatim}
|- !v w. v + w = n2w (w2n v + w2n w)
\end{verbatim}
\end{hol}
The \holtxt{+} on the left-hand side is word addition and on the right it is
natural number addition.

All of the standard word orderings are provided, with signed and unsigned
versions of $<$, $\leq$, $>$ and $\geq$.  The unsigned versions are suffixed
with a plus; for example, \holtxt{<+} is unsigned ``less than''.

\paragraph{Constants}

The word theory also defines a few word constants:
\begin{center}\small
\begin{tabular}{lll}
\multicolumn{1}{l}{Constant} & \multicolumn{1}{l}{Value}  &
\multicolumn{1}{l}{Binary} \\
\noalign{\smallskip}
\hline
\noalign{\smallskip}
\holtxt{word\_T} or \holtxt{UINT\_MAXw} & $2^l - 1$ & $11\cdots 11$ \\
\holtxt{word\_L} or \holtxt{INT\_MINw} & $2^{l - 1}$ & $10\cdots 00$ \\
\holtxt{word\_H} or \holtxt{INT\_MAXw} & $2^{l - 1} - 1$ & $01\cdots 11$
\end{tabular}
\end{center}

\paragraph{List of bit vector operations}

A list of operations is provided in the table below.
{
\setlength{\tabcolsep}{4pt}
\begin{center}
\tablefirsthead{%
\hline
\multicolumn{1}{|c}{Operation\rule{0pt}{14pt}} &
\multicolumn{1}{c}{Symbol} &
Type &
\multicolumn{1}{c|}{Description} \\[4pt]
\hline}
\tablehead{%
\hline
\multicolumn{4}{|l|}{\small\sl continued from previous page}\\
\hline
\multicolumn{1}{|c}{Operation\rule{0pt}{14pt}} &
\multicolumn{1}{c}{Symbol} &
Type &
\multicolumn{1}{c|}{Description} \\[4pt]
\hline}
\tabletail{%
\hline
\multicolumn{4}{|r|}{\small\sl continued on next page}\\
\hline}
\tablelasttail{\hline}
\small
\begin{supertabular}{|l|c|l|l|}
\holtxt{n2w} & & \num\rarr\worda & Map from a natural number \\
\holtxt{w2n} & & \worda\rarr\num & Map to a natural number \\
\holtxt{w2w} & & \worda\rarr\wordb & Map word-to-word (unsigned) \\
\holtxt{sw2sw} & & \worda\rarr\wordb & Map word-to-word (signed) \\
\holtxt{w2l} & & \num\rarr\worda\rarr\num~\ty{list} & Map word to digit list \\
\holtxt{l2w} & & \num\rarr\num~\ty{list}\rarr\worda & Map digit list to word \\
\holtxt{w2s} & & \num\rarr(\num\rarr\ty{char})\rarr\worda\rarr\ty{string} & Map word to string \\
\holtxt{s2w} & & \num\rarr(\ty{char}\rarr\num)\rarr\ty{string}\rarr\worda & Map string to word \\
\holtxt{word\_len} & & \worda\rarr\num & The word length \\
\holtxt{word\_lsb} & & \worda\rarr\bool & The least significant bit \\
\holtxt{word\_msb} & & \worda\rarr\bool & The most significant bit \\
\holtxt{word\_bit} & & \num\rarr\worda\rarr\bool & Test bit position \\
\holtxt{word\_bits} & \holtxt{--} & \num\rarr\num\rarr\worda\rarr\worda & Select a bit field \\
\holtxt{word\_signed\_bits} & \holtxt{---} & \num\rarr\num\rarr\worda\rarr\worda & Sign-extend selected bit field \\
\holtxt{word\_slice} & \holtxt{''} & \num\rarr\num\rarr\worda\rarr\worda &  Set bits outside field to zero \\
\holtxt{word\_extract} & \holtxt{><} & \num\rarr\num\rarr\worda\rarr\wordb & Extract (cast) a bit field \\
\holtxt{word\_reverse} & & \worda\rarr\worda & Reverse the bit order \\
\holtxt{bit\_field\_insert} & & {\setlength{\tabcolsep}{0pt}\begin{tabular}[t]{ll}\num\rarr\num\rarr\worda\rarr\\\wordb\rarr\wordb\end{tabular}} & Insert a bit field \\
\holtxt{word\_modify} & & {\setlength{\tabcolsep}{0pt}\begin{tabular}[t]{ll}(\num\rarr\bool\rarr\bool)\rarr\\\worda\rarr\worda\end{tabular}} & Apply a function to each bit \\
\holtxt{word\_join} & & \worda\rarr\wordb\rarr\fcp{\bool}{$\alpha+\beta$} & Join words \\
\holtxt{word\_concat} & \holtxt{@@} & \worda\rarr\wordb\rarr\wordc & Concatenate words \\
\holtxt{concat\_word\_list} & & \worda~\ty{list}\rarr\wordb & Concatenate list of words \\
\holtxt{word\_replicate} & & \num\rarr\worda\rarr\wordb & Replicate word \\
\holtxt{word\_or} & \holtxt{||} & \worda\rarr\worda\rarr\worda & Bitwise disjunction \\
\holtxt{word\_xor} & \holtxt{??} & \worda\rarr\worda\rarr\worda & Bitwise exclusive-or \\
\holtxt{word\_and} & \holtxt{\&\&} & \worda\rarr\worda\rarr\worda & Bitwise conjunction \\
\holtxt{word\_nor} & \holtxt{\~{}||} & \worda\rarr\worda\rarr\worda & Bitwise NOR \\
\holtxt{word\_xnor} & \holtxt{\~{}??} & \worda\rarr\worda\rarr\worda & Bitwise XNOR \\
\holtxt{word\_nand} & \holtxt{\~{}\&\&} & \worda\rarr\worda\rarr\worda & Bitwise NAND \\
\holtxt{word\_reduce} & & {\setlength{\tabcolsep}{0pt}\begin{tabular}[t]{ll}(\bool\rarr\bool\rarr\bool)\rarr\\\worda\rarr\fcp{\bool}{1}\end{tabular}} & Word reduction \\
\holtxt{reduce\_or} & & \worda\rarr\fcp{\bool}{1} & Disjunction reduction \\
\holtxt{reduce\_xor} & & \worda\rarr\fcp{\bool}{1} & Exclusive-or reduction \\
\holtxt{reduce\_and} & & \worda\rarr\fcp{\bool}{1} & Conjunction reduction \\
\holtxt{reduce\_nor} & & \worda\rarr\fcp{\bool}{1} & NOR reduction \\
\holtxt{reduce\_xnor} & & \worda\rarr\fcp{\bool}{1} & XNOR reduction \\
\holtxt{reduce\_nand} & & \worda\rarr\fcp{\bool}{1} & NAND reduction \\
\holtxt{word\_{}1comp} & \holtxt{\~} & \worda\rarr\worda & One's complement \\
\holtxt{word\_{}2comp} & \holtxt{-} & \worda\rarr\worda & Two's complement \\
\holtxt{word\_add} & \holtxt{+} & \worda\rarr\worda\rarr\worda & Addition \\
\holtxt{word\_sub} & \holtxt{-} & \worda\rarr\worda\rarr\worda & Subtraction \\
\holtxt{word\_mul} & \holtxt{*} & \worda\rarr\worda\rarr\worda & Multiplication \\
\holtxt{word\_div} & \holtxt{//} & \worda\rarr\worda\rarr\worda & Division (unsigned) \\
\holtxt{word\_sdiv} & \holtxt{/} & \worda\rarr\worda\rarr\worda & Division (signed) \\
\holtxt{word\_mod} & & \worda\rarr\worda\rarr\worda & Modulus \\
\holtxt{word\_log2} & & \worda\rarr\worda & Logarithm base-2 \\
\holtxt{word\_lsl} & \holtxt{<<} & \worda\rarr\num\rarr\worda & Logical shift left \\
\holtxt{word\_lsr} & \holtxt{>>>} & \worda\rarr\num\rarr\worda & Logical shift right \\
\holtxt{word\_asr} & \holtxt{>>} & \worda\rarr\num\rarr\worda & Arithmetic shift right \\
\holtxt{word\_ror} & \holtxt{\#>>} & \worda\rarr\num\rarr\worda & Rotate right \\
\holtxt{word\_rol} & \holtxt{\#<<} & \worda\rarr\num\rarr\worda & Rotate left \\
\holtxt{word\_rrx} & & \bool\#\worda\rarr\bool\#\worda & Rotate right extended by 1 place \\
\holtxt{word\_lt} & \holtxt{<} & \worda\rarr\worda\rarr\bool & Signed ``less than'' \\
\holtxt{word\_le} & \holtxt{<=} & \worda\rarr\worda\rarr\bool & Signed ``less than or equal'' \\
\holtxt{word\_gt} & \holtxt{>} & \worda\rarr\worda\rarr\bool & Signed ``greater than'' \\
\holtxt{word\_ge} & \holtxt{>=} & \worda\rarr\worda\rarr\bool & Signed ``greater than or equal'' \\
\holtxt{word\_lo} & \holtxt{<+} & \worda\rarr\worda\rarr\bool & Unsigned ``less than''  \\
\holtxt{word\_ls} & \holtxt{<=+} & \worda\rarr\worda\rarr\bool & Unsigned ``less than or equal'' \\
\holtxt{word\_hi} & \holtxt{>+} & \worda\rarr\worda\rarr\bool & Unsigned ``greater than'' \\
\holtxt{word\_hs} & \holtxt{>=+} & \worda\rarr\worda\rarr\bool & Unsigned ``greater than or equal'' \\
\end{supertabular}
\end{center}}

\index{bit vectors, the HOL theory of@bit vectors, the \HOL{} theory of|)}
} % matches bracket at beginning of n-bit section, where some n-bit
  % specific macros are defined

\section{Sequences}

\HOL{} provides theories for various kinds of sequences: finite lists, lazy lists,
paths, and finite strings.

\subsection{Lists}\label{sec:list}
\index{list, the type operator in HOL logic@\ml{list}, the type operator in \HOL{} logic}
\index{types, in HOL logic@types, in \HOL{} logic!tools for construction of}
\index{lists, the HOL theory of@lists, the \HOL{} theory of|(}
\index{ lists, the HOL theory of@\ml{[} $\cdots$ \ml{;} $\cdots$ \ml{]} (lists, the \HOL{} theory of)|(}
>>__ open listTheory
>>__ show_numeral_types := false

\index{lists, the HOL theory of@lists, the \HOL{} theory of!constructors}
\HOL{} lists are inductively defined finite sequences where each
element in a list has the same type. The theory \ml{list} introduces
the unary type operator $\alpha \; \konst{list}$ by a type definition
and a standard collection of list processing functions are
defined. The primitive constructors {\small\verb+NIL+} and {\small\verb+CONS+}
%
\begin{hol}
\index{NIL, the HOL constant@\holtxt{NIL}, the \HOL{} constant}
\index{CONS, the HOL constant@\holtxt{CONS}, the \HOL{} constant}
\begin{verbatim}
   NIL  : 'a list
   CONS : 'a -> 'a list -> 'a list
\end{verbatim}
\end{hol}
%
are used to build lists and have been defined from the representing type for
lists. The \HOL{} parser
%
\index{parsing, of HOL logic@parsing, of \HOL{} logic!of list expressions}
%
has been specially modified to parse the expression \holtxt{[]} into
\holtxt{NIL}, to parse the expression \holtxt{h::t} into \holtxt{CONS
  h t}, and to parse the expression \holtxt{[$t_1$;$t_2$;\dots;$t_n$]}
into \holtxt{CONS $t_1$ (CONS $t_2$ $\cdots$ (CONS $t_n$ NIL)
  $\cdots$)}.  The \HOL{} printer
%
\index{printing, in HOL logic@printing, in \HOL{} logic!of list expressions}
%
reverses these transformations.

\index{list theorems, in HOL logic@list theorems, in \HOL{} logic}
Based on the inductive characterization of the type, the following
fundamental theorems about lists are proved and stored in the theory
\ml{list}.

\begin{hol}
\index{list_Axiom@\ml{list\_Axiom}}
\index{axioms!non-primitive, of HOL logic@non-primitive, of \HOL{} logic!for lists}
\index{induction theorems, in HOL logic@induction theorems, in \HOL{} logic!for lists}
\index{characterizing theorem!for lists}
\index{lists, the HOL theory of@lists the \HOL{} theory of!initiality theorem}
\index{lists, the HOL theory of@lists the \HOL{} theory of!induction theorem}
\begin{alltt}
##thm list_Axiom
##thm list_INDUCT
##thm list_CASES
##thm CONS_11
##thm NOT_NIL_CONS
##thm NOT_CONS_NIL
\end{alltt}
\end{hol}

The theorem \ml{list\_Axiom} shown above is analogous to the primitive
recursion theorem
%
\index{primitive recursion theorem!for lists}
%
on the natural numbers discussed above in Section~\ref{num-prim-rec}.
It states the validity of primitive recursive definitions on lists,
and can be used to justify any such definition.  The \ML{} function
\ml{new\_recursive\_definition} uses this theorem to do
automatic
%
\index{primitive recursion theorem!automated use of, in HOL system@automated use of, in \HOL{} system|)}
%
proofs of the existence of primitive recursive functions on lists and
then make constant specifications to introduce constants that denote
such functions.

The induction theorem for lists, \ml{list\_INDUCT}, provides the main
proof tool used to reason about operations that manipulate lists. The
theorem \ml{list\_CASES} is used to perform case analysis on whether a
list is empty or not.

The theorem {\small\verb+CONS_11+} shows that {\small\verb+CONS+} is injective;
the theorems {\small\verb+NOT_NIL_CONS+} and {\small\verb+NOT_CONS_NIL+} show that
{\small\verb+NIL+} and {\small\verb+CONS+} are distinct, \ie,
cannot give rise to the same structure. Together, these three theorems
are used for equational reasoning about lists.

The predicate \ml{NULL} and the selectors
%
\index{selectors, in HOL logic@selectors, in \HOL{} logic!for lists}
%
\ml{HD} and \ml{TL} are defined in the theory \theoryimp{list} by
%
\begin{hol}
\index{NULL, the HOL constant@\ml{NULL}, the \HOL{} constant}
\index{HD, the HOL constant@\ml{HD}, the \HOL{} constant}
\index{TL, the HOL constant@\ml{TL}, the \HOL{} constant}
\begin{alltt}
##thm NULL
##thm HD
##thm TL_DEF
\end{alltt}
\end{hol}
The nil-clause for the \holtxt{TL} constant is included to make the function total, but does represent a case that often needs to be excluded.
For example:
\begin{hol}
\begin{alltt}
##thm LIST_NOT_NIL
\end{alltt}
\end{hol}

\noindent The following functions on lists are also defined in the theory \ml{list}.
%
%
\paragraph{Case expressions}
\index{case expressions!over lists}

Compound \HOL{} expressions that branch based on whether a term is an
empty or non-empty list have the surface syntax (roughly borrowed from
ML)
\begin{hol}
\begin{verbatim}
   case e1
    of [] => e2
     | (h::t) => e3
\end{verbatim}
\end{hol}
%
Such an expression is translated to
$\holtxt{list\_CASE}\ e_1\ e_2\ (\lambda h\; t.\ e_3)$ where the constant
\holtxt{list\_CASE} is defined as follows:
\begin{hol}
\begin{alltt}
##thm list_case_def
\end{alltt}
\end{hol}

\paragraph{List membership}
\index{MEM, the HOL notion of list membership@\holtxt{MEM}, the \HOL{} notion of list membership}

Membership in a list, written using the \holtxt{MEM} syntax, is characterised as follows:
%
\begin{hol}
\begin{alltt}
##thm MEM
\end{alltt}
\end{hol}

\paragraph {Concatenation of lists}
\index{APPEND, the HOL constant@\ml{APPEND}, the \HOL{} constant}
\index{concatenation, of lists!in HOL logic@in \HOL{} logic}
\index{FLAT, the HOL constant@\ml{FLAT}, the \HOL{} constant}
\index{SNOC, the HOL constant@\ml{SNOC}, the \HOL{} constant}

Binary list concatenation ({\small\verb+APPEND+}) may also be denoted by
the infix operator {\small\verb|++|}; thus the expression
{\small\verb|L1 ++ L2|} is translated into {\small\verb+APPEND L1 L2+}.
The concatenation of a list of lists into a list is achieved by
{\small\verb+FLAT+}.
The special case where a single element is appended to the end of a list (the ``opposite'' of \holtxt{CONS}, which adds elements to the front of a list), is implemented by \holtxt{SNOC}.
%
\begin{hol}
\begin{alltt}
##thm APPEND
##thm FLAT
##thm SNOC
\end{alltt}
\end{hol}

\paragraph {Numbers and lists}
\index{LENGTH, the HOL constant@\ml{LENGTH}, the \HOL{} constant}
\index{list_size, the HOL constant@\ml{list\_size}, the \HOL{} constant}

The length (\holtxt{LENGTH}) and size (\holtxt{list\_size}) of a list
are related notions. The size of a list takes account of the size of
each element of the list (given by parameter
$f:\alpha\to\konst{num}$), while the length of the list ignores the
size of each list element. The alternate length definition
(\holtxt{LEN}) is tail-recursive.
Numbers can also be used to index into lists, extracting the element at the specified position. %
\index{EL, the HOL constant@\holtxt{EL}, the \HOL{} constant}%
\begin{hol}
\begin{alltt}
##thm LENGTH
##thm LEN_DEF
##thm list_size_def
##thm EL
\end{alltt}
\end{hol}

\noindent
Note that the extraction of the $n$th element (\holtxt{EL}) of a list starts its indexing from 0.
If the length of the list $\ell$ is less than or equal to $n$, the result of \holtxt{EL~$n$~$\ell$~} is unspecified.

\index{GENLIST, the HOL constant@\ml{GENLIST}, the \HOL{} constant}
The \holtxt{GENLIST} constant can be used to generate a list of a particular size, where the value of each element is independently determined by reference to a function that takes natural numbers (the set $\{0\dots n-1\}$) to element values:
\begin{hol}
\begin{alltt}
##thm GENLIST
##thm EL_GENLIST
\end{alltt}
\end{hol}
\index{SNOC, the HOL constant@\ml{SNOC}, the \HOL{} constant}
Working with \holtxt{SNOC}, and thus the definition above, can occasionally be awkward, so a characterisation of \holtxt{GENLIST}'s \holtxt{SUC} clause in terms of \holtxt{CONS} can also be useful:
\begin{hol}
\begin{alltt}
##thm GENLIST_CONS
\end{alltt}
\end{hol}
For more on the ``indexed'' treatment of lists, see
Section~\ref{sec:indexed-lists} below.

\paragraph {Mapping functions over lists}
\index{MAP, the HOL constant@\ml{MAP}, the \HOL{} constant}
\index{MAP2, the HOL constant@\ml{MAP2}, the \HOL{} constant}
\index{mapPartial, the HOL constant@\ml{mapPartial}, the \HOL{} constant}
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for lists}

There are functions for mapping a function $f : \alpha \to \beta$ over
a single list (\holtxt{MAP}), a ``partial'' function $f : \alpha \to \beta\,\mathsf{option}$ over a list (\holtxt{mapPartial}), or a function $f : \alpha \to \beta \to \gamma$ over two lists (\holtxt{MAP2}):
\begin{hol}
\begin{alltt}
##thm MAP
##thm mapPartial_def
##thm MAP2_DEF
\end{alltt}
\end{hol}
If passed lists of unequal length, \holtxt{MAP2} returns a list of length equal to that of the shorter list.

\paragraph {Predicates over lists}
\index{FILTER, the HOL constant@\ml{FILTER}, the \HOL{} constant}
\index{EVERY, the HOL constant@\ml{EVERY}, the \HOL{} constant}
\index{nub, the HOL constant@\ml{nub}, the \HOL{} constant}
\index{ALL_DISTINCT, the HOL constant@\ml{ALL\_DISTINCT}, the \HOL{} constant}
\index{EXISTS, the HOL constant (over lists)@\ml{EXISTS}, the \HOL{}
  constant (over lists)}

Predicates can be applied to lists in a universal sense (the predicate
must hold of every element in the list) or an existential sense (the
predicate must hold of some element in the list). This functionality
is supported by \holtxt{EVERY} and \holtxt{EXISTS}, respectively. The
elimination of all elements in list not satisfying a given predicate
is performed by \holtxt{FILTER}.
\begin{hol}
\begin{alltt}
##thm EVERY_DEF
##thm EXISTS_DEF
##thm FILTER
##thm ALL_DISTINCT
\end{alltt}
\end{hol}
The predicate \holtxt{ALL\_DISTINCT} holds on a list just in case no
element in the list is equal to any other.
A list can have its duplicates removed through the use of the \holtxt{nub} constant:
\begin{hol}
\begin{alltt}
##thm nub_def
\end{alltt}
\end{hol}

\index{EVERY2@\ml{EVERY2}|see{\ml{LIST\_REL}}}
\index{LIST_REL, the HOL constant@\ml{LIST\_REL}, the \HOL{} constant}
\paragraph{Relations over lists}
A binary relation on elements can be ``lifted'' to a relation on lists of such elements with the \holtxt{LIST\_REL} constant:
\begin{hol}
\begin{alltt}
##thm LIST_REL_def
\end{alltt}
\end{hol}
This can be viewed as an application of \holtxt{EVERY}:
\begin{hol}
\begin{alltt}
##thm LIST_REL_EVERY_ZIP
\end{alltt}
\end{hol}
Acknowledging this view, the system overloads the name \holtxt{EVERY2} to map to the same constant.
\begin{hol}
\begin{alltt}
>> “EVERY2 (λm n. EVEN (m + n)) [1;2;3] [3;4;5]”;
\end{alltt}
\end{hol}
Some theorems in \ml{listTheory} have names that reflect this.

Equally, \holtxt{LIST\_REL} can be seen as a test that checks the relation at all relevant indices:
\begin{hol}
\begin{alltt}
##thm LIST_REL_EL_EQN
\end{alltt}
\end{hol}
Finally, there is a natural induction principle for this constant (as \emph{per} Section~\ref{sec:proofs-with-inductive-relations}, the tactic \ml{Induct_on~\bq{}LIST_REL'} applies it):
\begin{hol}
\begin{alltt}
##thm LIST_REL_strongind
\end{alltt}
\end{hol}



\paragraph {Folding}
\index{FOLDL, the HOL constant@\ml{FOLDL}, the \HOL{} constant}
\index{FOLDR, the HOL constant@\ml{FOLDR}, the \HOL{} constant}

Applying a binary function $f : \alpha\to\beta\to\beta$ pairwise
through a list and accumulating the result is known as
\emph{folding}. At times, it is necessary to do this operation
from left-to-right (\holtxt{FOLDL}), and at others the
right-to-left direction (\holtxt{FOLDR}) is required.
\begin{hol}
\begin{alltt}
##thm FOLDL
##thm FOLDR
\end{alltt}
\end{hol}

\paragraph {List reversal}

The reversal of a list (\holtxt{REVERSE}) and its tail recursive
counterpart \holtxt{REV} are defined in \theoryimp{list}.
\begin{hol}
\begin{verbatim}
   REVERSE_DEF
     |- (REVERSE [] = []) /\
        (!h t. REVERSE (h::t) = REVERSE t ++ [h])
   REV_DEF
     |- (!acc. REV [] acc = acc) /\
        (!h t acc. REV (h::t) acc = REV t (h::acc))
\end{verbatim}
\end{hol}

\paragraph {Conversion to sets}

Lists can be converted to sets with the \holtxt{LIST\_TO\_SET} constant, which is overloaded to the prettier name \holtxt{set}.
The definition is made by primitive recursion in \holtxt{listTheory}:
%
\begin{hol}
\begin{alltt}
>> listTheory.LIST_TO_SET;
\end{alltt}
\end{hol}
%
\index{MEM, the HOL notion of list membership@\holtxt{MEM}, the \HOL{} notion of list membership}
Note that \holtxt{MEM} is an overloaded form of syntax such that \holtxt{MEM~x~l} is actually a pretty-printing of the underlying term \holtxt{x~$\in$~set~l}.

Further support for translating between different kinds of
collections may be found in the \theoryimp{container} theory.

\paragraph {Pairs and lists}

Two lists of equal length may be component-wise paired by the {\small\verb+ZIP+} operation.
As with \holtxt{MAP2}, the result of zipping lists of unequal lengths is a list whose length is that of the shorter argument.
The inverse operation, {\small\verb+UNZIP+}, translates a list of pairs into a pair of lists.
\begin{hol}
\begin{alltt}
##thm ZIP_def
##thm UNZIP_THM
\end{alltt}
\end{hol}

\paragraph {Alternate access}
\index{LAST, the HOL constant@\ml{LAST}, the \HOL{} constant}
\index{FRONT, the HOL constant@\ml{FRONT}, the \HOL{} constant}
%
Lists are essentially treated in a stack-like manner. However, at
times it is convenient to access the last element
(\holtxt{LAST}) of a non-empty list directly. The last element
of a non-empty list is dropped by \holtxt{FRONT}.
\begin{hol}
\begin{alltt}
##thm LAST_DEF
##thm FRONT_DEF
##thm APPEND_FRONT_LAST
\end{alltt}
\end{hol}
%
Joining the front part and the last element of a non-empty list yields
the original list.  Both \holtxt{LAST} and \holtxt{FRONT}
are unspecified on empty lists.


\paragraph {Prefix checking}

\index{isPREFIX, the HOL constant@\ml{isPREFIX}, the \HOL{} constant}
The relation capturing whether a list $\ell_1$ is a prefix of $\ell_2$
({\holtxt{isPREFIX}) can be defined by recursion.
The infix symbols \holtxt{<{}<=} (ASCII) and \holtxt{$\preccurlyeq$} (U+227C) can also be used as notation for this partial order.
% use of {} above is just a trick to stop Emacs font-lock colouring
% this file disgustingly
%
\begin{hol}
\begin{alltt}
##thm68 isPREFIX_THM
\end{alltt}
\end{hol}
The above theorem states that: the empty list is a prefix of any other
list (clause 1); that no non-empty list is a prefix of the empty list
(clause 2); and that a non-empty list is a prefix of another non-empty
list if the first elements of the lists are the same, and if the tail
of the first is a prefix of the tail of the second.

\vspace{1ex}
\noindent For a complete list of available theorems in
\theoryimp{list}, see \REFERENCE.  Further development of list
theory can be found in \theoryimp{rich\_list}.


\subsubsection{List permutations and sorting}
\index{permutations (of lists), the HOL theory of@permutations (of lists), the \HOL{} theory of}
\index{sorting, the HOL theory of@sorting, the \HOL{} theory of}

The \theoryimp{sorting} theory defines a notion of two lists being
permutations of each other, then defines a general notion of sorting,
then shows that Quicksort is a sorting function. The
\theoryimp{mergesort} theory defines Merge sort and shows that it is a stable
sorting function.

\paragraph{List permutation}

Two lists are in permutation if they have exactly the same members,
and each member has the same number of occurrences in both lists. One
definition (\holtxt{PERM}) that captures this relationship is the
following:
%
\begin{hol}
\begin{alltt}
>>__ load "sortingTheory"; open sortingTheory
##thm PERM_DEF
##thm PERM_IND
\end{alltt}
\end{hol}
%
A derived induction theorem (\holtxt{PERM\_IND}) is very
useful in proofs about permutations.

\paragraph{Sorting}

A list is $R$-sorted if $R$ holds pairwise through the list. This
notion (\holtxt{SORTED}) is captured by a recursive definition. Then
a function of type
%
\begin{hol}
\begin{verbatim}
   ('a -> 'a -> bool) -> 'a list -> 'a list
\end{verbatim}
\end{hol}
%
is a sorting function (\holtxt{SORTS}) with respect to $R$ if
it delivers a permutation of its input, and the result is $R$-sorted.
%
\begin{hol}
\begin{alltt}
##thm SORTED_DEF
##thm SORTS_DEF
\end{alltt}
\end{hol}
%
Quicksort is defined in the usual functional programming style, and
it is indeed a sorting function, provided $R$ is a transitive and
total relation.
%
\begin{hol}
\begin{alltt}
##thm QSORT_DEF
##thm QSORT_SORTS
\end{alltt}
\end{hol}

\index{lists, the HOL theory of@lists, the \HOL{} theory of!element adjacency}
The notion of $R$ holding pairwise through a list can be expressed using the predicate \holtxt{adjacent}, where $\holtxt{adjacent}\;\ell\;a\;b$ holds if values $a$ and $b$ appear together (in that order) in list $\ell$.
Then, we have
\begin{hol}
\begin{alltt}
##thm SORTED_adjacent
\end{alltt}
\end{hol}
where the $\subseteq\subr$ relation is the notion of relation-subset (see below on page~\pageref{def:rsubset}).
There are a number of other theorems in \ml{listTheory} about adjacency, including for example:
\begin{hol}
\begin{alltt}
##thm adjacent_REVERSE
##thm adjacent_MAP
\end{alltt}
\end{hol}


\subsubsection{Indexed lists}
\label{sec:indexed-lists}

\index{EL, the HOL constant@\holtxt{EL}, the \HOL{} constant|pin}
\index{lists, the HOL theory of@lists, the \HOL{} theory of!retrieving elements by index}
As mentioned earlier, lists can be indexed with the constant \holtxt{EL}, viewing lists as partial functions from natural numbers (starting at 0!) into the element type.
The definition is given by primitive recursion over the index argument, in theorem \ml{EL}:
\begin{hol}
\begin{alltt}
   ##thm EL
\end{alltt}
\end{hol}
Because of the use of \holtxt{HD} and \holtxt{TL}, the value of $\holtxt{EL}\;n\;\ell$ is unspecified when $n \geq \holtxt{LENGTH}\;\ell$.
Subsequently, many theorems involving \holtxt{EL} have preconditions to preclude this possibility.

For example, these theorems describing the relationship between \holtxt{EL}, \holtxt{MAP} and \holtxt{MEM}:
\begin{hol}
\begin{alltt}
   ##thm EL_MAP
   ##thm MEM_EL
\end{alltt}
\end{hol}

It is occasionally useful to be able to update lists at particular positions, viewing them as similar to programming language arrays.
The relevant constant is \holtxt{LUPDATE}, where the term $\holtxt{LUPDATE}\;e\;n\;\ell$ has the same value as list $\ell$, except that the $n$-th element of the list is equal to $e$.%
\index{LUPDATE, the HOL constant@\holtxt{LUPDATE}, the \HOL{} constant}
The definition is given in three clauses:
\begin{hol}
\begin{alltt}
   ##thm LUPDATE_def
\end{alltt}
\end{hol}
The definition implies that attempting to update a list at an index beyond the end of the list returns the input list unchanged.

The basic characterisation of the link between \holtxt{EL} and \holtxt{LUPDATE} is
\begin{hol}
\begin{alltt}
   ##thm EL_LUPDATE
\end{alltt}
\end{hol}

\paragraph{The \ml{indexedLists} theory} The \ml{indexedLists} theory defines a number of extra constants that are ``aware'' of lists as indexed values.
Some of these constants are:
\begin{hol}
\begin{verbatim}
   >>__ open indexedListsTheory
   delN      : num -> 'a list -> 'a list
   findi     : 'a -> 'a list -> num
   LIST_RELi : (num -> 'a -> 'b -> bool) -> 'a list -> 'b list -> bool
   MAPi      : (num -> 'a -> 'b) -> 'a list -> 'b list
\end{verbatim}
\end{hol}

\noindent
The \holtxt{findi} constant%
\index{lists, the HOL theory of@lists, the \HOL{} theory of!finding element indices}
\index{findi, the HOL constant@\holtxt{findi}, the \HOL{} constant} %
is such that $\holtxt{findi}\;e\;\ell$ returns the first index of element $e$ within list $\ell$, or a number equal to $\ell$'s length, if $e$ is not present.
The definition is by recursion over the structure of the input list:
\begin{hol}
\begin{alltt}
   ##thm findi_def
\end{alltt}
\end{hol}

\noindent
The \holtxt{delN} constant%
\index{lists, the HOL theory of@lists, the \HOL{} theory of!removing elements by index}%
\index{delN, the HOL constant@\holtxt{delN}, the \HOL{} constant} %
is used to remove the $n$-th element from a list.
It is also defined by recursion over the structure of the input list:
\begin{hol}
\begin{alltt}
   ##thm delN_def
\end{alltt}
\end{hol}

\noindent
The higher-order \holtxt{MAPi} function%
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for lists, with indices}
\index{MAPi, the HOL constant@\holtxt{MAPi}, the \HOL{} constant} %
exemplifies another set of constants within the \ml{indexedLists} theory: its function parameter, which works on elements of the list argument is given access to the index of the list element as well as its value.
A simple example use might be to generate a numbered version of a list, using the term
\(
\holtxt{MAPi}\;(\lambda i\;e.\;(i,e))
\).
If this term were applied to the list \verb![a;c;d]! the resulting value would be \verb![(0,a);(1,c);(2,d)]!.

An example theorem about \holtxt{MAPi} relates it to \holtxt{MEM}:
\begin{hol}
\begin{alltt}
   ##thm MEM_MAPi
\end{alltt}
\end{hol}



\index{lists, the HOL theory of@lists, the \HOL{} theory of|)}
\index{ lists, the HOL theory of@\ml{[} $\cdots$ \ml{;} $\cdots$ \ml{]} (lists, the \HOL{} theory of)|)}

\subsection{Possibly infinite sequences (\theoryimp{llist})}

\index{lazy lists, the HOL theory of@``lazy'' lists, the \HOL{} theory of|(}

The theory \theoryimp{llist} contains the definition of a type of
possibly infinite sequences.  This type is similar to the ``lazy
lists'' of programming languages like Haskell, hence the name of the
theory.  The \theoryimp{llist} theory has a number of constants that
are analogous to constants in the theory of finite
lists.  The \theoryimp{llist} versions of these constants have the
same names, but with a capital `L\/' prepended.  Thus, some of the core
constants in this theory are:
\begin{hol}
\begin{verbatim}
   LNIL  : 'a llist
   LCONS : 'a -> 'a llist -> 'a llist
   LHD   : 'a llist -> 'a option
   LTL   : 'a llist -> 'a llist option
\end{verbatim}
\end{hol}

The \ml{LHD} and \ml{LTL} constants return \ml{NONE} when applied to
the empty sequence, \ml{LNIL}.  This use of an option type is another
way of modelling the essential partiality of these constants.  (In the
theory of lists, the analogous \ml{HD} and \ml{TL} functions simply
have unspecified values when applied to empty lists.)

The type \ml{llist} is not inductive, and there is no primitive
recursion theorem supporting the definition of functions that have
domains of type \ml{llist}.  Rather, \ml{llist} is a coinductive type,
and has an axiom that justifies the definition of (co-)recursive
functions that map \emph{into} the \ml{llist} type:
\begin{hol}
\begin{alltt}
   >>__ load "llistTheory"; open llistTheory
   ##thm llist_Axiom
\end{alltt}
\end{hol}
\noindent An equivalent form of the above is
\begin{hol}
\begin{alltt}
   ##thm llist_Axiom_1
\end{alltt}
\end{hol}

Other constants in the theory \theoryimp{llist} include \ml{LMAP}, \ml{LFINITE},
\ml{LNTH}, \ml{LTAKE}, \ml{LDROP}, and \ml{LFILTER}. Their types are
%
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for possibly infinite sequences}
\begin{hol}
\begin{verbatim}
   LMAP    : ('a -> 'b) -> 'a llist -> 'b llist
   LFINITE : 'a llist -> bool
   LNTH    : num -> 'a llist -> 'a option
   LTAKE   : num -> 'a llist -> 'a list option
   LDROP   : num -> 'a llist -> 'a llist option
   LFILTER : ('a -> bool) -> 'a llist -> 'a llist
\end{verbatim}
\end{hol}
They are characterised by the following theorems
\begin{hol}
\begin{alltt}
##thm LMAP
##thm LFINITE_THM
##thm LNTH_THM
##thm LTAKE_THM
##thm LDROP_THM
##thm LFILTER_THM
\end{alltt}
\end{hol}

\paragraph{Concatenation}

Two lazy lists may be concatenated by \ml{LAPPEND} (written below using its infix Unicode form \texttt{++$_l$}).
If the first lazy list is infinite, elements of the second are inaccessible in the
result.
A lazy list of lazy lists can be flattened to a lazy list by \ml{LFLATTEN}.
\begin{hol}
\begin{alltt}
##thm LAPPEND
##thm LFLATTEN_THM
\end{alltt}
\end{hol}

\paragraph{Lists and lazy lists}

Mapping back and forth from lists to lazy lists is accomplished
by \ml{fromList} and \ml{toList}:
\begin{hol}
\begin{alltt}
##thm fromList_def
##thm toList_THM
\end{alltt}
\end{hol}
Note that \holtxt{toList~ll~=~NONE} when \holtxt{ll} is infinite.

\paragraph{Proof principles}

Finally, there are two very important proof principles for proving
that two \ml{llist} values are equal.  The first states that two
sequences are equal if they return the same prefixes of length $n$ for
all possible values of $n$:
\begin{hol}
\begin{alltt}
##thm LTAKE_EQ
\end{alltt}
\end{hol}
This theorem is subsequently used to derive the bisimulation
principle:
\begin{hol}
\begin{alltt}
##thm LLIST_BISIMULATION
\end{alltt}
\end{hol}
The principle of bisimulation states that two \ml{llist} values $l_1$
and $l_2$ are equal if (and only if) it is possible to find a
relation $R$ such that
\begin{itemize}
\item $R$ relates the two values, \ie, $R\;l_1\;l_2$; and
\item if $R$ holds of any two values $l_3$ and $l_4$, then either
  \begin{itemize}
  \item both $l_3$ and $l_4$ are empty; or
  \item the head elements of $l_3$ and $l_4$ are the same, and the
    tails of those two values are again related by $R$
  \end{itemize}
\end{itemize}
Of course, a possible $R$ would be equality itself, but the strength
of this theorem is that other, more convenient relations can also be
used.
\index{lazy lists, the HOL theory of@``lazy'' lists, the \HOL{} theory of|)}

\subsection{Labelled paths (\theoryimp{path})}

The theory \theoryimp{path}
%
\index{labelled paths, the HOL theory of@labelled paths, the \HOL{} theory of|(}%
\index{reduction sequences, the HOL theory of@reduction sequences, the \HOL{} theory of|(}%
\index{paths (reduction sequences), the HOL theory of@paths (reduction sequences), the \HOL{} theory of|(}%
%
defines a binary type operator $(\alpha,\beta)\ml{path}$, which
stands for possibly infinite paths of the following form
\[
  \alpha_1 \stackrel{\beta_1}{\longrightarrow}
  \alpha_2 \stackrel{\beta_2}{\longrightarrow}
  \alpha_3 \stackrel{\beta_3}{\longrightarrow} \cdots
  \alpha_n \stackrel{\beta_n}{\longrightarrow}
  \alpha_{n+1} \stackrel{\beta_{n+1}}{\longrightarrow}  \cdots
  \]
The \ml{path} type is thus an appropriate model for reduction
sequences, where the $\alpha$ parameter corresponds to ``states'', and
the $\beta$ parameter corresponds to the labels on the arrows.

The model of $(\alpha,\beta)\ml{path}$ is $\alpha \times
((\alpha\times\beta)\ml{llist})$.  The type of paths has two
constructors:
\begin{hol}
\begin{verbatim}
   stopped_at : 'a -> ('a,'b) path
   pcons      : 'a -> 'b -> ('a,'b) path -> ('a,'b) path
\end{verbatim}
\end{hol}
The \holtxt{stopped\_at} constructor returns a path containing just one
state, and no transitions.  (Thus, the reduction sequence has
``stopped at'' this state.)  The \ml{pcons} constructor takes a state,
a label, and a path, and returns a path which is now headed by the
state argument, and which moves from that state via the label argument
to the path.  Graphically, $\ml{pcons}\;x\;l\;p$ is equal to
\[
x \stackrel{l}{\longrightarrow}
\underbrace{p_1 \stackrel{l_1}{\longrightarrow} p_2
  \stackrel{l_2}{\longrightarrow} \cdots\quad}_p
\]
Other constants defined in theory \theoryimp{path} include
%
\index{mapping functions, in the HOL logic@mapping functions, in the \HOL{} logic!for labelled paths}
%
\begin{hol}
\begin{verbatim}
   finite  : ('a,'b) path -> bool
   first   : ('a,'b) path -> 'a
   labels  : ('a,'b) path -> 'b llist
   last    : ('a,'b) path -> 'a
   length  : ('a,'b) path -> num option
   okpath  : ('a -> 'b -> 'a -> bool) -> ('a,'b) path -> bool
   pconcat : ('a,'b) path -> 'b -> ('a,'b) path -> ('a,'b) path
   pmap    : ('a -> 'c) -> ('b -> 'd) -> ('a,'b)path -> ('c,'d)path
\end{verbatim}
\end{hol}

The \ml{first} function returns the first element of a path.
There always is such an element, and the defining equations are
\begin{hol}
\begin{alltt}
>>__ load "pathTheory"
>>__ open pathTheory;
##thm first_thm
\end{alltt}
\end{hol}

On the other hand, the \ml{last} function does not always have a
well-specified value, though it still has nice characterising
equations:
\begin{hol}
\begin{alltt}
##thm last_thm
\end{alltt}
\end{hol}

The theorem for \ml{finite} has a similar feel, but has a definite
value (\ml{F}, or \emph{false}) on infinite paths), whereas the
value of \ml{last} on such paths is unspecified:
\begin{hol}
\begin{alltt}
##thm finite_thm
\end{alltt}
\end{hol}

The function \ml{pconcat} concatenates two paths, linking them
with a provided label.  If the first path is infinite, then the result
is equal to that first path.  The defining equation is
\begin{hol}
\begin{alltt}
##thm pconcat_thm
\end{alltt}
\end{hol}
%
These equations are true even when the first argument to
\ml{pconcat} is an infinite path.

The \ml{okpath} predicate tests whether or not a path is a valid
transition given a ternary transition relation.  Its characterising
theorem is
\begin{hol}
\begin{alltt}
##thm okpath_thm
\end{alltt}
\end{hol}
%
There is also an induction principle that simplifies reasoning about
finite $R$-paths:
%
\begin{hol}
\begin{alltt}
##thm finite_okpath_ind
\end{alltt}
\end{hol}

\noindent
One can show that a set \holtxt{P} of paths are all $R$-paths with the
co-induction principle:
\begin{hol}
\begin{alltt}
##thm okpath_co_ind
\end{alltt}
\end{hol}
\index{labelled paths, the HOL theory of@labelled paths, the \HOL{} theory of|)}
\index{reduction sequences, the HOL theory of@reduction sequences, the \HOL{} theory of|)}
\index{paths (reduction sequences), the HOL theory of@paths (reduction sequences), the \HOL{} theory of|)}


\subsection{Character strings (\theoryimp{string})}
\index{strings, the HOL theory of@strings, the \HOL{} theory of|(}
\label{sec:strings}

The theory \theoryimp{string} defines a type of characters and a type
of finite strings built from those characters, along with a useful suite of
definitions for operating on strings.

\paragraph {Characters}
\index{characters, the HOL theory of@characters, the \HOL{} theory of}

The type \holtxt{char} is represented by the numbers less than 256. Two
constants are defined: {\small\verb+CHR +}$: \konst{num}\to\konst{char}$ and
{\small\verb+ORD +}$: \konst{char}\to\konst{num}$. The following theorems
hold:
\begin{hol}
\begin{verbatim}
  CHR_ORD  |- !a. CHR (ORD a) = a
  ORD_CHR  |- !r. r < 256 = (ORD (CHR r) = r)
\end{verbatim}
\end{hol}

\index{character literals}
Character literals can also be entered using \ML{} syntax, with a hash
character immediately followed by a string literal of length one.
Thus:
\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>> load "stringTheory";
>> val t = ``f #"c" #"\n"``;

>> dest_comb ``#"\t"``;
\end{alltt}
\end{session}

\paragraph {Strings}

The type \holtxt{string} is an alias for the type \holtxt{char list}.
All functions and predicates over lists are thus available for use
over strings.  Some of these constants are overloaded so that they are
printed (and can be parsed) with names that are more appropriate for
the particular case of lists of characters.

For example, \holtxt{NIL} and \holtxt{CONS} over strings have
alternative names \holtxt{EMPTYSTRING} and \holtxt{STRING}
respectively:
%
\begin{hol}
\index{EMPTYSTRING, the HOL constant@\holtxt{EMPTYSTRING}, the \HOL{} constant}
\index{STRING, the HOL constant@\holtxt{STRING}, the \HOL{} constant}
\begin{verbatim}
   EMPTYSTRING : string
   STRING      : char -> string -> string
\end{verbatim}
\end{hol}
\index{string literals}
The \HOL{} parser maps the syntax \holtxt{""} to \holtxt{EMPTYSTRING},
and the \HOL{} printer inverts this.  The parser expands string
literals of the form \holtxt{"$c_1 c_2 \ldots c_n$"} to the compound
term
\[
\holtxt{STRING} \;c_1\; (\holtxt{STRING}\;c_2\,\ldots\,
 (\holtxt{STRING} \;c_{n-1} \; (\holtxt{STRING}\;
c_n \; \holtxt{EMPTYSTRING})) \,\ldots\, )
\]
Of course, one could also write
\begin{session}
\begin{alltt}
>> ``[#"a"; #"b"]``;
\end{alltt}
\end{session}

String literals can be constructed using the various special escape
sequences that are used in \ML{}.  For example, \ml{\bs{}n} for the
newline character, and a backslash followed by three decimal digits
for characters of the given number.
\begin{session}
\begin{alltt}
>> val t = ``"foo bar\n\001"``;
\end{alltt}
\end{session}
Note that if one wants to use the control-character syntax with the
caret that the pretty-printer has chosen to use in printing the given
string, and this occurs inside a quotation, then the caret will need
to be doubled.  (See Section~\ref{sec:quotation-antiquotation}.)

As with numerals, string literals can be injected into other types, where it might make sense to have string literals appear to inhabit types in addition to the core system's \holtxt{string} type.
Such literals can be written with different delimiters to make it clear that such an injection has occurred.
For more on this facility, see \REFERENCE{}'s description of the \ml{add_strliteral_form} function.

There is also a destructor function \holtxt{DEST_STRING} for strings which returns an \holtxt{option} type:
\begin{hol}
\begin{alltt}
>>__ open stringTheory;
##thm DEST_STRING_def
\end{alltt}
\end{hol}

\paragraph{Case expressions}
\index{case expressions!over strings}

Compound \HOL{} expressions that branch based on
whether a term is an empty or non-empty string can be written with the
surface syntax
\begin{hol}
\begin{verbatim}
   case s
    of "" => e1
     | STRING c rst => e2
\end{verbatim}
\end{hol}

Such an expression is actually a case-expression over the underlying list, and so the underlying constant is that for lists.

\paragraph {Length and concatenation}

A standard function \holtxt{LENGTH} can be written \holtxt{STRLEN}
when applied to a string, and \holtxt{APPEND} can be written as
\holtxt{STRCAT}.  There are also theorems characterising these
constants in \ml{stringTheory}, though they are simply instantiations
of results from \ml{listTheory}:
\begin{hol}
\begin{verbatim}
   STRLEN_THM
     |- (STRLEN "" = 0) /\
        (STRLEN (STRING c s) = 1 + STRLEN s)

   STRCAT_EQNS =
     |- (STRCAT "" s = s) /\
        (STRCAT s "" = s) /\
        (STRCAT (STRING c s1) s2 = STRING c (STRCAT s1 s2))
\end{verbatim}
\end{hol}


\paragraph{Strings into numbers, and \emph{vice versa}}
\index{strings, the HOL theory of@strings, the \HOL{} theory of!converting to and from numbers}
\index{numerals, in HOL logic@numerals, in \HOL{} logic!parsing/printing of in the logic}
>>__ load "ASCIInumbersTheory";
>>__ open ASCIInumbersTheory
It is natural to want to convert strings to and from (natural) numbers.
Constants supporting this for a variety of bases ($2$, $8$, $10$, and $16$) are defined in the theory \ml{ASCIInumbersTheory}.
There the constants are named according to the scheme
\[
\holtxt{num\_}\{\holtxt{to},\holtxt{from}\}\holtxt{\_}\{\holtxt{bin},\holtxt{oct},\holtxt{dec},\holtxt{hex}\}\holtxt{\_string}
\]
making for a total of eight constants.
The two decimal constants are also available under the (overloaded) names \holtxt{toString} and \holtxt{toNum}.
The natural theorem expressing these last two are inverse is
\begin{hol}
\begin{alltt}
##thm toNum_toString
\end{alltt}
\end{hol}
and there is also a theorem specifying how long the strings produced by \holtxt{toString} will be:
\begin{hol}
\begin{alltt}
##thm LENGTH_num_to_dec_string
\end{alltt}
\end{hol}


\index{strings, the HOL theory of@strings, the \HOL{} theory of|)}

\section{Collections}

Several different notions of a collection of elements are available in
\HOL: sets, multisets, relations, and finite maps.

\subsection{Sets (\theoryimp{pred\_set})}
\label{sec:theory-of-sets}
\index{sets, the HOL theory of@sets, the \HOL{} theory of|(}
>>__ open pred_setTheory

An extensive development of set theory is available in the theory
\theoryimp{pred\_set}. Sets are represented by functions of the type
$\alpha \to \konst{bool}$, \ie, they are so-called characteristic
functions.
%
\index{characteristic functions!as basis for \HOL{} theory of sets}
%
One can use the type abbreviation $\alpha\; \konst{set}$
instead of $\alpha \to \konst{bool}$. Sets may be finite or
infinite. All of the elements in a set must have the same type.

\emph{Set membership} is the basic notion that formalized set theory
is based on. In \HOL, membership is represented by a the infix
constant \holtxt{IN}, defined in theory \theoryimp{bool} for
convenience.
\begin{hol}
\begin{alltt}
  ##thm IN_DEF
\end{alltt}
\end{hol}
The \holtxt{IN} operator is merely a way of applying the
characteristic function to an item, as the following trivial
consequence of the definition shows:
\begin{hol}
\begin{alltt}
  ##thm SPECIFICATION
\end{alltt}
\end{hol}
Two sets are equal if they have the same elements.
\begin{hol}
\begin{alltt}
  ##thm EXTENSION
\end{alltt}
\end{hol}
The negation of set-membership is not a separate constant, but is available as a convenient overload (in both ASCII and Unicode forms).
Thus, instead of writing \holtxt{\td(e IN s)}, one can instead write \holtxt{e NOTIN s} or \holtxt{e \(\notin\) s}.

\paragraph{Empty and universal sets}
\index{universal set}
The empty set is the characteristic function that is constantly false. The constant \holtxt{EMPTY} denotes the empty set; it may be written as \holtxt{\{\}} and \holtxt{$\emptyset$} (U+2205).
The universal set, \holtxt{UNIV}, on a type is the characteristic function that is always true for elements of that type.
\begin{hol}
\begin{alltt}
  ##thm EMPTY_DEF
  ##thm UNIV_DEF
\end{alltt}
\end{hol}
In addition to \holtxt{UNIV} (perhaps with a type annotation \holtxt{:'a~set}), one may also write \holtxt{univ(:'a)} to represent the universal set over type \holtxt{:'a}.
The Unicode syntax \holtxt{$\mathbb{U}$(:'a)} means the same.
The Unicode symbol for $\mathbb{U}$ is U+1D54C, and may not exist in many fonts.

\index{traces, controlling HOL feedback@traces, controlling \HOL{} feedback!universal sets}One of these forms will be used to print \holtxt{UNIV} by default.
The user trace (see Section~\ref{sec:traces}) \ml{"Univ~pretty-printing"} can be set to zero to cancel this behaviour.
Additionally, the trace \ml{"Unicode Univ printing"} can be used to stop the U+1D54C syntax from being used, even if the Unicode trace is set.

The symbols \holtxt{univ} and \holtxt{$\mathbb{U}$} are high-priority prefixes (see Section~\ref{sec:parseprint:fixities}), and overloaded patterns (see Section~\ref{sec:parser:syntactic-patterns}) mapping a value of the itself type to the corresponding \holtxt{UNIV} constant.
One effect is that one can write things like
\begin{hol}
\begin{verbatim}
   FINITE univ(:'a)
\end{verbatim}
\end{hol}
without the need for parentheses around \holtxt{FINITE}'s argument.

\paragraph{Insertion, union, and intersection}

The insertion ({\small\verb+INSERT+}, written infix) of an element
into a set is defined with a set comprehension. Set comprehension is
discussed in the next subsection. Set union ({\small\verb+UNION+},
written infix) and intersection ({\small\verb+INTER+}, also infix)
are given their usual definitions by set comprehension.
\begin{hol}
\begin{alltt}
  ##thm INSERT_DEF
  ##thm UNION_DEF
  ##thm INTER_DEF
\end{alltt}
\end{hol}
\holtxt{UNION} and \holtxt{INTER} are binary
operations. Indexed union and intersection operations, \ie,
$\bigcup_{i \in P}$ and $\bigcap_{i \in P}$ are provided by the
definitions of  \holtxt{BIGUNION} and \holtxt{BIGINTER}.
\begin{hol}
\begin{alltt}
  ##thm BIGUNION
  ##thm BIGINTER
\end{alltt}
\end{hol}
Both \holtxt{BIGUNION} and \holtxt{BIGINTER} reduce a set of sets to a
set and thus have the type
$((\alpha\to\konst{bool})\to\konst{bool})\to (\alpha\to\konst{bool})$.

\paragraph{Subsets}

Set inclusion (\holtxt{SUBSET}, infix), proper set inclusion
(\holtxt{PSUBSET}, infix), and power set (\holtxt{POW}) are defined as
follows:
%
\begin{hol}
\begin{alltt}
  ##thm SUBSET_DEF
  ##thm PSUBSET_DEF
  ##thm POW_DEF
\end{alltt}
\end{hol}

\paragraph{Set difference and complement}

The difference between two sets (\holtxt{DIFF}, infix) is defined by a
set comprehension. Based on that, the deletion of a single element
(\holtxt{DELETE}, infix) from a set is straightforward. Since the
universe of a type is always available via \holtxt{UNIV}, the
complement (\holtxt{COMPL}) of a set may be taken.
\begin{hol}
\begin{alltt}
  ##thm DIFF_DEF
  ##thm DELETE_DEF
  ##thm COMPL_DEF
\end{alltt}
\end{hol}

\paragraph{Functions on sets}
The image of a function $f :\alpha \to \beta$ on
a set (\holtxt{IMAGE}) is defined with a set comprehension.
\begin{hol}
\begin{alltt}
  ##thm IMAGE_DEF
\end{alltt}
\end{hol}
%
Injections, surjections, and bijections between sets are defined as follows:
%
\begin{hol}
\begin{alltt}
  ##thm INJ_DEF
  ##thm68 SURJ_DEF
  ##thm BIJ_DEF
\end{alltt}
\end{hol}

\paragraph{Finite sets}
\index{finiteness!of sets}
The finite sets (\holtxt{FINITE}) are defined inductively as those
built from the empty set by a finite number of insertions.
%
\begin{hol}
\begin{alltt}
  ##thm FINITE_DEF
\end{alltt}
\end{hol}
%
\noindent
A set is infinite iff it is not finite, and there is an abbreviation in the system that parses \holtxt{\fholquote{INFINITE~s}} into  \holtxt{\fholquote{\td{}FINITE~s}}.
The pretty-printer reverses this transformation.

\medskip\noindent
The finite sets have an induction theorem:
%
\index{induction theorems, in HOL logic@induction theorems, in \HOL{} logic!for finite sets}
%
\begin{hol}
\begin{alltt}
  ##thm FINITE_INDUCT
\end{alltt}
\end{hol}
%
As mentioned, set operations apply to both finite and infinite
sets. However, some operations, such as cardinality
(\holtxt{CARD}), are only defined for finite sets. (See Section~\ref{ss:cardinals}
for the theory of cardinality of possibly infinite sets.)
\index{cardinality of (finite) sets}
%
\begin{hol}
\begin{alltt}
  ##thm CARD_DEF
\end{alltt}
\end{hol}
%
Since the finite and infinite sets are dealt with uniformly in
\theoryimp{pred\_set}, properties of operations on finite sets must
explicitly include constraints about finiteness. For example the
following theorem relating cardinality and subsets is only true for
finite sets.
%
\begin{hol}
\begin{alltt}
  ##thm CARD_PSUBSET
\end{alltt}
\end{hol}
%
An extensive suite of theorems dealing with finiteness and cardinality
is available in \theoryimp{pred\_set}.

\paragraph{Cross product}
The product of two sets ({\small\verb+CROSS+}, infix) is defined
with a set comprehension.
%
\begin{hol}
\begin{alltt}
  ##thm CROSS_DEF
\end{alltt}
\end{hol}
%
\noindent Cardinality and cross product are related by the following theorem:
\begin{hol}
\begin{alltt}
  ##thm CARD_CROSS
\end{alltt}
\end{hol}

\paragraph{Recursive functions on sets}

Recursive functions on sets may be defined by wellfounded
recursion. Usually, the totality of such a function is established by
measuring the cardinality of the (finite) set. However, another
theorem may be used to justify a fold ({\small\verb+ITSET+}) for finite sets.
Provided a function $f:\alpha\to\beta\to\beta$ obeys a condition
known as \emph{left-commutativity}, namely, $f\;x\;(f\;y\;z) =
f\;y\;(f\;x\;z)$, then $f$ can be applied by folding it on the set
in a tail-recursive fashion.
\begin{hol}
\begin{alltt}
  ##thm ITSET_THM

  ##thm ITSET_EMPTY

  ##thm COMMUTING_ITSET_INSERT
\end{alltt}
\end{hol}
A recursive version is also available:
\begin{hol}
\begin{alltt}
  ##thm COMMUTING_ITSET_RECURSES
\end{alltt}
\end{hol}
For the full derivation, see the sources of {\small\verb+pred_set+}.
The definition of {\small\verb+ITSET+} allows, for example, the
definition of summing the results of a function on a finite set of
elements, from which a recursive characterization and other useful
theorems are derived.
%
\begin{hol}
\begin{alltt}
  ##thm SUM_IMAGE_DEF
  ##thm SUM_IMAGE_THM
\end{alltt}
\end{hol}

\paragraph{Other definitions and theorems}

There are more definitions in \theoryimp{pred\_set}, but they are not
as heavily used as the ones presented here. Similarly, most theorems
in \theoryimp{pred\_set} relate the various common set operations to
each other, but do not express any deep theorems of set theory.

However, one notable theorem is Koenig's Lemma, which states that
every finitely branching infinite tree has an infinite path. There are
many ways to formulate this theorem, depending on how the notion of
tree is formalized.
In \HOL's formulation, the tree is characterised by making various assumptions about the finite-ness or otherwise of elements reachable using a relation \holtxt{R}.
Then the following version of Koenig's Lemma is stated and
proved:
\begin{hol}
\begin{alltt}
  ##thm KoenigsLemma
\end{alltt}
\end{hol}


\subsubsection{Syntax for sets}\index{set theory notation}\label{sec:set-syntax}

The special purpose set-theoretic notations
{\small\verb%{%}$t_1 ;t_2 ; \ldots ; t_n${\small\verb%}%} and
{\small\verb%{%}$t${\small\verb% | %}$p${\small\verb%}%} are recognized
by the \HOL{} parser and printer when the theory \theoryimp{pred\_set}
is loaded.

The normal interpretation of \lb$t_1 ;t_2 ; \ldots ; t_n$\rb{} is the finite set
containing just $t_1,t_2,\ldots,
t_n$. This can be modelled by starting with the empty set and
performing a sequence of insertions. For example, \holtxt{\lb{}1;2;3;4\rb{}}
parses to

\begin{hol}
\begin{verbatim}
   1 INSERT (2 INSERT (3 INSERT (4 INSERT EMPTY)))
\end{verbatim}
\end{hol}

\paragraph {Set comprehensions}

The normal interpretation of
{\small\verb%{%}$t${\small\verb% | %}$p${\small\verb%}%} is
the set of all $t$s such that $p$. In \HOL, such syntax parses to:
%
\ml{GSPEC(\bs($x_1$,$\ldots$,$x_n$).($t$,$p$))}
%
\noindent where $x_1, \ldots, x_n$ are those free variables that
occur in both $t$ and $p$ if both have at least one free variable. If
$t$ or $p$ has no free variables, then $x_1,\ldots,x_n$ are taken to
be the free variables of the other term.  If both terms have free
variables, but there is no overlap, then an error results. The order
in which the variables are listed in the variable structure of the
paired abstraction is an unspecified function of the structure of $t$
(it is approximately left to right). For example,
%
\begin{hol}
\begin{verbatim}
   {p+q | p < q /\ q < r}
\end{verbatim}
\end{hol}
%
parses to:
%
\begin{hol}
\begin{verbatim}
   GSPEC(\(p,q). ((p+q), (p < q /\ q < r)))
\end{verbatim}
\end{hol}
%
where \ml{GSPEC} is characterized by:
%
\begin{hol}
\begin{alltt}
  ##thm GSPECIFICATION
\end{alltt}
\end{hol}

This somewhat cryptic specification can be understood by exercising an
example. The syntax
%
\begin{hol}
\begin{verbatim}
   a IN {p+q | p < q /\ q < r}
\end{verbatim}
\end{hol}
%
is mapped by the \HOL{} parser to
\begin{hol}
\begin{alltt}
   ##parsetm a IN GSPEC(\(p,q). ((p+q), (p < q /\ q < r)))
\end{alltt}
\end{hol}
%
which, by \ml{GSPECIFICATION}, is equal to
\begin{hol}
\begin{verbatim}
   ?x. (a,T) = (\(p,q). ((p+q), (p < q /\ q < r))) x
\end{verbatim}
\end{hol}
%
The existentially quantified variable \verb+x+ has a pair type,
so it can be replaced by a pair \verb+(p,q)+ and a
paired-$\beta$-reduction can be performed, yielding
%
\begin{hol}
\begin{verbatim}
   ?(p,q). (a,T) = ((p+q), (p < q /\ q < r))
\end{verbatim}
\end{hol}
%
which is equal to the intended meaning of the original
syntax:
%
\begin{hol}
\begin{verbatim}
   ?(p,q). (a = p+q) /\ (p < q /\ q < r)
\end{verbatim}
\end{hol}

\paragraph{Unambiguous set comprehensions} There is also
an unambiguous set comprehension syntax, which allows the user to
specify which variables are to be quantified over in the abstraction
that is the argument of \holtxt{GSPEC}.  Terms of the form
\begin{hol}
\begin{verbatim}
   { t | vs | P }
\end{verbatim}
\end{hol}
generate sets containing values of the form given by \holtxt{t}, where
the variables mentioned in \holtxt{vs} must satisfy the constraint
\holtxt{P}.  For example, the set
\begin{hol}
\begin{verbatim}
   { x + y | x | x < y }
\end{verbatim}
\end{hol}
is the set of numbers from \holtxt{y} up to but not including
\holtxt{2~*~y}.  The set can be ``read'' computationally: draw out all
those \holtxt{x} that are less than \holtxt{y}, and to each such
\holtxt{x} add \holtxt{y}, thereby generating a set of numbers.

In the example above, the underlying \holtxt{GSPEC} term will be
\begin{hol}
\begin{verbatim}
   GSPEC (\x. (x + y, x < y))
\end{verbatim}
\end{hol}

The \holtxt{vs} component of the unambiguous notation must be a single
``variable structure'' that might appear underneath a possibly paired
abstraction as in section~\ref{HOL-varstruct}.  In other words, this
\begin{hol}
\begin{verbatim}
   { x + y | (x,y) | x < y }
\end{verbatim}
\end{hol}
is fine, but this
\begin{hol}
\begin{verbatim}
   { x + y | x y | x < y }
\end{verbatim}
\end{hol}
will raise an error.  (Additionally, the outermost parentheses around
pairs in the \holtxt{vs} position can be omitted.)

The unambiguous notation is printed by the pretty-printer whenever the
set to be printed can not be expressed with the default notation, or
if the trace variable with name \ml{pp\_unambiguous\_comprehensions}
is set to \ml{1}.
(If the same trace is set to \ml{2}, then the unambiguous notation will never be used.)
\index{traces, controlling HOL feedback@traces, controlling \HOL{} feedback!set comprehensions}
\index{sets, the HOL theory of@sets, the \HOL{} theory of|)}

\subsubsection{Decision procedure for set-theoretic theorems}
\index{set theory decision procedure}
\label{sec:set-decision}

\HOL{} provides some tools (in \texttt{bossLib}) to automate the proof of some routine
\theoryimp{pred_set} theorems by a reduction to first-order
logic, ported from HOL Light. They are based on \texttt{metisLib} (see
Section~\ref{sec:metisLib}). Below are the entry-points: (see
\REFERENCE{} for more details.)
\begin{hol}
\begin{verbatim}
   SET_TAC     : thm list -> tactic
   ASM_SET_TAC : thm list -> tactic
   SET_RULE    : term -> thm
\end{verbatim}
\end{hol}

The difference between \ml{SET\_TAC} and \ml{ASM\_SET\_TAC} is that
the latter one also makes use of assumptions. With them, many simple
set-theoretic results can be directly proved without finding needed
lemmas in \theoryimp{pred_setTheory}. For instance, a simple lemma
from \theoryimp{util_probTheory}:
\begin{hol}
\begin{verbatim}
Theorem DISJOINT_RESTRICT_L :
  !s t c. DISJOINT s t ==> DISJOINT (s INTER c) (t INTER c)
Proof SET_TAC []
QED
\end{verbatim}
\end{hol}

\subsection{Multisets (\theoryimp{bag})}\label{multiset}

Multisets, also known as \emph{bags}, are similar to sets, except that
they allow repeat occurrences of an element. Whereas sets are
represented by functions of type $\alpha\to\konst{bool}$, which signal
the presence, or absence, of an element, multisets are represented
by functions of type $\alpha\to\konst{num}$, which give the
multiplicity of each element in the multiset. Multisets may be finite
or infinite.

The type abbreviations $\alpha\;\konst{multiset}$ and
$\alpha\;\konst{bag}$ can be used instead of $\alpha\to\konst{num}$.

\paragraph {Empty multiset}

The empty bag has no elements. Thus, the function implementing it
returns $0$ for every input.
%
\begin{hol}
\begin{alltt}
>>__ load "bagTheory"; open bagTheory;
##thm EMPTY_BAG
\end{alltt}
\end{hol}

\noindent The special syntax {\verb+{||}+} (the analogue of \texttt{[]} for lists, and \texttt{\{\}} for sets) is used for both printing and parsing, but the underlying constant is indeed called \holtxt{EMPTY\_BAG}, and this name can also be passed to the parser.

\paragraph {Membership}

Much of the theory can be based on the notion of membership in a
bag. There are two notions: does an element occur at least $n$ times
in a bag ({\holtxt{BAG\_INN}); and does an element occur in a bag
at all ({\holtxt{BAG\_IN}).
%
\begin{hol}
\begin{alltt}
##thm BAG_INN
##thm BAG_IN
\end{alltt}
\end{hol}
%
Two bags are equal if all elements have the same tally.
%
\begin{hol}
\begin{alltt}
##thm BAG_EXTENSION
\end{alltt}
\end{hol}

\paragraph{Sub-multiset}

A sub-bag relationship (\holtxt{SUB\_BAG}) holds between $b_1$ and
$b_2$ provided that every element in $b_1$ occurs at least as often in
$b_2$. The notion of a proper sub-bag (\holtxt{PSUB\_BAG}) is easily
defined.
%
\begin{hol}
\begin{alltt}
##thm SUB_BAG
##thm PSUB_BAG
\end{alltt}
\end{hol}

\paragraph{Insertion}

Inserting an element into a bag (\holtxt{BAG\_INSERT}) updates the
tally for that element and leaves the others unchanged.
%
\begin{hol}
\begin{alltt}
##thm BAG_INSERT
\end{alltt}
\end{hol}

Explicitly-given multisets are supported by the syntax
{\small\verb%{|%}$t_1 ;t_2 ; \ldots ; t_n${\small\verb%|}%}, where
there may, of course, be repetitions. This is modelled by starting with the empty
multiset and performing a sequence of insertions. For example,
\verb+{|1; 2; 3; 2; 1|}+ parses to

\begin{hol}
\begin{verbatim}
   BAG_INSERT 1 (BAG_INSERT 2 (BAG_INSERT 3
                                 (BAG_INSERT 2 (BAG_INSERT 1 {||}))))
\end{verbatim}
\end{hol}


\paragraph{Union and difference}

The union (\holtxt{BAG\_UNION}) and difference (\holtxt{BAG\_DIFF})
operations on bags both reduce to an arithmetic calculation on their
elements. Deleting a single element from a bag may be expressed by
taking the multiset difference with a single-element multiset;
however, there is also a relational presentation
(\holtxt{BAG\_DELETE}) which relates its first and last arguments only
if the first contains exactly one more occurrence of the middle
argument than the last.  This is not the same as using
\holtxt{BAG\_DIFF} to remove a one-element bag because it insists that
the element being removed actually appear in the larger bag.
%
\begin{hol}
\begin{alltt}
##thm BAG_UNION
##thm BAG_DIFF
##thm BAG_DELETE
\end{alltt}
\end{hol}

\paragraph {Intersection, merge, and filter}

The intersection of two bags (\holtxt{BAG\_INTER}) takes the pointwise
minimum. The dual operation, merging (\holtxt{BAG\_MERGE}), takes the
pointwise maximum. A bag can be `filtered' by a set to return the bag
where all the elements not in the set have been dropped
(\holtxt{BAG\_FILTER}).
%
\begin{hol}
\begin{alltt}
##thm BAG_INTER
##thm BAG_MERGE
##thm BAG_FILTER_DEF
\end{alltt}
\end{hol}

\paragraph {Sets and multisets}

Moving between bags and sets is accomplished by the following two
definitions.
%
\begin{hol}
\begin{alltt}
##thm SET_OF_BAG
##thm BAG_OF_SET
\end{alltt}
\end{hol}

\paragraph {Image}

Taking the image of a function on a multiset to get a new multiset
seems to be simply a matter of applying the function to each element
of the multiset. However, there is a problem if $f$ is non-injective
and the multiset is infinite. For example, take the multiset
consisting of all the natural numbers and apply $\lambda x.\; 1$ to
each element. The resulting multiset would hold an infinite number of
$1$s. To avoid this requires some constraints: for example,
stipulating that the function be only finitely non-injective, or that
the input multiset be finite. Such conditions would be onerous in
proof; the compromise is to map the multipicity of problematic
elements to $0$.
%
\begin{hol}
\begin{alltt}
##thm BAG_IMAGE_DEF
\end{alltt}
\end{hol}


\paragraph {Finite multisets}
\index{finiteness!of multi-sets}
The finite multisets (\holtxt{FINITE\_BAG}) are defined inductively as
those built from the empty bag by a finite number of insertions.
%
\begin{hol}
\begin{alltt}
##thm FINITE_BAG
\end{alltt}
\end{hol}
%
The finite multisets have an induction theorem, and also a strong
induction theorem.
%
\index{induction theorems, in HOL logic@induction theorems, in \HOL{} logic!for finite bags}
%
\begin{hol}
\begin{alltt}
##thm FINITE_BAG_INDUCT

##thm STRONG_FINITE_BAG_INDUCT
\end{alltt}
\end{hol}
%
The cardinality (\holtxt{BAG\_CARD}) of a multiset counts the
total number of occurrences. It is only specified for finite multisets.
%
\begin{hol}
\begin{alltt}
##thm BAG_CARD_THM
\end{alltt}
\end{hol}

\paragraph{Recursive functions on multisets}

Recursive functions on multiset may be defined by wellfounded
recursion. Usually, the totality of such a function is established by
measuring the cardinality of the (finite) multiset. However, a fold
(\holtxt{ITBAG}) for finite sets is provided.  Provided a function
$f:\alpha\to\beta\to\beta$ obeys a condition known as
\emph{left-commutativity}, namely, $f\;x\;(f\;y\;z) =
f\;y\;(f\;x\;z)$, then $f$ can be applied by folding it on the
multiset in a tail-recursive fashion.
%
\begin{hol}
\begin{alltt}
##thm ITBAG_EMPTY
##thm COMMUTING_ITBAG_INSERT
\end{alltt}
\end{hol}
%
A recursive version is also available:
\begin{hol}
\begin{alltt}
##thm COMMUTING_ITBAG_RECURSES
\end{alltt}
\end{hol}

\subsection{Relations (\theoryimp{relation})}\label{relation}

Mathematical relations can be represented in \HOL{} by the type
$\alpha \to\beta\to\konst{bool}$. (In most applications, the type of a
relation is an instance of $\alpha \to\alpha\to\konst{bool}$, but the
extra generality doesn't hurt.) The theory \theoryimp{relation}
provides definitions of basic properties and operations on relations,
defines various kinds of orders and closures, defines wellfoundedness
and proves the wellfounded recursion theorem, and develops some
basic results used in Term Rewriting.

\paragraph {Basic properties}

The following basic properties of relations are defined.
%
\begin{hol}
\begin{alltt}
>>__ open relationTheory
##thm transitive_def
##thm reflexive_def
##thm irreflexive_def
##thm symmetric_def
##thm antisymmetric_def
##thm equivalence_def
##thm trichotomous
##thm total_def
\end{alltt}
\end{hol}

\paragraph{Basic operations}

The following basic operations on relations are defined: the empty
relation (\holtxt{EMPTY\_REL}, or $\emptyset\subr$), relation composition (\holtxt{O}, or $\circ\subr$,
infix), inversion (\holtxt{inv}, or $\_^{\mathsf{T}}$ (suffix superscript `T')), domain (\holtxt{RDOM}), and range
(\holtxt{RRANGE}).
%
\begin{hol}
\begin{alltt}
##thm EMPTY_REL_DEF
##thm O_DEF
##thm inv_DEF
##thm RDOM_DEF
##thm RRANGE
\end{alltt}
\end{hol}

\noindent Set operations lifted to work on relations include subset
(\holtxt{RSUBSET}, or $\subseteq\subr$, infix), union (\holtxt{RUNION}, or $\cup\subr$, infix),
intersection (\holtxt{RINTER}, or $\cap\subr$, infix), complement (\holtxt{RCOMPL}),
and universe (\holtxt{RUNIV}, or $\mathbb{U}\subr$).\label{def:rsubset}
%
\begin{hol}
\begin{alltt}
##thm RSUBSET
##thm RUNION
##thm RINTER
##thm RCOMPL
##thm RUNIV
\end{alltt}
\end{hol}

\paragraph {Orders}

A sequence of definitions capturing various notions of order are made
in \theoryimp{relation}.
%
\begin{hol}
\begin{alltt}
##thm PreOrder
##thm Order
##thm WeakOrder
##thm StrongOrder
##thm LinearOrder
##thm WeakLinearOrder
##thm StrongLinearOrder
\end{alltt}
\end{hol}

\paragraph {Closures}

The transitive closure (\holtxt{TC}) of a relation $R : \alpha
\to\alpha\to\konst{bool}$ is defined inductively, as the least
relation including $R$ and closed under transitivity.
Similarly, the
reflexive-transitive closure (\holtxt{RTC}) is defined to be the least
relation closed under transitivity and reflexivity.
The ASCII syntax for the transitive closure \holtxt{R\^{}+} is meant to suggest the prettier \holtxt{R${}^+$}.
Similarly, \holtxt{R\^{}*} is meant to suggest \holtxt{R${}^*$}.
Indeed, with Unicode enabled, transitive closure will print with a superscript \texttt{+}, and \holtxt{RTC} will print as a superscript asterisk.

From the underlying definitions, one can recover the initial rules:
%
\begin{hol}
\begin{alltt}
##thm TC_RULES
##thm RTC_RULES
##thm RTC_RULES_RIGHT1
\end{alltt}
\end{hol}
%
Notice that {\small\verb+RTC_RULES+}, in keeping with the definition
of {\small\verb+RTC+}, extends an \verb+R+-step from \verb+x+ to
\verb+y+ with a sequence of \verb+R+-steps from \verb+y+ to \verb+z+
to construct \holtxt{R$^*$ x z}. The theorem
{\small\verb+RTC_RULES_RIGHT1+} first makes a sequence of \verb+R+
steps and then a single \verb+R+ step to form \holtxt{R$^*$ x z}.
Similar alternative theorems are proved for case analysis and induction.

For example, {\small\verb+TC_CASES1+} and {\small\verb+TC_CASES2+} in the
following decompose \holtxt{R$^+$ x z} to either
\holtxt{R x y} followed by \holtxt{R$^+$ y z}
(\ml{TC\_CASES1})
or
\holtxt{R$^+$ x y} followed by \holtxt{R y z} (\ml{TC\_CASES2}).

%
\begin{hol}
\begin{alltt}
##thm TC_CASES1
##thm TC_CASES2

##thm RTC_CASES1
##thm RTC_CASES2
##thm RTC_CASES_RTC_TWICE
\end{alltt}
\end{hol}

As well as the basic induction theorems for {\small\verb+TC+} and
{\small\verb+RTC+}, there are so-called \emph{strong} induction
theorems, which have stronger induction hypotheses.
%
\begin{hol}
\begin{alltt}
##thm TC_INDUCT
##thm68 RTC_INDUCT
##thm TC_STRONG_INDUCT
##thm RTC_STRONG_INDUCT
\end{alltt}
\end{hol}
Variants of these induction theorems are also available which break
apart the closure from the left or right, as for the case analysis theorems.

\medskip

The reflexive~(\holtxt{RC}) and symmetric closures~(\holtxt{SC}) are
straightforward to define. The equivalence closure
({\small\verb+EQC+}) is the symmetric then transitive then reflexive
closure of $R$.
When applied to an argument, as in \holtxt{EQC~R}, \holtxt{EQC} is written with the suffix \holtxt{\^{}=}.
Note how the suffix binds more tightly than function application, so that in \ml{EQC_DEF}, \holtxt{RC} really is applied to the transitive closure of the symmetric closure of \holtxt{R}.
%
\begin{hol}
\begin{alltt}
##thm RC_DEF
##thm SC_DEF
##thm EQC_DEF
\end{alltt}
\end{hol}

\paragraph {Wellfounded relations}
\index{wellfounded relations!existence of minimal elements|(}

A relation $R$ is wellfounded ({\small\verb+WF+}) if every non-empty set
has an $R$-minimal element. Wellfoundedness is used to justify the
principle of wellfounded induction ({\small\verb+WF_INDUCTION_THM+}).
%
\begin{hol}
\begin{alltt}
##thm WF_DEF
##thm WF_INDUCTION_THM
\end{alltt}
\end{hol}

The \emph{wellfounded part} ({\small\verb+WFP+}) of a relation can be
inductively defined, from which its rules, case-analysis theorem and
induction theorems may be derived.
%
\begin{hol}
\begin{alltt}
##thm WFP_DEF
##thm WFP_RULES
##thm WFP_CASES
##thm WFP_INDUCT
##thm WFP_STRONG_INDUCT
\end{alltt}
\end{hol}

Wellfoundedness can also be used to justify a general recursion
theorem. Intuitively, a collection of recursion equations can be
admitted into the \HOL{} logic with no loss of consistency provided
that every possible sequence of recursive calls is finite. Wellfounded
relations are used to capture this notion: if there is a wellfounded
relation $R$ on the domain of the desired function such that every
sequence of recursive calls is $R$-decreasing, then the recursion
equations specify a unique total function and the equations can be
admitted into the logic.

The recursion theorems {\small\verb+WFREC_COROLLARY+} and
{\small\verb+WF_RECURSION_THM+} use the notion of a function
restriction ({\small\verb+RESTRICT+}) in order to force the recursive
function to be applied to $R$-smaller arguments in recursive calls..
%
\begin{hol}
\begin{alltt}
##thm RESTRICT_DEF
##thm WFREC_COROLLARY

##thm WF_RECURSION_THM
\end{alltt}
\end{hol}

\noindent The theorems {\small\verb+WF_INDUCTION_THM+} and
{\small\verb+WFREC_COROLLARY+} are used to automate recursive
definitions; see Section~\ref{TFL}. A few basic operators for
wellfounded relations are also defined, along with theorems stating
that they propagate wellfoundedness.

\begin{hol}
\begin{alltt}
##thm inv_image_def

##thm WF_inv_image
##thm WF_SUBSET
##thm WF_TC
##thm WF_EMPTY_REL
\end{alltt}
\end{hol}
\index{wellfounded relations!existence of minimal elements}

\paragraph {Term Rewriting}

A few basic definitions from Term Rewriting theory
(the diamond property (\verb+diamond+), the Church-Rosser
property ({\small\verb+CR+} and {\small\verb+WCR+}), and Strong
Normalization ({\small\verb+SN+})) appear
in \theoryimp{relation}.
%
\begin{hol}
\begin{alltt}
##thm diamond_def
##thm CR_def
##thm WCR_def
##thm SN_def
\end{alltt}
\end{hol}
%
From those, Newman's Lemma is proved.
%
\begin{hol}
\begin{alltt}
##thm Newmans_lemma
\end{alltt}
\end{hol}

\subsection{Bisimulation for labelled transition systems (\theoryimp{bisimulation})}
\label{bisimulation}

\HOL{} provides a minimal theory (\theoryimp{bisimulation}) for
generating bisimulation and bisimulation
relations~\cite{Mil89}
from any labelled transition relation of the type $\alpha\to\beta\to\alpha\to\konst{bool}$.
Suppose there is a user-defined labelled transition system (LTS) and
\holtxt{ts} is the transition relation in it, then \holtxt{ts p l
  q} denotes a transition from $p$ to $q$ by an action $l$, \ie,~$p \overset{l}{\longrightarrow} q$.
A binary relation $R$ is called a \emph{bisimulation} if \holtxt{BISIM
  ts R} holds under the following definition:
\begin{hol}
\begin{alltt}
>>__ load "bisimulationTheory";
>>__ open bisimulationTheory;
##thm BISIM_def
\end{alltt}
\end{hol}
Furthermore, the bisimulation relation (or bisimilarity, usually
denoted by $\sim$),
\holtxt{BISIM_REL ts}, is the \emph{union} (in the sense of
\holtxt{RUNION}) of all bisimulations in this LTS, and it can be proven
to be an equivalence relation: (the \emph{original}
definition hereafter)
\begin{hol}
\begin{alltt}
##thm BISIM_REL_def
##thm BISIM_REL_IS_EQUIV_REL
\end{alltt}
\end{hol}

Bisimulation is a special case of coinduction, by far the most studied
coinductive concept~\cite{Sangiorgi2012}. In practice it is hard to
directly work with the above definition of \holtxt{BISIM_REL}.
Partly for this reason, \holtxt{BISIM_REL} is defined by the coinductive relation package (see Section~\ref{sec:coinductive}):
\begin{hol}
\begin{verbatim}
CoInductive BISIM_REL :
    !p q. (!l.
            (!p'. ts p l p' ==> ?q'. ts q l q' /\ (BISIM_REL ts) p' q') /\
            (!q'. ts q l q' ==> ?p'. ts p l p' /\ (BISIM_REL ts) p' q'))
      ==> (BISIM_REL ts) p q
End
\end{verbatim}
\end{hol}
which automatically generates the following coinduction principle:
\begin{hol}
\begin{alltt}
##thm BISIM_REL_coind
\end{alltt}
\end{hol}
A simple rewrite by \holtxt{BISIM_def} shows that \holtxt{BISIM_REL}
defined in this way is actually equivalent to the original
definition (which now becomes a theorem):\footnote{Starting with the
\emph{original definition} it is not that easy to derive the coinduction
principle, which is very useful in practice.}
\begin{session}
\begin{alltt}
>> Q.SPECL [`ts`, `R`]
           (REWRITE_RULE [GSYM BISIM_def, GSYM RSUBSET] BISIM_REL_coind);
\end{alltt}
\end{session}

The bisimulation and bisimulation relation considered so far are
the \emph{strong} ones, in the sense that all involved transitions are
\emph{one-step} transitions. To define \emph{weak} bisimulation (and the corresponding
weak bisimulation relation), beside the transition relation,
the user must also designate a special unique
action to be \emph{invisible} (usually denoted by $\tau$).
An \emph{empty} transition (\holtxt{ETS}) is the
reflexive-transitive closure (\holtxt{RTC}) of (one-step) invisible transitions:
\begin{hol}
\begin{alltt}
##thm ETS_def
\end{alltt}
\end{hol}
Then a \emph{weak} transition (\holtxt{WTS}) is a one-step transition
(the action may be invisible) concatenated with two empty transitions:
\begin{hol}
\begin{alltt}
##thm WTS_def
\end{alltt}
\end{hol}
An empty transition \holtxt{ETS ts tau p q} is usually denoted by
$p\overset{\epsilon}{\Longrightarrow} q$ (assuming \holtxt{ts} and
\holtxt{tau} is clear from the context), and a weak transition
\holtxt{WTS ts tau p l q} is denoted by $p\overset{l}{\Longrightarrow}q$.
Note that a weak transition must have at least one transition (even it
is $\tau$), while an empty transition may have no actual transition at all.
To simplify the informal definitions, we denote by
$p\overset{\hat{a}}{\Longrightarrow}q$ the special notion of weak
transitions such that, whenever the action $a$ is invisible, it is the
same as $p\overset{\epsilon}{\Longrightarrow} q$.

A binary relation $R$ is a weak bisimulation if, whenever $p\ R\ q$,
\begin{itemize}
\item $p \overset{a}{\longrightarrow} p'$ implies that there is $q'$ such that
  $q\overset{\hat{a}}{\Longrightarrow} q'$ and $p'\ R\ q'$;
\item $q \overset{a}{\longrightarrow} q'$ implies that there is $p'$ such that
  $p\overset{\hat{a}}{\Longrightarrow} p'$ and $p'\ R\ q'$.
\end{itemize}
 $p$ and $p$ are \emph{weakly bisimilar}, written as $p \approx q$, if $p\ R\ q$ for some bisimulation $R$.

Following the example of the strong case (including the use of the \ml{CoInductive} command),
below are the definition of weak
bisimulation (\holtxt{WBISIM}),
the equivalent definition of weak bisimulation relation
(\holtxt{WBISIM_REL}) and the theorem saying \holtxt{WBISIM_REL ts
  tau} is indeed an equivalence relation (in the LTS given by
\holtxt{ts} and \holtxt{tau}):
\begin{hol}
\begin{alltt}
##thm WBISIM_def
##thm WBISIM_REL_def
##thm WBISIM_REL_IS_EQUIV_REL
\end{alltt}
\end{hol}

In \ml{examples/CCS}, the \HOL{} distribution includes a comprehensive formalization of Milner's Calculus of Communicating Systems (CCS)~\cite{Mil89}, where the definitions of strong and weak bisimulations are based on the present \theoryimp{bisimulation} theory.

\subsection{Finite maps (\theoryimp{finite\_map})}
\label{sec:finite-map}

>>__ load "finite_mapTheory"; open finite_mapTheory;
>>__ set_grammar_ancestry ["finite_map"]

The theory \theoryimp{finite\_map} formalizes a type
$(\alpha,\beta)\,\holtxt{fmap}$ of finite functions. These notionally
have type $\alpha\to\beta$, but additionally have only finitely many
elements in their domain. Finite maps are useful for formalizing
substitutions and arrays. The representing type is $\alpha\to\beta +
\konst{one}$, where only a finite number of the $\alpha$ map to a
$\beta$ and the rest map to \verb+one+. The syntax
$\alpha\,\holtxt{|->}\,\beta$ is recognized by the parser as an
alternative to $(\alpha,\beta)\,\holtxt{fmap}$.

\paragraph {Basic notions}

The empty map (\holtxt{FEMPTY}), the updating of a map
(\holtxt{FUPDATE}), the application of a map to an argument
(\holtxt{FAPPLY}), and the domain of a map (\holtxt{FDOM}) are the
main notions in the theory.
\begin{hol}
\begin{verbatim}
   FEMPTY  : 'a |-> 'b
   FUPDATE : ('a |-> 'b) -> 'a # 'b -> ('a |-> 'b)
   FAPPLY  : ('a |-> 'b) -> 'a -> 'b
   FDOM    : ('a |-> 'b) -> 'a set
\end{verbatim}
\end{hol}

The \HOL{} parser and printer will treat the syntax \holtxt{f\,'\,x} as
the application of finite map \verb+f+ to argument \verb+x+, \ie, as
\holtxt{FAPPLY\,f\,x}. The notation \holtxt{f\,|+\,(x,y)} represents
\holtxt{FUPDATE\,f\,(x,y)}, \ie, the updating of finite map
\verb+f+ by the pair \verb+(x,y)+.

The basic constants have obscure definitions, from which more useful
properties are then derived. {\small\verb+FAPPLY_FUPDATE_THM+} relates
map update with map application.  {\small\verb+fmap_EXT+} is an
extensionality result: two maps are equal if they have the same domain
and agree when applied to arguments in that domain. One can prove
properties of finite maps by induction on the construction of the map
({\small\verb+fmap_INDUCT+}).  The cardinality of a finite map is
just the cardinality of its domain ({\small\verb+FCARD_DEF+}); from
this a recursive characterization ({\small\verb+FCARD_FUPDATE+}) is
derived.
\begin{hol}
\begin{alltt}
   ##thm FAPPLY_FUPDATE_THM
   ##thm fmap_EXT
   ##thm fmap_INDUCT
   ##thm FCARD_DEF
   ##thm FCARD_FUPDATE
\end{alltt}
\end{hol}
Iterated updates (\holtxt{FUPDATE\_LIST}) to a map are useful. The
infix notation \holtxt{|++} may also be used.  For example, \holtxt{fm\,|++\,[(k1,v1);\,(k2,v2)]} is equal to \holtxt{(fm\,|+\,(k1,v1))\,|+\,(k2,v2)}.
\begin{hol}
\begin{alltt}
   ##thm FUPDATE_LIST
   ##thm FUPDATE_LIST_THM
\end{alltt}
\end{hol}


\paragraph {Domain and range}

The domain of a finite map is the set of elements that it applies to;
this can be characterized recursively
({\small\verb+FDOM_FUPDATE+}). The range of a map is defined in the
usual way.
\begin{hol}
\begin{alltt}
   ##thm FDOM_FUPDATE
   ##thm FRANGE_DEF
\end{alltt}
\end{hol}
%
A finite map may have its domain ({\small\verb+DRESTRICT+})
or range ({\small\verb+RRESTRICT+}) restricted by intersection with a
set. These notions have recursive versions as well
({\small\verb+DRESTRICT_FUPDATE+} and {\small\verb+RRESTRICT_FUPDATE+}).
%
\begin{hol}
\begin{alltt}
   ##thm DRESTRICT_DEF
   ##thm RRESTRICT_DEF
   ##thm DRESTRICT_FUPDATE
   ##thm RRESTRICT_FUPDATE
\end{alltt}
\end{hol}
The removal of a single element from the domain of a map
(\holtxt{\bs\bs}, infix) is a simple application of
\holtxt{DRESTRICT}, but sufficiently useful to deserve its own
definition. Again, this concept has a alternate recursive presentation
(\holtxt{DOMSUB\_FUPDATE\_THM}).
%
\begin{hol}
\begin{alltt}
   ##thm fmap_domsub
   ##thm DOMSUB_FUPDATE_THM
\end{alltt}
\end{hol}
%
Similarly, the removal of multiple elements from the domain of a map (\holtxt{FDIFF}) is defined in terms of \holtxt{DRESTRICT}.
It too has an alternate recursive presentation.
%
\begin{hol}
\begin{alltt}
   ##thm FDIFF_def
   ##thm FDIFF_FUPDATE
\end{alltt}
\end{hol}

\paragraph {Union and sub-maps}

Unlike set union, the union of two finite maps (\holtxt{FUNION}) is not symmetric: the domain of the first map takes precedence.
The notion of a finite map being a submap of another (\holtxt{SUBMAP}, infix) is an extension of how subsets are formalized.
\begin{hol}
\begin{alltt}
   ##thm FUNION_DEF
   ##thm SUBMAP_DEF
\end{alltt}
\end{hol}

\paragraph {Merges}

The key-aware merge of two finite maps (\holtxt{FMERGE_WITH_KEY}) generalises the left-biased union of two finite maps (\holtxt{FUNION}).
In \holtxt{FMERGE_WITH_KEY f m1 m2}, rather than the domain of \holtxt{m1} taking precedence (as in \holtxt{FUNION}), overlapping keys and their associated values are processed by the function parameter \holtxt{f}.
\begin{hol}
\begin{alltt}
   ##thm FMERGE_WITH_KEY_DEF
\end{alltt}
\end{hol}
%
The key-ignorant merge of two finite maps (\holtxt{FMERGE}) specialises \holtxt{FMERGE_WITH_KEY}, and is itself a generalisation of \holtxt{FUNION}.
\begin{hol}
\begin{alltt}
   ##thm FMERGE_WITH_KEY_FMERGE
   ##thm FMERGE_FUNION
\end{alltt}
\end{hol}

\paragraph {Finite maps and functions}

As much as possible, finite maps should be like ordinary functions.
Thus, if \holtxt{f} is a finite map, then \holtxt{FAPPLY f} is an ordinary function.
Similarly, there is an operation for \emph{totalizing} a finite map (\holtxt{FLOOKUP}) so that an application of it returns an ordinary function, the range of which is the option type.
An ordinary function can be turned into a finite map by restricting the function to a finite set of arguments (\ml{FUN\_FMAP\_DEF}).
%
\begin{hol}
\begin{alltt}
   ##thm FLOOKUP_DEF

   ##thm FUN_FMAP_DEF
\end{alltt}
\end{hol}

\paragraph {Composition of maps}
\index{function composition, in HOL logic@function composition, in \HOL{} logic!of finite maps}

There are three new definitions of composition, determined by whether
the composed functions are finite maps or not. The composition of two
finite maps (\verb+f_o_f+, infix) has domain constraints
attached. Composition of a finite map with an ordinary function
(\verb+o_f+, infix) applies the finite map first, then the ordinary
function.  Composition of an ordinary function with a finite map
(\verb+f_o+, infix) applies the ordinary function and then the finite
map; the application of the ordinary function is achieved by turning
it into a finite map.
%
\begin{hol}
\begin{alltt}
   ##thm f_o_f_DEF
   ##thm o_f_DEF
   ##thm f_o_DEF
\end{alltt}
\end{hol}

\section{While Loops}
\label{sec:while-loops}

It is a curious fact that higher order logic, although a logic of
total functions, allows the definition of functions that don't
seem total, at least from a computational perspective. An example
is \holtxt{WHILE}-loops. The following equation is derived in theory
\theoryimp{while}:
%
\begin{hol}
\begin{alltt}
>>__ open whileTheory
##thm WHILE
\end{alltt}
\end{hol}
%
Clearly, if \holtxt{P} in this theorem was instantiated to $\lambda
x.\;\konst{T}$, the resulting instance of \holtxt{WHILE} would `run
forever' if executed. Why is such an ``obviously'' partial function
definable in HOL?
%
The answer lies in a subtle definition of \holtxt{WHILE},
\footnote{The original idea is due to J Moore,
          who suggested it for use in ACL2.}
which uses the expressive power of HOL to surprising effect. Consider
the following total and non-recursive function:
%
\begin{hol}
\begin{verbatim}
  \x. if (?n. P (FUNPOW g n x))
       then FUNPOW g (@n. P (FUNPOW g n x) /\
                          !m.  m < n ==> ~P (FUNPOW g m x)) x
       else ARB
\end{verbatim}
\end{hol}
%
This function does a case analysis on the iterations of function
\holtxt{g}: the finite ones return the first value in the iteration at
which \holtxt{P} holds (\ie, when the iteration stops); the infinite
ones are mapped to \holtxt{ARB}. This function is used as the witness
for \verb+f+ in the proof of the following theorem:
%
\begin{hol}
\begin{alltt}
##thm ITERATION
\end{alltt}
\end{hol}
%
From this, it is a simple application of Skolemization and
\holtxt{new\_specification} to obtain the equation for \holtxt{WHILE}.

\paragraph{Reasoning about \holtxt{WHILE} loops}

The induction theorem for \holtxt{WHILE} loops is proved by
wellfounded induction, and carries wellfoundedness constraints
limiting its application. In order to apply \verb+WHILE_INDUCTION+,
the instantiations for \verb+B+ and \verb+C+ must be known before
a wellfounded relation for \verb+R+ is found and used to eliminate the
constraints.
%
\begin{hol}
\begin{alltt}
##thm WHILE_INDUCTION
\end{alltt}
\end{hol}
%
A more refined level of support is provided by the standard Hoare
Logic \holtxt{WHILE} rule, phrased in terms of Hoare triples
(\holtxt{HOARE\_SPEC}).
%
\begin{hol}
\begin{alltt}
##thm HOARE_SPEC_DEF
##thm WHILE_RULE
\end{alltt}
\end{hol}
%
As a follow-on, an operator for finding the least number with property
\verb+P+ is defined.
%
\begin{hol}
\begin{alltt}
##thm LEAST_DEF
\end{alltt}
\end{hol}
%
The \holtxt{LEAST} constant is treated as a binder by the parser, which explains the special printing of the name above.
Its use as a binder can be seen in:
\begin{hol}
\begin{alltt}
##thm LEAST_LESS_EQ
\end{alltt}
\end{hol}
A fundamental result, the operation of which is embodied in the tactic \ml{LEAST\_ELIM\_TAC} is:
\begin{hol}
\begin{alltt}
##thm LEAST_ELIM
\end{alltt}
\end{hol}
If one wants a specified result even when the predicate is everywhere false, the \holtxt{OLEAST} function (also treated as a binder by the parser and pretty-printer) may be helpful:
\begin{hol}
\begin{alltt}
##thm OLEAST_def
\end{alltt}
\end{hol}

More theorems for reasoning about \holtxt{LEAST}, \holtxt{OLEAST} and \holtxt{WHILE} may be found in theory \theoryimp{while}.


%\section{Partial orders}

\section{Monads}
\index{monads|(}

\HOL{}'s simple type system means that it is impossible to define a general type of monad in the way that is possible in programming languages such as Haskell.
Nonetheless, a number of the types predefined in \HOL{}, such as options and lists, can indeed be seen as monads, and it is useful to be able to write functions over those types that leverage this view.
Equally, it is useful to be able to declare monads of one's own that can use the same syntactic facilities.

Monads are defined by their ``unit'' and ``bind'' functions, and these can be composed in expressive ways.
In particular, \HOL{} supports a syntax inspired by Haskell's do notation, wherein it is possible to write such functions as
\begin{session}
\begin{alltt}
>>__ load "monadsyntax";
>>__ monadsyntax.add_monadsyntax();
>>__ monadsyntax.enable_monad "list";
>> Definition mapM_def:
     mapM f [] = return [] ∧
     mapM f (x::xs) = do
        e  <- f x;
        es <- mapM f xs;
        return (e::es);
      od
   End

>> type_of “mapM”;
\end{alltt}
\end{session}

Again, because \HOL{} does not have a sufficiently expressive type system, though the notation is generic, the function is fixed to a particular monad instance.
In this case, the monad instance is that of lists.
We can use the \holtxt{mapM} function to implement what one might term a cross-product operation on lists:
\begin{session}
\begin{alltt}
>> EVAL “mapM I [[1;2;3]; [a;b]; [x;y;z]]”;
\end{alltt}
\end{session}

The general abstract syntax is described by the following grammar
\[
\begin{array}{rcl}
M &::=& e_{\alpha\,\texttt{\scriptsize M}} \;\;\mid\;\; \texttt{do}\;\, \mathit{binds}\,\;\texttt{od} \;\;\mid\;\;\texttt{return}\;e_\alpha\\
\mathit{binds} &::=& \mathit{bind}\;\texttt{;}^? \;\;\mid\;\; \mathit{bind}\,\texttt{;}\,\;\mathit{binds}\\
\mathit{bind} &::=& M \;\;\mid\;\; \mathit{vs}\;\,\texttt{\lt-}\;M \;\;\mid\;\; \mathit{vs}\;\,\texttt{\lt\lt-}\;e_\alpha
\end{array}
\]
where $\mathit{e}_\tau$ is a \HOL{} expression required to be of type $\tau$, and $\mathit{vs}$ is a single variable, or a tuple of variables (\eg, \holtxt{(x,y,z)}).
If a given $M$ has type \holtxt{:$\alpha$ M} for a monad instance \holtxt{M}, then writing a binding such as \holtxt{$v$~\lt-~$M$} will require variable $v$ to have type $\alpha$.
This variable is then bound in later bindings within the same \holtxt{do}-\holtxt{od} block.
One can also bind variables directly to expressions of the appropriate type with the \texttt{\lt\lt-} arrow.
This corresponds to an underlying \holtxt{let}-term, but equally, one can see \holtxt{$v$~\lt\lt-~$e$} as semantically equivalent to \holtxt{$v$~\lt-~return~$e$}.

The special monad syntax has a straightforward translation into underlying \HOL{} terms.
The \holtxt{do}-\holtxt{od} delimiters have no semantic effect; they can be viewed as a special form of parenthesis that identifies where the binding syntax is going to be used.\footnote{Indeed, writing \holtxt{do~$M$~od} for a single binding form $M$ will see the system print back $M$ on its own.}
Subsequently, the translation from $\mathit{vs}\;\holtxt{\lt-} M_1\holtxt{;}\;M_2$ is to $\holtxt{monad\_bind}\;M_1\;(\lambda\mathit{vs}.\,M_2)$, making it clear that $\mathit{vs}$ can be used (and is bound) in $M_2$.
If there is no variable-arrow on the first binding, then $M_1\holtxt{;}\;M_2$ translates to something equivalent to $\holtxt{monad\_bind}\;M_1\;(\holtxt{K}\;M_2)$, where \holtxt{K} is the K-combinator from \ml{combinTheory} (see Section~\ref{sec:combinTheory}).
As already suggested, $\mathit{vs}\;\holtxt{\lt\lt-}\;e\holtxt{;}\;M$ translates to $\holtxt{let}\;\mathit{vs}\;\holtxt{=}\;e\;\holtxt{in}\;M$.
Finally, the \holtxt{return} keyword is an overloading for the monad instance's unit function (which will have type $\alpha \to \alpha\,\holtxt{M}$).

\subsection{Declaring monads}

Monad instances have to be declared if the system is to support their parsing and pretty-printing.
The function responsible is \index{declare_monad@\ml{declare\_monad}}\ml{declare\_monad} in the \ml{monadsyntax} module.
\begin{alltt}
>>__ val SOME ms_struct =
       #lookupStruct PolyML.globalNameSpace "monadsyntax";
>>__ val ms_ns = PolyML.NameSpace.Structures.contents ms_struct;
>>__ val SOME minfo_ty = #lookupType ms_ns "monadinfo"
>>__ val SOME dm_val = #lookupVal ms_ns "declare_monad"
>>__ val dmval_p =
       PolyML.NameSpace.Values.printWithType(dm_val,100,NONE)
>>__ val minfo_p =
       PolyML.NameSpace.TypeConstrs.print (minfo_ty, 100, NONE)
>>__ val safeprint =
        TextIO.print o
        String.translate
          (fn #"{" => "\\{" | #"}" => "\\}" | c => str c)
>>__ val _ = PP.prettyPrint(safeprint, 70) minfo_p
>>__ val _ = PP.prettyPrint(safeprint, 70) dmval_p
\end{alltt}

The terms for the \ml{bind} and \ml{unit} fields are the terms implementing the corresponding monad functions.
For example, the bind function for the option function is \holtxt{OPTION\_BIND}, characterised by its defining theorem:
\begin{alltt}
>>__ open optionTheory
##thm OPTION_BIND_def
\end{alltt}
The unit function is just the \holtxt{SOME} constructor for the type.

All of the other fields in the \ml{monadinfo} record can be left unspecified.
The \ml{ignorebind} field is used to encode the situation where the user writes
\begin{alltt}
   do m1; m2 od
\end{alltt}
meaning that though \holtxt{m1} may return a value, the remainder of the function does not use that value.
As above, this can be handled through the use of the \holtxt{K} combinator, which is what is done if the \ml{ignorebind} field is set to \ml{NONE}.
However, if desired, one can specify a specific term to be used in this situation.
For example, the system's encoding of the option monad uses a separate constant with exactly the definition one would expect:
\begin{alltt}
##thm OPTION_IGNORE_BIND_def
\end{alltt}

The three remaining fields (\ml{guard}, \ml{fail} and \ml{choice}) are relevant for monads with errors or failure modes.
The underlying property is that if $m_1$ is an error value, then $\holtxt{monad\_bind}\;m_1\;f\;\;=\;\;m_1$, meaning that attempting to sequence computations after an error just causes the error to be the result, without any use of the $f$ value.
In this way, one might see $m_1$ as a computation that has thrown some sort of exception.

If one specifies a \ml{fail} term in declaring a monad, an overload is set up from the string \holtxt{fail} to that term.
This is flexible enough to allow parameterised errors: make the term be the function that takes a parameter and returns a monad error value.
There is no monad-specific support required for this concept: the overload is sufficient.

When provided, the \ml{guard} and \ml{choice} terms are similarly established as overloads so that monadic code across different monads will look similar.
If one views \ml{fail} as throwing an exception, then the \ml{choice} notation allows for catching an exception and trying another computation.
The overload is to the infix \holtxt{++} syntax, meaning that one can write
$M_1\;\holtxt{++}\;M_2$ to represent the ``choice'' between $M_1$ and $M_2$.
(Note that in the list monad, \holtxt{++} is \holtxt{APPEND}.
This explains the choice of notation, though in the list monad, viewing ``choice'' as throwing and catching exceptions is actually harder to motivate.)

Finally, the \ml{guard} term (if given) overloads to the term \holtxt{assert}, which is expected to be defined such that
\[
   \holtxt{assert}\;b\;\; = \;\;\textsf{if}\;b\;\textsf{then}\;\holtxt{return}\;()\;\textsf{else}\;\holtxt{fail}
\]
A typical use of \holtxt{assert} might be in a function such as
\begin{alltt}
  do
     list <- some_monad;
     assert(list <> []);
     return (HD list + 1)
  od
\end{alltt}
where the \holtxt{assert} ensures that the subsequent call to \holtxt{HD} makes sense.

\subsection{Enabling monad syntax}

There are two steps to being able to use monadic syntax.
Both steps \emph{persist}, meaning that their effects are preserved for the benefit of descendant theories.
Because of this persistence, the function calls implementing these two steps should only be used in \ml{$x$Script.sml} files.
As with other parsing and pretty-printing functions, there are \ml{temp\_} versions of the functions.
These do not cause persistence and can safely be used in other \ml{.sml} files (such as library implementations).

\smallskip
\noindent
The first step is to enable the generic monad syntax, by calling
\begin{alltt}
   monadsyntax.enable_monadsyntax : unit -> unit
\end{alltt}
After this, one can write \holtxt{do}\dots\holtxt{od} blocks, even though without any specific instances enabled the output will be unhelpful (the \holtxt{monad\_bind} printed in the session below is actually a variable):
\begin{session}
\begin{alltt}
>>__ monadsyntax.disable_monadsyntax();
>>__ List.app (monadsyntax.disable_monad o #1)
              (monadsyntax.all_monads());
>> monadsyntax.enable_monadsyntax();
>> “do x <- M1; M2 od”;
\end{alltt}
\end{session}

\smallskip
\noindent
One can see which monads have been declared with a call to \ml{all_monads}:
\begin{session}
\begin{alltt}
>> monadsyntax.all_monads()
\end{alltt}
\end{session}

Particular monads can be enabled with calls to \ml{enable\_monad}.
The most recently enabled is preferred when the context makes the choice ambiguous.

\begin{session}
\begin{alltt}
>> List.app monadsyntax.enable_monad ["list", "option"];

>> val t = “do x <- M; return (x + 1) od”;
>> type_of t;

>> val t' = “do x <- MAP f l; return (x + 1); od”;
>> type_of t';
\end{alltt}
\end{session}

\smallskip\noindent
Thanks to the persistence features of these API points, loading fresh theories may cause more monads to be declared and/or enabled:
\begin{session}
\begin{alltt}
>> load "errorStateMonadTheory";
>> monadsyntax.all_monads();
\end{alltt}
\end{session}

\smallskip\noindent
Everything that has been enabled can in turn be disabled, with calls drawn from:
\begin{alltt}
     disable_monad            : string -> unit
     temp_disable_monad       : string -> unit

     disable_monadsyntax      : unit -> unit
     temp_disable_monadsyntax : unit -> unit
\end{alltt}

\subsection{Some built-in monad theories}

See Figure~\ref{fig:bind-defns} for the bind definitions for a number of different monads that are present in the core HOL set of theories.
\begin{figure}[hbtp]
\begin{alltt}
>>__ app load ["readerMonadTheory", "state_transformerTheory",
               "errorStateMonadTheory"];
>>__ List.app (fn (s,_) => monadsyntax.disable_monad s)
              (monadsyntax.all_monads())
>>__ val oldwidth = !Globals.linewidth;
     val _ = Globals.linewidth := oldwidth - 10;
>>__ hide "BIND";
##thm errorStateMonadTheory.BIND_DEF

##thm listTheory.LIST_BIND_THM

##thm optionTheory.OPTION_BIND_def

##thm readerMonadTheory.BIND_def

##thm state_transformerTheory.BIND_DEF
>>__ val _ = Globals.linewidth := oldwidth;
\end{alltt}
\caption{Monad bind definitions}
\label{fig:bind-defns}
\end{figure}

\index{monads|)}

\section{Other Theories}
Other theories of interest in \HOL{} are listed and briefly described
in Figure~\ref{fig:further-hol-theories}.

\begin{figure}[hbtp]
\renewcommand{\arraystretch}{1.5}
\begin{tabular}{|p{0.2\textwidth}p{0.7\textwidth}|}
  \hline
  \theoryimp{poset} & Partial Orders, Knaster-Tarski theorem
  \\
  \theoryimp{divides}, \theoryimp{gcd} &
  Divisibility and the greatest common divisor.
  \\
  \theoryimp{poly} &
  A theory of polynomials over $\mathbb{R}$, providing
  a collection of operations on polynomials, and theorems about them.
  \\
  \theoryimp{Temporal\_Logic},\newline \theoryimp{Omega\_Automata}
  &
  Klaus Schneider's development of temporal logic and\newline $\omega$-automata.
  \\
  \theoryimp{ctl}, \theoryimp{mu}
  &
  Computation Tree Logic and the $\mu$-calculus. See Hasan Amjad's
  thesis. \\
  \theoryimp{lbtree} & Possibly infinitely deep (\ie, co-algebraic) binary trees.\\
  \theoryimp{inftree} & Possibly infinitely branching, algebraic trees\\
  \hline
\end{tabular}
\caption{A selection of \HOL{} theories}
\label{fig:further-hol-theories}
\end{figure}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:

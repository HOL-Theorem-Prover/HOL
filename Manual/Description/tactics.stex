\chapter{Goal Directed Proof: Tactics and Tacticals}

\label{tactics-and-tacticals}

\index{tactics!purpose of|(}
There are three primary devices that together make theorem proving practical
in \HOL. All three originate with Milner
\index{Milner, R.}%
\index{LCF@\LCF!Edinburgh}%
for Edinburgh \LCF.
The first is the theory as
a record of (among other things) facts already proved
and thence available as lemmas
\index{lemmas}
without having to be re-proved.  The second,
the subject of Chapter~\ref{derived-rules}, is the
derived rule of inference as a meta-language procedure that implements a
broad pattern of inference, but that also, at each application,
generates every primitive step of the proof. The third device is
the tactic as a means of organizing the construction of proofs;
and the use of tacticals for composing tactics.

Even with recourse to derived inference rules, it is still surprisingly awkward to work forward, \index{forward proof!compared to goal-directed} to find a chain of theorems that culminates in a desired theorem.
This is in part because chains have no structure, while `proof efforts' do.  For instance, if within one sequence, two chains of steps are to be combined in the end by conjunction, then one chain must follow or be interspersed with the other in the overall sequence.
It can also be difficult to direct the proof toward its object when starting from only hypotheses (if any), lemmas (if any), axioms, and theorems following from no hypotheses (\eg,\ by \ml{ASSUME} or \ml{REFL}).
\index{tactics!as documentation of proofs}%
Likewise, it can be equally difficult to reconstruct the plan of the proof effort after the fact, from the linear sequence of theorems; the sequence is unhelpful as documentation.

The idea of goal directed proof\index{goal directed proof search!reason for} is a simple one, well known in
artificial intelligence: to organize the search\index{proof construction!as tree search} as a tree, and to reverse
the process and {\it begin\/} with the objective. The goal is then
decomposed, successively if necessary,
into what one hopes are more tractable subgoals, each decomposition
accompanied by a
plan for translating the solution of subgoals into a solution of the goal.
The choice of decomposition is an explicit way of expressing a proof
`strategy'.
\index{strategies, for proof}

Thus, for example, instead of
the linear sequencing of two branches of the proof of the conjunction,
each branch starting from scratch, the proof task is organized
as a tree search, starting with a conjunctive goal
and decomposing it into the two conjunct subgoals (undertaken in optional
order), with the intention of conjoining the two solutions when and if found.
The proof itself, as a sequence of steps, is the same however it is found;
the difference is in the search, and in the preservation, if required, of
the structured proof plan.

The representation of this idea in \LCF\ was Milner's inspiration;
the idea is similarly central to theorem proving in \HOL.
Although subgoaling theorem provers had already been built at the time,
Milner's particular contribution was in formalizing the method for
translating subgoals solutions to solutions of goals.



%The tactics and tacticals in the \HOL{} system are derived from those in the
%Cambridge \LCF\ system \cite{new-LCF-man} (which evolved
%from the ones
%in Edinburgh \LCF\ \cite{Edinburgh-LCF}).

\section{Tactics, Goals and Validations}
\label{tactics}

\index{goal directed proof search!concepts of|(}
A \emph{tactic}\index{proof steps, as ML function applications@proof steps, as \ML{} function applications} is an \ML{} function that when applied to a \emph{goal}\index{goals, in HOL system@goals, in \HOL{} system} reduces it to
(i) a list\footnote{The ordering is necessary for selecting a tree search strategy.} of (sub)goals, along with
(ii) a \emph{validation}\index{validations, in goal-directed proof search} function mapping a list of theorems to a theorem.
The idea is that this function justifies the decomposition of the goal, and so it is also known as a \emph{justification}.
A goal is an \ML{} value whose type is isomorphic to, but distinct from, the \ML{} abstract type \ml{thm} of theorems.
That is, a goal is a list of terms (\emph{assumptions})\index{assumption list, of goal} paired with a term.\index{term component, of goal}
These two components correspond, respectively, to the list of hypotheses
and the conclusion of a theorem.
The list of assumptions is a working record of facts that may be used in decomposing the goal.

The relation of theorems to goals is achievement:
\index{achievement, of goals}
a theorem achieves a goal if the conclusion of the theorem
is equal to the term part of the goal (up to $\alpha$-conversion), and
if each hypothesis of the theorem is equal (up to $\alpha$-conversion,
again) to some assumption of the goal. This definition assures that
the theorem purporting to satisfy a goal does not depend on
assumptions beyond the working assumptions of the goal.

A tactic is said to \emph{solve}\index{solving, of goals} a goal if it reduces the goal to the empty set of subgoals.
This depends, obviously, on there being at least one tactic that maps a goal to the empty subgoal list.
The simplest tactic that does this is one that can recognize when a goal is achieved by an axiom or an existing theorem; in \HOL, the function \ml{ACCEPT\_TAC}\index{ACCEPT_TAC@\ml{ACCEPT\_TAC}} does this. \ml{ACCEPT\_TAC} takes a theorem $\mathit{th}$
and produces a tactic that maps a value of type \ml{thm} to the empty list of subgoals.
It justifies this `decomposition' by a validation function that maps the empty list of theorems to the theorem $\mathit{th}$.
The use of this technical device, or other such tactics, ends the decomposition of subgoals, and allows the proof to be built up.\index{tactics!purpose of|)}

Unlike theorems, goals need not be defined as an abstract type; they are transparent and can be constructed freely. Thus, an \ML{} type abbreviation is introduced for goals.
The operations on goals are therefore just the ordinary pair selectors and constructor.
Likewise, type abbreviations are introduced for validations and tactics. Conceptually, the following abbreviations are made in \HOL:

\begin{hol}
\index{goal@\ml{goal}}
\index{tactic@\ml{tactic}}
\index{proof@\ml{proof}}
\index{tactics!ML type of@\ML{} type of}
\begin{verbatim}
   goal       = term list * term
   tactic     = goal -> goal list * validation
   validation = thm list -> thm
\end{verbatim}
\end{hol}

It does not follow, of course, from the type \ml{tactic} that a particular tactic is well-behaved.
For example, suppose that $T\ g${\small\verb% = ([%}$g_1${\small\verb%,%}$\ldots ${\small\verb%,%}$g_n${\small\verb%],%}$v${\small\verb%)%}, and that the subgoals $g_1$ , $\dots$, $g_n$ have been solved.
That means that some theorems $\mathit{th}_1$ , $\dots$, $\mathit{th}_n$ have been proved such that each $\mathit{th}_i$ ($1\leq i\leq n$) achieves the goal $g_i$.
The validation $v$ is intended to be a function that when applied to the list {\small\verb%[%}$\mathit{th}_1${\small\verb%,%}$\ldots${\small\verb%,%}$\mathit{th}_n${\small\verb%]%}, succeeds in returning a theorem, $\mathit{th}$, achieving the original goal $g$; but, of course, it might sometimes not succeed.
If $v$ succeeds for every list of achieving theorems, then the tactic $T$ is said to be \emph{valid}\index{validity, of tactics|(}.
This does not guarantee, however, that the subgoals are solvable in the first place.
If, in addition
to being valid, a tactic always produces solvable subgoals from a
solvable goal, it is called \emph{strongly valid}.\index{strong validity, of tactics}

Tactics can be perfectly useful without being
strongly valid, or without
even being valid;
in fact, some of the most basic theorem proving strategies, expressed
as tactics, are invalid or not strongly valid.\footnote{The subgoal
  package, discussed in Section~\ref{sec:goalstack}, prevents the use of
  invalid tactics when they are liable to result in unexpected
  theorem results, but the \HOL{} system used directly allows
  it.}
An invalid tactic cannot result in the proof of false theorems;
\index{consistency, of HOL logic@consistency, of \HOL{} logic|(}
\index{security, in goal directed proof|(}
theorems in \HOL{} are always the result of performing a proof in the
basic logic, whether the proof is found by goal directed search
or forward search.\footnote{`Invalid' is perhaps a misleading term, since
  there is nothing logically amiss in the use of invalid tactics
  or the theorems produced thereby; but the term has stuck over time.}
However, an invalid tactic may produce an unintended theorem---one
that does not achieve the original goal. The typical case is when a
theorem purporting to achieve a goal actually depends on hypotheses
that extend beyond the assumptions of the goal.  The inconvenience to
the \HOL{} user in this case is that the problem may be not
immediately obvious; the default print format of theorems has
hypotheses abbreviated as dots. Invalidity may also be the result of
the failure
\index{failure, of tactics|(}
of the proof function, in the \ML{} sense of failure, when
applied to a list of theorems (if, for example, the function were
defined incorrectly); but again, no false theorems can result.
Likewise, a tactic that is not strongly valid cannot result in a false
theorem; the worst outcome of applying such a tactic is the production
of unsolvable subgoals%
\index{consistency, of HOL logic@consistency, of \HOL{} logic|)}%
\index{security, in goal directed proof|)}\index{validity, of tactics|)}.

Tactics are specified using the following notation:
\index{notation!for specification of tactics}

\begin{center}
\begin{tabular}{c} \\
$\mathit{goal}$ \\ \hline \hline
$\mathit{goal}_1\ \ \ \mathit{goal}_2 \ \ \ \ldots\ \ \ \mathit{goal}_n$ \\
\end{tabular}
\end{center}

\noindent For example, the tactic for decomposing conjunctions into two  conjunct subgoals is called {\small\verb%conj_tac%}.\index{conj_tac@\ml{conj\_tac}}\footnote{The tactic is also available under the name \ml{CONJ\_TAC}.}
It is described by:
\begin{center}
\begin{tabular}{lcr}
\multicolumn{3}{c}{$t_1 \quad\land\quad t_2$} \\ \hline \hline
$t_1$ & & $t_2$
\end{tabular}
\end{center}

\noindent This indicates that {\small\verb%conj_tac%} reduces a goal of the form
{\small\verb%(%}$\Gamma${\small\verb%,%}$t_1${\small\verb%/\%}$t_2${\small\verb%)%}
to subgoals
{\small\verb%(%}$\Gamma${\small\verb%,%}$t_1${\small\verb%)%} and {\small\verb%(%}$\Gamma${\small\verb%,%}$t_2${\small\verb%)%}.
The fact that the assumptions of the original goal
are propagated unchanged to the two subgoals is indicated by the absence
of assumptions in the notation. The notation gives no indication of the
proof function.

Another example is {\small\verb%numLib.INDUCT_TAC%}\index{INDUCT_TAC@\ml{INDUCT\_TAC}}\index{induction tactics}, a low-level tactic for performing mathematical induction on the natural numbers:

\begin{center}
\begin{tabular}{lcr} \\
\multicolumn{3}{c}{$\forall n.\;t[n]$}\\ \hline \hline
$t[${\small\verb%0%}$]$ & &  $\{t[n]\}\ t[${\small\verb%SUC %}$n]$
\end{tabular}
\end{center}

Thus, {\small\verb%INDUCT_TAC%} reduces a goal of the form
{\small\verb%(%}$\Gamma,\forall n.\;t[n]${\small\verb%)%} to a basis subgoal
{\small\verb%(%}$\Gamma${\small\verb%,%}$t[${\small\verb%0%}$]${\small\verb%)%}
and an induction step subgoal
{\small\verb%(%}$\Gamma\cup\{${\small\verb%%}$t[n]${\small\verb%%}$\}${\small\verb%,%}$t[${\small\verb%SUC %}$n]${\small\verb%)%}.
The induction assumption is indicated in the tactic notation with set brackets.

Tactics fail \index{failure, of tactics|)} (in the \ML{} sense) if they are applied to inappropriate goals.
For example, {\small\verb%conj_tac%} will fail if it is applied to a goal whose conclusion is not a conjunction.
Some tactics never fail; for example
{\small\verb%all_tac%}\index{all_tac@\ml{all\_tac}}

\begin{center}
\begin{tabular}{c} \\
$t$ \\ \hline \hline
$t$
\end{tabular}
\end{center}

\noindent is the identity tactic;
\index{identity tactic} it reduces a goal
{\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%}
to the single
subgoal {\small\verb%(%}$\Gamma${\small\verb%,%}$t${\small\verb%)%}---\ie,\
it has no effect.
The {\small\verb%all_tac%} tactic is useful for writing
compound tactics, as discussed later~(see Section~\ref{tacticals}).

In just the way that the derived rule \ml{REWRITE\_RULE}\index{rewrite_tac@\ml{rewrite\_tac}|(} can be used in forward proof (Section~\ref{sec:rewriting}), the corresponding tactic \ml{rewrite\_tac}\index{rewriting!main tactic for|(}\index{rewriting!importance of, in goal directed proof|(} can be used in goal-directed proof.
Given a goal and a list of equational theorems, \ml{rewrite\_tac} transforms the term component of the goal by applying the equations as left-to-right rewrites, recursively and to all depths, until no more changes can be made.
Unless not required, the function includes as rewrites the same standard set of pre-proved tautologies \index{tautologies, in rewriting tactic} that \ml{REWRITE\_RULE} uses.
By use of the tautologies, some subgoals can be solved
internally by rewriting, and in that case, an empty list of subgoals
is returned. The transformation of the goal is justified in each case by the
appropriate chain of inferences.
Rewriting is a simple implementation of an extremely powerful idea.
The more sophisticated simplification functions~(\eg, \ml{simp}; see Section~\ref{sec:simpLib}) often do a very large share of the work in goal directed proof searches.\index{goal directed proof search!concepts of|)}
\index{rewrite_tac@\ml{rewrite\_tac}|)}
\index{simplification}
\index{rewriting!importance of, in goal directed proof|)}
\index{rewriting!main tactic for|)}

A simple example from list theory (Section~\ref{sec:list})
illustrates the use of tactics.
A conjunctive goal is declared, and \ml{conj\_tac} applied to it:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>> val gl0 = ([]:term list,``(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])``);

>> val (gl1,p1) = conj_tac gl0;
\end{alltt}
\end{session}

\noindent The subgoals are each rewritten, using the definitions of
\ml{HD} and \ml{TL}:

\begin{session}
\begin{alltt}
>>_ open listTheory;

>> HD;

>> TL;

>> val (gl1_1,p1_1) = rewrite_tac[HD,TL](hd gl1);

>> val (gl1_2,p1_2) = rewrite_tac[HD,TL](hd(tl gl1));
\end{alltt}
\end{session}

\noindent Both of the two subgoals are now solved, so the
decomposition is complete and the proof can be built up in stages.
First the theorems achieving the subgoals are proved, then from those,
the theorem achieving the original goal:
\begin{session}
\begin{alltt}
>> val th1 = p1_1[];

>> val th2 = p1_2[];

>> p1[th1,th2];
\end{alltt}
\end{session}

\noindent Although only the theorems achieving the subgoals are `seen' here,
the proof functions of the three tactic applications together perform
the entire chain\index{goal directed proof search!generation of proofs by}\index{proofs, in HOL logic@proofs, in \HOL{} logic!as generated by tactics}
 of inferences leading to the theorem achieving the goal.
The same proof could be constructed by forward search, starting from
the definitions of \ml{HD} and \ml{TL}, but not nearly as easily.

The \HOL{} system provides a very large collection of pre-defined tactics that includes
\ml{conj\_tac}, \ml{INDUCT\_TAC}, \ml{all\_tac}  and
\ml{rewrite\_tac}.
The pre-defined tactics are adequate for many applications.
In addition, there are two means of defining new tactics.
\index{tactics!definition of new}
Since a tactic\index{proof steps, as ML function applications@proof steps, as \ML{} function applications} is an \ML{} function, the user
can define a new tactic directly in \ML.  Definitions of this sort
use \ML{} functions to construct the term part of the subgoals from
the term part of the original goal (if any transformation is required);
and they specify the justification,
which expects a list of theorems achieving the subgoals and
returns the theorem achieving (one hopes) the goal.
The proof of the theorem is encoded in the definition of the justification
 function;
that is, the means for deriving the desired theorem from the theorems
given. This typically involves references to axioms and
primitive and defined inference rules,
and is usually the more difficult part of the project.

A simple example of a tactic written in \ML\index{proofs, in HOL logic@proofs, in \HOL{} logic!as ML function applications@as \ML{} function applications}\ is afforded by \ml{conj\_tac},
whose definition in \HOL{} is as follows:

\begin{hol}
\index{conj_tac@\ML{conj\_tac}!ML implementation of@\ML{} implementation of}
\begin{verbatim}
   fun conj_tac (asl,w) =
     let val (l,r) = dest_conj w
     in
         ([(asl,l), (asl,r)],(fn [th1, th2] => CONJ th1 th2))
     end
\end{verbatim}
\end{hol}

\noindent This shows how the subgoals are constructed, and how the
proof function is specified in terms of the derived rule \ml{CONJ}~(Section~\ref{sec:conj}).

The second method is to compose
\index{tactics!indirect implementation of}%
\index{tactics!compound}%
\index{proof construction}%
existing tactics by the use
of \ML{} functions called {\it tacticals\/}.
\index{tacticals}
The tacticals provided in \HOL{} are listed in Section~\ref{tacticals}.
For example, two existing tactics can be sequenced
\index{sequencing!of tactics}%
\index{tactics!sequencing of}%
 by use of the
tactical \ml{>>}\footnote{The \ml{>>} function can also be written as \ml{THEN} or as \ml{\bs\bs}.}:\index{THEN@\ml{THEN}}\index{ THEN@\ml{\bs\bs} (\ml{THEN} tactical)|see{\ml{THEN}}}
if $T_1$ and
$T_2$ are  tactics,  then the  \ML{} expression  $T_1${\small\verb% >> %}$T_2$
evaluates to a  tactic that first applies  $T_1$ to  a goal  and then applies
$T_2$ to each subgoal produced by $T_1$.   The  tactical {\small\verb%>>%} is
an infixed \ML{} function. Complex and powerful tactics can be
constructed in this way; and new tacticals can also be defined, although
this is unusual.

The example from earlier
is continued, to illustrate the use of the tactical \ml{>>}:

\begin{session}
\begin{alltt}
>> val (gl2,p2) = (conj_tac >> rewrite_tac [HD, TL]) gl0;

>> p2 [];
\end{alltt}
\end{session}

\noindent The single tactic \ml{conj\_tac >> rewrite\_tac[HD;TL]}
solves the goal in one single application. The chain of inference computed,
however, is exactly the same as in the interactive proof; only the search is
different.

In general, the second method is both easier and more reliable.  It is
easier because it does not involve writing \ML{} procedures (usually
rather complicated procedures); and more reliable because
the composed tactics are valid
\index{validity, of tactics} when the constituent tactics are valid,
as a consequence of the way the tacticals are defined. Tactics written
directly in \ML{} may fail
\index{failure, of tactics!debugging}%
\index{failure, of tactics|(}%
\index{debugging, of tactics}%
\index{tactics!debugging of}%
in a variety of ways, and although, as usual, they cannot cause false
theorems to appear, the failures can be difficult to understand and
trace.
On the other hand, there are some proof strategies that cannot be implemented as compositions of existing tactics, and these have to be implemented directly in \ML.
Certain sorts of inductions are an example of this; as well as tactics
to support some personal styles of proof.

Either sort of tactic can be difficult to apply by hand, as shown in the examples above.
There can be a lot of book-keeping required to support such an activity.
For this reason, most interactive theorem-proving uses the subgoal or goalstack package described in Section~\ref{sec:goalstack}.


\section{\texorpdfstring{Some Tactics Built into \HOL{}}{Some Tactics Built into HOL}}

This section contains a selection of the more commonly
\index{tactics!list of some|(}
used tactics in the \HOL{} system. (See \REFERENCE\
for the complete list, with fuller explanations.)

It should be recalled that the \ML{} type \ml{thm\_tactic} abbreviates
\ml{thm->tactic}, and the type \ml{conv} abbreviates \ml{term->thm}.

\subsection{Specialization}\index{universal quantifier, in HOL logic@universal quantifier, in \HOL{} logic!tactics for}

\index{gen_tac@\ml{gen\_tac}|pin}
\begin{holboxed}
\begin{verbatim}
   gen_tac : tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\index{specialization tactic}
\item[Summary:]
Specializes a universally quantified theorem to an arbitrary value.
Also available under the name \ml{GEN_TAC}.


\begin{center}
\begin{tabular}{c} \\
$\forall{}x${\small\verb%.%}$t[x]$
\\ \hline \hline
$t[x']$
\\
\end{tabular}
\end{center}

\noindent where $x'$ is a variant of $x$
not free in either goal or assumptions.

\item{\bf   Use:} Solving universally quantified goals.
\ml{gen\_tac} is often the first step of a goal directed proof.
{\small\verb%strip_tac%} (see below)
applies {\small\verb%gen_tac%} to universally quantified goals.
\end{description}

\subsection{Conjunction}

\index{conj_tac@\ml{conj\_tac}|pin}
\begin{holboxed}
\begin{verbatim}
   conj_tac : tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\index{conjunction, in HOL logic@conjunction, in \HOL{} logic!tactic for splitting of}
\item[Summary:] Splits a goal $t_1\land t_2$ into two subgoals, $t_1$ and $t_2$.

\begin{center}
\begin{tabular}{c} \\
$t_1${\small\verb% /\ %}$t_2$
\\ \hline \hline
$t_1\ \ \ \ \ \ t_2$
\\
\end{tabular}
\end{center}

\item[Use:] Solving conjunctive goals.
{\small\verb%conj_tac%} is also invoked by {\small\verb%strip_tac%} (see below).

\end{description}

\subsection{Combined simple decompositions}

\index{strip_tac@\ml{strip\_tac}|pin}
\begin{holboxed}
\begin{verbatim}
   strip_tac : tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\item[Summary:] Breaks a goal apart.
The tactic {\small\verb%strip_tac%} removes one outer connective from the goal, using
{\small\verb%conj_tac%}, {\small\verb%gen_tac%}, and other tactics.
If the goal has the form $t_1\land \cdots \land t_n${\small\verb% ==> %}$t$
then {\small\verb%strip_tac%} makes each $t_i$ into a separate assumption.

\item[Use:] Useful for splitting a goal up into manageable pieces.
Often the best thing to do first is {\small\verb%rpt strip_tac%},
where \ml{rpt} is the tactical that repeatedly applies a tactic
until it fails (see Section~\ref{sec:repeat}).
\end{description}



\subsection{Case analysis}
\index{case analysis, in HOL logic@case analysis, in \HOL{} logic!tactics for|(}

\index{Cases_on@\ml{Cases\_on}|(}
\begin{holboxed}
\begin{verbatim}
   Cases_on : term quotation -> tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\item[Summary:]
\ml{Cases\_on}~$q$, where $q$ is a quotation denoting a term of an algebraic type (\eg, booleans, lists, natural numbers, types defined by the user with \ml{Datatype}), does case analysis on that term.
Let the relevant type have $m$ constructors $\textsf{C}_1$ to $\textsf{C}_m$, where $\textsf{C}_i$ has $n_i$ arguments.
If the term is a variable, then the variable is substituted out of the goal entirely:

\begin{center}
\begin{tabular}{c} \\
$t$
\\ \hline \hline
$t[q := \textsf{C}_1\,a_{11}\cdots a_{1n_1}]\quad\cdots\quad
t[q := \textsf{C}_m\,a_{m1}\cdots a_{mn_m}]$
\\
\end{tabular}
\end{center}

If the term denoted by $q$ is not simply a variable (\eg, \ml{Cases\_on`n~+~1`}), then fresh assumptions are introduced:
\begin{center}
\begin{tabular}{c} \\
$t$
\\ \hline \hline
$\{q := \textsf{C}_1\,a_{11}\cdots a_{1n_1}\}t\quad\cdots\quad
\{q := \textsf{C}_m\,a_{m1}\cdots a_{mn_m}\}t$
\\
\end{tabular}
\end{center}
\item[Use:] Case analysis.
\end{description}
\index{Cases_on@\ml{Cases\_on}|)}

\subsection{Rewriting}
\label{rewrite}

\index{rewriting!main tactic for|(}
\begin{holboxed}
\index{rewrite_tac@\ml{rewrite\_tac}|pin}
\begin{verbatim}
   rewrite_tac : thm list -> tactic
\end{verbatim}
\end{holboxed}
\begin{description}
\item[Summary:] {\small\verb%rewrite_tac[%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%}
transforms the term part of a goal by rewriting
it with the given theorems $th_1$, $\dots$, $th_n$,
and the set of pre-proved standard tautologies\index{tautologies, in rewriting tactic}.
Also written \ml{REWRITE\_TAC}.


\begin{center}
\begin{tabular}{c} \\
$\{t_1, \ldots , t_m\}t$
\\ \hline \hline
$\{t_1, \ldots , t_m\}t'$
\\
\end{tabular}
\end{center}

\noindent where $t'$ is obtained from $t$ as described.

\item[Use:] Advancing goals by using definitions and
previously proved theorems.


\item[Other rewriting tactics] (based on \ml{rewrite\_tac}) are:
\begin{enumerate}
\item {\small\verb%asm_rewrite_tac%}\index{asm_rewrite_tac@\ml{asm\_rewrite\_tac}} adds the assumptions of the goal to the list of theorems used for rewriting.
Also written \ml{ASM\_REWRITE\_TAC}.

\index{PURE_ASM_REWRITE_TAC@\ml{PURE\_ASM\_REWRITE\_TAC}}
\item {\small\verb%PURE_ASM_REWRITE_TAC%} is like {\small\verb%asm_rewrite_tac%}, but it
doesn't use any built-in rewrites.
\index{PURE_REWRITE_TAC@\ml{PURE\_REWRITE\_TAC}}
\item {\small\verb%PURE_REWRITE_TAC%} uses neither the assumptions nor the built-in rewrites.
\index{FILTER_ASM_REWRITE_TAC@\ml{FILTER\_ASM\_REWRITE\_TAC}}
\item {\small\verb%FILTER_ASM_REWRITE_TAC %}$p${\small\verb% [%}$th_1${\small\verb%,%}$\ldots${\small\verb%,%}$th_n${\small\verb%]%}
simplifies the goal by rewriting
it with the explicitly given theorems $th_1$ , $\dots$, $th_n$ ,
together with those
assumptions of the goal which satisfy the predicate $p$ and also
the standard rewrites.

\end{enumerate}

See also the more powerful simplification tactics described in Section~\ref{sec:simpLib}.

\end{description}

\index{rewriting!main tactic for|)}


\subsection{Resolution by Modus Ponens}

\index{implication, in HOL logic@implication, in \HOL{} logic!tactics for}
\index{imp_res_tac@\ml{imp\_res\_tac}|pin}
\begin{holboxed}
\begin{verbatim}
   imp_res_tac : thm -> tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\index{resolution tactics}
\item[Summary:]
\ml{imp\_res\_tac}~$th$ does a limited amount of automated theorem proving in the form of forward inference; it `resolves' the theorem $th$ with the assumptions of the goal and adds any new results to the assumptions.
The specification for \ml{imp\_res\_tac} is:

\begin{center}
\begin{tabular}{c} \\
$\{t_1,\ldots,t_m\}t$
\\ \hline \hline
$\{t_1,\ldots,t_m,u_1,\ldots,u_n\}t$
\\
\end{tabular}
\end{center}

\noindent  where $u_1$, $\dots$, $u_n$ are derived by `resolving' the theorem $th$ with the existing assumptions $t_1$, $\dots$, $t_m$.
Resolution in \HOL{} is not classical resolution, but just Modus Ponens with one-way pattern matching (not unification) and term and type instantiation.
The general case is where $th$ is of the canonical form

$\ \ \ ${\small\verb%|- !%}$x_1$$\ldots x_p${\small\verb%.%}$v_1$ {\small\verb%==>%} $v_2$ {\small\verb%==>%} $\ldots$ {\small\verb%==>%} $v_q$ {\small\verb%==>%} $v$

\noindent
\ml{imp\_res\_tac}~$th$ then tries to specialize $x_1$, $\dots$, $x_p$ in succession so that $v_1$, $\dots$, $v_q$ match members of $\{t_1,\ldots ,t_m\}$.
Each time a match is found for some antecedent $v_i$, for $i$ successively equal to $1$, $2$, \dots, $q$, a term and type instantiation is made and the rule of Modus Ponens is applied.
If all the antecedents $v_i$ (for $1 \leq i \leq q$) can be dismissed in this way, then the appropriate instance of $v$ is added to the assumptions.
Otherwise, if only some initial sequence $v_1$, \dots, $v_k$ (for some $k$ where $1 < k < q$) of the assumptions can be dismissed, then the remaining implication:

$\ \ \ ${\small\verb%|- %} $v_{k+1}$ {\small\verb%==>%} $\ldots$ {\small\verb%==>%} $v_q$ {\small\verb%==>%} $v$

\noindent is added to the assumptions.

For a more detailed description of resolution and \ml{imp\_res\_tac}, see
\REFERENCE.  (See also the Cambridge \LCF\ Manual \cite{new-LCF-man}.)

\item[Use:] Deriving new results from a previously proved implicative
theorem, in combination with the current assumptions, so that subsequent
tactics can use these new results.

\end{description}




\subsection{Identity}

\index{all_tac@\ml{all\_tac}|pin}
\begin{holboxed}
\begin{verbatim}
   all_tac : tactic
\end{verbatim}
\end{holboxed}

\begin{description}
\index{identity tactic}\index{tactics!identity for}
\index{THEN@\ml{THEN}}
\item[Summary:] The identity tactic for the tactical \ml{\gt\gt} (see the example in Section~\ref{tactics}, and Section~\ref{sec:sequencing-tacticals}). Useful for writing tactics.

\item[Use:]
\begin{enumerate}
\index{REPEAT@\ml{REPEAT}}
\item Writing tacticals (see description of \ml{rpt} in Section~\ref{tacticals}).
\index{THENL@\ml{THENL}}
\index{ THENL tactical@\ml{\gt\pipe} (\ml{THENL} tactical)|see{\ml{THENL}}}
\item
With \ml{THENL} (see Section~\ref{sec:thenl}); for example, if tactic $T$ produces two subgoals and $T_1$ is to be applied to the first while nothing is to be done to the second, then $T\;\ml{THENL}\;[T_1,\,\ml{all\_tac}]$ is the
tactic required.
\end{enumerate}
\end{description}

\subsection{Splitting logical equivalences}


\begin{holboxed}
\index{eq_tac@\ml{eq\_tac}|pin}
\index{equality, in HOL logic@equality, in \HOL{} logic!tactic for splitting}
\begin{verbatim}
   eq_tac : tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\item[Summary:]
\ml{eq_tac} splits an equational goal into two implications (the `if-case' and the `only-if' case):

\begin{center}
\begin{tabular}{c} \\
$u \iff v$
\\ \hline \hline
$u\ \Rightarrow\ v \qquad v\ \Rightarrow\ u$
\\
\end{tabular}
\end{center}

\item[Use:]
Proving logical equivalences, \ie, goals of the form ``$u\iff v$'' where $u$ and $v$ are boolean terms.
Note that the same end can often be achieved by rewriting with the theorem \ml{EQ\_IMP\_THM}, which states
\[
\vdash (u \iff v) \iff (u \Rightarrow v) \land (v \Rightarrow u)
\]

\end{description}

\subsection{Solving existential goals}


\begin{holboxed}
\index{EXISTS_TAC@\ml{EXISTS\_TAC}|pin}
\index{existential quantifier, in HOL logic@existential quantifier, in \HOL{} logic!tactic for}
\begin{verbatim}
   EXISTS_TAC : term -> tactic
\end{verbatim}
\end{holboxed}

\begin{description}

\item[Summary:]
$\ml{EXISTS\_TAC}\;u$ reduces an existential goal $\exists x.\;t[x]$ to the subgoal $t[u]$.
(In ASCII form, the existential is printed as a question mark.)

\begin{center}
\begin{tabular}{c} \\
$\ml{?}x\ml{.} t[x]$
\\ \hline \hline
$t[u]$
\\
\end{tabular}
\end{center}

\item[Use:] Proving existential goals.

\end{description}
\index{tactics!list of some|)}

\section{Tacticals}
\label{tacticals}

\index{tactics!tacticals for|(}
\index{tacticals|(}
\index{tacticals!list of some|(}
\index{tacticals!purpose of}
A {\it tactical\/} is not represented by a single \ML{} type,
but is in general
an \ML{} function that returns a tactic (or tactics) as result.
Tacticals may take parameters, and this is reflected in the variety of
\ML{} types that the built-in tacticals have.
Tacticals are used for building compound tactics.\index{compound tactics, in HOL system@compound tactics, in \HOL{} system}
\index{tactics!compound}
Some important tacticals in
the \HOL{} system
are listed below.
For a complete list of the tacticals in \HOL{} see \REFERENCE.

\subsection{Alternation}\index{alternation!of tactics|(}\index{tactics!alternation of}

\index{ORELSE@\ml{ORELSE}|pin}
\begin{holboxed}
\begin{verbatim}
   ORELSE : tactic -> tactic -> tactic
\end{verbatim}
\end{holboxed}


The tactical {\small\verb%ORELSE%}
is an \ML{} infix. If $T_1$ and $T_2$ are tactics,
\index{tacticals!for alternation}
then the \ML{} expression $T_1${\small\verb% ORELSE %}$T_2$
evaluates to a tactic which applies $T_1$ unless that fails;
if it fails,
it applies $T_2$. \ml{ORELSE} is defined in \ML\
as a curried infix by

\begin{hol}
\begin{verbatim}
   (T1 ORELSE T2) g = T1 g handle HOL_ERR _ => T2 g
\end{verbatim}
\end{hol}\index{alternation!of tactics|)}


\subsection{First success}

\index{FIRST@\ml{FIRST}|pin}
\begin{holboxed}
\begin{verbatim}
   FIRST : tactic list -> tactic
\end{verbatim}\end{holboxed}

The tactical \ml{FIRST} applies the first tactic, in a list
of tactics, that succeeds.

\begin{hol}
\begin{alltt}
   FIRST [\(T\sb{1}\);\(T\sb{2}\);\(\ldots\);\(T\sb{n}\)] = \(T\sb{1}\) ORELSE \(T\sb{2}\) ORELSE \(\ldots\) ORELSE \(T\sb{n}\)
\end{alltt}\end{hol}



\subsection{Change detection}

\index{CHANGED_TAC@\ml{CHANGED\_TAC}|pin}
\begin{holboxed}
\begin{verbatim}
   CHANGED_TAC : tactic -> tactic
\end{verbatim}
\end{holboxed}


\ml{CHANGED\_TAC\ $T$\ $g$} fails if the subgoals produced by $T$ are just \ml{[$g$]}; otherwise it is equivalent to $T\ g$.
It is defined by the following, where
\begin{verbatim}
  set_eq: 'a list -> 'a list -> bool
\end{verbatim}
tests whether two lists denote the same set (\ie, contain the same elements).


\begin{hol}
\begin{verbatim}
   fun CHANGED_TAC tac g =
    let val (gl,p) = tac g
    in
      if set_eq gl [g] then raise ERR "CHANGED_TAC" "no change"
      else (gl,p)
    end
\end{verbatim}
\end{hol}



\subsection{Sequencing}
\label{sec:sequencing-tacticals}
\index{sequencing!of tactics|(}
\index{tacticals!for sequencing|(}
\index{tactics!sequencing of|(}
\index{THEN@\ml{THEN}}
\index{ THEN tactical@\ml{\gt\gt} (\ml{THEN} tactical)|see{\ml{THEN}}}

\begin{holboxed}%triple > is to escape in presence of polyscripter
\begin{verbatim}
   THEN : tactic -> tactic -> tactic
   >>>   : tactic -> tactic -> tactic
   \\   : tactic -> tactic -> tactic
\end{verbatim}
\end{holboxed}

The tactical \ml{\gt\gt} is an \ML{} infix.
Its aliases \ml{THEN} and \ml{\bs\bs} are also infixes.
If $T_1$ and $T_2$ are tactics, then the \ML{} expression $T_1\;\ml{\gt\gt}\;T_2$ evaluates to a tactic which first applies $T_1$ and then applies $T_2$ to each subgoal produced by $T_1$.

Both \ml{\gt\gt} and \ml{THEN} associate to the left, which can lead to some counter-intuitive behaviours when they combine with other sequencing operators.
However, chains of tactics connected with \ml{\gt\gt} behave as one might expect.
In particular, if $T_1$ produces $n$ sub-goals, and $T_2$ produces varying numbers of sub-goals when applied to each of those, then the expression
\(
T_1 \;\texttt{\gt\gt}\; T_2 \;\texttt{\gt\gt}\; T_3
\)
will apply $T_3$ to \emph{all} of the leaf sub-goals generated by the sequencing of $T_1$ and $T_2$.
\index{sequencing!of tactics|)}
\index{tacticals!for sequencing|)}
\index{THEN@\ml{THEN}!ML implementation of@\ML{} implementation of|)}

\subsection{Selective sequencing}

\index{THENL@\ml{THENL}}
\begin{holboxed}
\begin{verbatim}
   THENL : tactic -> tactic list -> tactic
   >|    : tactic -> tactic list -> tactic
\end{verbatim}
\end{holboxed}
\label{sec:thenl}

\index{selective sequencing tactical}
If tactic $T$ produces $n$ subgoals and $T_1$, $\dots$,
$T_n$ are tactics
then $T${\small\verb% >| [%}$T_1${\small\verb%,%}$\ldots${\small\verb%,%}$T_n${\small\verb%]%}
is a tactic which first applies $T$ and then
applies $T_i$ to the $i$th subgoal produced by $T$.
The tactical {\small\verb%THENL%} is useful if one wants to apply different
tactics to different subgoals.
\index{tactics!sequencing of|)}

\subsection{Successive application}



\begin{holboxed}
\index{EVERY, the ML function@\ml{EVERY}, the \ML{} function|pin}
\begin{verbatim}
   EVERY : tactic list -> tactic
\end{verbatim}\end{holboxed}

\index{tacticals!for successive application}
\index{successive application!tactical for}
The tactical \ml{EVERY} applies a list of tactics one after the other.


\begin{hol}
\begin{alltt}
   EVERY [\(T\sb{1}\),\(T\sb{2}\),\(\ldots\),\(T\sb{n}\)] = \(T\sb{1}\) \gt\gt \(T\sb{2}\) \gt\gt \(\ldots\) \gt\gt \(T\sb{n}\)
\end{alltt}
\end{hol}



\subsection{Repetition}

\begin{holboxed}\index{REPEAT@\ml{REPEAT}|pin}\index{rpt@\ml{rpt}|see{\ml{REPEAT}}}
\begin{verbatim}
   REPEAT : tactic -> tactic
   rpt    : tactic -> tactic
\end{verbatim}
\end{holboxed}
\label{sec:repeat}

If $T$ is a
tactic then {\small\verb%rpt %}$T$ is a tactic\index{tactics!repetition of}
\index{tacticals!for repetition}\index{repetition!of tactics}
that repeatedly applies
$T$ until it fails. It is defined in \ML{} by:

{\small\baselineskip\HOLSpacing
\begin{verbatim}
   fun REPEAT T g = ((T THEN REPEAT T) ORELSE ALL_TAC) g
\end{verbatim}}

\noindent (The extra argument {\small\verb%g%} is needed because \ML{} does not use lazy evaluation.)
\index{tacticals|)}
\index{tacticals!list of some|)}
\index{tactics!tacticals for|)}

\section{Tactics for Manipulating Assumptions}
\label{asm-manip}

\index{tactics!for manipulating assumptions|(}
There are in general two kinds of tactics\index{tactics!term transforming}\index{tactics!assumption transforming}
 in \HOL: those that transform the
conclusion of a goal without affecting the assumptions, and those that
do (also or only) affect the assumptions.  The various tactics that
rewrite\index{rewriting!main tactic for}
 are typical of the first class; those that do `resolution'
\index{resolution tactics} belong to
the second.  Often, many of the steps of a proof in \HOL{} are carried
out `behind the scenes' on the assumptions, by tactics of the second sort.
A tactic that in some way changes the assumptions must also have a
justification that `knows how' to restore the corresponding hypotheses of
the theorem achieving the subgoal. All of this is explicit, and can be
examined by a user moving about the subgoal-proof tree.\footnote{The current
subgoal package makes this difficult, but the point still holds.}
Using these tactics in the most straightforward way, the assumptions at any
point in a goal-directed proof, \ie, at any node in the subgoal tree,
\index{subgoal tree!in proof construction}
\index{tree of subgoals, in proof construction} form
an unordered record of every assumption made, but not yet dismissed, up to that
point.

In practice, the straightforward use of assumption-changing
\index{assumptions!role of, in goal directed proof}
tactics,
with the tools currently provided in \HOL, presents at
least two difficulties.  The first is that assumption sets can grow to an
unwieldy size, the number and/or length of terms making them difficult to
read.  In addition, forward-search tactics such as resolution often add at least
some assumptions that are never subsequently used, and these have to be
carried along with the useful assumptions; the straightforward
method provides no ready way of intercepting their arrival.
Likewise, there is no straightforward way of discarding
\index{discarding assumptions}
\index{assumptions!discarding of, in proofs}
assumptions after they have been used and are merely adding to the clutter.
Although perhaps against the straightforward spirit, this is a perfectly valid
strategy, and
requires no more than a way of denoting
the specific assumptions to be discarded. That, however,
raises the more general problem of denoting\index{assumptions!denoting of, in proofs}\index{denoting assumptions} assumptions in the first place.
Assumptions are also denoted
so that they can be
manipulated: given as parameters, combined to draw inferences, etc.  The only
straightforward way to denote them in the existing system is to supply
their quoted text.  Though adequate, this
method may result in bulky \ML{} expressions; and it may take some effort to present the text
correctly (with necessary type information, \etc).

As always in \HOL, there are quite a few ways around the various difficulties.
One approach, of course, is the one intended in the original
design of\index{LCF@\LCF!Edinburgh} Edinburgh \LCF,
and advocates the rationale for providing a full programming language, \ML,
\index{ML@\ML!purpose of, in HOL system@purpose of, in \HOL{} system}
rather than a simple proof command set: that is for the user to
implement new tactics in \ML.  For example, resolution tactics can be adapted
by the user to add new assumptions more selectively; and case analysis tactics
to make direct replacements without adding case assumptions.
This, again, is adequate, but can involve the user in extensive amounts of
programming, and in debugging exercises for which there is no
system support.

Short of implementing new tactics, two other standard
approaches are reflected in the current system.  Both were originally
developed for Cambridge \LCF\ \cite{lcp-rewrite,new-LCF-man}; both reflect
fresh views of the assumptions; and both rely on tacticals\index{tacticals!purpose of} that transform
tactics.  The two approaches are
partly but not completely complementary.

The first
approach, described in this section, implicitly regards the assumption
set, already represented as a list, as a stack, with a {\it pop\/}
operation, so that the assumption at the top of the stack can be (i) discarded
and (ii) denoted without explicit quotation.  (The corresponding {\it push\/}
adds new assumptions at the head of the list.)
The stack can be generalized to an array to allow for access to
arbitrary assumptions.

The other approach, described in Section~\ref{tacont},
gives a way of intercepting and manipulating results without them necessarily
being added as assumptions in the first place.  The two approaches can
be combined in \HOL{} interactions.


\subsection{Theorem continuations with popping}

The first proof style, that of popping assumptions
\index{popping, of assumptions}
from the assumption `stack',
\index{assumptions!as stack}%
\index{stack, of assumptions}%
is illustrated using its main tool: the tactical \ml{POP\_ASSUM}.

\index{POP_ASSUM@\ml{POP\_ASSUM}|pin}
\begin{holboxed}
\begin{verbatim}
   POP_ASSUM : (thm -> tactic) -> tactic
   pop_assum : (thm -> tactic) -> tactic
\end{verbatim}\end{holboxed}

\noindent Given a function $f$\ml{:thm -> tactic}, the tactic
\ml{pop\_assum}\ $f$ applies $f$ to the (assumed) first
assumption of a goal (\ie, to the top element of the assumption stack)
and then applies the tactic created thereby to the original goal
minus its top assumption:

\begin{hol}
\begin{alltt}
   pop_assum \(f\) ([\(t\sb{1}\);\(\ldots\);\(t\sb{n}\)],\(t\)) = \(f\) (ASSUME \(t\sb{1}\)) ([\(t\sb{2}\);\(\ldots\);\(t\sb{n}\)],\(t\))
\end{alltt}\end{hol}

\noindent \ML{} functions such as $f$,
with type \ml{thm -> tactic}, abbreviated to \ml{thm\_tactic},
\index{thm_tactic@\ml{thm\_tactic}}
are called theorem continuations,
\index{theorem continuations} suggesting the fact that they
take theorems and then continue the proof.\footnote{There is a superficial analogy
with continuations in denotational semantics.}
The use of \ml{pop\_assum}\ can be illustrated by applying it
to a particular tactic, namely \ml{DISCH\_TAC}.

\index{DISCH_TAC@\ml{DISCH\_TAC}}
\begin{holboxed}
\begin{verbatim}
   DISCH_TAC : tactic
\end{verbatim}\end{holboxed}

\noindent On a goal whose conclusion is an implication $u \imp v$,
\ml{DISCH\_TAC} reflects the natural strategy of attempting to prove
$v$ under the assumption $u$, the discharged antecedent.  For example,
suppose it were required to prove that $(n = 0) \imp (n\times n = n)$:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>> g `(n = 0) ==> (n * n = n)`;

>> e DISCH_TAC;
\end{alltt}\end{session}

\noindent Application of \ml{DISCH\_TAC} to the goal produces one subgoal,
as shown, with the added assumption. To engage the assumption
as a simple substitution, the tactic \ml{SUBST1\_TAC} is useful
(see \REFERENCE\ for details).


\index{SUBST1_TAC@\ml{SUBST1\_TAC}|pin}
\begin{holboxed}
\begin{verbatim}
   SUBST1_TAC : thm_tactic
\end{verbatim}\end{holboxed}

\noindent \ml{SUBST1\_TAC} expects a theorem with an equational conclusion, and
substitutes accordingly, into the conclusion of the goal. At this
point in the session, the tactical
\ml{POP\_ASSUM} is applied to
\ml{SUBST1\_TAC} to form a new tactic.
The new tactic is applied to the current subgoal.

\begin{session}
\begin{alltt}
>> p();

>> e(pop_assum SUBST1_TAC);;
\end{alltt}\end{session}

\noindent The result, as shown, is that the assumption is used as a
substitution rule and then discarded.
\index{discarding assumptions}
\index{assumptions!discarding of, in proofs}
The one subgoal therefore has no
assumptions on its stack.  The two tactics used thus far could be combined
into one using the tactical \ml{\gt\gt}:\index{THEN@\ml{THEN}}

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop()
>> g `(n = 0) ==> (n * n = n)`;

>> e(DISCH_TAC >> pop_assum SUBST1_TAC);;
\end{alltt}\end{session}

\noindent The goal can now be solved by simplification:of arithmetic:

\begin{session}
\begin{alltt}
>> e(simp[]);
##assert can top_thm()
\end{alltt}\end{session}

\noindent A single tactic can, of course, be written to solve the goal:\footnote{Indeed, the tactic \ml{simp[]} solves the entire goal from the outset.}

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>_ restart();

>> e(DISCH_TAC >> pop_assum SUBST1_TAC >> simp[]);;
\end{alltt}\end{session}

This example illustrates how the tactical \ml{pop\_assum} provides
access\index{assumptions!denoting of, in proofs}
\index{denoting assumptions}
to the top of the assumption `stack' (a capability that
is useful, obviously, only when the
most recently pushed assumption is the very one required).
To accomplish this access in the straightforward way would
require some more awkward
\index{assumptions!explicit} construct, with explicit assumptions:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop();
>> g `(n = 0) ==> (n * n = n)`;

>> e DISCH_TAC;

>> e(SUBST1_TAC(ASSUME ``n = 0``));
\end{alltt}\end{session}

In contrast to the above, the popping example also illustrates the
convenient disappearance of an assumption no longer required, by removing it
from the stack at the moment when it is accessed and used. This is valid
because any theorem that achieves the subgoal
will still achieve the original goal. Discarding\index{discarding assumptions}\index{assumptions!discarding of, in proofs} assumptions
is a separate issue from accessing them;
there could, if one liked, be another
tactical that produced a similar tactic on a theorem continuation
to \ml{pop\_assum} but which did not pop the
stack.

Finally, \ml{pop\_assum} $f$ induces case splits where $f$ does.
To prove $(n=0 \disj n=1) \imp (n\times n = n)$, the function \ml{DISJ\_CASES\_TAC} can be used.
The tactic

\ \ \ml{DISJ\_CASES\_TAC\ |- $p$}{\small\verb% \/ %}\ml{$q$}

\noindent splits a goal into two subgoals that have
$p$ and $q$, respectively, as new assumptions.

Simply using \ml{DISCH\_TAC} does not cause the disjunction to split when it becomes an assumption.
\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop()
>> g `((n = 0) \/ (n = 1)) ==> (n * n = n)`;

>> e DISCH_TAC;
\end{alltt}
\end{session}

So, we can combine \ml{pop\_assum} and \ml{DISJ\_CASES\_TAC} to apply the latter to the theorem corresponding to the disjunctive assumption:
\begin{session}
\begin{alltt}
>>_ restart();

>> e(DISCH_TAC >> pop_assum DISJ_CASES_TAC);
\end{alltt}
\end{session}

Indeed, we can then combine this with our earlier use of \ml{SUBST1\_TAC} to have both branches make progress at once:
\begin{session}
\begin{alltt}
>>_ restart();

>> e(DISCH_TAC >> pop_assum DISJ_CASES_TAC >> pop_assum SUBST1_TAC);
\end{alltt}
\end{session}

As noted earlier, \ml{pop\_assum} is useful when an assumption
is required that is still at the top of the stack,
as in the examples.  However, it is often
necessary to access assumptions made at arbitrary previous times, in order to
give them as parameters, combine them, etc.

Two other useful tacticals that can be used to manipulate the assumption list are
\ml{first\_assum} and \ml{qpat_assum}.
The first has an easy characterisation:

\index{FIRST_ASSUM@\ml{FIRST\_ASSUM}}
\begin{hol}
\begin{alltt}
   first_assum \(f\) ([\(t\sb{1}\), \(\ldots\) ,\(t\sb{n}\)], \(t\)) =
    (\(f\)(ASSUME \(t\sb{1}\)) ORELSE \(\ldots\) ORELSE \(f\)(ASSUME \(t\sb{n}\))) ([\(t\sb{1}\), \(\ldots\) ,\(t\sb{n}\)], \(t\))
\end{alltt}
\end{hol}

The \index{FIRST_X_ASSUM@\ml{FIRST\_X\_ASSUM}}\ml{first\_x\_assum} tactical is similar to \ml{first\_assum}, but in addition to assuming one of the goal's assumptions as a theorem and passing this to the function $f$, the goal-state that $f\,(t_i\vdash t_i)$ acts upon has had $t_i$ removed from the assumption list.
It is a ``popping'' version of \ml{first\_assum}.

\index{qpat_assum@\ml{qpat\_assum}}
The \ml{qpat\_assum} tactical takes a pattern-quotation as its first argument.
The second \ml{thm\_tactic} parameter is then passed the first assumption that matches this pattern.

Thus:
\begin{hol}
\begin{alltt}
   qpat_assum pat \(f\) ([\(t\sb{1}\), \(\ldots\) ,\(t\sb{p}\), \(\ldots\) ,\(t\sb{n}\)], \(t\)) = f (ASSUME \(t\sb{p}\)) ([\(t\sb{1}\), \(\ldots\), \(t\sb{n}\)], \(t\))
\end{alltt}
\end{hol}
where $t_p$ is the first assumption that matches the pattern \ml{pat}.

Just as with \ml{first\_assum}, there is a ``popping'' version called \ml{qpat\_x\_assum} that removes the matching assumption from the list.
Thus:
\begin{hol}
\begin{alltt}
   qpat_x_assum pat \(f\) ([\(t\sb{1}\), \(\ldots\) ,\(t\sb{p}\), \(\ldots\) ,\(t\sb{n}\)], \(t\)) =
     f (ASSUME \(t\sb{p}\)) ([\(t\sb{1}\), \(\ldots\) ,\(t\sb{p-1}\),\(t\sb{p+1}\), \(\ldots\) ,\(t\sb{n}\)], \(t\))
\end{alltt}
\end{hol}
where $t_p$ is the first assumption that matches the pattern \ml{pat}.

While \ml{first\_assum} (and \ml{first\_x\_assum}) try to apply their theorem-tactic to every assumption, eventually using the first that succeeds, \ml{qpat\_assum} (and \ml{qpat\_x\_assum}) only apply their theorem-tactic to one assumption (the first that matches).


\subsection{Theorem continuations without popping}
\label{tacont}

The idea of the second approach is suggested by the way the array-style tacticals\index{tacticals!purpose of} supply a list of theorems (the assumed assumptions) to a function.
These tacticals use the function to infer new results from the list of theorems, and then to do something with the results.
In some cases, \eg, the last example, the assumptions need never have been made in the first place, which suggests a different use of tacticals.
The original example for \ml{pop\_assum} illustrates this: namely, to show that $(n = 0) \imp (n\times n = n)$.
Here, instead of discharging the antecedent by applying \ml{DISCH\_TAC} to the goal, which adds the antecedent as an assumption and returns the consequent as the conclusion, and {\it then\/} supplying the (assumed) added assumption to the theorem continuation \ml{SUBST1\_TAC} and discarding it at the same time, a tactical called \ml{disch\_then} is applied to \ml{SUBST1\_TAC} directly.
\ml{disch\_then} transforms \ml{SUBST1\_TAC} into a new tactic: one that applies \ml{SUBST1\_TAC} directly to the (assumed) antecedent, and the resulting tactic to a subgoal with no new assumptions and the consequent as its conclusion:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop();
>> disch_then;

>> disch_then SUBST1_TAC;

>> g `(n = 0) ==> (n * n = n)`;

>> e(disch_then SUBST1_TAC);
\end{alltt}
\end{session}

\noindent This gives the same result as the stack method, but more
directly, with a more compact \ML{} expression,
and with the attractive feature that the term
$n=0$ is never an assumption, even for an interval of one step.
This technique is often used at the moment when results are available;
as above, where the result produced by discharging the antecedent can be
immediately passed to substitution. If the result were only needed
later, it {\it would\/} have to be held as an assumption. However, results
can be manipulated when they are available, and their results
either held as assumptions or used immediately.
For example, to prove $(0=n) \imp (n \times n = n)$,
the result $n=0$ could be reversed
immediately:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop();
>> g `(0 = n) ==> (n * n = n)`;
>> e(disch_then(SUBST1_TAC o SYM));
\end{alltt}
\end{session}

The justification of \ml{disch\_then SUBST1\_TAC} is easily constructed
from the justification of \ml{DISCH\_TAC} composed with the justification of
\ml{SUBST1\_TAC}. \index{assumptions!internal|(}
The term $n=0$ is assumed, to yield the
theorem that is passed to the theorem continuation \ml{SUBST1\_TAC},
and it is accordingly discharged during the construction of the
actual proof; but the assumption happens
only internally
\index{assumptions!internal|)} to the tactic \ml{disch\_then SUBST1\_TAC}, and not
as a step in the tactical proof.  In other words, the subgoal tree here
has one node fewer than before, when an explicit step (\ml{DISCH\_TAC})
reflected the assumption.

On the goal with the disjunctive antecedent, this method again
provides a compact tactic:

\setcounter{sessioncount}{0}
\begin{session}
\begin{alltt}
>>__ drop();
>> g `((n = 0) \/ (n = 1)) ==> (n * n = n)`;

>> e(disch_then(DISJ_CASES_THEN SUBST1_TAC));
\end{alltt}
\end{session}

\noindent This avoids the repeated popping and pushing of the stack
solution, and likewise, gives a shorter \ML{} expression. Both give
a shorter expression than the direct method, which is:

\begin{hol}
\begin{verbatim}
   DISCH_TAC
    >>> DISJ_CASES_TAC(ASSUME ``(n = 0) \/ (n = 1)``)
    >| [SUBST1_TAC(ASSUME ``n = 0``);
        SUBST1_TAC(ASSUME ``n = 1``)]
\end{verbatim}
\end{hol}

To summarize, there are so far at least five ways to solve a goal
(and these are often combined in one interaction):
directly, using the stack view of the assumptions,
using the array view with or without discarding assumptions, and using a
tactical to intercept an assumption step.  All of the following work
\index{assumptions!compared methods of handling}
on the goal $(n=0) \imp (n \times n = n)$:

\begin{hol}
\begin{verbatim}
   DISCH_TAC
    >>> SUBST1_TAC(ASSUME ``n = 0``)
    >>> simp[]

   DISCH_TAC
    >>> pop_assum SUBST1_TAC
    >>> simp[]

   disch_then SUBST1_TAC
    >>> simp[]
\end{verbatim}
\end{hol}

\noindent Furthermore, all induce the
same sequence of inferences leading to
the desired theorem; internally, no inference steps are saved by the
economies in the \ML{} text or the subgoal tree.  In this sense,
the choice is entirely one of style and taste;
of how to organize the decomposition into subgoals.
The first expression illustrates the verbosity of denoting
assumptions by text (the goal with the
disjunctive antecedent gave a clearer
example); but also
the intelligibility of the resulting expression, which, of course, is all
that is saved of the interaction, aside from the final theorem.
The last expression
illustrates both the elegance and the inscrutibility of
using functions to manipulate intermediate results directly, rather than
as assumptions.
The middle expression
shows how results can be used as assumptions (discarded when
redundant, if desired); and how
assumptions can be denoted without
recourse to their text.
%
It is a strength of the \LCF\ approach \index{LCF@\LCF} to theorem proving that many different proof styles are supported, (all in a secure way) and indeed, can be studied in their own right.

\HOL{} provides several other theorem continuation functions analogous to
\ml{disch\_then} and \ml{DISJ\_CASES\_THEN}.
(Their names always end with
`\ml{\_THEN}', `\ml{\_THENL} or `\ml{\_THEN2}'.)
Some of these do convenient inferences for the user.
For example:

\index{CHOOSE_THEN@\ml{CHOOSE\_THEN}|pin}
\begin{holboxed}
\begin{verbatim}
   CHOOSE_THEN : thm_tactical
\end{verbatim}
\end{holboxed}

\noindent Where \ml{thm\_tactical} abbreviates \ml{thm\_tactic -> tactic}.
\ml{CHOOSE\_THEN\ $f$\ ($\vdash\;\exists x.\;t[x]$)}
is a tactic that, given a goal, generates the subgoal
obtained
by applying $f$ to \ml{($t[x]$|-$t[x]$)}.
The intuition is that if
\ml{|-\ $\exists x$.$t[x]$} holds then \ml{|-\ $t[x]$}
holds for some value of $x$ (as long as the
variable $x$ is not free elsewhere in the theorem or current goal).
This gives an easy way of using existentially quantified theorems, something that is otherwise awkward.

The new method has other applications as well, including as an
implementation technique.
For example,
\index{tactics!indirect implementation of}
taking \ml{DISJ\_CASES\_THEN} as basic, \ml{DISJ\_CASES\_TAC}
can be defined by:

\begin{hol}
\begin{verbatim}
   val DISJ_CASES_TAC = DISJ_CASES_THEN ASSUME_TAC
\end{verbatim}
\end{hol}

\noindent Similarly, the method is useful for modifying existing tactics (\eg, resolution tactics) without having to re-program them in \ML.
This avoids the danger of introducing tactics whose justifications may fail, \index{failure, of tactics} a particularly difficult problem to track down; it is also much easier than starting from scratch.

The main theorem continuation functions in the system are:

\begin{hol}
\begin{verbatim}
   ANTE_RES_THEN
   CHOOSE_THEN      X_CHOOSE_THEN
   CONJUNCTS_THEN   CONJUNCTS_THEN2
   DISJ_CASES_THEN  DISJ_CASES_THEN2   DISJ_CASES_THENL
   DISCH_THEN
   IMP_RES_THEN
   RES_THEN
   STRIP_THM_THEN
   STRIP_GOAL_THEN
\end{verbatim}
\end{hol}

\noindent See \REFERENCE\ for full details.
\index{tactics!for manipulating assumptions|)}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "description"
%%% End:

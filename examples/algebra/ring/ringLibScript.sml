(* ========================================================================= *)
(*  HOL-Light's ringtheory.ml (partial)                                      *)
(*                                                                           *)
(*       John Harrison, University of Cambridge Computer Laboratory          *)
(*            (c) Copyright, University of Cambridge 1998                    *)
(*                                                                           *)
(* ------------------------------------------------------------------------- *)
(* Ported by Chun Tian. The Australian National University (ANU), 2024       *)
(* ========================================================================= *)

open HolKernel boolLib bossLib Parse;

open combinTheory pred_setTheory pred_setLib arithmeticTheory integerTheory
     numLib intLib mesonLib hurdUtils cardinalTheory oneTheory newtypeTools
     tautLib;

open monoidTheory groupTheory ringTheory;

val _ = new_theory "ringLib";

val _ = deprecate_int ();
val INT_ARITH = intLib.ARITH_PROVE;

val std_ss' = std_ss ++ PRED_SET_ss;

(* NOTE: HOL4's ‘trivial_ring’ is HOL-Light's ‘singleton_ring’ (also here).
   HOL-Light's ‘trivial_ring’ is a predicate indicating any ring having
   singleton carrier. (And singleton rings are trivial.)

   The theorem ringTheory.trivial_ring will be overwritten by the definition
   of HOL-Light's ‘trivial_ring’.
 *)
val _ = hide "trivial_ring";

(* NOTE: The constant “ring” was generated by the record syntax, never needed.
   It's now reused for HOL-Light's way of constructing rings with explicit
   elements (except for ring_neg, which is derived in HOL4's ringTheory).
 *)
val _ = hide "ring";

(* |- !P Q. P /\ (?x. Q x) <=> ?x. P /\ Q x *)
val RIGHT_AND_EXISTS_THM = GSYM RIGHT_EXISTS_AND_THM

(* |- !P Q. (?x. P x) /\ Q <=> ?x. P x /\ Q *)
val LEFT_AND_EXISTS_THM = GSYM LEFT_EXISTS_AND_THM

(* ------------------------------------------------------------------------- *)
(*  'a Ring as type bijections of a subset of 'a ring                        *)
(* ------------------------------------------------------------------------- *)

(* NOTE: The ring construction here follows ring_tybij in ringtheory.ml *)
Theorem EXISTS_Ring[local] :
    ?r. Ring (r :'a ring)
Proof
    Q.EXISTS_TAC ‘ring$trivial_ring ARB’
 >> rw [trivial_ring_thm]
QED

(* This defines a new type “:'a Ring” *)
val Ring_tydef = rich_new_type {tyname = "Ring", exthm = EXISTS_Ring,
                                ABS = "toRing", REP = "fromRing"};

(* |- Ring (fromRing g) *)
Theorem Ring_fromRing[simp] = #termP_term_REP Ring_tydef

(* |- !r. Ring r ==> fromRing (toRing r) = r *)
Theorem from_toRing = #repabs_pseudo_id Ring_tydef

(* |- !g h. fromRing g = fromRing h <=> g = h *)
Theorem fromRing_11 = #term_REP_11 Ring_tydef |> Q.GENL [‘g’, ‘h’]

(* NOTE: this is the old Ring_tybij, returned by define_new_type_bijections. *)
val Ring_ABSREP = DB.fetch "-" "Ring_ABSREP";

(* NOTE: HOL-Light's ring constructor takes an explicit ring_neg function, while
         in HOL4's it's derived from other slots.
 *)
Definition raw_ring_def :
    raw_ring ((c :'a set),zero,uno,add,mul) =
        let g = <| carrier := c; op := add; id := zero |>;
            m = <| carrier := c; op := mul; id := uno  |>
        in
           <| carrier := c; sum := g; prod := m |>
End

Definition ring_def :
    ring = toRing o raw_ring
End

(* ------------------------------------------------------------------------- *)
(* The ring operations, primitive plus subtraction as a derived operation.   *)
(* ------------------------------------------------------------------------- *)

Definition ring_carrier_def :
    ring_carrier (r :'a Ring) = (fromRing r).carrier
End

Definition ring_0_def :
    ring_0 (r :'a Ring) = (fromRing r).sum.id
End

Definition ring_1_def :
    ring_1 (r :'a Ring) = (fromRing r).prod.id
End

Definition ring_neg_def :
    ring_neg (r :'a Ring) = (fromRing r).sum.inv
End

Definition ring_add_def :
    ring_add (r :'a Ring) = (fromRing r).sum.op
End

val _ = hide "ring_sub";
Definition ring_sub :
    ring_sub (r :'a Ring) = ring$ring_sub (fromRing r)
End

Definition ring_mul_def :
    ring_mul (r :'a Ring) = (fromRing r).prod.op
End

Definition ring_pow_def :
    ring_pow (r :'a Ring) = (fromRing r).prod.exp
End

(* NOTE: not used, only to make sure ‘ring_inv’ is not treated as variables *)
Definition ring_inv_def :
    ring_inv (r :'a Ring) = (Invertibles ((fromRing r).prod)).inv
End

(* NOTE: not used *)
Definition ring_div_def :
    ring_div r (a :'a) b = ring_mul r a (ring_inv r b)
End

(* NOTE: Now the following theorems have exactly the same statements with their
         corresponding theorems in HOL-Light.
 *)
Theorem RING_0 :
    !r. ring_0 r IN ring_carrier (r :'a Ring)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> rw [ring_0_def, ring_carrier_def]
 >> MATCH_MP_TAC ring_zero_element
 >> rw [Abbr ‘r’]
QED

Theorem RING_1 :
    !r. ring_1 r IN ring_carrier (r :'a Ring)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> rw [ring_1_def, ring_carrier_def]
 >> MATCH_MP_TAC ring_one_element
 >> rw [Abbr ‘r’]
QED

Theorem RING_NEG :
    !r x. x IN ring_carrier r ==> ring_neg r x IN ring_carrier (r :'a Ring)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> rw [ring_neg_def, ring_carrier_def]
 >> irule ring_neg_element
 >> rw [Abbr ‘r’]
QED

Theorem RING_NEG_0 :
    !r. ring_neg r (ring_0 r) = ring_0 (r :'a Ring)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> rw [ring_neg_def, ring_0_def]
 >> MATCH_MP_TAC ring_neg_zero
 >> rw [Abbr ‘r’]
QED

fun xfer th :tactic =
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> RW_TAC std_ss [ring_carrier_def, ring_pow_def, ring_add_def, ring_sub,
                   ring_mul_def, ring_0_def, ring_1_def, ring_neg_def]
 >> irule th
 >> rw [Abbr ‘r’];

Theorem RING_POW :
    !r x n. x IN ring_carrier r ==> ring_pow r x n IN ring_carrier (r :'a Ring)
Proof
    xfer ring_exp_element
QED

Theorem RING_ADD :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring) ==>
            ring_add r x y IN ring_carrier r
Proof
    xfer ring_add_element
QED

Theorem RING_SUB :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring) ==>
            ring_sub r x y IN ring_carrier r
Proof
    xfer ring_sub_element
QED

Theorem RING_MUL :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring) ==>
            ring_mul r x y IN ring_carrier r
Proof
    xfer ring_mult_element
QED

Theorem RING_ADD_LZERO :
    !r x. x IN ring_carrier (r :'a Ring) ==> ring_add r (ring_0 r) x = x
Proof
    xfer ring_add_lzero
QED

Theorem RING_ADD_RZERO :
    !r x. x IN ring_carrier (r :'a Ring) ==> ring_add r x (ring_0 r) = x
Proof
    xfer ring_add_rzero
QED

Theorem RING_ADD_SYM :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring)
             ==> ring_add r x y = ring_add r y x
Proof
    xfer ring_add_comm
QED

Theorem RING_ADD_LNEG :
    !r x. x IN ring_carrier (r :'a Ring) ==> ring_add r (ring_neg r x) x = ring_0 r
Proof
    xfer ring_add_lneg
QED

Theorem RING_ADD_RNEG :
    !r (x :'a). x IN ring_carrier r ==> ring_add r x (ring_neg r x) = ring_0 r
Proof
    xfer ring_add_rneg
QED

Theorem RING_ADD_ASSOC :
    !r x y (z :'a).
        x IN ring_carrier r /\ y IN ring_carrier r /\ z IN ring_carrier r
        ==> ring_add r x (ring_add r y z) = ring_add r (ring_add r x y) z
Proof
    xfer (GSYM ring_add_assoc)
QED

Theorem RING_MUL_LID :
    !r (x :'a). x IN ring_carrier r ==> ring_mul r (ring_1 r) x = x
Proof
    xfer ring_mult_lone
QED

Theorem RING_MUL_LZERO :
    !r (x :'a). x IN ring_carrier r ==> ring_mul r (ring_0 r) x = ring_0 r
Proof
    xfer ring_mult_lzero
QED

Theorem RING_MUL_RZERO :
    !r (x :'a). x IN ring_carrier r ==> ring_mul r x (ring_0 r) = ring_0 r
Proof
    xfer ring_mult_rzero
QED

Theorem RING_MUL_SYM :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring)
             ==> ring_mul r x y = ring_mul r y x
Proof
    xfer ring_mult_comm
QED

Theorem RING_MUL_ASSOC :
    !r x y z. x IN ring_carrier r /\ y IN ring_carrier r /\
              z IN ring_carrier (r :'a Ring)
          ==> ring_mul r x (ring_mul r y z) = ring_mul r (ring_mul r x y) z
Proof
    xfer (GSYM ring_mult_assoc)
QED

Theorem RING_ADD_EQ_0 :
    !r x y.
        x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring)
        ==> (ring_add r x y = ring_0 r <=> ring_neg r x = y)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> RW_TAC std_ss [ring_carrier_def, ring_add_def, ring_neg_def, ring_0_def]
 >> ‘-x = y <=> y = -x’ by PROVE_TAC [] >> POP_ORW
 >> irule ring_add_eq_zero
 >> rw [Abbr ‘r’]
QED

Theorem RING_LNEG_UNIQUE :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier r /\
            ring_add r x y = ring_0 (r :'a Ring)
        ==> ring_neg r x = y
Proof
  MESON_TAC[RING_ADD_EQ_0]
QED

Theorem RING_RNEG_UNIQUE :
    !r x y. x IN ring_carrier r /\ y IN ring_carrier (r :'a Ring) /\
            ring_add r x y = ring_0 r ==> ring_neg r y = x
Proof
  MESON_TAC[RING_ADD_EQ_0, RING_ADD_SYM]
QED

Theorem RING_NEG_NEG :
    !r (x :'a). x IN ring_carrier r ==> ring_neg r (ring_neg r x) = x
Proof
    xfer ring_neg_neg
QED

Theorem RING_ADD_LCANCEL :
    !r x y (z :'a).
        x IN ring_carrier r /\ y IN ring_carrier r /\ z IN ring_carrier r
        ==> (ring_add r x y = ring_add r x z <=> y = z)
Proof
    xfer ring_add_lcancel
QED

Theorem RING_ADD_RCANCEL :
    !r x y (z :'a).
        x IN ring_carrier r /\ y IN ring_carrier r /\ z IN ring_carrier r
        ==> (ring_add r x z = ring_add r y z <=> x = y)
Proof
    xfer ring_add_rcancel
QED

Theorem RING_ADD_EQ_RIGHT :
    !r x (y :'a).
        x IN ring_carrier r /\ y IN ring_carrier r
        ==> (ring_add r x y = y <=> x = ring_0 r)
Proof
  MESON_TAC[RING_ADD_RCANCEL, RING_NEG, RING_0, RING_ADD_LZERO]
QED

Theorem RING_ADD_EQ_LEFT :
    !r x (y :'a).
        x IN ring_carrier r /\ y IN ring_carrier r
        ==> (ring_add r x y = x <=> y = ring_0 r)
Proof
  MESON_TAC[RING_ADD_EQ_RIGHT, RING_ADD_SYM]
QED

Theorem RING_LZERO_UNIQUE :
    !r x (y :'a).
        x IN ring_carrier r /\ y IN ring_carrier r /\ ring_add r x y = y
        ==> x = ring_0 r
Proof
  MESON_TAC[RING_ADD_EQ_RIGHT]
QED

Theorem RING_RZERO_UNIQUE :
    !r x (y :'a).
        x IN ring_carrier r /\ y IN ring_carrier r /\ ring_add r x y = x
        ==> y = ring_0 r
Proof
  MESON_TAC[RING_ADD_EQ_LEFT]
QED

Theorem RING_CARRIER_NONEMPTY :
    !(r:'a Ring). ~(ring_carrier r = {})
Proof
  MESON_TAC[MEMBER_NOT_EMPTY, RING_0]
QED

Theorem RING_SUB_EQ_0 :
    !r x (y :'a).
        x IN ring_carrier r /\ y IN ring_carrier r
        ==> (ring_sub r x y = ring_0 r <=> x = y)
Proof
    xfer ring_sub_eq_zero
QED

(* ------------------------------------------------------------------------- *)
(* Homomorphisms etc.                                                        *)
(* ------------------------------------------------------------------------- *)

Definition ring_homomorphism_def :
    ring_homomorphism (r,r') (f :'a -> 'b) <=> RingHomo f (fromRing r) (fromRing r')
End

(* NOTE: This theorem is a definition in HOL-Light (ringtheory.ml, L4708) *)
Theorem ring_homomorphism :
    !f r r'.
       (ring_homomorphism (r,r') (f :'a -> 'b) <=>
        IMAGE f (ring_carrier r) SUBSET ring_carrier r' /\
        f (ring_0 r) = ring_0 r' /\
        f (ring_1 r) = ring_1 r' /\
        (!x. x IN ring_carrier r
             ==> f(ring_neg r x) = ring_neg r' (f x)) /\
        (!x y. x IN ring_carrier r /\ y IN ring_carrier r
               ==> f(ring_add r x y) = ring_add r' (f x) (f y)) /\
        (!x y. x IN ring_carrier r /\ y IN ring_carrier r
               ==> f(ring_mul r x y) = ring_mul r' (f x) (f y)))
Proof
    qx_genl_tac [‘f’, ‘r0’, ‘r1’]
 >> RW_TAC std_ss [ring_homomorphism_def, RingHomo_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> EQ_TAC >> STRIP_TAC (* 2 subgoals *)
 >| [ (* goal 1 (of 2) *)
      REWRITE_TAC [ring_carrier_def, ring_0_def, ring_1_def, ring_add_def,
                   ring_neg_def, ring_mul_def] \\
      CONJ_TAC >- (rw [SUBSET_DEF] >> FIRST_X_ASSUM MATCH_MP_TAC >> art []) \\
     ‘Group r.sum /\ Group r'.sum’ by PROVE_TAC [ring_add_group] \\
      MP_TAC (Q.SPECL [‘f’, ‘r.sum’, ‘r'.sum’] group_homo_id) >> simp [] \\
      MP_TAC (Q.SPECL [‘f’, ‘r.sum’, ‘r'.sum’] group_homo_inv) >> simp [] \\
      fs [GroupHomo_def, MonoidHomo_def],
      (* goal 2 (of 2) *)
      rfs [SUBSET_DEF, ring_carrier_def, ring_0_def, ring_1_def, ring_neg_def,
          ring_add_def, ring_mul_def] \\
      CONJ_TAC >- (rpt STRIP_TAC \\
                   FIRST_X_ASSUM MATCH_MP_TAC >> Q.EXISTS_TAC ‘x’ >> art []) \\
      CONJ_TAC >| (* 2 subgoals *)
      [ (* goal 2.1 (of 2) *)
        rw [GroupHomo_def] \\
        FIRST_X_ASSUM MATCH_MP_TAC >> Q.EXISTS_TAC ‘x’ >> art [],
        (* goal 2.2 (of 2) *)
        rw [MonoidHomo_def] \\
        FIRST_X_ASSUM MATCH_MP_TAC >> Q.EXISTS_TAC ‘x’ >> art [] ] ]
QED

Theorem RING_HOMOMORPHISM_0 :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f ==> f(ring_0 r) = ring_0 r'
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_0_def]
QED

Theorem RING_HOMOMORPHISM_1 :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f ==> f(ring_1 r) = ring_1 r'
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_1_def]
QED

Theorem RING_HOMOMORPHISM_NEG :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !x. x IN ring_carrier r
                ==> f(ring_neg r x) = ring_neg r' (f x)
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_carrier_def, ring_neg_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule ring_homo_neg >> art []
QED

Theorem RING_HOMOMORPHISM_ADD :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !x y. x IN ring_carrier r /\ y IN ring_carrier r
                  ==> f(ring_add r x y) = ring_add r' (f x) (f y)
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_carrier_def, ring_add_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule ring_homo_add >> art []
QED

Theorem RING_HOMOMORPHISM_MUL :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !x y. x IN ring_carrier r /\ y IN ring_carrier r
                  ==> f(ring_mul r x y) = ring_mul r' (f x) (f y)
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_carrier_def, ring_mul_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule ring_homo_mult >> art []
QED

Theorem RING_HOMOMORPHISM_SUB :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !x y. x IN ring_carrier r /\ y IN ring_carrier r
                  ==> f(ring_sub r x y) = ring_sub r' (f x) (f y)
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_carrier_def, ring_sub]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule (REWRITE_RULE [ring_sub_def] ring_homo_sub) >> art []
QED

Theorem RING_HOMOMORPHISM_POW :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !x n. x IN ring_carrier r
                  ==> f(ring_pow r x n) = ring_pow r' (f x) n
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_carrier_def, ring_pow_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule ring_homo_exp >> art []
QED

Definition ring_monomorphism :
    ring_monomorphism (r,r') (f :'a -> 'b) <=>
        ring_homomorphism (r,r') f /\
        !x y. x IN ring_carrier r /\ y IN ring_carrier r /\ f x = f y ==> x = y
End

(* ------------------------------------------------------------------------- *)
(* Mapping natural numbers and integers into a ring in the obvious way.      *)
(* ------------------------------------------------------------------------- *)

(* ##n *)
Definition ring_of_num_def :
    ring_of_num (r :'a Ring) = (fromRing r).sum.exp (ring_1 r)
End

Theorem ring_of_num :
    !r. ring_of_num r (0 :num) = ring_0 (r :'a Ring) /\
        !n. ring_of_num r (SUC n) = ring_add r (ring_of_num r n) (ring_1 r)
Proof
    Q.X_GEN_TAC ‘r0’
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> RW_TAC std_ss [ring_num_0, ring_of_num_def, ring_0_def, ring_1_def,
                   ring_add_def]
 >> ‘Ring r’ by rw [Abbr ‘r’]
 >> Know ‘##n + #1 = #1 + ##n’
 >- (irule ring_add_comm >> rw [])
 >> Rewr'
 >> MATCH_MP_TAC ring_num_SUC >> art []
QED

Theorem RING_OF_NUM :
    !r n. ring_of_num r n IN ring_carrier (r :'a Ring)
Proof
    qx_genl_tac [‘r0’, ‘n’]
 >> Q.ABBREV_TAC ‘r = fromRing r0’
 >> RW_TAC std_ss [ring_carrier_def, ring_of_num_def, ring_1_def]
 >> MATCH_MP_TAC ring_num_element
 >> rw [Abbr ‘r’]
QED

Theorem RING_OF_NUM_0 :
    !(r :'a Ring). ring_of_num r 0 = ring_0 r
Proof
  REWRITE_TAC[ring_of_num]
QED

Theorem RING_OF_NUM_1 :
    !(r :'a Ring). ring_of_num r 1 = ring_1 r
Proof
  SIMP_TAC bool_ss[num_CONV “1:num”, ring_of_num, RING_ADD_LZERO, RING_1]
QED

Definition ring_of_int :
    ring_of_int (r :'a Ring) (n :int) =
        if &0 <= n then ring_of_num r (num_of_int n)
        else ring_neg r (ring_of_num r (num_of_int (-n)))
End

Theorem RING_OF_INT :
     !r n. ring_of_int r n IN ring_carrier (r :'a Ring)
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[ring_of_int] THEN COND_CASES_TAC THEN
  ASM_SIMP_TAC std_ss [RING_NEG, RING_OF_NUM]
QED

(* |- !n. num_of_int(&n) = n *)
Theorem NUM_OF_INT_OF_NUM = NUM_OF_INT;

Theorem RING_OF_INT_OF_NUM :
    !r n. ring_of_int r (&n) = ring_of_num (r :'a Ring) n
Proof
  REWRITE_TAC[ring_of_int, INT_POS, NUM_OF_INT_OF_NUM]
QED

Theorem RING_HOMOMORPHISM_RING_OF_NUM :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !n. f(ring_of_num r n) = ring_of_num r' n
Proof
    qx_genl_tac [‘r0’, ‘r1’, ‘f’]
 >> rw [ring_homomorphism_def, ring_of_num_def, ring_1_def]
 >> Q.ABBREV_TAC ‘r  = fromRing r0’
 >> Q.ABBREV_TAC ‘r' = fromRing r1’
 >> ‘Ring r /\ Ring r'’ by rw [Abbr ‘r’, Abbr ‘r'’]
 >> irule ring_homo_num >> art []
QED

(* |- |- !x. --x = x *)
Theorem INT_NEG_NEG = INT_NEGNEG

(* |- !m n. &m = &n <=> m = n *)
Theorem INT_OF_NUM_EQ = INT_INJ

(* NOTE: The proof is a direct translation from OCaml to SML *)
Theorem RING_OF_INT_CASES :
   (!r n. ring_of_int r (&n) = ring_of_num (r : 'a Ring) n) /\
   (!r n. ring_of_int r (-&n) = ring_neg r (ring_of_num r n))
Proof
  REPEAT STRIP_TAC THEN REWRITE_TAC[RING_OF_INT_OF_NUM] THEN
  REWRITE_TAC[ring_of_int, INT_ARITH “0:int <= - &n <=> &n:int = &0”] THEN
  SIMP_TAC std_ss[INT_NEG_NEG, INT_OF_NUM_EQ, INT_NEG_0, NUM_OF_INT_OF_NUM] THEN
  COND_CASES_TAC THEN ASM_REWRITE_TAC[ring_of_num, RING_NEG_0]
QED

(* NOTE: The proof is a direct translation from OCaml to SML *)
Theorem RING_HOMOMORPHISM_RING_OF_INT :
    !r r' (f :'a -> 'b). ring_homomorphism(r,r') f
        ==> !n. f(ring_of_int r n) = ring_of_int r' n
Proof
  REPEAT GEN_TAC THEN DISCH_TAC THEN
  SIMP_TAC std_ss [FORALL_INT_CASES, RING_OF_INT_CASES] THEN
  FIRST_ASSUM(fn th => ASM_SIMP_TAC std_ss
   [RING_NEG, RING_OF_NUM, MATCH_MP RING_HOMOMORPHISM_NEG th]) THEN
  FIRST_ASSUM(fn th =>
   ASM_SIMP_TAC std_ss [MATCH_MP RING_HOMOMORPHISM_RING_OF_NUM th])
QED

(* NOTE: This theorem was part of HOL-Light's RING_MONOMORPHIC_IMAGE_RULE *)
Theorem RING_MONOMORPHIC_IMAGE_RULE_THM :
    !r r' (f :'a -> 'b).
          ring_monomorphism(r,r') f
          ==> (!x x' y y'.
                  (x IN ring_carrier r /\ f x = x') /\
                  (y IN ring_carrier r /\ f y = y')
                  ==> (x = y <=> x' = y')) /\
              (!x. x IN ring_carrier r
                   ==> x IN ring_carrier r /\ f x = f x) /\
              (ring_0 r IN ring_carrier r /\ f(ring_0 r) = ring_0 r') /\
              (ring_1 r IN ring_carrier r /\ f(ring_1 r) = ring_1 r') /\
              (!n. ring_of_num r n IN ring_carrier r /\
                   f(ring_of_num r n) = ring_of_num r' n) /\
              (!n. ring_of_int r n IN ring_carrier r /\
                   f(ring_of_int r n) = ring_of_int r' n) /\
              (!x x'. x IN ring_carrier r /\ f x = x'
                      ==> ring_neg r x IN ring_carrier r /\
                          f(ring_neg r x) = ring_neg r' x') /\
              (!n x x'.
                  x IN ring_carrier r /\ f x = x'
                  ==> ring_pow r x n IN ring_carrier r /\
                      f(ring_pow r x n) = ring_pow r' x' n) /\
              (!x x' y y'.
                  (x IN ring_carrier r /\ f x = x') /\
                  (y IN ring_carrier r /\ f y = y')
                  ==> ring_add r x y IN ring_carrier r /\
                      f(ring_add r x y) = ring_add r' x' y') /\
              (!x x' y y'.
                  (x IN ring_carrier r /\ f x = x') /\
                  (y IN ring_carrier r /\ f y = y')
                  ==> ring_sub r x y IN ring_carrier r /\
                      f(ring_sub r x y) = ring_sub r' x' y') /\
              (!x x' y y'.
                  (x IN ring_carrier r /\ f x = x') /\
                  (y IN ring_carrier r /\ f y = y')
                  ==> ring_mul r x y IN ring_carrier r /\
                      f(ring_mul r x y) = ring_mul r' x' y')
Proof
    rpt GEN_TAC >> REWRITE_TAC[ring_monomorphism]
 >> GEN_REWRITE_TAC LAND_CONV empty_rewrites [CONJ_SYM]
 >> MATCH_MP_TAC MONO_AND
 >> CONJ_TAC >- MESON_TAC[]
 >> METIS_TAC[RING_0, RING_1, RING_OF_NUM, RING_OF_INT, RING_NEG,
              RING_POW, RING_ADD, RING_SUB, RING_MUL,
              RING_HOMOMORPHISM_0, RING_HOMOMORPHISM_1,
              RING_HOMOMORPHISM_RING_OF_NUM, RING_HOMOMORPHISM_RING_OF_INT,
              RING_HOMOMORPHISM_NEG, RING_HOMOMORPHISM_POW,
              RING_HOMOMORPHISM_ADD, RING_HOMOMORPHISM_SUB,
              RING_HOMOMORPHISM_MUL]
QED

(* ------------------------------------------------------------------------- *)
(* Relation of isomorphism.                                                  *)
(* ------------------------------------------------------------------------- *)

Definition ring_isomorphisms :
    ring_isomorphisms (r,r') ((f:'a->'b),g) <=>
        ring_homomorphism (r,r') f /\
        ring_homomorphism (r',r) g /\
        (!x. x IN ring_carrier r ==> g(f x) = x) /\
        (!y. y IN ring_carrier r' ==> f(g y) = y)
End

Definition ring_isomorphism_def :
    ring_isomorphism (r,r') (f :'a -> 'b) <=> RingIso f (fromRing r) (fromRing r')
End

(* NOTE: This theorem is the definition of ‘ring_isomorphism’ in HOL-Light *)
Theorem ring_isomorphism :
    !(f :'a -> 'b) r r'.
      ring_isomorphism (r,r') (f:'a->'b) <=> ?g. ring_isomorphisms (r,r') (f,g)
Proof
    RW_TAC std_ss [ring_isomorphism_def, RingIso_def, ring_isomorphisms]
 >> EQ_TAC >> rw [] (* 3 subgoals *)
 >| [ (* goal 1 (of 3) *)
      Q.PAT_ASSUM ‘BIJ f _ _’
        (fn th => MP_TAC (REWRITE_RULE [th]
                           (Q.SPECL [‘f’, ‘ring_carrier r’, ‘ring_carrier r'’]
                                    BIJ_IFF_INV))) \\
      RW_TAC std_ss [ring_carrier_def] \\
      Q.EXISTS_TAC ‘g’ >> art [] \\
      qabbrev_tac ‘r1 = fromRing r’ \\
      qabbrev_tac ‘r2 = fromRing r'’ \\
      MP_TAC (Q.SPECL [‘r1’, ‘r2’, ‘f’] ring_homo_sym) \\
     ‘Ring r1 /\ Ring r2’ by rw [Abbr ‘r1’, Abbr ‘r2’] >> art [] \\
      Suff ‘RingHomo (LINV f r1.carrier) r2 r1 = RingHomo g r2 r1’
      >- rw [ring_homomorphism_def] \\
      MATCH_MP_TAC ring_homo_cong >> rw [] \\
      irule BIJ_IS_INJ \\
      qexistsl_tac [‘f’, ‘r1.carrier’, ‘r2.carrier’] >> rw []
      >- (irule BIJ_LINV_INV >> Q.EXISTS_TAC ‘r2.carrier’ >> art []) \\
      Q.ABBREV_TAC ‘h = LINV f r1.carrier’ \\
     ‘BIJ h r2.carrier r1.carrier’ by PROVE_TAC [BIJ_LINV_BIJ] \\
      POP_ASSUM MP_TAC >> rw [BIJ_ALT, IN_FUNSET],
      (* goal 2 (of 2) *)
      ASM_REWRITE_TAC [GSYM ring_homomorphism_def],
      (* goal 2 (of 1) *)
      rw [BIJ_IFF_INV]
      >- (Q.PAT_X_ASSUM ‘ring_homomorphism (r,r') f’ MP_TAC \\
          rw [ring_homomorphism_def, RingHomo_def]) \\
      Q.EXISTS_TAC ‘g’ >> fs [ring_carrier_def] \\
      Q.PAT_X_ASSUM ‘ring_homomorphism (r',r) g’ MP_TAC \\
      rw [ring_homomorphism_def, RingHomo_def] ]
QED

val _ = set_fixity "isomorphic_ring" (Infixr 490);
Definition isomorphic_ring :
    r isomorphic_ring r' <=> ?(f :'a -> 'b). ring_isomorphism (r,r') f
End

Theorem CARD_LE_RING_MONOMORPHIC_IMAGE :
    !r r' (f :'a -> 'b).
        ring_monomorphism(r,r') f ==> ring_carrier r <=_c ring_carrier r'
Proof
  REWRITE_TAC[ring_monomorphism, le_c, ring_homomorphism] THEN
  REPEAT STRIP_TAC THEN EXISTS_TAC “f :'a -> 'b” THEN ASM_SET_TAC[]
QED

Definition ring_epimorphism :
    ring_epimorphism (r,r') (f :'a -> 'b) <=>
        ring_homomorphism (r,r') f /\
        IMAGE f (ring_carrier r) = ring_carrier r'
End

Theorem CARD_LE_RING_EPIMORPHIC_IMAGE :
    !r r' (f :'a -> 'b).
        ring_epimorphism(r,r') f ==> ring_carrier r' <=_c ring_carrier r
Proof
  REWRITE_TAC[ring_epimorphism, LE_C, ring_homomorphism] THEN
  REPEAT STRIP_TAC THEN EXISTS_TAC “f :'a -> 'b” THEN ASM_SET_TAC[]
QED

Theorem FORALL_IN_IMAGE_2 :
    !(f :'a -> 'b) P s.
                 (!x y. x IN IMAGE f s /\ y IN IMAGE f s ==> P x y) <=>
                 (!x y. x IN s /\ y IN s ==> P (f x) (f y))
Proof
  SET_TAC[]
QED

Theorem RING_ISOMORPHISM :
    !r r' (f :'a -> 'b).
      ring_isomorphism (r,r') (f :'a -> 'b) <=>
      ring_homomorphism (r,r') f /\
      IMAGE f (ring_carrier r) = ring_carrier r' /\
      (!x y. x IN ring_carrier r /\ y IN ring_carrier r /\ f x = f y
             ==> x = y)
Proof
  REPEAT GEN_TAC THEN
  REWRITE_TAC[ring_isomorphism, ring_isomorphisms, ring_homomorphism] THEN
  SIMP_TAC std_ss[INJECTIVE_ON_LEFT_INVERSE, RIGHT_AND_EXISTS_THM] THEN
  AP_TERM_TAC THEN ABS_TAC THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] >- ASM_SET_TAC[] THEN
  SUBST1_TAC(SYM(ASSUME
    “IMAGE (f :'a -> 'b) (ring_carrier r) = ring_carrier r'”)) THEN
  SIMP_TAC std_ss[SUBSET_DEF, FORALL_IN_IMAGE, FORALL_IN_IMAGE_2] THEN
  ASM_SIMP_TAC std_ss[] THEN
  ASM_MESON_TAC[RING_0, RING_ADD, RING_MUL, RING_1, RING_NEG]
QED

Theorem RING_MONOMORPHISM_EPIMORPHISM :
    !r r' (f :'a -> 'b).
        ring_monomorphism (r,r') f /\ ring_epimorphism (r,r') f <=>
        ring_isomorphism (r,r') f
Proof
  REWRITE_TAC[RING_ISOMORPHISM, ring_monomorphism, ring_epimorphism] THEN
  MESON_TAC[]
QED

Theorem RING_ISOMORPHISM_IMP_MONOMORPHISM :
    !r r' (f :'a -> 'b).
        ring_isomorphism (r,r') f ==> ring_monomorphism (r,r') f
Proof
  SIMP_TAC std_ss[GSYM RING_MONOMORPHISM_EPIMORPHISM]
QED

Theorem CARD_EQ_RING_ISOMORPHIC_IMAGE :
    !r r' (f :'a -> 'b).
        ring_isomorphism(r,r') f ==> ring_carrier r =_c ring_carrier r'
Proof
  REWRITE_TAC[GSYM RING_MONOMORPHISM_EPIMORPHISM, GSYM CARD_LE_ANTISYM] THEN
  MESON_TAC[CARD_LE_RING_MONOMORPHIC_IMAGE, CARD_LE_RING_EPIMORPHIC_IMAGE]
QED

Theorem ISOMORPHIC_RING_CARD_EQ :
    !(r :'a Ring) (r' :'b Ring).
        r isomorphic_ring r' ==> ring_carrier r =_c ring_carrier r'
Proof
    RW_TAC std_ss[isomorphic_ring, LEFT_IMP_EXISTS_THM]
 >> MATCH_MP_TAC CARD_EQ_RING_ISOMORPHIC_IMAGE
 >> Q.EXISTS_TAC ‘f’ >> art []
QED

Theorem ISOMORPHIC_COPY_OF_RING :
    !(r :'a Ring) (s :'b -> bool).
        (?r'. ring_carrier r' = s /\ r isomorphic_ring r') <=> ring_carrier r =_c s
Proof
    rpt GEN_TAC
 >> EQ_TAC >- MESON_TAC[ISOMORPHIC_RING_CARD_EQ, CARD_EQ_TRANS]
 >> SIMP_TAC std_ss[EQ_C_BIJECTIONS, LEFT_IMP_EXISTS_THM]
 >> rpt STRIP_TAC
 >> Q.ABBREV_TAC
   ‘r0 = raw_ring (s, f (ring_0 r), f (ring_1 r),
                      (\x1 x2. f(ring_add r (g x1) (g x2))),
                      (\x1 x2. f(ring_mul r (g x1) (g x2))))’
 >> Know ‘Ring r0’
 >- (rw [Abbr ‘r0’, raw_ring_def] \\
     simp [Once Ring_def] \\
     ONCE_REWRITE_TAC [DECIDE “p /\ q /\ r <=> r /\ q /\ p”] \\
     CONJ_TAC >- (rpt STRIP_TAC \\
                  fs [ring_mul_def, ring_add_def, ring_carrier_def]) \\
  (* AbelianMonoid ... (easier) *)
     CONJ_TAC
     >- (simp [AbelianMonoid_def, Once Monoid_def] \\
         reverse CONJ_TAC
         >- (rpt STRIP_TAC >> AP_TERM_TAC \\
             MATCH_MP_TAC RING_MUL_SYM >> rw []) \\
         CONJ_TAC >- (rw [ring_mul_def] >> fs [ring_carrier_def]) \\
         reverse CONJ_TAC >- (rw [ring_mul_def, ring_1_def] \\
                              fs [ring_carrier_def]) \\
         rpt STRIP_TAC >> AP_TERM_TAC \\
        ‘ring_mul r (g x) (g y) IN ring_carrier r /\
         ring_mul r (g y) (g z) IN ring_carrier r’
           by fs [ring_mul_def, ring_carrier_def] >> simp [] \\
         MATCH_MP_TAC (GSYM RING_MUL_ASSOC) >> rw []) \\
  (* AbelianMonoid ... (harder) *)
     simp [AbelianGroup_def, Group_def] \\
     reverse CONJ_TAC
     >- (rpt STRIP_TAC >> AP_TERM_TAC \\
         MATCH_MP_TAC RING_ADD_SYM >> rw []) \\
     simp [Once Monoid_def] \\
     CONJ_TAC
     >- (CONJ_TAC >- fs [ring_add_def, RING_ADD] \\
         reverse CONJ_TAC
         >- (rw [ring_0_def, ring_add_def] >> fs [ring_carrier_def]) \\
         rpt STRIP_TAC >> AP_TERM_TAC \\
        ‘ring_add r (g x) (g y) IN ring_carrier r /\
         ring_add r (g y) (g z) IN ring_carrier r’
           by fs [ring_add_def, ring_carrier_def] >> simp [] \\
         MATCH_MP_TAC (GSYM RING_ADD_ASSOC) >> rw []) \\
  (* monoid_invertibles *)
     rw [monoid_invertibles_def, Once EXTENSION] (* key *) \\
     EQ_TAC >> rw [] (* one goal left *) \\
  (* NOTE: The process of guessing out this ‘y’:
           f (ring_add r (g x) (g y)) = f (ring_0 r)
       <=> ring_add r (g x) (g y) = ring_0 r
       <=> (g y) = ring_neg r (g x)
       <=> f (g y) = f (ring_neg r (g x))
       <=> y = f (ring_neg r (g x))
   *)
     Q.EXISTS_TAC ‘f (ring_neg r (g x))’ \\
    ‘g x IN ring_carrier r’ by rw [] \\
    ‘ring_neg r (g x) IN ring_carrier r’ by rw [RING_NEG] \\
     CONJ_TAC >- rw [] (* f (ring_neg r (g x)) IN s *) \\
     Know ‘g (f (ring_neg r (g x))) = ring_neg r (g x)’ >- rw [] >> Rewr' \\
     REWRITE_TAC [ring_add_def, ring_neg_def, ring_0_def] \\
     qabbrev_tac ‘r0 = fromRing r’ \\
    ‘Ring r0’ by rw [Abbr ‘r0’] >> fs [ring_carrier_def])
 >> DISCH_TAC
 >> Q.EXISTS_TAC ‘toRing r0’
 >> Q.ABBREV_TAC ‘r' = toRing r0’
 >> Q.SUBGOAL_THEN
   ‘ring_carrier r' = s /\
    ring_0 r' = (f :'a -> 'b) (ring_0 r) /\
    ring_1 r' = f (ring_1 r) /\
   (!x. x IN ring_carrier r' ==> ring_neg r' x = f(ring_neg r (g x))) /\
    ring_add r' = (\x1 x2. f(ring_add r (g x1) (g x2))) /\
    ring_mul r' = (\x1 x2. f(ring_mul r (g x1) (g x2)))’ STRIP_ASSUME_TAC
 >- (simp [Abbr ‘r'’] \\
     REWRITE_TAC [ring_carrier_def, ring_0_def, ring_1_def,
                  ring_add_def, ring_mul_def, ring_neg_def] \\
     Know ‘fromRing (toRing r0) = r0’
     >- (MATCH_MP_TAC from_toRing >> art []) >> Rewr' \\
     REWRITE_TAC [GSYM ring_add_def, GSYM ring_mul_def, GSYM ring_neg_def,
                  GSYM ring_0_def, GSYM ring_1_def] \\
     rw [Abbr ‘r0’, raw_ring_def, ring_0_def, ring_1_def, ring_add_def,
         ring_mul_def] (* one goal about ‘ring_neg’ is left *) \\
     REWRITE_TAC [GSYM ring_add_def, GSYM ring_mul_def, GSYM ring_neg_def,
                  GSYM ring_0_def, GSYM ring_1_def] \\
     Q.ABBREV_TAC ‘r1 = <|carrier := s;
                               op := (\x1 x2. f (ring_add r (g x1) (g x2)));
                               id := f (ring_0 r)|>’ \\
  (* applying (Q.SPEC ‘r1’ group_inv_eq_swap) *)
     Know ‘r1.inv x = f (ring_neg r (g x)) <=>
           x = r1.inv (f (ring_neg r (g x)))’
     >- (irule (Q.ISPEC ‘r1 :'b monoid’ group_inv_eq_swap) \\
         CONJ_TAC >- (Q.PAT_X_ASSUM ‘Ring _’ MP_TAC \\
                      rw [raw_ring_def, Once Ring_def, AbelianGroup_def]) \\
         CONJ_ASM1_TAC >- rw [Abbr ‘r1’] \\
         rw [Abbr ‘r1’, RING_NEG]) >> Rewr' \\
  (* stage work *)
     fs [raw_ring_def, Once Ring_def, AbelianGroup_def, Group_def] \\
     Q.PAT_X_ASSUM ‘AbelianMonoid _’ K_TAC (* useless, so is the next *) \\
     Q.PAT_X_ASSUM ‘!x y z. x IN s /\ y IN s /\ z IN s ==> P’ K_TAC \\
     Q.PAT_X_ASSUM ‘!x y. x IN r1.carrier /\ y IN r1.carrier ==> P’ K_TAC \\
     MP_TAC (Q.SPEC ‘r1’ (INST_TYPE [“:'a” |-> “:'b”] monoid_inv_def)) \\
     RW_TAC std_ss [] (* ‘s’ is removed here *) \\
     qabbrev_tac ‘s = r1.carrier’ (* recreate ‘s’ *) \\
    ‘s = IMAGE f (ring_carrier r)’ by ASM_SET_TAC [] (* from HOL-Light's proof *) \\
     POP_ASSUM (fs o wrap) \\
     rename1 ‘x = f y’ (* renamed x' to y *) \\
     Q.PAT_X_ASSUM ‘!z. (?x. z = f x /\ x IN ring_carrier r) ==> P’
        (MP_TAC o (Q.SPEC ‘f (ring_neg r y)’)) \\
     Know ‘?x. f (ring_neg r y) = f x /\ x IN ring_carrier r’
     >- (Q.EXISTS_TAC ‘ring_neg r y’ >> rw [RING_NEG]) \\
     RW_TAC std_ss [] \\
     rename1 ‘r1.inv (f (ring_neg r y)) = f z’ (* rename x' to z *) \\
     Q.PAT_X_ASSUM ‘z IN ring_carrier r’ K_TAC (* z assumptions are useless *) \\
     Q.PAT_X_ASSUM ‘r1.inv (f (ring_neg r y)) = f z’ K_TAC \\
  (* now using assumptions given by monoid_inv_def *)
     POP_ASSUM MP_TAC \\
     Know ‘r1.op = (\x1 x2. f (ring_add r (g x1) (g x2)))’ >- rw [Abbr ‘r1’] \\
     Know ‘r1.id = f (ring_0 r)’ >- rw [Abbr ‘r1’] \\
     NTAC 2 Rewr' >> rw [] \\
     Q.PAT_X_ASSUM ‘r1.op _ _ = r1.id’ K_TAC (* the other is useless *) \\
     Know ‘ring_neg r y IN ring_carrier r’
     >- (MATCH_MP_TAC RING_NEG >> art []) >> DISCH_TAC \\
     Know ‘g (f (ring_neg r y)) = g (f x)’ >- (AP_TERM_TAC >> art []) \\
     Q.PAT_X_ASSUM ‘f (ring_neg r y) = f x’ K_TAC \\
     simp [] >> DISCH_TAC \\
     Know ‘ring_neg r x = y’
     >- (MATCH_MP_TAC RING_RNEG_UNIQUE >> PROVE_TAC [RING_ADD_EQ_0]) \\
     DISCH_THEN (ONCE_REWRITE_TAC o wrap o SYM) \\
     Know ‘r1.inv (f x) IN monoid_invertibles r1’
     >- (irule monoid_inv_invertible >> rw []) >> art [IN_IMAGE] \\
     DISCH_TAC \\
    ‘g (r1.inv (f x)) IN ring_carrier r’ by PROVE_TAC [] \\
     Q.ABBREV_TAC ‘z = g (r1.inv (f x))’ \\
     Know ‘g (f (ring_add r z x)) = g (f (ring_0 r))’ >- (AP_TERM_TAC >> art []) \\
    ‘ring_add r z x IN ring_carrier r /\ ring_0 r IN ring_carrier r’
       by rw [RING_ADD, RING_0] \\
     simp [] \\
     Q.PAT_X_ASSUM ‘f (ring_add r z x) = f (ring_0 r)’ K_TAC \\
     DISCH_TAC (* ring_add r z x = ring_0 r *) \\
  (* cf. Q.SPECL [‘r’, ‘z’, ‘x’] RING_RNEG_UNIQUE *)
     Know ‘ring_neg r x = z’ >- (MATCH_MP_TAC RING_RNEG_UNIQUE >> art []) \\
     Rewr' (* new goal: f z = r1.inv (f x) *) \\
     rw [Abbr ‘z’])
 (* stage work *)
 >> ASM_REWRITE_TAC[isomorphic_ring] THEN
    Q.EXISTS_TAC ‘f’ THEN REWRITE_TAC[ring_isomorphism] THEN
    Q.EXISTS_TAC ‘g’ THEN REWRITE_TAC[ring_isomorphisms] THEN
    NTAC 2 (POP_ASSUM MP_TAC) \\
    NTAC 2 (DISCH_THEN (STRIP_ASSUME_TAC o SIMP_RULE std_ss [FUN_EQ_THM])) \\
    ASM_SIMP_TAC std_ss [ring_homomorphism, RING_0, RING_1, SUBSET_DEF,
                         FORALL_IN_IMAGE, RING_NEG, RING_ADD, RING_MUL]
QED

(* ------------------------------------------------------------------------- *)
(* Charaterizing trivial (zero) rings.                                       *)
(* ------------------------------------------------------------------------- *)

(* NOTE: ringTheory.trivial_ring is a theorem *)
Definition trivial_ring :
    trivial_ring (r :'a Ring) <=> ring_carrier r = {ring_0 r}
End

Theorem TRIVIAL_RING_10 :
    !r :'a Ring. trivial_ring r <=> ring_1 r = ring_0 r
Proof
  REWRITE_TAC[trivial_ring, EXTENSION, IN_SING] THEN
  MESON_TAC[RING_1, RING_0, RING_MUL_LID, RING_MUL_LZERO]
QED

Definition singleton_ring :
    singleton_ring (a :'a) = toRing (ring$trivial_ring a)
End

Theorem RING_HOMOMORPHISM :
    !r r' (f :'a -> 'b).
        ring_homomorphism (r,r') (f :'a -> 'b) <=>
        IMAGE f (ring_carrier r) SUBSET ring_carrier r' /\
        f(ring_1 r) = ring_1 r' /\
        (!x y. x IN ring_carrier r /\ y IN ring_carrier r
               ==> f(ring_add r x y) = ring_add r' (f x) (f y)) /\
        (!x y. x IN ring_carrier r /\ y IN ring_carrier r
               ==> f(ring_mul r x y) = ring_mul r' (f x) (f y))
Proof
  REPEAT GEN_TAC THEN REWRITE_TAC[ring_homomorphism] THEN
  EQ_TAC THEN STRIP_TAC THEN ASM_REWRITE_TAC[] THEN
  RULE_ASSUM_TAC(SIMP_RULE std_ss[SUBSET_DEF, FORALL_IN_IMAGE]) THEN
  MATCH_MP_TAC(TAUT `p /\ (p ==> q) ==> p /\ q`) THEN CONJ_TAC THENL
  [ (* goal 1 (of 2) *)
    REPEAT(FIRST_X_ASSUM(MP_TAC o SPECL [“ring_0 r:'a”, “ring_0 r:'a”])) THEN
    SIMP_TAC std_ss[RING_0, RING_ADD_LZERO] THEN
    ASM_MESON_TAC[RING_LZERO_UNIQUE, RING_0],
    (* goal 2 (of 2) *)
    REPEAT STRIP_TAC THEN CONV_TAC SYM_CONV THEN
    MATCH_MP_TAC RING_LNEG_UNIQUE THEN
    REPEAT(FIRST_X_ASSUM(MP_TAC o SPECL [“x :'a”, “ring_neg r (x :'a)”])) THEN
    ASM_SIMP_TAC std_ss[RING_NEG, RING_ADD_RNEG] ]
QED

Theorem RING_HOMOMORPHISM_FROM_TRIVIAL_RING :
    !(f :'a -> 'b) r r'.
        trivial_ring r
        ==> (ring_homomorphism(r,r') f <=>
             trivial_ring r' /\ IMAGE f (ring_carrier r) = {ring_0 r'})
Proof
  REPEAT GEN_TAC THEN
  GEN_REWRITE_TAC LAND_CONV empty_rewrites [trivial_ring] THEN
  DISCH_TAC THEN EQ_TAC THENL
  [ (* goal 1 (of 2) *)
    ASM_SIMP_TAC std_ss[ring_homomorphism, TRIVIAL_RING_10] THEN
    MP_TAC(ISPEC “r:'a Ring” RING_1) THEN ASM_SET_TAC[],
    (* goal 2 (of 2) *)
    SIMP_TAC std_ss[trivial_ring, RING_HOMOMORPHISM] THEN
    STRIP_TAC THEN FIRST_X_ASSUM(ASSUME_TAC o MATCH_MP
     (SET_RULE “IMAGE f s = {a} ==> !x. x IN s ==> f x = a”)) THEN
    ASM_SIMP_TAC std_ss[RING_0, RING_1, RING_ADD, RING_MUL,
                        RING_ADD_LZERO, RING_MUL_LZERO] THEN
    MP_TAC(ISPEC “r':'b Ring” RING_0) THEN
    MP_TAC(ISPEC “r':'b Ring” RING_1) THEN ASM_SET_TAC[] ]
QED

Theorem RING_MONOMORPHISM_FROM_TRIVIAL_RING :
    !(f :'a -> 'b) r r'.
        trivial_ring r
        ==> (ring_monomorphism (r,r') f <=> ring_homomorphism (r,r') f)
Proof
  REWRITE_TAC[ring_monomorphism, trivial_ring] THEN SET_TAC[]
QED

(* NOTE: Similar with the case of PRODUCT_RING, the ring_neg part is out *)
Theorem SINGLETON_RING :
   (!a :'a. ring_carrier(singleton_ring a) = {a}) /\
   (!a :'a. ring_0(singleton_ring a) = a) /\
   (!a :'a. ring_1(singleton_ring a) = a) /\
   (!a :'a. ring_add(singleton_ring a) = \x y. a) /\
   (!a :'a. ring_mul(singleton_ring a) = \x y. a)
Proof
    rw [singleton_ring, ring_carrier_def, ring_0_def, ring_1_def,
        ring_add_def, ring_mul_def] (* 5 subgoals, same initial tactics *)
 >> ‘fromRing (toRing (ring$trivial_ring a)) = ring$trivial_ring a’
       by (MATCH_MP_TAC from_toRing >> rw [trivial_ring_thm])
 >> POP_ORW
 >> MP_TAC (Q.SPEC ‘a’ trivial_ring_thm)
 >> rw [trivial_ring_def]
QED

Theorem TRIVIAL_RING_SINGLETON_RING :
    !a :'a. trivial_ring(singleton_ring a)
Proof
  REWRITE_TAC[trivial_ring, SINGLETON_RING]
QED

(* ------------------------------------------------------------------------- *)
(* General Cartesian product / dependent function space (sets.ml/card.ml)    *)
(* ------------------------------------------------------------------------- *)

Definition cartesian_product :
    cartesian_product k (s :'k -> 'a -> bool) =
        {f :'k -> 'a | EXTENSIONAL k f /\ !i. i IN k ==> f i IN s i}
End

Theorem IN_CARTESIAN_PRODUCT :
    !k s (x :'k -> 'a).
        x IN cartesian_product k s <=>
        EXTENSIONAL k x /\ (!i. i IN k ==> x i IN s i)
Proof
    RW_TAC std_ss' [cartesian_product]
QED

(* NOTE: HOL-Light's set_exp is denoted by "^_c", which cannot be parsed in
         HOL-Light. HOL-Light's theorem [exp_c] is HOL4's [set_exp_def].
 *)
Theorem CARTESIAN_PRODUCT_CONST :
    !(s :'a -> bool) (t :'b -> bool).
        cartesian_product t (\i. s) = s ** t
Proof
    rw [Once EXTENSION, cartesian_product, set_exp_def, EXTENSIONAL_def]
 >> SET_TAC []
QED

Theorem RESTRICTION_IN_CARTESIAN_PRODUCT :
    !k s (f :'k -> 'a).
        RESTRICTION k f IN cartesian_product k s <=>
        !i. i IN k ==> (f i) IN (s i)
Proof
    RW_TAC std_ss' [RESTRICTION, cartesian_product, EXTENSIONAL]
QED

(* ------------------------------------------------------------------------- *)
(* Direct products of rings                                                  *)
(* ------------------------------------------------------------------------- *)

Definition raw_product_ring_def :
    raw_product_ring k (r :'k -> 'a Ring) =
        let c = cartesian_product k (\i. ring_carrier ((r :'k -> 'a Ring) i));
            g = <| carrier := c;
                   op := (\x y. RESTRICTION k (\i. ring_add (r i) (x i) (y i)));
                   id := RESTRICTION k (\i. ring_0 (r i)) |>;
            m = <| carrier := c;
                   op := (\x y. RESTRICTION k (\i. ring_mul (r i) (x i) (y i)));
                   id := RESTRICTION k (\i. ring_1 (r i)) |>
        in
           <| carrier := c; sum := g; prod := m |>
End

Theorem Ring_raw_product_ring[local] :
    !k (r :'k -> 'a Ring). Ring (raw_product_ring k r)
Proof
    rw [raw_product_ring_def]
 >> simp [Once Ring_def]
 >> ONCE_REWRITE_TAC [CONJ_ASSOC]
 >> reverse CONJ_TAC
 >- (rw [IN_CARTESIAN_PRODUCT, ring_carrier_def, ring_mul_def, ring_add_def] \\
     rw [RESTRICTION_EXTENSION] \\
     rw [RESTRICTION_DEFINED])
 (* AbelianMonoid ... (easier) *)
 >> reverse CONJ_TAC
 >- (simp [AbelianMonoid_def] \\
     reverse CONJ_TAC
     >- (rw [IN_CARTESIAN_PRODUCT, RESTRICTION_EXTENSION] \\
         MATCH_MP_TAC RING_MUL_SYM >> rw []) \\
     rw [Once Monoid_def, IN_CARTESIAN_PRODUCT,
         EXTENSIONAL_RESTRICTION] >| (* 5 subgoals *)
     [ (* goal 1 (of 5) *)
       rw [RESTRICTION_DEFINED, ring_mul_def] \\
       fs [ring_carrier_def],
       (* goal 2 (of 5) *)
       rw [RESTRICTION_EXTENSION] \\
       rw [RESTRICTION_DEFINED] \\
       MATCH_MP_TAC (GSYM RING_MUL_ASSOC) >> rw [],
       (* goal 3 (of 5) *)
       rw [RESTRICTION_DEFINED, ring_1_def, ring_carrier_def],
       (* goal 4 (of 5) *)
       simp [RESTRICTION, FUN_EQ_THM, ring_mul_def, ring_1_def] \\
       Q.X_GEN_TAC ‘i’ \\
       Cases_on ‘i IN k’ >> fs [EXTENSIONAL_def, ring_carrier_def],
       (* goal 5 (of 5) *)
       simp [RESTRICTION, FUN_EQ_THM, ring_mul_def, ring_1_def] \\
       Q.X_GEN_TAC ‘i’ \\
       Cases_on ‘i IN k’ >> fs [EXTENSIONAL_def, ring_carrier_def] ])
 (* AbelianMonoid ... (harder) *)
 >> simp [AbelianGroup_def, Group_def]
 >> reverse CONJ_TAC
 >- (rw [IN_CARTESIAN_PRODUCT] \\
     rw [RESTRICTION_EXTENSION] \\
     MATCH_MP_TAC RING_ADD_SYM >> rw [])
 >> CONJ_TAC (* Monoid ... *)
 >- (rw [Once Monoid_def, IN_CARTESIAN_PRODUCT,
         EXTENSIONAL_RESTRICTION] >| (* 5 subgoals *)
     [ (* goal 1 (of 5) *)
       rw [RESTRICTION_DEFINED, ring_add_def] \\
       fs [ring_carrier_def],
       (* goal 2 (of 5) *)
       rw [RESTRICTION_EXTENSION] \\
       rw [RESTRICTION_DEFINED] \\
       MATCH_MP_TAC (GSYM RING_ADD_ASSOC) >> rw [],
       (* goal 3 (of 5) *)
       rw [RESTRICTION_DEFINED, ring_0_def, ring_carrier_def],
       (* goal 4 (of 5) *)
       simp [RESTRICTION, FUN_EQ_THM, ring_add_def, ring_0_def] \\
       Q.X_GEN_TAC ‘i’ \\
       Cases_on ‘i IN k’ >> fs [EXTENSIONAL_def, ring_carrier_def],
       (* goal 5 (of 5) *)
       simp [RESTRICTION, FUN_EQ_THM, ring_add_def, ring_0_def] \\
       Q.X_GEN_TAC ‘i’ \\
       Cases_on ‘i IN k’ >> fs [EXTENSIONAL_def, ring_carrier_def] ])
 (* monoid_invertibles *)
 >> rw [monoid_invertibles_def] (* key *)
 >> rw [Once EXTENSION, IN_CARTESIAN_PRODUCT]
 >> EQ_TAC >> rw [] (* one goal left *)
 >> Q.EXISTS_TAC ‘RESTRICTION k (\i. ring_neg (r i) (x i))’
 >> rw [RESTRICTION_EXTENSION, EXTENSIONAL_RESTRICTION] (* 3 subgoals, same tactic *)
 >> rw [RESTRICTION_DEFINED, RING_NEG, RING_ADD_EQ_0, RING_NEG_NEG]
QED

Definition product_ring :
    product_ring k (r :'k -> 'a Ring) = toRing (raw_product_ring k r)
End

(* NOTE: the original version of this theorem in HOL Light has also a part for
  ‘ring_neg’, but in HOL4 it cannot be proved as .inv is a derived operator.
   See PRODUCT_RING_NEG for the modified theorem corresponding to that part.
 *)
Theorem PRODUCT_RING :
   (!k (r :'k -> 'a Ring).
        ring_carrier(product_ring k r) =
          cartesian_product k (\i. ring_carrier(r i))) /\
   (!k (r :'k -> 'a Ring).
        ring_0 (product_ring k r) =
          RESTRICTION k (\i. ring_0 (r i))) /\
   (!k (r :'k -> 'a Ring).
        ring_1 (product_ring k r) =
          RESTRICTION k (\i. ring_1 (r i))) /\
   (!k (r :'k -> 'a Ring) x y.
        ring_add (product_ring k r) x y =
          RESTRICTION k (\i. ring_add (r i) (x i) (y i))) /\
   (!k (r :'k -> 'a Ring) x y.
        ring_mul (product_ring k r) x y =
          RESTRICTION k (\i. ring_mul (r i) (x i) (y i)))
Proof
    rw [product_ring, Once ring_carrier_def, Once ring_0_def, Once ring_1_def,
        Once ring_add_def, Once ring_mul_def] (* 5 subgoals, same initial tactics *)
 >> ‘fromRing (toRing (raw_product_ring k r)) = raw_product_ring k r’
       by (MATCH_MP_TAC from_toRing \\
           rw [Ring_raw_product_ring])
 >> POP_ORW
 >> MP_TAC (Q.SPECL [‘k’, ‘r’] Ring_raw_product_ring)
 >> rw [raw_product_ring_def]
QED

Theorem PRODUCT_RING_NEG :
    !k (r :'k -> 'a Ring).
       !x. x IN ring_carrier (product_ring k r) ==>
           ring_neg (product_ring k r) x =
           RESTRICTION k (\i. ring_neg (r i) (x i))
Proof
    rpt GEN_TAC
 >> simp [product_ring, Once ring_neg_def, Once ring_carrier_def]
 >> ‘fromRing (toRing (raw_product_ring k r)) = raw_product_ring k r’
       by (MATCH_MP_TAC from_toRing \\
           rw [Ring_raw_product_ring])
 >> POP_ORW
 >> MP_TAC (Q.SPECL [‘k’, ‘r’] Ring_raw_product_ring)
 >> rw [raw_product_ring_def]
 (* stage work *)
 >> fs [Once Ring_def]
 (* cleanup irrelevant assumptions *)
 >> Q.PAT_X_ASSUM ‘!x y z. P’       K_TAC
 >> Q.PAT_X_ASSUM ‘AbelianMonoid _’ K_TAC
 >> fs [AbelianGroup_def]
 (* cleanup irrelevant assumptions *)
 >> Q.PAT_X_ASSUM ‘!x y. P’         K_TAC
 >> Q.ABBREV_TAC
     ‘g = <|carrier := cartesian_product k (\i. ring_carrier (r i));
            op := (\x y. RESTRICTION k (\i. ring_add (r i) (x i) (y i)));
            id := RESTRICTION k (\i. ring_0 (r i))|>’
 (* now we know ‘x IN cartesian_product k (\i. ring_carrier (r i))’ *)
 >> fs [Group_def]
 (* applying monoid_inv_def *)
 >> MP_TAC (Q.SPECL [‘g’, ‘x’]
                    (INST_TYPE [“:'a” |-> “:'k -> 'a”] monoid_inv_def))
 >> simp []
 >> ‘g.carrier = cartesian_product k (\i. ring_carrier (r i))’
       by rw [Abbr ‘g’] >> POP_ORW
 >> rw []
 >> Q.PAT_X_ASSUM ‘g.op x (g.inv x) = g.id’ MP_TAC
 >> ‘g.op = (\x y. RESTRICTION k (\i. ring_add (r i) (x i) (y i)))’
       by rw [Abbr ‘g’] >> POP_ORW
 >> ‘g.id = RESTRICTION k (\i. ring_0 (r i))’
       by rw [Abbr ‘g’] >> POP_ORW
 >> rw [RESTRICTION_EXTENSION]
 >> fs [EXTENSIONAL_def, IN_CARTESIAN_PRODUCT]
 >> simp [FUN_EQ_THM]
 >> Q.X_GEN_TAC ‘i’
 >> reverse (Cases_on ‘i IN k’) >- rw [RESTRICTION]
 >> rw [RESTRICTION_DEFINED]
 >> Q.PAT_X_ASSUM ‘!i. i IN k ==> ring_add (r i) (x i) (g.inv x i) = ring_0 (r i)’
      (MP_TAC o (Q.SPEC ‘i’))
 >> rw []
 >> ONCE_REWRITE_TAC [EQ_SYM_EQ]
 >> MATCH_MP_TAC RING_LNEG_UNIQUE >> rw []
QED

(* |- !k r x.
        EXTENSIONAL k x /\ (!i. i IN k ==> x i IN ring_carrier (r i)) ==>
        ring_neg (product_ring k r) x = RESTRICTION k (\i. ring_neg (r i) (x i))
 *)
Theorem PRODUCT_RING_NEG' =
        PRODUCT_RING_NEG |> SIMP_RULE std_ss [PRODUCT_RING, IN_CARTESIAN_PRODUCT]

Theorem RING_TOTALIZATION_lemma[local] :
    !r :'a Ring.
            ~(trivial_ring r) /\ INFINITE univ(:'b) /\ univ(:'a) <=_c univ(:'b)
            ==> ring_carrier(product_ring univ(:'b) (\(i :'b). r)) =_c univ(:'b -> bool)
Proof
    rpt STRIP_TAC
 >> REWRITE_TAC[PRODUCT_RING, CARTESIAN_PRODUCT_CONST, UNIV_fun_exp]
 >> MATCH_MP_TAC CARD_EXP_ABSORB >> art []
 >> CONJ_TAC (* 2 subgoals *)
 >| [ (* goal 1 (of 2) *)
      TRANS_TAC CARD_LE_TRANS “{ring_0 r:'a;ring_1 r:'a}” \\
      CONJ_TAC >| (* 2 subgoals *)
      [ (* goal 1.1 (of 2) *)
        RULE_ASSUM_TAC(REWRITE_RULE[TRIVIAL_RING_10]) \\
        rw [CARD_LE_CARD, FINITE_INSERT, FINITE_EMPTY, FINITE_BOOL,
            CARD_BOOL, CARD_CLAUSES],
        (* goal 1.2 (of 2) *)
        MATCH_MP_TAC CARD_LE_SUBSET \\
        REWRITE_TAC[INSERT_SUBSET, EMPTY_SUBSET, RING_0, RING_1] ],
      (* goal 2 (of 2) *)
      TRANS_TAC CARD_LE_TRANS “univ(:'a)” \\
      ASM_SIMP_TAC std_ss [CARD_LE_SUBSET, SUBSET_UNIV] \\
      TRANS_TAC CARD_LE_TRANS “univ(:'b)” >> art [] \\
      SIMP_TAC std_ss[CARD_EXP_CANTOR, CARD_LT_IMP_LE] ]
QED

Theorem RING_MONOMORPHISM_COMPOSE :
    !r1 r2 r3 (f :'a -> 'b) (g :'b -> 'c).
        ring_monomorphism(r1,r2) f /\ ring_monomorphism(r2,r3) g
        ==> ring_monomorphism(r1,r3) (g o f)
Proof
  SIMP_TAC std_ss[ring_monomorphism, ring_homomorphism, INJECTIVE_ON_ALT] THEN
  SIMP_TAC std_ss[SUBSET_DEF, FORALL_IN_IMAGE, IMAGE_o, o_THM]
QED

Theorem RING_HOMOMORPHISM_COMPONENTWISE :
    !r k s (f :'a -> 'k -> 'b).
        ring_homomorphism(r,product_ring k s) f <=>
        IMAGE f (ring_carrier r) SUBSET EXTENSIONAL k /\
        !i. i IN k ==> ring_homomorphism (r,s i) (\x. f x i)
Proof
  REPEAT GEN_TAC THEN
  SIMP_TAC std_ss[ring_homomorphism, SUBSET_DEF, FORALL_IN_IMAGE] THEN
  SIMP_TAC std_ss[PRODUCT_RING, IN_CARTESIAN_PRODUCT] THEN
  REWRITE_TAC[RESTRICTION_UNIQUE_ALT] THEN
  REWRITE_TAC[SET_RULE “f IN EXTENSIONAL s <=> EXTENSIONAL s f”] THEN
  ASM_CASES_TAC
    “!x. x IN ring_carrier r ==> EXTENSIONAL k ((f :'a -> 'k -> 'b) x)”
  THENL [ALL_TAC, ASM_MESON_TAC[]] THEN
  ASM_SIMP_TAC std_ss[RING_0, RING_1, RING_NEG, RING_ADD, RING_MUL] THEN
 (* NOTE: below are additional proofs for PRODUCT_RING_NEG *)
  EQ_TAC >> RW_TAC std_ss [] >| (* 2 subgoals *)
  [ (* goal 1 (of 2) *)
    Know ‘ring_neg (product_ring k s) (f x) =
          RESTRICTION k (\i. ring_neg (s i) (f x i))’
    >- (rpt STRIP_TAC \\
        MATCH_MP_TAC PRODUCT_RING_NEG' >> rw []) >> Rewr' \\
    rw [RESTRICTION],
    (* goal 2 (of 2) *)
    Know ‘ring_neg (product_ring k s) (f x) =
          RESTRICTION k (\i. ring_neg (s i) (f x i))’
    >- (rpt STRIP_TAC \\
        MATCH_MP_TAC PRODUCT_RING_NEG' >> rw []) >> Rewr' \\
    REWRITE_TAC [FUN_EQ_THM] \\
    Q.X_GEN_TAC ‘i’ \\
    REWRITE_TAC [RESTRICTION] \\
    Cases_on ‘i IN k’ >- rw [] \\
    fs [EXTENSIONAL_def, RING_NEG] ]
QED

Theorem RING_HOMOMORPHISM_COMPONENTWISE_UNIV :
    !r s (f :'a -> 'k -> 'b).
        ring_homomorphism(r,product_ring univ(:'k) s) f <=>
        !i. ring_homomorphism (r,s i) (\x. f x i)
Proof
  REWRITE_TAC[RING_HOMOMORPHISM_COMPONENTWISE, IN_UNIV] THEN
  SIMP_TAC std_ss[SET_RULE “s SUBSET P <=> !x. x IN s ==> P x”] THEN
  REWRITE_TAC[EXTENSIONAL_UNIV]
QED

Theorem RING_HOMOMORPHISM_ID :
    !r :'a Ring. ring_homomorphism (r,r) (\x. x)
Proof
  SIMP_TAC std_ss[ring_homomorphism, IMAGE_ID, SUBSET_REFL]
QED

Theorem RING_HOMOMORPHISM_DIAGONAL_UNIV :
    !(r :'a Ring).
        ring_homomorphism (r,product_ring univ(:'k) (\i. r)) (\x i. x)
Proof
  REWRITE_TAC[RING_HOMOMORPHISM_COMPONENTWISE_UNIV] THEN
  SIMP_TAC std_ss[RING_HOMOMORPHISM_ID]
QED

Theorem RING_MONOMORPHISM_DIAGONAL_UNIV :
   !(r :'a Ring).
        ring_monomorphism (r,product_ring univ(:'k) (\i. r)) (\x i. x)
Proof
  REWRITE_TAC[ring_monomorphism, RING_HOMOMORPHISM_DIAGONAL_UNIV] THEN
  SET_TAC[]
QED

Theorem RING_TOTALIZATION :
    !r :'a Ring.
          (?r' f. ring_carrier r' = {()} /\
                  ring_monomorphism(r,r') f) \/
          (?r' f. ring_carrier r' = univ(:(num # 'a) -> bool)/\
                  ring_monomorphism(r,r') f)
Proof
    GEN_TAC THEN ASM_CASES_TAC “trivial_ring (r:'a Ring)”
 >- ( DISJ1_TAC THEN EXISTS_TAC “singleton_ring one” THEN
      EXISTS_TAC “(\x. one) :'a -> unit” THEN
      ASM_SIMP_TAC std_ss[RING_MONOMORPHISM_FROM_TRIVIAL_RING,
                          RING_HOMOMORPHISM_FROM_TRIVIAL_RING] THEN
      ASM_SIMP_TAC std_ss[TRIVIAL_RING_SINGLETON_RING, SINGLETON_RING] THEN
      REWRITE_TAC[IMAGE_CONST, RING_CARRIER_NONEMPTY] )
 >> DISJ2_TAC
 >> MP_TAC(snd(EQ_IMP_RULE(ISPECL
     [“product_ring univ(:num # 'a) (\i. (r :'a Ring))”, “univ(:num # 'a -> bool)”]
     ISOMORPHIC_COPY_OF_RING)))
 >> ANTS_TAC
 >| [ (* goal 1 (of 2) *)
      MATCH_MP_TAC RING_TOTALIZATION_lemma THEN
      ASM_REWRITE_TAC[GSYM MUL_C_UNIV, CARD_MUL_FINITE_EQ] THEN
      REWRITE_TAC[UNIV_NOT_EMPTY, DE_MORGAN_THM] THEN
      REWRITE_TAC[num_INFINITE, MUL_C_UNIV] THEN
      REWRITE_TAC[le_c] THEN EXISTS_TAC “\x:'a. (0,x)” THEN
      SIMP_TAC std_ss[IN_UNIV],
      (* goal 2 (of 2) *)
      HO_MATCH_MP_TAC MONO_EXISTS THEN Q.X_GEN_TAC ‘r'’ THEN
      STRIP_TAC THEN ASM_REWRITE_TAC[] ] THEN
 (* stage work *)
    FIRST_X_ASSUM(MP_TAC o GEN_REWRITE_RULE I empty_rewrites [isomorphic_ring]) THEN
    DISCH_THEN(Q.X_CHOOSE_TAC ‘f’) THEN
    Q.EXISTS_TAC ‘f o (\x i. x)’ THEN
    MATCH_MP_TAC RING_MONOMORPHISM_COMPOSE THEN
    EXISTS_TAC “product_ring univ(:num # 'a) (\i. (r :'a Ring))” THEN
    REWRITE_TAC[RING_MONOMORPHISM_DIAGONAL_UNIV] THEN
    ASM_SIMP_TAC std_ss[RING_ISOMORPHISM_IMP_MONOMORPHISM]
QED

Theorem RING_WORD_UNIVERSAL_LEMMA1 :
    ring_0 r = ring_of_int (r :'a Ring) (&0) /\
    ring_1 r = ring_of_int (r :'a Ring) (&1)
Proof
  REWRITE_TAC[RING_OF_INT_OF_NUM, RING_OF_NUM_0, RING_OF_NUM_1]
QED

Theorem RING_WORD_UNIVERSAL_LEMMA2 :
    ring_carrier r = univ(:'a) ==>
    (x = y <=> ring_sub r x y = ring_of_int r (&0))
Proof
  SIMP_TAC bool_ss[RING_SUB_EQ_0, IN_UNIV, RING_OF_INT_OF_NUM, RING_OF_NUM_0]
QED

Theorem RING_WORD_UNIVERSAL_LEMMA3 :
    ring_carrier r = univ(:'a) ==>
    p = ring_of_int r (&0) ==> !c. ring_mul r c p = ring_of_int r (&0)
Proof
  SIMP_TAC bool_ss[RING_MUL_RZERO, RING_OF_INT_OF_NUM, RING_OF_NUM_0, IN_UNIV]
QED

Theorem RING_WORD_UNIVERSAL_LEMMA4 :
    ring_carrier r = univ(:'a) ==>
      p = ring_of_int r (&0) /\ q = ring_of_int r (&0) ==>
        ring_add r p q = ring_of_int r (&0)
Proof
  SIMP_TAC bool_ss[RING_ADD_RZERO, RING_OF_INT_OF_NUM, RING_OF_NUM_0, IN_UNIV]
QED

val _ = export_theory();
val _ = html_theory "ringLib";

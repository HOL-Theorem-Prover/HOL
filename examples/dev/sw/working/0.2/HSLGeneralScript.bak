
(*---------------------------------------------------------------------------------*)
(*
quietdec := true;

app load ["arithmeticTheory", "wordsTheory", "wordsLib", "pairTheory", "listTheory", "whileTheory", "finite_mapTheory", 
          "pred_setSimps", "pred_setTheory", "preARMTheory", "CFLTheory"];

open HolKernel Parse boolLib bossLib numLib arithmeticTheory wordsTheory wordsLib pairTheory listTheory whileTheory 
       pred_setSimps pred_setTheory finite_mapTheory preARMTheory CFLTheory;

quietdec := false;
*)

(*---------------------------------------------------------------------------------*)
(* This file investigates general implementation of HSL and its translation to CFL *) 
(* Function call implementation is required in this level                          *)
(* Since a concrete implementation has been defined in "HSLScript.sml",            *)
(*  "FunCallScript.sml" and "HSL2CFLScript.sml", the compiler won't use anything   *)
(*  defined or proved in this file. It is just an illustrutation of the general    *)
(*  principles in designed the compilation from HSL to CFL                         *)                                  
(*---------------------------------------------------------------------------------*)

val _ = new_theory "HSLGeneral";

(*---------------------------------------------------------------------------------*)
(*      Simplifier on finite maps                                                  *)
(*---------------------------------------------------------------------------------*)

val FUPDATE_LT_COMMUTES = Q.store_thm (
  "FUPDATE_LT_COMMUTES",
  ` !f a b c d. c < a ==> (f |+ (a:num, b) |+ (c,d) = f |+ (c,d) |+ (a,b))`,
    RW_TAC arith_ss [FUPDATE_COMMUTES]
    );


val fupdate_normalizer =
 let val thm = SPEC_ALL FUPDATE_LT_COMMUTES
     val pat = lhs(snd(dest_imp(concl thm)))
 in
   {name = "Finite map normalization",
    trace = 2,
    key = SOME([],pat),
    conv = let fun reducer tm =
                 let val (theta,ty_theta) = match_term pat tm
                     val thm' = INST theta (INST_TYPE ty_theta thm)
                     val constraint = fst(dest_imp(concl thm'))
                     val cthm = EQT_ELIM(reduceLib.REDUCE_CONV constraint)
                 in MP thm' cthm
                 end
           in
               K (K reducer)
           end}
 end;


val finmap_conv_frag =
 simpLib.SSFRAG
     {convs = [fupdate_normalizer],
      rewrs = [], ac=[],filter=NONE,dprocs=[],congs=[]};

val finmap_ss = std_ss ++ finmap_conv_frag ++  rewrites [FUPDATE_EQ, FAPPLY_FUPDATE_THM];

val set_ss = std_ss ++ SET_SPEC_ss ++ PRED_SET_ss;

(*---------------------------------------------------------------------------------*)
(*      Separate finite maps                                                       *)
(*      Isomorphic finite maps                                                     *)
(*---------------------------------------------------------------------------------*)

val separate_def = Define `
    separate D1 D2 = 
        (D1 INTER D2 = {})`;

val SEPARATE_COMM = Q.store_thm (
    "SEPARATE_COMM",
    `separate D1 D2 = separate D2 D1`,
    RW_TAC std_ss [separate_def, INTER_COMM]
    );

val SEPARATE_LEM_1 = Q.store_thm (
    "SEPARATE_LEM_1",
    `!D1 D2. separate D1 D2 ==>
         !i. i IN D1 ==> ~(i IN D2)`,
    RW_TAC std_ss [separate_def] THEN STRIP_TAC THEN
    `{i} SUBSET D1 /\ {i} SUBSET D2` by RW_TAC set_ss [] THEN
    `{i} SUBSET {}` by METIS_TAC [SUBSET_INTER] THEN
    FULL_SIMP_TAC set_ss [SUBSET_DEF]
  );

 val SEPARATE_UPDATE = Q.store_thm (
    "SEPARATE_UPDATE",
    `!i v f D1 D2. separate D1 D2 /\ i IN D2 ==> 
         (DRESTRICT f D1 = DRESTRICT (f |+ (i,v)) D1)`,
    RW_TAC finmap_ss [DRESTRICT_FUPDATE] THEN
    METIS_TAC [SEPARATE_LEM_1]
   );

(*---------------------------------------------------------------------------------*)
(*      Logical Registers                                                          *)
(*---------------------------------------------------------------------------------*)

(* Pointer registers *)

val _ = Hol_datatype `
    PTR = THP | TFP | TIP | TSP | TLR`;

val toPTR_def = Define `
    (toPTR THP = 10) /\
    (toPTR TFP = 11) /\
    (toPTR TIP = 12) /\
    (toPTR TSP = 13) /\
    (toPTR TLR = 14)`;

val toPTR_lem = Q.store_thm
  ("toPTR_lem",
   `!p. ~(toPTR p = 0) /\ ~(toPTR p = 1) /\ ~(toPTR p = 2) /\
        ~(toPTR p = 3) /\ ~(toPTR p = 4) /\ ~(toPTR p = 5) /\
        ~(toPTR p = 6) /\ ~(toPTR p = 7) /\ ~(toPTR p = 8) /\
        ~(toPTR p = 9)`,
    Cases_on `p` THEN
    RW_TAC arith_ss [toPTR_def]
  );

(* Data regisiters *)

val _ = Hol_datatype `
    TREG = r0 | r1 | r2 | r3 | r4 | r5 | r6 | r7 | r8 | r9`;

val data_reg_index_def = Define `
    (data_reg_index r0 = 0) /\
    (data_reg_index r1 = 1) /\
    (data_reg_index r2 = 2) /\
    (data_reg_index r3 = 3) /\
    (data_reg_index r4 = 4) /\
    (data_reg_index r5 = 5) /\
    (data_reg_index r6 = 6) /\
    (data_reg_index r7 = 7) /\
    (data_reg_index r8 = 8) /\
    (data_reg_index r9 = 9)`;

val data_reg_name_lem = Q.store_thm
  ("data_reg_name_lem",
   `!r.((data_reg_index r = 0) = (r = r0)) /\
       ((data_reg_index r = 1) = (r = r1)) /\
       ((data_reg_index r = 2) = (r = r2)) /\
       ((data_reg_index r = 3) = (r = r3)) /\
       ((data_reg_index r = 4) = (r = r4)) /\
       ((data_reg_index r = 5) = (r = r5)) /\
       ((data_reg_index r = 6) = (r = r6)) /\
       ((data_reg_index r = 7) = (r = r7)) /\
       ((data_reg_index r = 8) = (r = r8)) /\
       ((data_reg_index r = 9) = (r = r9))`,
    Cases_on `r` THEN
    RW_TAC std_ss [data_reg_index_def]
  );


val data_reg_name_def = Define `
    data_reg_name i =
      if i = 0 then r0
      else if i = 1 then r1
      else if i = 2 then r2
      else if i = 3 then r3
      else if i = 4 then r4
      else if i = 5 then r5
      else if i = 6 then r6
      else if i = 7 then r7
      else if i = 8 then r8
      else r9`;

val data_reg_name_thm = Q.store_thm
  ("data_reg_name_thm",
   `(data_reg_name 0 = r0) /\
    (data_reg_name 1 = r1) /\
    (data_reg_name 2 = r2) /\
    (data_reg_name 3 = r3) /\
    (data_reg_name 4 = r4) /\
    (data_reg_name 5 = r5) /\
    (data_reg_name 6 = r6) /\
    (data_reg_name 7 = r7) /\
    (data_reg_name 8 = r8) /\
    (data_reg_name 9 = r9)`,
   RW_TAC std_ss [data_reg_name_def]
  );


val toPTR_lem_2 = Q.store_thm
  ("toPTR_lem_2",
   `!p r. ~(toPTR p = data_reg_index r)`,
    Cases_on `p` THEN Cases_on `r` THEN
    RW_TAC arith_ss [toPTR_def, data_reg_index_def]
  );

val conv_reg_def = Define `
    conv_reg = from_reg_index o data_reg_index`;


val conv_reg_thm = Q.store_thm (
  "conv_reg_thm",
  `(conv_reg r0 = R0) /\ (conv_reg r1 = R1) /\ (conv_reg r2 = R2) /\ (conv_reg r3 = R3) /\ (conv_reg r4 = R4) /\
   (conv_reg r5 = R5) /\ (conv_reg r6 = R6) /\ (conv_reg r7 = R7) /\ (conv_reg r8 = R8) /\ (conv_reg r9 = R9)`,
  SIMP_TAC std_ss [conv_reg_def, data_reg_index_def, from_reg_index_def]
  );

val CONV_REG_LEM = Q.store_thm (
  "CONV_REG_LEM",
  `!r r'. (data_reg_index r = index_of_reg (conv_reg r)) /\
        ((data_reg_index r = data_reg_index r') ==> (r = r'))`,
  SIMP_TAC std_ss [conv_reg_def] THEN
  Cases_on `r` THEN Cases_on `r'` THEN
  RW_TAC std_ss [data_reg_index_def, from_reg_index_def, index_of_reg_def]
  );

(*---------------------------------------------------------------------------------*)
(*      Data in memory, Expressions                                                *)
(*---------------------------------------------------------------------------------*)

val FORALL_HS_STATE = Q.store_thm (
    "FORALL_HS_STATE",
    `(!s.P s) = (!dr dp hp sk. P (dr,dp,hp,sk))`,
    RW_TAC std_ss [FORALL_PROD]
   );

val _ = Hol_datatype `
    TMEM = Hp of num      (* heap variable *)
         | Sk of num      (* stack variable *)
    `;

val _ = Hol_datatype `
    TEXP = inR of TREG           (* registers *)
         | inC of word4 => word8 (* constants *)
         | inM of TMEM           (* memory slots *)
         | inP of PTR
    `;

(* Register Or Constants *)

val _ = Hol_datatype `
    TROC = Rg of TREG           (* registers *)
         | Cn of word4 => word8 (* constants *)
    `;

val roc_2_exp_def = Define `
  (roc_2_exp (Rg r) =  inR r) /\
  (roc_2_exp (Cn shift c) = inC shift c)
  `;

val tread_def = Define `
  (tread (dr,pr,hp,sk) (inM (Hp i)) =  hp ' i) /\
  (tread (dr,pr,hp,sk) (inM (Sk i)) =  sk ' i) /\
  (tread (dr,pr,hp,sk) (inC shift c) =  (w2w c):word32 #>> (2*w2n shift)) /\
  (tread (dr,pr,hp,sk) (inR r) = dr ' r) /\
  (tread (dr,pr,hp,sk) (inP p) = pr ' p)
  `;

val twrite_def = Define `
  (twrite (dr,pr,hp,sk) (inM (Hp i)) v =  (dr, pr, hp |+ (i,v), sk)) /\
  (twrite (dr,pr,hp,sk) (inM (Sk i)) v =  (dr, pr, hp, sk |+ (i,v))) /\
  (twrite (dr,pr,hp,sk) (inR r) v = (dr |+ (r,v), pr, hp, sk)) /\
  (twrite (dr,pr,hp,sk) (inP p) v = (dr, pr |+ (p,v), hp, sk))
  `;

val from_MEXP_def = Define `
  (from_MEXP (MR r) = inR (data_reg_name (index_of_reg r))) /\
  (from_MEXP (MC shift v) = inC shift v)
  `;

val _ = type_abbrev("TCND", Type`:MREG # COND # MEXP`);

(*---------------------------------------------------------------------------------*)
(*      Operational Semantics of the intermediate language                         *)
(*---------------------------------------------------------------------------------*)

val _ = Hol_datatype `
    TOPER = TLDR of TREG => TMEM |
            TSTR of TMEM => TREG |
	    TMOV of TREG => TROC |
            TADD of TREG => TREG => TROC |
            TSUB of TREG => TREG => TROC |
            TRSB of TREG => TREG => TROC |
            TMUL of TREG => TREG => TREG |
            TAND of TREG => TREG => TROC |
            TORR of TREG => TREG => TROC |
            TEOR of TREG => TREG => TROC |
	    TLSL of TREG => TREG => word5 |
            TLSR of TREG => TREG => word5 |
            TASR of TREG => TREG => word5 |
            TROR of TREG => TREG => word5 
`;
(*
|
            TCPY of TEXP list => TEXP list   (* copy from a list to a list *)
    `;
*)

val _ = Hol_datatype `CFL_STRUCTURE =
    Blk of TOPER list |
    Sc of CFL_STRUCTURE => IL1_STRUCTURE |
    Cj of TCND => CFL_STRUCTURE => CFL_STRUCTURE |
    Tr of TCND => CFL_STRUCTURE |
    Fc of TEXP list # TEXP list # CFL_STRUCTURE # TEXP list # TEXP list
  `;

(*---------------------------------------------------------------------------------*)
(*      Translation from IL1 to IL2                                                *)
(*---------------------------------------------------------------------------------*)

val conv_roc_def = Define `
  (conv_roc (Rg r) =  MR (conv_reg r)) /\
  (conv_roc (Cn shift c) = MC shift c)
  `;

val conv_base_def = Define `
  (conv_base (base,offset) =
      (toPTR base, offset)
  )`;

val conv_base_thm = Q.store_thm (
  "conv_base_thm",
  `(conv_base (THP, offset) = (10,offset)) /\ (conv_base (TFP, offset) = (11,offset)) /\ (conv_base (TIP, offset) = (12,offset)) /\
   (conv_base (TSP, offset) = (13,offset)) /\ (conv_base (TLR, offset) = (14,offset))`,
  SIMP_TAC std_ss [conv_base_def, toPTR_def]
  );

val toLocn_def = Define `
  (toLocn (Hp i) (hp_f,sk_f) =
      conv_base (hp_f i)
  ) /\
  (toLocn (Sk i) (hp_f,sk_f) =
      conv_base (sk_f i)
  )`;

val translate_assgn_def = Define `
    (!dst src.translate_assgn (TLDR dst src) = \(hp_f,sk_f). MLDR (conv_reg dst) (toLocn src (hp_f,sk_f))) /\
    (!dst src.translate_assgn (TSTR dst src) = \(hp_f,sk_f). MSTR (toLocn dst (hp_f,sk_f)) (conv_reg src)) /\
    (translate_assgn (TMOV dst src) = \(hp_f,sk_f). MMOV (conv_reg dst) (conv_roc src)) /\
    (translate_assgn (TADD dst src1 src2) = \(hp_f,sk_f). MADD (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TSUB dst src1 src2) = \(hp_f,sk_f). MSUB (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TRSB dst src1 src2) = \(hp_f,sk_f). MRSB (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TMUL dst src1 src2_reg) = \(hp_f,sk_f). MMUL (conv_reg dst) (conv_reg src1) (conv_reg src2_reg)) /\ 
    (translate_assgn (TAND dst src1 src2) = \(hp_f,sk_f). MAND (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TORR dst src1 src2) = \(hp_f,sk_f). MORR (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TEOR dst src1 src2) = \(hp_f,sk_f). MEOR (conv_reg dst) (conv_reg src1) (conv_roc src2)) /\
    (translate_assgn (TLSL dst src2_reg src2_num) = \(hp_f,sk_f). MLSL (conv_reg dst) (conv_reg src2_reg) src2_num) /\
    (translate_assgn (TLSR dst src2_reg src2_num) = \(hp_f,sk_f). MLSR (conv_reg dst) (conv_reg src2_reg) src2_num) /\
    (translate_assgn (TASR dst src2_reg src2_num) = \(hp_f,sk_f). MASR (conv_reg dst) (conv_reg src2_reg) src2_num) /\
    (translate_assgn (TROR dst src2_reg src2_num) = \(hp_f,sk_f). MROR (conv_reg dst) (conv_reg src2_reg) src2_num)
    `;

val translate_ir1_def = Define `
    (translate_ir1 (Blk stmL) = \(hp_f,sk_f). BLK (MAP (\stm. translate_assgn stm (hp_f,sk_f)) stmL)) /\
    (translate_ir1 (Sc S1 S2) =  
         \(hp_f,sk_f). SC (translate_ir1 S1 (hp_f,sk_f)) (translate_ir1 S2 (hp_f,sk_f)))`;

(*
    (translate_ir1 (Cj cond Strue Sfalse) =
         CJ (translate_condition cond) (translate_ir1 Strue) (translate_ir1 Sfalse)) /\
    (translate (Tr cond Sbody) =
         TR (translate_condition cond) (translate_ir1 Sbody))
  `;
*)

(*---------------------------------------------------------------------------------*)
(*      Intermediate Representation                                                *)
(*      Definition of run_ir1                                                      *)
(*---------------------------------------------------------------------------------*)

val map_to_lemma = Q.prove (
 `!f.!fm. ?comp. ONE_ONE f ==> 
       (!x. x IN FDOM fm ==> (fm ' x = comp ' (f x)))`,
   GEN_TAC THEN INDUCT_THEN fmap_INDUCT STRIP_ASSUME_TAC THENL [
       Q.EXISTS_TAC `FEMPTY` THEN RW_TAC set_ss [FDOM_FEMPTY],
       RW_TAC std_ss [] THEN Q.EXISTS_TAC `comp |+ (f x,y)` THEN
         RW_TAC std_ss [FDOM_FUPDATE] THEN
         Cases_on `x' = x` THENL [
            FULL_SIMP_TAC finmap_ss [],
            FULL_SIMP_TAC finmap_ss [ONE_ONE_THM] THEN
                FULL_SIMP_TAC set_ss [] THEN
                METIS_TAC []
         ]
   ]
 );

val map_to_def = new_specification
  ("map_to_def", ["map_to"],
   CONV_RULE (ONCE_DEPTH_CONV SKOLEM_CONV) map_to_lemma);

  (* |- !f fm. ONE_ONE f ==> !x. x IN FDOM fm ==> (fm ' x = map_to f fm ' (f x)) *)


(*---------------------------------------------------------------------------------*)
(*      Deploy the heap and stack in the memory, then run the ir                   *)
(*---------------------------------------------------------------------------------*)

(*
val deploy_run_def = Define `
      deploy_run ir (rg,hp,sk) (hp_f,sk_f) = 
         run_ir (translate_ir1 ir (hp_f,sk_f)) (rg, FUNION (map_to ((addr rg) o hp_f) hp) (map_to ((addr rg) o sk_f) hp))`
    ;

val map_separate_def = Define `
     map_separate (hp,sk) mem (p,q) =
       !i j. i IN FDOM hp /\ j IN FDOM sk ==>
          ~(addr (p i) = addr (q j)) 
    `;
*)

(*---------------------------------------------------------------------------------*)
(*      Valid IL1 programs                                                         *)
(*      All heap and stack operations in each instruction should be within the     *)
(*        predefined domains                                                       *)
(*      The heap area and the stack area are separate                              *)
(*      Data registers include only r0-r9                                          *)
(*---------------------------------------------------------------------------------*)

val inD_def = Define `
  (inD (Hp i) (DHp,DSk) = i IN DHp) /\
  (inD (Sk i) (DHp,DSk) = i IN DSk)`;

val valid_TEXP_def = Define `
  (valid_TEXP (inM m) Ds = inD m Ds) /\
  (valid_TEXP (inR r) Ds = T) /\
  (valid_TEXP (inC _ _) Ds  = T)`;

(* valid assignments *)

val valid_assgn_def = Define `
  (valid_assgn (TLDR r m) Ds = inD m Ds) /\
  (valid_assgn (TSTR m r) Ds = inD m Ds) /\
  (valid_assgn _ Ds = T)`;

val valid_struct_def = Define `
  (valid_struct (Blk stmL) Ds = EVERY (\stm. valid_assgn stm Ds) stmL) /\
  (valid_struct (Sc ir1 ir2) Ds = valid_struct ir1 Ds /\ valid_struct ir2 Ds)`;

(*
 /\
  (valid_struct (Cj (r,rop,e) ir_t ir_f) Ds =
       valid_TEXP (inR r) Ds /\ valid_MEXP e Ds /\ valid_struct ir_t Ds /\ valid_struct ir_f Ds) /\
  (valid_struct (Tr (r,rop,e) ir_body) Ds =
       valid_TEXP (inR r) Ds /\ valid_MEXP e Ds /\ valid_struct ir_body Ds)`;
*)

(*---------------------------------------------------------------------------------*)
(*      Decode assignment statement                                                *)
(*---------------------------------------------------------------------------------*)

val addr_def = Define `
    (addr pr (base, POS i) = w2n (pr ' base) + i) /\
    (addr pr (base, NEG i) = w2n (pr ' base) - i)
    `;

val is_map_f_def = Define `
    is_map_f fm fm' f =
      !i. i IN FDOM fm ==> (fm ' i = fm' ' (f i))
    `;

val correspond_def = Define `
    correspond (dr,pr,hp,sk) (regs,mem) (hp_f,sk_f) =
      (!r. dr ' r = regs ' (data_reg_index r)) /\
      (!p. pr ' p = regs ' (toPTR p)) /\ 
      is_map_f hp mem ((addr pr) o hp_f) /\
      is_map_f sk mem ((addr pr) o sk_f)
    `;

(* Congruence of the heap/stack with the memory *)

val one_one_addr_def = Define `
    one_one_addr pr hs hs_f = 
         !i j. i IN FDOM hs /\ j IN FDOM hs ==> 
             ~(addr pr (hs_f i) = addr pr (hs_f j))
    `;

val proper_config_def = Define `
    proper_config (dr,pr,hp,sk) st (hp_f,sk_f) =
      correspond (dr,pr,hp,sk) st (hp_f,sk_f) /\
      one_one_addr pr hp hp_f /\ one_one_addr pr sk sk_f
    `;

(*---------------------------------------------------------------------------------*)
(*      Decode assignment statement                                                *)
(*---------------------------------------------------------------------------------*)

val tdecode_def = Define `
  (!dst src.tdecode hs (TLDR dst src) =
      twrite hs (inR dst) (tread hs (inM src))) /\
  (!dst src.tdecode hs (TSTR dst src) =
      twrite hs (inM dst) (tread hs (inR src))) /\
  (tdecode hs (TMOV dst src) =
      twrite hs (inR dst) (tread hs (roc_2_exp src))) /\
  (tdecode hs (TADD dst src1 src2) =
      twrite hs (inR dst) (tread hs (inR src1) + tread hs (roc_2_exp src2))) /\
  (tdecode hs (TSUB dst src1 src2) =
      twrite hs (inR dst) (tread hs (inR src1) - tread hs (roc_2_exp src2))) /\
  (tdecode hs (TRSB dst src1 src2) =
      twrite hs (inR dst) (tread hs (roc_2_exp src2) - tread hs (inR src1))) /\
  (tdecode hs (TMUL dst src1 src2_reg) =
      twrite hs (inR dst) (tread hs (inR src1) * tread hs (inR src2_reg))) /\
  (tdecode hs (TAND dst src1 src2) =
      twrite hs (inR dst) (tread hs (inR src1) && tread hs (roc_2_exp src2))) /\
  (tdecode hs (TORR dst src1 src2) =
      twrite hs (inR dst) (tread hs (inR src1) !! tread hs (roc_2_exp src2))) /\
  (tdecode hs (TEOR dst src1 src2) =
      twrite hs (inR dst) (tread hs (inR src1) ?? tread hs (roc_2_exp src2))) /\
  (tdecode hs (TLSL dst src2_reg src2_num) =
      twrite hs (inR dst) (tread hs (inR src2_reg) << w2n src2_num)) /\
  (tdecode hs (TLSR dst src2_reg src2_num) =
      twrite hs (inR dst) (tread hs (inR src2_reg) >>> w2n src2_num)) /\  
  (tdecode hs (TASR dst src2_reg src2_num) =
      twrite hs (inR dst) (tread hs (inR src2_reg) >> w2n src2_num)) /\
  (tdecode hs (TROR dst src2_reg src2_num) =
      twrite hs (inR dst) (tread hs (inR src2_reg) #>> w2n src2_num))
  `;

(*---------------------------------------------------------------------------------*)
(*      Intermediate Representation 1                                              *)
(*      Properties about heaps/stacks in memory                                    *)
(*---------------------------------------------------------------------------------*)

(* The semantics of IR1, defined on heap and stacks *)

val run_ir1_def = Define `
    (run_ir1 (Blk (stm::stmL)) s = 
       run_ir1 (Blk stmL) (tdecode s stm)) /\
    (run_ir1 (Blk []) s = s) /\
    (run_ir1 (Sc S1 S2) s = 
       run_ir1 S2 (run_ir1 S1 s))
  `;

(*---------------------------------------------------------------------------------*)
(*      Sanity                                                                     *)
(*      The domain would be changed                                                *)
(*---------------------------------------------------------------------------------*)

val ASSGN_SAME_FDOM_HP_SK = Q.store_thm (
  "ASSGN_SAME_FDOM_HP_SK",
  `!dr pr hp sk stm rg' hp' sk'. 
     ((dr',pr',hp',sk') = tdecode (dr,pr,hp,sk) stm) /\ valid_assgn stm (FDOM hp, FDOM sk) ==> 
        (FDOM hp' = FDOM hp) /\ (FDOM sk' = FDOM sk)`,

   let val tac1 = RW_TAC std_ss [valid_assgn_def, inD_def, tdecode_def, twrite_def, FDOM_EQ_FDOM_FUPDATE]
   in
   Cases_on `stm` THENL [
      Cases_on `T'` THEN tac1,                      (* LDR *)
      Cases_on `T'` THEN tac1,                      (* STR *)
      Cases_on `T0` THEN tac1,                      (* MOV *)
      Cases_on `T1` THEN tac1,                      (* ADD *)
      Cases_on `T1` THEN tac1,                      (* SUB *)
      Cases_on `T1` THEN tac1,                      (* RSB *)
      tac1,                                         (* MUL *)
      Cases_on `T1` THEN tac1,                      (* AND *)
      Cases_on `T1` THEN tac1,                      (* ORR *)
      Cases_on `T1` THEN tac1,                      (* EOR *)
      tac1,                                         (* LSL *)
      tac1,                                         (* LSR *)
      tac1,                                         (* ASR *)
      tac1                                          (* ROR *)
  ]
  end
 );

val ASSGN_ONE_ONE_ADDR = Q.store_thm (
  "ASSGN_ONE_ONE_ADDR",
  `!dr pr hp sk stm dr' pr' hp' sk' hp_f sk_f. 
     ((dr',pr',hp',sk') = tdecode (dr,pr,hp,sk) stm) /\ valid_assgn stm (FDOM hp, FDOM sk) /\ 
      one_one_addr pr hp hp_f /\ one_one_addr pr sk sk_f ==> 
        one_one_addr pr' hp' hp_f /\ one_one_addr pr' sk' sk_f`,

   Cases_on `stm` THEN 
   RW_TAC std_ss [one_one_addr_def, tdecode_def, twrite_def, tread_def] THEN
   Cases_on `T'` THEN 
   FULL_SIMP_TAC set_ss [valid_assgn_def, inD_def, tdecode_def, twrite_def] THEN
   METIS_TAC [FDOM_EQ_FDOM_FUPDATE]
   );

(*---------------------------------------------------------------------------------*)
(*      Validation on the translation of single instructions                       *)
(*---------------------------------------------------------------------------------*)

val DECODE_LDR_LEM = Q.store_thm (
  "DECODE_LDR_LEM",
  `!rg hp sk hp_f sk_f st T' T0. 
    proper_config (dr,pr,hp,sk) st (hp_f,sk_f) /\ valid_assgn (TLDR T' T0) (FDOM hp, FDOM sk)
      ==> 
       correspond (tdecode (dr,pr,hp,sk) (TLDR T' T0))
             (mdecode st (translate_assgn (TLDR T' T0) (hp_f,sk_f))) (hp_f,sk_f)`,
   let 
       val lem1 = prove (
	 Term `(!p. pr ' p = regs ' (toPTR p)) ==> (mem ' (addr pr (q,r)) = read (regs,mem) (toMEM (conv_base (q,r))))`,
         Cases_on `q` THEN Cases_on `r` THEN RW_TAC std_ss [conv_base_def, toMEM_def, addr_def, read_thm]
       )
       val tac1 = RW_TAC std_ss [translate_assgn_def, tdecode_def, twrite_def, tread_def, mdecode_def, toREG_def, toMEM_def, write_thm, 
                            toEXP_def, toEXP_def, read_thm] THEN
             RW_TAC finmap_ss [correspond_def, is_map_f_def] THEN
             RW_TAC std_ss [CONV_REG_LEM] THEN
             FULL_SIMP_TAC std_ss [CONV_REG_LEM, REWRITE_RULE [CONV_REG_LEM] toPTR_lem_2, lem1]
   in
      SIMP_TAC std_ss [proper_config_def, FORALL_DSTATE] THEN
      RW_TAC std_ss [correspond_def, is_map_f_def] THEN
      Cases_on `T0` THEN
      FULL_SIMP_TAC std_ss [translate_assgn_def, valid_assgn_def, toLocn_def, inD_def] THENL [
         Cases_on `hp_f n` THEN tac1,
         Cases_on `sk_f n` THEN tac1
      ]
   end
);


val DECODE_STR_LEM = Q.store_thm (
  "DECODE_STR_LEM",

  `!rg hp sk hp_f sk_f st T' T0. 
    proper_config (dr,pr,hp,sk) st (hp_f,sk_f) /\ valid_assgn (TSTR T' T0) (FDOM hp, FDOM sk)
      ==> 
       correspond (tdecode (dr,pr,hp,sk) (TSTR T' T0))
             (mdecode st (translate_assgn (TSTR T' T0) (hp_f,sk_f))) (hp_f,sk_f)`,

   let 
       val lem1 = prove (
          Term `!v regs r q pr mem.
             (!p. pr ' p = regs ' (toPTR p)) ==> (write (regs,mem) (toMEM (conv_base (q,r))) v = (regs, mem |+ (addr pr (q,r), v)))`,
          Cases_on `q` THEN Cases_on `r` THEN
            RW_TAC std_ss [toMEM_def, write_thm, conv_base_def, addr_def, toPTR_def]
          )
       val tac1 = 
             RW_TAC std_ss [translate_assgn_def, tdecode_def, twrite_def, tread_def, mdecode_def, toREG_def, toEXP_def, 
                              read_thm, write_thm] THEN
             IMP_RES_TAC lem1 THEN
             RW_TAC finmap_ss [correspond_def, is_map_f_def] THEN
             RW_TAC std_ss [CONV_REG_LEM] THEN
             FULL_SIMP_TAC set_ss [FDOM_FUPDATE, one_one_addr_def] THEN
             METIS_TAC []
   in
      SIMP_TAC std_ss [proper_config_def, FORALL_DSTATE] THEN
      RW_TAC std_ss [correspond_def, is_map_f_def] THEN
      Cases_on `T'` THEN
      FULL_SIMP_TAC std_ss [translate_assgn_def, valid_assgn_def, toLocn_def, inD_def] THENL [
         Cases_on `hp_f n` THEN tac1,
         Cases_on `sk_f n` THEN tac1
      ]
   end
 );


val DECODE_STM_THM = Q.store_thm (
  "DECODE_STM_THM",
  `!rg hp sk hp_f sk_f st stm. 
    proper_config (dr,pr,hp,sk) st (hp_f,sk_f) /\ valid_assgn stm (FDOM hp, FDOM sk)
      ==> 
       correspond (tdecode (dr,pr,hp,sk) stm)
             (mdecode st (translate_assgn stm (hp_f,sk_f))) (hp_f,sk_f)`,

   let val tac1 =  
	     RW_TAC std_ss [translate_assgn_def, tdecode_def, twrite_def, tread_def, mdecode_def, toREG_def, toMEM_def, write_thm, 
                            toEXP_def, conv_roc_def, toEXP_def, read_thm, roc_2_exp_def] THEN
             RW_TAC finmap_ss [correspond_def, is_map_f_def] THEN
             RW_TAC std_ss [CONV_REG_LEM] THEN
             FULL_SIMP_TAC std_ss [CONV_REG_LEM, REWRITE_RULE [CONV_REG_LEM] toPTR_lem_2]
   in

   SIMP_TAC std_ss [proper_config_def, FORALL_DSTATE] THEN
   RW_TAC std_ss [correspond_def, is_map_f_def] THEN
   Cases_on `stm` THENL [                       
       METIS_TAC [SIMP_RULE std_ss [proper_config_def, FORALL_DSTATE, correspond_def, is_map_f_def] DECODE_LDR_LEM],        (* LDR *)
       METIS_TAC [SIMP_RULE std_ss [proper_config_def, FORALL_DSTATE, correspond_def, is_map_f_def] DECODE_STR_LEM],        (* STR *) 
       Cases_on `T0` THEN tac1,                      (* MOV *) 
       Cases_on `T1` THEN tac1,                      (* ADD *)
       Cases_on `T1` THEN tac1,                      (* SUB *)
       Cases_on `T1` THEN tac1,                      (* RSB *)
       tac1,                                         (* MUL *)
       Cases_on `T1` THEN tac1,                      (* AND *)
       Cases_on `T1` THEN tac1,                      (* ORR *)
       Cases_on `T1` THEN tac1,                      (* EOR *)
       tac1,                                         (* LSL *)
       tac1,                                         (* LSR *)
       tac1,                                         (* ASR *)
       tac1                                          (* ROR *)
  ]
  end
 );

(*---------------------------------------------------------------------------------*)
(*      Congruence for basic blocks                                                *)
(*---------------------------------------------------------------------------------*)

val  BLK_CORRESPONDENCE = Q.store_thm (
  "BLK_CORRESPONDENCE",
  `!dr pr hp sk hp_f sk_f st stmL. 
    proper_config (dr,pr,hp,sk) st (hp_f,sk_f) /\ valid_struct (Blk stmL) (FDOM hp, FDOM sk)
      ==> 
       correspond (run_ir1 (Blk stmL) (dr,pr,hp,sk))
                  (run_ir (translate_ir1 (Blk stmL) (hp_f,sk_f)) st) (hp_f,sk_f)`,

  Induct_on `stmL` THENL [
      SIMP_TAC std_ss [FORALL_DSTATE] THEN
          RW_TAC list_ss [valid_struct_def, proper_config_def, correspond_def, run_ir1_def, translate_ir1_def, IR_SEMANTICS_BLK],

      RW_TAC list_ss [proper_config_def, valid_struct_def, run_ir1_def, translate_ir1_def, IR_SEMANTICS_BLK] THEN 
          `?dr' pr' hp' sk'. (dr',pr',hp',sk') = tdecode (dr,pr,hp,sk) h` by  METIS_TAC [ABS_PAIR_THM] THEN
          Q.PAT_ASSUM `!dr pr hp sk hp_f sk_f st.x` (ASSUME_TAC o SIMP_RULE std_ss [valid_struct_def, translate_ir1_def] o
               Q.SPECL [`dr'`,`pr'`,`hp'`,`sk'`,`hp_f`,`sk_f`,`mdecode st (translate_assgn h (hp_f,sk_f))`]) THEN
          `(FDOM hp',FDOM sk') = (FDOM hp,FDOM sk)` by METIS_TAC [ASSGN_SAME_FDOM_HP_SK, ABS_PAIR_THM] THEN
          FULL_SIMP_TAC std_ss [proper_config_def] THEN
          METIS_TAC [SIMP_RULE std_ss [proper_config_def] DECODE_STM_THM, ASSGN_ONE_ONE_ADDR]
      ]
  );


(*---------------------------------------------------------------------------------*)
(*      Valid IL1 programs                                                         *)
(*      All heap and stack operations in each instruction should be within the     *)
(*        predefined domains                                                       *)
(*      The heap area and the stack area are separate                              *)
(*      Data registers include only r0-r9                                          *)
(*---------------------------------------------------------------------------------*)

(*
val well_depl_def = Define `
   well_depl (DHp,DSk) (p,q) = 
   (!i:num j. i IN DHp /\ j IN DSk ==> ~(p - i = q - j)) /\
   (!i:num i'. i IN DHp /\ i' IN DHp ==> ~(p - i = p - i')) /\
   (!i:num i'. i IN DSk /\ i' IN DSk ==> ~(q - i = q - i'))`;
*)

(*

val ASSGN_SAME_BASE_REGS = Q.store_thm (
  "ASSGN_SAME_BASE_REGS",
  `!D1 D2 stm st. 
     valid_assgn stm (D1, D2) ==> 
       let st' = mdecode st (translate_assgn stm) in
        (read st HP = read st' HP) /\
        (read st FP = read st' FP) /\
        (read st SP = read st' SP)
       `,

   let val tac1 = SIMP_TAC std_ss [FORALL_DSTATE, translate_assgn_def, mdecode_def, LET_THM] THEN 
                  RW_TAC finmap_ss [valid_assgn_def, valid_TEXP_def, toREG_def, index_of_reg_def, read_thm, write_thm, 
                                    toMEM_def, HP_def, FP_def, SP_def]
   in
   Cases_on `stm` THENL [
      Cases_on `M` THEN tac1,                      (* LDR *)
      Cases_on `T'` THEN                           (* STR *)
          SIMP_TAC std_ss [translate_assgn_def, toLocn_def] THEN 
          Cases_on `M` THEN tac1,                   
      Cases_on `M` THEN tac1,                      (* MOV *)
      Cases_on `M` THEN tac1,                      (* ADD *)
      Cases_on `M` THEN tac1,                      (* SUB *)
      Cases_on `M` THEN tac1,                      (* RSB *)
      Cases_on `M` THEN tac1,                      (* MUL *)
      Cases_on `M` THEN tac1,                      (* AND *)
      Cases_on `M` THEN tac1,                      (* ORR *)
      Cases_on `M` THEN tac1,                      (* EOR *)
      Cases_on `M` THEN tac1,                      (* LSL *)
      Cases_on `M` THEN tac1,                      (* LSR *)
      Cases_on `M` THEN tac1,                      (* ASR *)
      Cases_on `M` THEN tac1                       (* ROR *)
  ]
  end
 );
*)


(*---------------------------------------------------------------------------------*)
(*      Essential Properties about valid structures                                *)
(*      1. the domains of the heap and stack won't be changed                      *)
(*      2. the values of hp, fp and sp (pointer registers) won't be changed        *)
(*---------------------------------------------------------------------------------*)

(* the domains of the heap and stack are unchanged *)

val hs_dom_intact_def = Define `
    hs_dom_intact ir = !rg hp sk rg' hp' sk'. 
     valid_struct ir (FDOM hp,FDOM sk) /\ ((rg',hp',sk') = run_ir1 ir (rg,hp,sk)) ==> 
        (FDOM hp' = FDOM hp) /\ (FDOM sk' = FDOM sk)`;

(* the values of hp, fp and sp (pointer registers) are unchanged *)

val pt_regs_intact_def = Define `
    pt_regs_intact ir =
     !D1 D2 st st'. valid_struct ir (D1,D2) /\ (st' = run_ir (translate_ir1 ir) st) ==>
        (read st HP = read st' HP) /\
        (read st FP = read st' FP) /\
        (read st SP = read st' SP)`;

val BLK_HS_DOM_INTACT = Q.store_thm (
  "BLK_HS_DOM_INTACT",
  `!stmL. hs_dom_intact (Blk stmL)`,
  Induct_on `stmL` THENL [
    RW_TAC list_ss [hs_dom_intact_def, valid_struct_def, run_ir1_def],
    FULL_SIMP_TAC list_ss [hs_dom_intact_def, valid_struct_def, run_ir1_def] THEN
      RW_TAC std_ss [] THEN
      METIS_TAC [ASSGN_SAME_FDOM_HP_SK, ABS_PAIR_THM]
  ]
  ); 

val BLK_PT_REGS_INTACT = Q.store_thm (
  "BLK_PT_REGS_INTACT",
  `!stmL. pt_regs_intact (Blk stmL)`,
  Induct_on `stmL` THENL [
    RW_TAC list_ss [pt_regs_intact_def, valid_struct_def, translate_ir1_def, IR_SEMANTICS_BLK],
    FULL_SIMP_TAC list_ss [pt_regs_intact_def, valid_struct_def, translate_ir1_def, IR_SEMANTICS_BLK] THEN
      RW_TAC std_ss [LET_THM] THEN
      METIS_TAC [ASSGN_SAME_BASE_REGS]
  ]
  );

val SC_HS_DOM_INTACT = Q.store_thm (
  "SC_HS_DOM_INTACT",
  `!S1 S2.  hs_dom_intact S1 /\ hs_dom_intact S2 ==> 
          hs_dom_intact (Sc S1 S2)`,
  RW_TAC std_ss [hs_dom_intact_def, run_ir1_def, valid_struct_def] THEN
  `?rg1 hp1 sk1. (run_ir1 S1 (rg,hp,sk)) = (rg1,hp1,sk1)` by METIS_TAC [ABS_PAIR_THM] THEN
  Q.PAT_ASSUM `!rg.x` (ASSUME_TAC o Q.SPECL [`rg1`,`hp1`,`sk1`,`rg'`,`hp'`,`sk'`]) THEN
  Q.PAT_ASSUM `!rg.x` (ASSUME_TAC o Q.SPECL [`rg`,`hp`,`sk`,`rg1`,`hp1`,`sk1`]) THEN
  FULL_SIMP_TAC std_ss []
  ); 

val SC_PT_REGS_INTACT = Q.store_thm (
  "SC_PT_REGS_INTACT",
  `!S1 S2. pt_regs_intact S1 /\ pt_regs_intact S2 /\ 
           WELL_FORMED (translate_ir1 S1) /\ WELL_FORMED (translate_ir1 S2) ==> 
           pt_regs_intact (Sc S1 S2)`,
  RW_TAC std_ss [pt_regs_intact_def, run_ir1_def, valid_struct_def, translate_ir1_def, SEMANTICS_OF_IR] THEN
  METIS_TAC []
  );


(*---------------------------------------------------------------------------------*)
(*      Intermediate Representation 1                                              *)
(*      Properties about heaps/stacks in memory                                    *)
(*---------------------------------------------------------------------------------*)

val Well_Formed_def = Define `
    Well_Formed ir = WELL_FORMED (translate_ir1 ir)`;

val WELL_FORMED_SC = Q.store_thm (
  "WELL_FORMED_SC",
  `!S1 S2. Well_Formed (Sc S1 S2) = Well_Formed S1 /\ Well_Formed S2`,
  RW_TAC std_ss [Well_Formed_def, translate_ir1_def, IR_SC_IS_WELL_FORMED]
  );

val well_behv_def = Define `
    well_behv ir =
      hs_dom_intact ir /\ 
      pt_regs_intact ir /\
      Well_Formed ir`;

(*---------------------------------------------------------------------------------*)
(*      Operations on different stacks                                             *)
(*---------------------------------------------------------------------------------*)

val transfer_def = Define `
    (transfer s1 s0 [] [] = s1) /\
    (transfer s1 s0 (dst::dstL) (src::srcL) = 
       transfer (twrite s1 dst (tread s0 src)) s0 dstL srcL)`;

val empty_s_def = Define `
    empty_s = (FEMPTY,FEMPTY,FEMPTY,FEMPTY)`;


val data_correspond_def = Define `
    data_correspond (dr,pr,hp,sk) (regs,mem) (hp_f,sk_f) = 
        (!r. dr ' r = regs ' (data_reg_index r)) /\
        is_map_f hp mem (addr pr o hp_f) /\
        is_map_f sk mem (addr pr o sk_f)`;


(* Fc of TEXP list # TEXP list # IL1_STRUCTURE # TEXP list # TEXP list *)

val run_fc_def = Define `
    run_fc (caller_i,callee_i) ir (caller_o,callee_o) s = 
        let s1 = transfer empty_s s callee_i caller_i in
        let s2 = run_ir1 ir s1 in
        transfer s s2 caller_o callee_o`;


val translate_fc_def = Define `
    translate_fc (caller_i,callee_i) ir (caller_o,callee_o) (transfer_ins,translate_f,transfer_outs) = 
        SC (SC (transfer_ins (caller_i,callee_i)) 
                (translate_f ir))
           (transfer_outs (caller_o,callee_o))
           `;

val FC_2_SC = Q.store_thm (
    "FC_2_SC",
     `!ir1 ir2 ir3 st. WELL_FORMED ir1 /\ WELL_FORMED ir2 /\WELL_FORMED ir3 ==>
             (run_ir (SC (SC ir1 ir2) ir3) st = run_ir ir3 (run_ir ir2 (run_ir ir1 st)))`,
     RW_TAC std_ss [] THEN
     `WELL_FORMED (SC ir1 ir2)` by METIS_TAC [IR_SC_IS_WELL_FORMED] THEN
      RW_TAC std_ss [SEMANTICS_OF_IR]
   );

val FC_BASIC_LEM = Q.store_thm (
    "FC_BASIC_LEM",
    `!hp_f sk_f hp_f' sk_f' s st. 
        WELL_FORMED (transfer_outs (caller_o,callee_o)) /\
        WELL_FORMED (translate_f ir) /\ 
        WELL_FORMED (transfer_ins (caller_i,callee_i)) /\
        data_correspond s st (hp_f,sk_f) /\
        (!s st s'. data_correspond s st (hp_f,sk_f) ==>
                   data_correspond (transfer s' s callee_i caller_i) (run_ir (transfer_ins (caller_i,callee_i)) st) (hp_f',sk_f')) /\
        (!s st. data_correspond s st (hp_f',sk_f') ==>
                   data_correspond (run_ir1 ir s) (run_ir (translate_f ir) st) (hp_f',sk_f')) /\
        (!s st s'. data_correspond s st (hp_f',sk_f') ==>
                   data_correspond (transfer s' s caller_o callee_o)  (run_ir (transfer_outs (caller_o,callee_o)) st) (hp_f,sk_f))
        ==> 
         data_correspond (run_fc (caller_i,callee_i) ir (caller_o,callee_o) s)
            (run_ir (translate_fc (caller_i,callee_i) ir (caller_o,callee_o) (transfer_ins,translate_f,transfer_outs)) st) (hp_f,sk_f)`,

     RW_TAC std_ss [run_fc_def, translate_fc_def, FC_2_SC, LET_THM]
    );     



(*---------------------------------------------------------------------------------*)
(*      An Deployment of Stacks and Heaps in the Memory                            *)
(*      Prefixed by dp1 (deployment 1)                                             *)
(*      Heap (Stack) is mapped to an area indexed by the HP (FP)                   *)
(*---------------------------------------------------------------------------------*)

val dp1_translate_def = Define `
    dp1_translate ir = translate_ir1 ir ((\i. (THP, NEG i)), (\i.(TFP, NEG i)))`;

(*
 val test1 = prove (
   ``dp1_translate (Blk [TLDR r0 (Hp 0); TSTR (Sk 5) r0]) = 
        BLK [MLDR R0 (10,NEG 0); MSTR (11,NEG 5) R0]``,
   RW_TAC std_ss [dp1_translate_def, translate_ir1_def] THEN
   RW_TAC list_ss [translate_assgn_def, conv_reg_thm, toLocn_def, conv_base_thm]
  );

 val test2 = prove (
  ``!s. tread (run_ir1 (Blk [TLDR r0 (Hp 0); TSTR (Sk 5) r0]) s) (inM (Sk 5)) = tread s (inM (Hp 0))``,
     SIMP_TAC std_ss [FORALL_HS_STATE] THEN
     RW_TAC finmap_ss [run_ir1_def, tdecode_def, tread_def, twrite_def]
  );    
*)

val dp1_correspond_def = Define `
    dp1_correspond (dr,hp,sk) (regs,mem) =
      data_correspond (dr, regs_2_pr regs, hp, sk) (regs,mem) ((\i. (THP, NEG i)), (\i.(TFP, NEG i)))`;

val dp1_correspond_thm = 
      (SIMP_RULE std_ss [ regs_2_pr_thm, data_correspond_def, is_map_f_def, addr_def, toPTR_def] o
       SIMP_RULE std_ss [FORALL_HS_STATE, FORALL_DSTATE]
      ) dp1_correspond_def; 

(*---------------------------------------------------------------------------------*)
(*      Correspondence for basic blocks in DP1                                     *)
(*---------------------------------------------------------------------------------*)

val  DP1_BLK_CORRESPONDENCE = Q.store_thm (
  "DP1_BLK_CORRESPONDENCE",
  `!dr pr hp sk hp_f sk_f st stmL.
    proper_config (dr,pr,hp,sk) st ((\i. (THP, NEG i)), (\i.(TFP, NEG i))) /\ valid_struct (Blk stmL) (FDOM hp, FDOM sk)
      ==>
       correspond (run_ir1 (Blk stmL) (dr,pr,hp,sk))
                  (run_ir (dp1_translate (Blk stmL)) st)`,

  Induct_on `stmL` THENL [
      SIMP_TAC std_ss [FORALL_DSTATE] THEN
          RW_TAC list_ss [valid_struct_def, proper_config_def, correspond_def, run_ir1_def, translate_ir1_def, IR_SEMANTICS_BLK],

      RW_TAC list_ss [proper_config_def, valid_struct_def, run_ir1_def, translate_ir1_def, IR_SEMANTICS_BLK] THEN
          `?dr' pr' hp' sk'. (dr',pr',hp',sk') = tdecode (dr,pr,hp,sk) h` by  METIS_TAC [ABS_PAIR_THM] THEN
          Q.PAT_ASSUM `!dr pr hp sk hp_f sk_f st.x` (ASSUME_TAC o SIMP_RULE std_ss [valid_struct_def, translate_ir1_def] o
               Q.SPECL [`dr'`,`pr'`,`hp'`,`sk'`,`hp_f`,`sk_f`,`mdecode st (translate_assgn h (hp_f,sk_f))`]) THEN
          `(FDOM hp',FDOM sk') = (FDOM hp,FDOM sk)` by METIS_TAC [ASSGN_SAME_FDOM_HP_SK, ABS_PAIR_THM] THEN
          FULL_SIMP_TAC std_ss [proper_config_def] THEN
          METIS_TAC [SIMP_RULE std_ss [proper_config_def] DECODE_STM_THM, ASSGN_ONE_ONE_ADDR]
      ]
  );


(*---------------------------------------------------------------------------------*)
(*      Semantics preservation                                                     *)
(*---------------------------------------------------------------------------------*)

val preserve_def = Define `
     preserve ir = 
      !rg hp sk p q st. proper_config (rg,hp,sk) (p,q) st /\ 
             valid_struct ir (FDOM hp, FDOM sk)
            ==> proper_config (run_ir1 ir (rg,(hp,sk))) (p,q) (run_ir (translate_ir1 ir) st)
    `;

val  BLK_PRESERVATION = Q.store_thm (
  "BLK_PRESERVATION",
   `!stmL. preserve (Blk stmL)`,
   RW_TAC std_ss [preserve_def, proper_config_def] THEN
   `?rg' hp' sk'. run_ir1 (Blk stmL) (rg,hp,sk) = (rg',hp',sk')` by METIS_TAC [ABS_PAIR_THM] THEN
   METIS_TAC [REWRITE_RULE [hs_dom_intact_def] BLK_HS_DOM_INTACT, 
              REWRITE_RULE [pt_regs_intact_def] BLK_PT_REGS_INTACT, proper_config_def, BLK_CONGRUENCE]
  );


val  SC_PRESERVATION = Q.store_thm (
  "SC_PRESERVATION",
  `!S1 S2. well_behv S1 /\ well_behv S2 ==>
          preserve S1 /\ preserve S2 ==>
            preserve (Sc S1 S2)`,
  RW_TAC std_ss [preserve_def, run_ir1_def, translate_ir1_def, valid_struct_def, hs_dom_intact_def, 
                 well_behv_def, WELL_FORMED_SC, Well_Formed_def, SEMANTICS_OF_IR] THEN
  METIS_TAC [ABS_PAIR_THM]
  );

(*---------------------------------------------------------------------------------*)

val _ = export_theory();

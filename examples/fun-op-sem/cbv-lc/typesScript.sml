(* By Scott Owens and Theo Laurent, 2016
 * Prove that simply typed call-by-value lambda calculus programs always
 * terminate. *)

(* Standard things to open at the top of a script file *)
open HolKernel boolLib bossLib Parse;

(* Generally useful theories *)
open integerTheory stringTheory alistTheory listTheory pred_setTheory;
open pairTheory optionTheory finite_mapTheory arithmeticTheory rich_listTheory;

(* The call-by-value LC that we're building on *)
open cbvTheory;

(* Name the theory types *)
val _ = new_theory "types";

(* The datatype of types *)
Datatype: type = Int | Arrow type type
End

(* Get the size function generated by the call to Datatype *)
val type_size_def = fetch "-" "type_size_def";

(* Our type environments will be type lists, because we are in a De Bruijn
 * representation. *)
val _ = type_abbrev ("type_env", ``:type list``);

(* The standard inductive relation for typing STLC.
 * Get a rules, induction and case split theorem back *)
Inductive type:
[~lit:]
  !G i. type G (Lit (Int i)) Int
[~var:]
  ∀G n. n < LENGTH G ⇒ type G (Var n) (EL n G)
[~app:]
  !G e1 e2 t1 t2.
    type G e1 (Arrow t1 t2) ∧
    type G e2 t1
    ⇒
    type G (App e1 e2) t2
[~fun:]
  !G e t1 t2.
    type (t1::G) e t2
    ⇒
    type G (Fun e) (Arrow t1 t2)
[~tick:] !G e t. type G e t ⇒ type G (Tick e) t
End

(* Define a helper function for the termination argument below. *)
Definition sn_v_term_fun_def:
  (sn_v_term_fun (INL (t, v)) = (type_size t, 0:num)) ∧
  (sn_v_term_fun (INR (INL (t, s, env, e))) = (type_size t, 2)) ∧
  (sn_v_term_fun (INR (INR s)) = (0, 1))
End

(* A unary logical relation for strong normalisation, for values, executing
 * expressions and states. HOL can't get the termination on its own, so we
 * have to supply a well-founded relation with WF_REL_TAC and prove that it
 * works. Things in the store must be related at Int type, since higher-order
 * stores lose strong normalisation. *)
Definition sn_v_def:
(sn_v Int (Litv l) ⇔ T) ∧
(sn_v (Arrow t1 t2) (Clos env exp) ⇔
  !v s. sn_state s ∧ sn_v t1 v ⇒ sn_exec t2 s (v::env) exp) ∧
(sn_v _ _ ⇔ F) ∧
(sn_exec t s env exp ⇔
  ?ck v s'.
    sem env (s with clock := ck) exp = (Rval v, s') ∧
    sn_v t v ∧
    sn_state s') ∧
(sn_state s ⇔ EVERY (sn_v Int) s.store)
Termination
 WF_REL_TAC `inv_image ((<) LEX (<)) sn_v_term_fun` >>
 rw [sn_v_term_fun_def, type_size_def]
End

(* Define the logical relation for arbitrary expressions at a given type
 * and typing context *)
Definition sn_e_def:
  sn_e G t e ⇔
    !s env. sn_state s ∧ LIST_REL sn_v G env ⇒ sn_exec t s env e
End

(* The main lemma, proceed by rule induction over the type relation. *)
Theorem sn_lemma:
  ∀G e t. type G e t ⇒ sn_e G t e
Proof
  Induct_on ‘type’ >> rw[] >~
  [‘Lit (Int i)’] >- simp[sn_e_def, sn_v_def, sem_def] >~
  [‘Var v’, ‘EL i G’]
  >- (rw [sn_e_def, sn_v_def, sem_def] >> gvs[LIST_REL_EL_EQN]) >~
  [‘Tick t’]
  >- (simp[sn_e_def, sn_v_def, sem_def, AllCaseEqs(), dec_clock_def] >>
      gvs[sn_e_def, sn_v_def] >> rpt strip_tac >>
      irule_at Any numTheory.NOT_SUC >> simp[] >> metis_tac[]) >~
  [‘sn_e G rty (App f x)’, ‘sn_e G (Arrow dty rty) f’]
  >- (gvs[sn_e_def, sn_v_def, sem_def, AllCaseEqs(), PULL_EXISTS] >>
      rpt strip_tac >>
      ‘∃fc fv fs. sem env (s with clock := fc) f = (Rval fv, fs) ∧
                  sn_v (Arrow dty rty) fv ∧ EVERY (λa. sn_v Int a) fs.store’
        by metis_tac[] >>
      Cases_on ‘fv’ >> gvs[sn_v_def] >>
      dxrule_then strip_assume_tac sem_clock_add >>
      first_assum $ irule_at (Pat ‘sem _ _ _ = _’) >> pop_assum kall_tac >>
      ‘∃xc xv xs. sem env (fs with clock := xc) x = (Rval xv, xs) ∧
                  sn_v dty xv ∧ EVERY (λa. sn_v Int a) xs.store’
        by metis_tac[] >>
      dxrule_then strip_assume_tac sem_clock_add >>
      pop_assum
        (qspec_then ‘fs.clock + 1 + X’ (strip_assume_tac o Q.GEN ‘X’)) >>
      ‘∀Y. xc + (fs.clock + 1 + Y) = fs.clock + (xc + 1 + Y)’ by simp[] >>
      pop_assum (RULE_ASSUM_TAC o REWRITE_RULE o single) >>
      pop_assum $ irule_at Any >> simp[dec_clock_def] >>
      first_x_assum $ drule_all_then strip_assume_tac >>
      dxrule_then strip_assume_tac sem_clock_add >>
      pop_assum $ qspec_then ‘fs.clock + xs.clock’ assume_tac >>
      pop_assum $ irule_at Any >> simp[]) >>
  gvs[sn_e_def, PULL_EXISTS, sn_v_def] >> rpt strip_tac >>
  simp[sem_def, sn_v_def]
QED

(* The main theorem *)
Theorem strong_norm_thm:
  !e t. type [] e t ⇒ ?v. eval e (Rval v)
Proof
  rpt strip_tac
  >> ‘sn_e [] t e’ by (match_mp_tac sn_lemma >> simp [])
  >> fs [sn_v_def, sn_e_def, eval_def]
  >> first_x_assum (qspec_then ‘<|clock := c; store := []|>’ assume_tac)
  >> fs [] >> metis_tac []
QED

val _ = export_theory ();

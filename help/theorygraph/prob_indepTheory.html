<HTML>
<HEAD><TITLE>Theory: prob_indep</TITLE></HEAD>
<BODY bgcolor=linen text=midnightblue>
<H1><font color="black">Theory "prob_indep"</font></H1>
<STRONG><font size=+3 color="black">Parents</font></STRONG>&nbsp;&nbsp;&nbsp;&nbsp;
    <A HREF = "state_transformerTheory.html"><STRONG><font color="black">state_transformer</font></STRONG></A>
    <A HREF = "probTheory.html"><STRONG><font color="black">prob</font></STRONG></A>

<H1><font color="black">Signature</font></H1>
<center>
<table BORDER=4 CELLPADDING=10 CELLSPACING=1>

    <tr>
    <th>
    <font color="crimson">Constant</font>
    <th>
    <font color="crimson">Type</font><tr><td>
                                         <STRONG><font color="black">indep</font></STRONG>
                                         <td>
                                         :((num -> bool) ->
                                           'a # (num -> bool)) -> bool
    <tr><td>
        <STRONG><font color="black">indep_set</font></STRONG>
        <td>
        :((num -> bool) -> bool) -> ((num -> bool) -> bool) -> bool
    <tr><td>
        <STRONG><font color="black">alg_cover_set</font></STRONG>
        <td>
        :bool list list -> bool
    <tr><td>
        <STRONG><font color="black">alg_cover</font></STRONG>
        <td>
        :bool list list -> (num -> bool) -> bool list
    
</table>
</center>

<H1><font color="black">Definitions</font></H1>
<DL>
<DT><STRONG><font color="black">indep_set_def</font></STRONG>
<DD>
<PRE>
|- !p q.
     indep_set p q =
     measurable p /\ measurable q /\ (prob (p INTER q) = prob p * prob q)
</PRE>

<DT><STRONG><font color="black">alg_cover_set_def</font></STRONG>
<DD>
<PRE>
|- !l.
     alg_cover_set l =
     alg_sorted l /\ alg_prefixfree l /\ (algebra_embed l = UNIV)
</PRE>

<DT><STRONG><font color="black">alg_cover_def</font></STRONG>
<DD>
<PRE>
|- !l x. alg_cover l x = @b. IS_EL b l /\ alg_embed b x
</PRE>

<DT><STRONG><font color="black">indep_def</font></STRONG>
<DD>
<PRE>
|- !f.
     indep f =
     ?l r.
       alg_cover_set l /\
       !s. f s = (let c = alg_cover l s in (r c,SDROP (LENGTH c) s))
</PRE>

</DL>


<HR>

<HR>
<H1><font color="black">Theorems</font></H1>
<DL>
<DT><STRONG><font color="black">INDEP_SET_BASIC</font></STRONG>
<DD>
<PRE>
|- !p. measurable p ==> indep_set {} p /\ indep_set UNIV p
</PRE>

<DT><STRONG><font color="black">INDEP_SET_SYM</font></STRONG>
<DD>
<PRE>
|- !p q. indep_set p q = indep_set p q
</PRE>

<DT><STRONG><font color="black">INDEP_SET_DISJOINT_DECOMP</font></STRONG>
<DD>
<PRE>
|- !p q r.
     indep_set p r /\ indep_set q r /\ (p INTER q = {}) ==>
     indep_set (p UNION q) r
</PRE>

<DT><STRONG><font color="black">ALG_COVER_SET_BASIC</font></STRONG>
<DD>
<PRE>
|- ~alg_cover_set [] /\ alg_cover_set [[]] /\ alg_cover_set [[T]; [F]]
</PRE>

<DT><STRONG><font color="black">ALG_COVER_WELL_DEFINED</font></STRONG>
<DD>
<PRE>
|- !l x.
     alg_cover_set l ==>
     IS_EL (alg_cover l x) l /\ alg_embed (alg_cover l x) x
</PRE>

<DT><STRONG><font color="black">ALG_COVER_UNIV</font></STRONG>
<DD>
<PRE>
|- alg_cover [[]] = K []
</PRE>

<DT><STRONG><font color="black">MAP_CONS_TL_FILTER</font></STRONG>
<DD>
<PRE>
|- !l b.
     ~IS_EL [] l ==>
     (MAP (CONS b) (MAP TL (FILTER (\x. HD x = b) l)) =
      FILTER (\x. HD x = b) l)
</PRE>

<DT><STRONG><font color="black">ALG_COVER_SET_CASES_THM</font></STRONG>
<DD>
<PRE>
|- !l.
     alg_cover_set l =
     (l = [[]]) \/
     ?l1 l2.
       alg_cover_set l1 /\ alg_cover_set l2 /\
       (l = APPEND (MAP (CONS T) l1) (MAP (CONS F) l2))
</PRE>

<DT><STRONG><font color="black">ALG_COVER_SET_CASES</font></STRONG>
<DD>
<PRE>
|- !P.
     P [[]] /\
     (!l1 l2.
        alg_cover_set l1 /\ alg_cover_set l2 /\
        alg_cover_set (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2)) ==>
        P (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2))) ==>
     !l. alg_cover_set l ==> P l
</PRE>

<DT><STRONG><font color="black">ALG_COVER_SET_INDUCTION</font></STRONG>
<DD>
<PRE>
|- !P.
     P [[]] /\
     (!l1 l2.
        alg_cover_set l1 /\ alg_cover_set l2 /\ P l1 /\ P l2 /\
        alg_cover_set (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2)) ==>
        P (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2))) ==>
     !l. alg_cover_set l ==> P l
</PRE>

<DT><STRONG><font color="black">ALG_COVER_EXISTS_UNIQUE</font></STRONG>
<DD>
<PRE>
|- !l. alg_cover_set l ==> !s. ?!x. IS_EL x l /\ alg_embed x s
</PRE>

<DT><STRONG><font color="black">ALG_COVER_UNIQUE</font></STRONG>
<DD>
<PRE>
|- !l x s.
     alg_cover_set l /\ IS_EL x l /\ alg_embed x s ==> (alg_cover l s = x)
</PRE>

<DT><STRONG><font color="black">ALG_COVER_STEP</font></STRONG>
<DD>
<PRE>
|- !l1 l2 h t.
     alg_cover_set l1 /\ alg_cover_set l2 ==>
     (alg_cover (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2)) (SCONS h t) =
      (if h then T::alg_cover l1 t else F::alg_cover l2 t))
</PRE>

<DT><STRONG><font color="black">ALG_COVER_HEAD</font></STRONG>
<DD>
<PRE>
|- !l. alg_cover_set l ==> !f. f o alg_cover l = algebra_embed (FILTER f l)
</PRE>

<DT><STRONG><font color="black">ALG_COVER_TAIL_STEP</font></STRONG>
<DD>
<PRE>
|- !l1 l2 q.
     alg_cover_set l1 /\ alg_cover_set l2 ==>
     (q o
      (\x.
         SDROP
           (LENGTH (alg_cover (APPEND (MAP (CONS T) l1) (MAP (CONS F) l2)) x))
           x) =
      (\x. SHD x = T) INTER
      q o (\x. SDROP (LENGTH (alg_cover l1 x)) x) o STL UNION
      (\x. SHD x = F) INTER q o (\x. SDROP (LENGTH (alg_cover l2 x)) x) o STL)
</PRE>

<DT><STRONG><font color="black">ALG_COVER_TAIL_MEASURABLE</font></STRONG>
<DD>
<PRE>
|- !l.
     alg_cover_set l ==>
     !q.
       measurable (q o (\x. SDROP (LENGTH (alg_cover l x)) x)) = measurable q
</PRE>

<DT><STRONG><font color="black">ALG_COVER_TAIL_PROB</font></STRONG>
<DD>
<PRE>
|- !l.
     alg_cover_set l ==>
     !q.
       measurable q ==>
       (prob (q o (\x. SDROP (LENGTH (alg_cover l x)) x)) = prob q)
</PRE>

<DT><STRONG><font color="black">INDEP_INDEP_SET_LEMMA</font></STRONG>
<DD>
<PRE>
|- !l.
     alg_cover_set l ==>
     !q.
       measurable q ==>
       !x.
         IS_EL x l ==>
         (prob
            (alg_embed x INTER q o (\x. SDROP (LENGTH (alg_cover l x)) x)) =
          (1 / 2) pow LENGTH x * prob q)
</PRE>

<DT><STRONG><font color="black">INDEP_SET_LIST</font></STRONG>
<DD>
<PRE>
|- !q l.
     alg_sorted l /\ alg_prefixfree l /\ measurable q /\
     (!x. IS_EL x l ==> indep_set (alg_embed x) q) ==>
     indep_set (algebra_embed l) q
</PRE>

<DT><STRONG><font color="black">INDEP_INDEP_SET</font></STRONG>
<DD>
<PRE>
|- !f p q. indep f /\ measurable q ==> indep_set (p o FST o f) (q o SND o f)
</PRE>

<DT><STRONG><font color="black">INDEP_UNIT</font></STRONG>
<DD>
<PRE>
|- !x. indep (UNIT x)
</PRE>

<DT><STRONG><font color="black">INDEP_SDEST</font></STRONG>
<DD>
<PRE>
|- indep SDEST
</PRE>

<DT><STRONG><font color="black">BIND_STEP</font></STRONG>
<DD>
<PRE>
|- !f. BIND SDEST (\k. f o SCONS k) = f
</PRE>

<DT><STRONG><font color="black">INDEP_BIND_SDEST</font></STRONG>
<DD>
<PRE>
|- !f. (!x. indep (f x)) ==> indep (BIND SDEST f)
</PRE>

<DT><STRONG><font color="black">INDEP_BIND</font></STRONG>
<DD>
<PRE>
|- !f g. indep f /\ (!x. indep (g x)) ==> indep (BIND f g)
</PRE>

<DT><STRONG><font color="black">INDEP_PROB</font></STRONG>
<DD>
<PRE>
|- !f p q.
     indep f /\ measurable q ==>
     (prob (p o FST o f INTER q o SND o f) = prob (p o FST o f) * prob q)
</PRE>

<DT><STRONG><font color="black">INDEP_MEASURABLE1</font></STRONG>
<DD>
<PRE>
|- !f p. indep f ==> measurable (p o FST o f)
</PRE>

<DT><STRONG><font color="black">INDEP_MEASURABLE2</font></STRONG>
<DD>
<PRE>
|- !f q. indep f /\ measurable q ==> measurable (q o SND o f)
</PRE>

<DT><STRONG><font color="black">PROB_INDEP_BOUND</font></STRONG>
<DD>
<PRE>
|- !f n.
     indep f ==>
     (prob (\s. FST (f s) < SUC n) =
      prob (\s. FST (f s) < n) + prob (\s. FST (f s) = n))
</PRE>

</DL>



<HR>
</BODY>
</HTML>

(* this is an -*- sml -*- file *)

(* ======================================================================
       Automatic generation of clickable image maps of the
       HOL theory hierarchy.
   ----------------------------------------------------------------------

    The algorithm works as follows:

      1. Generate the dependencies from the current theory hierarchy
      2. Write them to a file ready for processing by "dot"
      3. Invoke dot to generate the JPEG-format image, the image map
         information, and a PDF file while we're at it.
      4. Generate a HTML file to hold the reference to the image, and
         to contain the map information
      5. Generate the html files for each segment in the current
         theory hierarchy.

    Before loading this file, you might need to tell "dot" where the
    TrueType fonts that it needs are. On my Linux system, this used to
    be:

        DOTFONTPATH=/dosc/windows/fonts; export DOTFONTPATH

    Run the file by

       hol < DOT

   ====================================================================== *)

val HTML_DIR   = Path.toString(Path.fromString(Path.concat
                    (Globals.HOLDIR,"help/theorygraph")));
val SIGOBJ_DIR = Path.toString(Path.fromString(Path.concat
                    (Globals.HOLDIR,"sigobj")));

(*---------------------------------------------------------------------------
     Extract dot-friendly digraph from HOL theory graph.
 ---------------------------------------------------------------------------*)

fun node thy = map (fn p => (p,thy)) (parents thy);

local fun leq (s:string,_) (t,_) = s <= t
in
fun ancestor_nodes thy =
  let val thys = ancestry thy
      val pairs = sort leq (flatten (map node thys))
  in (thys, pairs)
  end
end;

(*---------------------------------------------------------------------------*)
(* There are lots of parameters that can be played with here. See the dot    *)
(* manual for tweakables.                                                    *)
(*---------------------------------------------------------------------------*)

fun pp_dot_file {size,ranksep,nodesep} (dom,pairs) ppstrm =
 let open Portable
     val {add_string,add_break,begin_block,end_block,
          add_newline,flush_ppstream,...} = with_ppstream ppstrm
     fun pp_thy s =
       (begin_block CONSISTENT 2;
        add_string s; add_break (1,0);
        add_string "[URL ="; add_break(1,0);
        add_string (quote (s^"Theory.html"));
        add_string "]";
        end_block())
     fun pp_pair (x,y) =
       (begin_block CONSISTENT 0;
        add_string x;
        add_string " -> ";
        add_string y;
        end_block())
 in
  begin_block CONSISTENT 0;
  begin_block CONSISTENT 5;
  add_string "digraph G {";
  add_break (1,0);

  add_string "ratio = compress"; add_break(1,0);
  add_string "size = ";    add_string (quote size); add_break(1,0);
  add_string "ranksep = "; add_string ranksep;      add_break(1,0);
  add_string "nodesep = "; add_string nodesep;      add_break(1,0);
  add_string "node [fontcolor = darkgreen fontsize=30 fontname=Arial]";
  add_break(1,0);
  add_newline();
  begin_block CONSISTENT 0;
   pr_list pp_thy (fn () => ()) add_newline dom;
  end_block();
  add_newline(); add_newline();
  begin_block CONSISTENT 0;
   pr_list pp_pair (fn () => ()) add_newline pairs;
  end_block();
  end_block();
  add_newline(); add_string "}"; add_newline();
  end_block()
 end;

fun gen_dotfile file node_info =
 let open TextIO
     val ostrm = openOut file
 in  PP.with_pp {consumer=fn s => output(ostrm,s),linewidth=75,
                 flush=fn () => flushOut ostrm}
        (pp_dot_file {size="16,16",ranksep="1.0",nodesep="0.30"} node_info);
     closeOut ostrm
 end;

(* ----------------------------------------------------------------------
    cat filename out

    push contents of filename into outstream out
   ---------------------------------------------------------------------- *)

fun cat fname outstr = let
  val instr = TextIO.openIn fname
  val infile = TextIO.inputAll instr
in
  TextIO.output(outstr, infile)
end

(*---------------------------------------------------------------------------
       Parse theory coordinates generated by dot -Timap. Note that
       these come (i,j) (p,q), but it seems that they should be
       transformed to (i,q) (p,j) ... and so that's what we do!
 ---------------------------------------------------------------------------*)

fun gen_map_file dot node_info name = let
  open TextIO
  val dotfile   = name^".dot"
  val jpegfile   = name^".jpg"
  val imapfile  = name^".imap"
  val mapfile   = name^".html"
  val pdffile    = name^".pdf"
  val  _        = gen_dotfile dotfile node_info
  val cmdstatus = Systeml.systeml [dot,
                                   "-Tjpeg", "-o"^jpegfile,
                                   "-Tcmapx", "-o"^imapfile,
                                   "-Tpdf", "-o"^pdffile,
                                   dotfile]
in
  if OS.Process.isSuccess cmdstatus then let
      val ostrm = openOut mapfile
      fun out s = output(ostrm, s^"\n")
    in
      out "<HTML>";
      out "<HEAD><TITLE>HOL Theory Hierarchy</TITLE></HEAD>";
      out "<BODY bgcolor=linen text=crimson>";
      out "<H1>HOL Theory Hierarchy (clickable)</H1>";
      out (String.concat
               ["<IMG src = \"",OS.Path.file jpegfile,"\"",
                " usemap=\"#G\"",
                " alt=\"HOL Theory Map\">"]);
      cat imapfile ostrm;
      out "</MAP>";
      out "</BODY>";
      out "</HTML>";
      closeOut ostrm
    end
  else raise Fail "gen_map_file: failed "
end;

fun dir_theories dir = let
  open Substring FileSys
  val dstrm = openDir dir
  fun thys () =
      case readDir dstrm of
        NONE => []
      | SOME file => let
          val (ss1,ss2) = position "Theory.sig" (full file)
        in
          if isEmpty ss1 orelse isEmpty ss2 orelse string ss1 = "Final" then
            thys()
          else string ss1 :: thys()
        end
in
  thys()
end;


fun load_theories thyl = app (load o C (curry op^) "Theory") thyl;


(* ----------------------------------------------------------------------
    Up to this point, no work is done - the above just sets up
    functions to do the work.  What follows actually figures out what
    the graph is and causes lots of stuff to be written to disk
   ---------------------------------------------------------------------- *)

val sys_theories = List.filter (not o String.isSuffix "_emit")
                               (dir_theories SIGOBJ_DIR);
load_theories sys_theories;
val ancs = ancestor_nodes "-";

val all_theories = "min"::sys_theories;
val paths = map(fn s => Path.concat (HTML_DIR,s^"Theory.html")) all_theories;
val _ = HOLPP.catch_withpp_err := false
fun mapthis (thy,path) =
    print_theory_as_html thy path
    handle Fail s => print (">>> PP failure on "^thy^": "^s^"\n")
val _ = ListPair.map mapthis (all_theories, paths);

(* The following works on Unix with dot version 1.10.2003xxxxxxx *)

gen_map_file "/usr/bin/dot" ancs (Path.concat(HTML_DIR, "theories"));


## `expand_list` {#proofManagerLib.expand_list}


```
expand_list : list_tactic -> proof
```



Applies a list-tactic to replace the current goal list.


The function `expand_list` is part of the subgoal package.
It may be abbreviated by the function `elt`.
It applies a tactic to the current goal list (that is,
the list of goals produced by the most recent use of `expand` or `expand_list`)
to give a new proof state.
The previous state is stored on the backup list. If the list-tactic produces
subgoals, the new proof state is formed from the old one by removing the
current goal list from the goal stack and replacing it by the list of subgoals
produced by the list-tactic.
The corresponding justification is modified accordingly,
appropriate to the new goal list.
The new subgoals are printed. If more than one subgoal is produced, they are
printed from the bottom of the stack so that the new current goal is  printed
last.

If a list-tactic solves the current goal list (returns an empty subgoal list),
then its justification is used to prove a corresponding theorem.  This theorem
is incorporated into the justification of the parent goal and printed.
That level of goals is removed and the parent
goal is proved using  its (new) justification. This process is repeated until a
level with unproven subgoals is reached. The next goal on the goal stack then
becomes the current goal. This goal is printed. If all the subgoals are proved,
the resulting proof state consists of the theorem proved by the justifications.

The list-tactic applied is a validating version of the list-tactic given.
It ensures that
the justification of the list-tactic does provide a proof of the goals from the
subgoals generated by the tactic. It will cause failure if this is not so. The
tactical `VALID_LT` performs this validation.

For a description of the subgoal package, see  `set_goal`.

### Failure

`expand_list ltac` fails if the tactic `ltac` fails for the current goal list.
It will diverge if the list-tactic diverges for the goal. It will fail if there are no unproven goals.
This could be because no goal has been set using `set_goal` or because
the last goal set has been completely proved. It will also fail in cases when
the list-tactic is invalid.

### Example

    
    > expand_list (ALLGOALS CONJ_TAC) ;
    OK..
    NO_PROOFSException- NO_PROOFS raised
    
    > g `(HD[1;2;3] = 1) /\ (TL[1;2;3] = [2;3])`;
    > val it =
        Proof manager status: 1 proof.
        1. Incomplete:
             Initial goal:
             (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3])
    
         : proofs
    
    > expand CONJ_TAC;
    OK..
    2 subgoals:
    > val it =
        TL [1; 2; 3] = [2; 3]
    
    
        HD [1; 2; 3] = 1
    
         : proof
    
    > expand_list (ALLGOALS (REWRITE_TAC[listTheory.HD,listTheory.TL])) ;
    OK..
    val it =
       Initial goal proved.
       |- (HD [1; 2; 3] = 1) /\ (TL [1; 2; 3] = [2; 3]):
          proof
    
    


Doing a step in an interactive goal-directed proof,
in particular, a step which affects all the subgoals generated by the
preceding step.

### See also

[`proofManagerLib.set_goal`](#proofManagerLib.set_goal), [`proofManagerLib.restart`](#proofManagerLib.restart), [`proofManagerLib.backup`](#proofManagerLib.backup), [`proofManagerLib.redo`](#proofManagerLib.redo), [`proofManagerLib.restore`](#proofManagerLib.restore), [`proofManagerLib.save`](#proofManagerLib.save), [`proofManagerLib.set_backup`](#proofManagerLib.set_backup), [`proofManagerLib.expand`](#proofManagerLib.expand), [`proofManagerLib.expandf`](#proofManagerLib.expandf), [`proofManagerLib.expand_listf`](#proofManagerLib.expand_listf), [`proofManagerLib.flatn`](#proofManagerLib.flatn), [`proofManagerLib.p`](#proofManagerLib.p), [`proofManagerLib.top_thm`](#proofManagerLib.top_thm), [`proofManagerLib.top_goal`](#proofManagerLib.top_goal)

